{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/imgs/1.png","path":"imgs/1.png","modified":0,"renderable":0},{"_id":"source/imgs/admin.png","path":"imgs/admin.png","modified":0,"renderable":0},{"_id":"source/imgs/git-merg.png","path":"imgs/git-merg.png","modified":0,"renderable":0},{"_id":"source/imgs/titleIcon.gif","path":"imgs/titleIcon.gif","modified":0,"renderable":0},{"_id":"source/imgs/git-snapshot.png","path":"imgs/git-snapshot.png","modified":0,"renderable":0},{"_id":"source/imgs/reactCode/reactCode1-1.jpg","path":"imgs/reactCode/reactCode1-1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-5.jpg","path":"imgs/scip/scip2-5.jpg","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-6.jpeg","path":"imgs/scip/scip2-6.jpeg","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-7.jpg","path":"imgs/scip/scip2-7.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-icarus-master/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/css/back-to-top.css","path":"css/back-to-top.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/css/progressbar.css","path":"css/progressbar.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/js/clipboard.js","path":"js/clipboard.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/js/back-to-top.js","path":"js/back-to-top.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-icarus-master/source/images/og_image.png","path":"images/og_image.png","modified":0,"renderable":1},{"_id":"source/imgs/avatar.jpg","path":"imgs/avatar.jpg","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-8.jpg","path":"imgs/scip/scip2-8.jpg","modified":0,"renderable":0},{"_id":"source/imgs/SEO/chap1/example.png","path":"imgs/SEO/chap1/example.png","modified":0,"renderable":0},{"_id":"source/imgs/SEO/chap1/example2.png","path":"imgs/SEO/chap1/example2.png","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-4.jpg","path":"imgs/scip/scip2-4.jpg","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-3.jpg","path":"imgs/scip/scip2-3.jpg","modified":0,"renderable":0},{"_id":"source/imgs/scip/scip2-2.jpg","path":"imgs/scip/scip2-2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/avatar.png","path":"imgs/avatar.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/hexo-theme-icarus-master/.gitignore","hash":"35572c0f161a751b9f30ae3a9935ac045dba5220","modified":1591839812399},{"_id":"themes/hexo-theme-icarus-master/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1591839812400},{"_id":"themes/hexo-theme-icarus-master/README.md","hash":"c351bc76d3b4a138989c50f57bd3c52fa95eaa56","modified":1591839812400},{"_id":"themes/hexo-theme-icarus-master/_config.yml","hash":"b3ee91604ef31d724a10ccbd8dc6920f4017bab8","modified":1591839812400},{"_id":"themes/hexo-theme-icarus-master/package.json","hash":"4167e65682af257bdf8531a05730e6c42339996d","modified":1591839812413},{"_id":"themes/hexo-theme-icarus-master/.github/ISSUE_TEMPLATE.md","hash":"6b17b84116938367757928087a09dcb8489d06f6","modified":1591839812399},{"_id":"source/imgs/1.png","hash":"95b734c48598130f9f2ec8d2ebea1a45507cb1f3","modified":1591839812382},{"_id":"source/imgs/admin.png","hash":"3cc4733c4a003d9e206f01ee5a1148baacf026c0","modified":1591839812383},{"_id":"source/imgs/git-merg.png","hash":"c6937b6993a2f4bf3728dcd3725744d733fa786c","modified":1591839812390},{"_id":"source/imgs/titleIcon.gif","hash":"200f385add8a0e2bb156a5f5b3fbf6ce80fe2318","modified":1591839812399},{"_id":"source/imgs/git-snapshot.png","hash":"69f0f2c5bf0ac8538e1f7e562de0b4c8ddbca6b7","modified":1591839812391},{"_id":"themes/hexo-theme-icarus-master/languages/es.yml","hash":"8827823e5b2ce967566854c9bfebc7c69098b4ac","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/en.yml","hash":"b69c91878f30937f50438ff64dffd3f6bf91bcf5","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/languages/id.yml","hash":"92d2d19a62a17b6e99f82a014309bbf6c13c9ae8","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/ko.yml","hash":"eef426a7d580058024260ccc111476d5b1b688d1","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/layout/archive.ejs","hash":"64a81f4c6ca9517169413408d076371e8e09c63a","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/layout/categories.ejs","hash":"29d304f2b95a04fbc5e7529f9bdce9648e3545ef","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/languages/vn.yml","hash":"6d9f4fabca711a6cb0a0efd72aa75c3641beb4a6","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/languages/zh-CN.yml","hash":"804f6a1edee49bb6a5ecb8e9d14d3e93eaca37c0","modified":1591839812405},{"_id":"themes/hexo-theme-icarus-master/layout/category.ejs","hash":"bda344da0e6c03899f53abc20ae2a2efab5ab243","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/languages/zh-TW.yml","hash":"79fab0bff625634fb6bb6cadf9c547bd36226dcf","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/layout/index.ejs","hash":"71120f41d019bf2866a5556747e5e671c8147f85","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/layout.ejs","hash":"da63c914247eba116ea5263bfc27a69e96f859b6","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/tag.ejs","hash":"1feac7aa842882757a479b8ad427f6a72fce70c4","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/tags.ejs","hash":"0c527c6b72386f11c18e8aa5249be8c601e69906","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/scripts/index.js","hash":"9203e2ba1f821d945edf20fc277f3c58d22bfd00","modified":1591839812413},{"_id":"source/_posts/FunctionalProgrammingInJS/FPinJS(chap1-3).md","hash":"42f2de49ec42a817c6c209c22c112c43486e4686","modified":1591839812373},{"_id":"source/_posts/FunctionalProgrammingInJS/FPinJS(chap4-8).md","hash":"86883d7845828f7290e57e99e13c34244f2cb9a0","modified":1591839812373},{"_id":"source/_posts/SEO/SEO(chap1-3).md","hash":"60f8a92bec1037d69be269595df0639ec02d0778","modified":1591839812373},{"_id":"source/_posts/SEO/SEO(chap4-6).md","hash":"6bc7520110063fc02232571b21a9b7de38c6a260","modified":1591839812374},{"_id":"source/_posts/SEO/SEO(chap10-12).md","hash":"0610e216e3eadf1fc3f2c3562e566f77014cc97c","modified":1591839812373},{"_id":"source/_posts/SEO/SEO(chap7-9).md","hash":"d5aa0d58cbfa0a2668e067978dbcd2f7d099a536","modified":1591839812374},{"_id":"source/_posts/js/Date.md","hash":"2391420d205a4f13a2b8adb5af031a60bc7fb7ea","modified":1591839812374},{"_id":"source/_posts/js/artOfModule.md","hash":"5e3412e8f14a6dc6d3e46b97d795f7d58aa9c2f3","modified":1591839812375},{"_id":"source/_posts/js/implicitCall.md","hash":"60170733c12c6ace4c6aeb2c6604aef2b4d719f9","modified":1591839812375},{"_id":"source/_posts/js/numberStoreInBit.md","hash":"6f204570518b29584ab26393520884ba09ef958e","modified":1591839812375},{"_id":"source/_posts/js/promise.md","hash":"58812fec6e57ca2309566e5e791a71ed470d617a","modified":1591839812375},{"_id":"source/_posts/lodash/sourceCode_lodash_1.md","hash":"561304b29913b613143e45eca5167d577d00acd7","modified":1591839812376},{"_id":"source/_posts/lodash/sourceCode_lodash_2.md","hash":"a9bc450926f05834351ef377ce3695f73364fe34","modified":1591839812376},{"_id":"source/_posts/lodash/sourceCode_lodash_3.md","hash":"8852322bcd8e1a6d97af5c70f447a7ce01d84003","modified":1591839812376},{"_id":"source/_posts/node/whatDoPackageHave.md","hash":"9fb8ebf656e7c563888d1e626dd5af405e523f0a","modified":1591839812377},{"_id":"source/_posts/nihonngo/nihonngo-1.md","hash":"dccf81090576b555fb64f9058eb9ab3bfb742de6","modified":1591839812377},{"_id":"source/_posts/nihonngo/nihonngo-2.md","hash":"1e2a1b58795b87ec2babcdc0cc8eeafa2adafec0","modified":1591839812377},{"_id":"source/_posts/others/2019.md","hash":"739be42990b4e2a814c873c48aa2d67743f70792","modified":1591839812378},{"_id":"source/_posts/others/git-1.md","hash":"da576f943e011742bd0cf9820c0284914c1cb106","modified":1591839812378},{"_id":"source/_posts/others/hello-world.md","hash":"418ab8460c3c908a4023baa4df6b4aafb3af23e4","modified":1591839812378},{"_id":"source/_posts/others/reinstall.md","hash":"2f1c66981ebed17d7756b1ea6fecba7b2cc8e7f8","modified":1591839812378},{"_id":"source/_posts/react/hooks.md","hash":"79bc429ab8c7b4c365cb3b040b1e9d4f1b2811a8","modified":1591839812379},{"_id":"source/_posts/react/reactCode-react-1.md","hash":"0792a48fd77aa9a08aeac756d103d5ff9c220c04","modified":1591839812379},{"_id":"source/_posts/react/reactCode-react-2.md","hash":"32524a333898d683475daa09ad42cd1ffaa3a41f","modified":1591839812379},{"_id":"source/_posts/react/reactCode-react-4.md","hash":"b4c58f0b2fe2f6910b9b817f7b619533ec26a4ee","modified":1591839812380},{"_id":"source/_posts/scip/scip(chap2-1).md","hash":"7516d7e8741dee12ec5f8d9dd503c8bdce47c581","modified":1591839812380},{"_id":"source/_posts/react/reactCode-react-3.md","hash":"554ccdbf7936d5206b98e6e43fd5fa59eb6a77c7","modified":1591839812379},{"_id":"source/_posts/scip/scip(chap2-2).md","hash":"3a26690fdddd7542a99af4c65a799d07a90263ac","modified":1591839812380},{"_id":"source/_posts/scip/scip(chap2-3).md","hash":"fdc9cb39530c53e0d8525ae199c72d2fe54bf6ef","modified":1591839812380},{"_id":"source/_posts/scip/scip(chap2-4).md","hash":"1131726fc97885b5f352cd256274c5c0a45b2f8a","modified":1591839812380},{"_id":"source/_posts/scip/scip(chap2-5).md","hash":"8c2d437eb10fe4d5bd02c2ff9f7831b956b1d416","modified":1591839812381},{"_id":"source/_posts/scip/scip(chap3-1).md","hash":"3282277f0d3d6cb53f306edd7ac006b200b17555","modified":1591839812381},{"_id":"source/_posts/scip/scip(chap3-2).md","hash":"43b29d4dfcedc84c19e428d1e8c7f163ce3ea4dd","modified":1591839812381},{"_id":"source/_posts/scip/scip(chap3-3).md","hash":"f5d7c4977327f51616fae31751de5d0f3806bb51","modified":1591839812381},{"_id":"source/_posts/scip/scip(chap3-4).md","hash":"32465fe317f51ecd166424ac72ecb3b2cccb6fba","modified":1591839812381},{"_id":"source/_posts/scip/scip(chap3-5).md","hash":"edc1b01f27a680f31791424fa41e2ed5fa5b8d5b","modified":1591839812382},{"_id":"source/_posts/scip/scip(start).md","hash":"acfc1cdd6c7cf4a2de6ebe99804811aa8562ae96","modified":1591839812382},{"_id":"source/_posts/scip/sicp(chap1).md","hash":"82a519690dc257bb81844f8d06da8ffec9e144a6","modified":1591839812382},{"_id":"source/imgs/reactCode/reactCode1-1.jpg","hash":"24a78da374ac4175f7922c5d70b25da28aabe6c0","modified":1591839812391},{"_id":"source/imgs/scip/scip2-5.jpg","hash":"1a14e6dff9553268cb8fbd1708aa23556c2b5854","modified":1591839812397},{"_id":"source/imgs/scip/scip2-6.jpeg","hash":"b40bdb4ee081504c2c713ce39fc1f32bfead9ef0","modified":1591839812397},{"_id":"themes/hexo-theme-icarus-master/includes/common/ConfigGenerator.js","hash":"451397efc7808787419fa3eb6b043c0bd8bbdf30","modified":1591839812400},{"_id":"themes/hexo-theme-icarus-master/includes/common/ConfigValidator.js","hash":"cd3cd12bc042b401825fd7bfd9a6434c8b14e092","modified":1591839812400},{"_id":"themes/hexo-theme-icarus-master/includes/common/utils.js","hash":"c0aeaeb57a42bcc71a92da2249762f91abd83ffe","modified":1591839812400},{"_id":"themes/hexo-theme-icarus-master/includes/filters/highlight.js","hash":"19a4dcd2dee7388544b57e473cfb0fc9eea9623e","modified":1591839812401},{"_id":"themes/hexo-theme-icarus-master/includes/generators/categories.js","hash":"7cb370ac53a05d6b1b9203579716c0ca83d35c36","modified":1591839812401},{"_id":"themes/hexo-theme-icarus-master/includes/generators/category.js","hash":"313e170e55d74526c4e1be7181ef7a21439147c9","modified":1591839812401},{"_id":"themes/hexo-theme-icarus-master/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1591839812401},{"_id":"themes/hexo-theme-icarus-master/includes/generators/tags.js","hash":"8195322c208706427a1cf56361669dca4d86f6f1","modified":1591839812401},{"_id":"source/imgs/scip/scip2-7.jpg","hash":"b6a797fc30ebda8475fd7e34684ca0ca886d1bdf","modified":1591839812398},{"_id":"themes/hexo-theme-icarus-master/includes/helpers/cdn.js","hash":"7d34ea6400cb3611c374c135304abcb65ef291b7","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/helpers/config.js","hash":"173e02987e7a7d5df1e686f6ee4edd8cf494bdd3","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/helpers/layout.js","hash":"afdf5e9704cfc087526b4a0403fe7eb04f22190e","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/helpers/override.js","hash":"726cf99612fd060753d9da08db2776aec1802e20","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/helpers/page.js","hash":"50dab1e4ecef55cd090625f91c5456b801e307f2","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/helpers/site.js","hash":"f154ddb0dac79fd28ced2b518f8052b42555d0c9","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/specs/article.spec.js","hash":"a805c1a6f03ccb07d73512aef40d38541ddbb0eb","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/specs/comment.spec.js","hash":"4b84b08214cc21feaa4322357f0bec800bfca826","modified":1591839812402},{"_id":"themes/hexo-theme-icarus-master/includes/specs/config.spec.js","hash":"7a9bac384a73cf9f39173fdb2dfc2813784d8891","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/donate.spec.js","hash":"722cb2662569957e8b1d1a467d9632b8cc6e69d6","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/footer.spec.js","hash":"8e6d7c5f9a13ce03241b6562259d210b389cb88e","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/icon_link.spec.js","hash":"f2a83ac5ccb74fc6f3dfbd25430e142297d8491c","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/meta.spec.js","hash":"70abe77d3664176ec977316522014ce7e0aa439d","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/navbar.spec.js","hash":"7de29c0031738a4de4d31ed4f7b0c43447c7961c","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/plugins.spec.js","hash":"2f33728c24d3076dbbd48a7aeb467d2600d07577","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/providers.spec.js","hash":"820cc6936ba75e3104cc2e8641716ed65ada8b6f","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/search.spec.js","hash":"1e3995cdc471e6a2817cd45e2b6f0fd39b4540ec","modified":1591839812403},{"_id":"themes/hexo-theme-icarus-master/includes/specs/share.spec.js","hash":"5ec65409a17ead13974140fc5ddc19e526586d9f","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/includes/specs/sidebar.spec.js","hash":"630c9701affe2549abc61cd4d1e5153af2224fb6","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/includes/specs/widgets.spec.js","hash":"48ceaab9ef8221bfffd7baabc57c4d6de7240750","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/includes/tasks/check_config.js","hash":"ce7626d643737c90dee6b75435ccdec26b89dacf","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/includes/tasks/check_deps.js","hash":"cfc357f27116d1b9285a3b0bec35c3e89ae73711","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/includes/tasks/welcome.js","hash":"00d1ef8c9609552b82e9a5140b838a9057c59508","modified":1591839812404},{"_id":"themes/hexo-theme-icarus-master/layout/comment/changyan.ejs","hash":"9ccc7ec354b968e60bdcfcd1dba451d38de61f12","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/layout/comment/disqus.ejs","hash":"b5fff46e453d58baa20028a47fd85923494bb85c","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/layout/comment/facebook.ejs","hash":"b38ea86a1cae48f671501af74d7f109f63fb3d72","modified":1591839812406},{"_id":"themes/hexo-theme-icarus-master/layout/comment/gitalk.ejs","hash":"ef01396e64ab4f6e62155f0b357bcd903138d611","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/comment/isso.ejs","hash":"cc6a43bd24be764086f88ad7c5c97ff04df87e0b","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/comment/gitment.ejs","hash":"430416210933b7edcbfcc67ede4aa55539da2750","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/comment/livere.ejs","hash":"12ff9a345f6bba2f732f592e39508c2afde89b00","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/comment/valine.ejs","hash":"c23628e801e8b09ddb05b5a6b8267b767e21c6f1","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/common/footer.ejs","hash":"dc91946bfe2c25507927cffc7f97fb445e839462","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/common/article.ejs","hash":"76e4b72b62cf3e34227980aa8c7161ee27b57a7a","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/common/head.ejs","hash":"12506ec5e7970eafdfde92c8d2ea44a40f1ba141","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/common/navbar.ejs","hash":"5082ea45df0f79f955143177287d92bcf3832fcf","modified":1591839812407},{"_id":"themes/hexo-theme-icarus-master/layout/common/paginator.ejs","hash":"7837d80b27f166161b3deeffb571680025c7d723","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/common/scripts.ejs","hash":"5414d6bfbf88efa7e72ccf7e44a79d0378ddeb77","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/common/widget.ejs","hash":"5417af9f208d2fb5aaeb96031caa261e9683557c","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/donate/alipay.ejs","hash":"3290058879973e403a05472a0fe2ac0219d5b961","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/donate/patreon.ejs","hash":"8e52a9c28ffaf4b0b786a20977b848c5f60f2274","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/donate/paypal.ejs","hash":"3975dee39f9378975b9c10f37d118ad7cb6f5bf6","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/donate/wechat.ejs","hash":"051b873e1fc28c1d7c2d6443991b6a2f43813e6b","modified":1591839812408},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/animejs.ejs","hash":"198062ef863c96aa4d6a8225d575afcb60dfb1d1","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/back-to-top.ejs","hash":"79d1118a3d3ebc521ffce452b986b504f0e7d6b7","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/baidu-analytics.ejs","hash":"eb66e313ad43ec4424b2d75bae94e5c8a7568428","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/busuanzi.ejs","hash":"205dedf8f97e328bb3182dc8daebd2e2b2204aca","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/clipboard.ejs","hash":"8662ed9c211f3993b93eedcf5e41c2a1ddbede57","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/gallery.ejs","hash":"ad68fafd923747d6b7c1b5873d00989d1639678c","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/google-analytics.ejs","hash":"282cecb28ac458b71b56cf429c72ffac0f820199","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/hotjar.ejs","hash":"2b97737d802984750a7b4461fcf68818a57a2439","modified":1591839812409},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/mathjax.ejs","hash":"667aabb6b9cb4d707b37975af794d4a3c66b5264","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/outdated-browser.ejs","hash":"fe051093893c64c8575bcc67dc1c146d409e8e80","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/plugin/progressbar.ejs","hash":"e594ed6705bccbef27f49d84b6153f6443efbecd","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/search/baidu.ejs","hash":"850aa91778100d693a52b10eaa8586c8e3215ee6","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/search/google-cse.ejs","hash":"4b881a99325a6a0cebf97ac53e09d8fc67f87d29","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/search/insight.ejs","hash":"9a27db2a007582ceee7ca4b1eebddbd456893568","modified":1591839812410},{"_id":"themes/hexo-theme-icarus-master/layout/share/addthis.ejs","hash":"f1c5f337333009d5f00dfbac4864a16ef8f9cb8d","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/share/addtoany.ejs","hash":"04cb247d8c83ca7c5b52f3b11bb3ac155b1bc3ab","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/share/bdshare.ejs","hash":"f14c8084b7ee16a091f0bd2ae9039e3bfff7e7b7","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/share/sharejs.ejs","hash":"65d08316cc479910ea4f526cd1c299d0104daf7f","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/share/sharethis.ejs","hash":"4f2c40f790f3be0a4e79db04f02ea41ba2f4d4c0","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/widget/archive.ejs","hash":"eb738a2ac2935ce7a542964d90088613b281dd15","modified":1591839812411},{"_id":"themes/hexo-theme-icarus-master/layout/widget/category.ejs","hash":"c2a9f2211a21a168c54b0563cdfd58bd25fa39fe","modified":1591839812412},{"_id":"themes/hexo-theme-icarus-master/layout/widget/links.ejs","hash":"2b707fd65c94b00d8b4c6755fbc6c19709f3d49a","modified":1591839812412},{"_id":"themes/hexo-theme-icarus-master/layout/widget/profile.ejs","hash":"af05fb29b2b4e221bc50f61c1a85bb1f8c6cab89","modified":1591839812412},{"_id":"themes/hexo-theme-icarus-master/layout/widget/recent_posts.ejs","hash":"2166f3190e47bf4746775b5d16654564a88c2041","modified":1591839812412},{"_id":"themes/hexo-theme-icarus-master/layout/widget/tag.ejs","hash":"8c5b8020ca776cc3ebbc7b723915f3173efc28d4","modified":1591839812412},{"_id":"themes/hexo-theme-icarus-master/layout/widget/tagcloud.ejs","hash":"d32e7c56e8e2074da16d9141f9a597841d28d07d","modified":1591839812413},{"_id":"themes/hexo-theme-icarus-master/layout/widget/toc.ejs","hash":"bdc6f22602cdabe7c740f1818e0681ff8508fb64","modified":1591839812413},{"_id":"themes/hexo-theme-icarus-master/source/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1591839812414},{"_id":"themes/hexo-theme-icarus-master/source/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1591839812413},{"_id":"themes/hexo-theme-icarus-master/source/css/style.styl","hash":"8df581f6d748c7268b93c9f35549e757cd999bbd","modified":1591839812414},{"_id":"themes/hexo-theme-icarus-master/source/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1591839812414},{"_id":"themes/hexo-theme-icarus-master/source/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1591839812414},{"_id":"themes/hexo-theme-icarus-master/source/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1591839812414},{"_id":"themes/hexo-theme-icarus-master/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1591839812414},{"_id":"themes/hexo-theme-icarus-master/source/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1591839812416},{"_id":"themes/hexo-theme-icarus-master/source/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1591839812415},{"_id":"themes/hexo-theme-icarus-master/source/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1591839812416},{"_id":"themes/hexo-theme-icarus-master/source/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1591839812416},{"_id":"themes/hexo-theme-icarus-master/source/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1591839812417},{"_id":"themes/hexo-theme-icarus-master/source/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1591839812417},{"_id":"themes/hexo-theme-icarus-master/source/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1591839812417},{"_id":"themes/hexo-theme-icarus-master/source/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1591839812416},{"_id":"themes/hexo-theme-icarus-master/source/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1591839812415},{"_id":"source/imgs/avatar.jpg","hash":"f461b959d0313398387e62c310bcae05f53f437c","modified":1591839812385},{"_id":"source/imgs/scip/scip2-8.jpg","hash":"ea6e80b6a1650d61742e29bc9448fefd1059c045","modified":1591839812399},{"_id":"source/imgs/SEO/chap1/example.png","hash":"4df20a6de6b1c86abdc7bc1817f4c9d113e16f63","modified":1591839812383},{"_id":"source/imgs/SEO/chap1/example2.png","hash":"fb7c033f81a3f7e8ab9846867807e0693a6582d3","modified":1591839812383},{"_id":"source/imgs/scip/scip2-4.jpg","hash":"e163f4c862d45e29992d9e2c3bc685220d991fb3","modified":1591839812396},{"_id":"source/imgs/scip/scip2-3.jpg","hash":"6abcef453967107aadeb668af9bb1fa3e2aeb527","modified":1591839812394},{"_id":"source/imgs/scip/scip2-2.jpg","hash":"cc8a8f3752e58d635becc04db080f6af7d49d5b3","modified":1591839812393},{"_id":"source/imgs/avatar.png","hash":"95324890fed441c312b20be420334dc37e27c9f5","modified":1591839812390},{"_id":"public/content.json","hash":"855618bab72c57248a0f09ba137ca62ead34c4fe","modified":1591840371240},{"_id":"public/react/reactCode-react-4-2020-05-31/index.html","hash":"6bfca3097ca3d6f9fd5c071ed9eb25366408d542","modified":1591840375940},{"_id":"public/react/hooks-2020-04-22/index.html","hash":"682977dbf07cd375ff6f08936ab2b0c77d61d960","modified":1591840375940},{"_id":"public/react/reactCode-react-3-2020-04-01/index.html","hash":"1e1c3396a74273aef8529dbf9e03bf89f1756f2f","modified":1591840375940},{"_id":"public/js/numberStoreInBit-2020-03-30/index.html","hash":"4c0260c89998dbd694583cb9c61b01754e7e196a","modified":1591840375940},{"_id":"public/react/reactCode-react-2-2020-03-22/index.html","hash":"8eded42d30fa25bd4985841a83ef2ba647a3ae49","modified":1591840375940},{"_id":"public/lodash/sourceCode_lodash_3-2020-01-27/index.html","hash":"0fe99140bc727767d9c32115fa828fd08b647075","modified":1591840375940},{"_id":"public/lodash/sourceCode_lodash_2-2020-01-10/index.html","hash":"a272433dcb3a9b790fc6eb1104345b15a5c50281","modified":1591840375940},{"_id":"public/FunctionalProgrammingInJS/FPinJS(chap4-8)-2019-12-21/index.html","hash":"c5237ab5f8ef5cda3aba1a02230ac3845d8b089a","modified":1591840375940},{"_id":"public/FunctionalProgrammingInJS/FPinJS(chap1-3)-2019-12-14/index.html","hash":"89985a8cb1cff2208f561f532a63747ca85282d9","modified":1591840375940},{"_id":"public/react/reactCode-react-1-2019-12-01/index.html","hash":"1c4fe36dd5695a4daebe8ebfafdc559c3ab5597f","modified":1591840375940},{"_id":"public/lodash/sourceCode_lodash_1-2019-11-23/index.html","hash":"b58b52d287e66b9f60d004d2f36dbb28ba6c1219","modified":1591840375941},{"_id":"public/scip/scip(chap3-5)-2019-11-15/index.html","hash":"2c6a9c435d3ec0fc58ff634b9de7e02f9fd7221a","modified":1591840375941},{"_id":"public/others/reinstall-2019-11-05/index.html","hash":"6ba443b98fafe83bab67074fdd40f2be799244c0","modified":1591840375941},{"_id":"public/scip/scip(chap3-4)-2019-10-31/index.html","hash":"cabe8493e5e985fcb013c7f969e15aed72d3c41d","modified":1591840375941},{"_id":"public/scip/scip(chap3-3)-2019-10-26/index.html","hash":"ec2b135c6ba4014bba2e098d4d124890c4a27e36","modified":1591840375941},{"_id":"public/scip/scip(chap3-2)-2019-10-19/index.html","hash":"a245533da306a764383d2a1e3333693e45513ca6","modified":1591840375941},{"_id":"public/js/implicitCall-2019-09-29/index.html","hash":"ab7a84a5d165b8777dde2fc55abdd8af21c00bb5","modified":1591840375941},{"_id":"public/nihonngo/nihonngo-2-2019-09-21/index.html","hash":"013f579371bb3ce6f471f5bd080d997e79a8aa2c","modified":1591840375941},{"_id":"public/scip/scip(chap3-1)-2019-08-31/index.html","hash":"4470395cadb6f2f04a59db246fc8af929a8ffac1","modified":1591840375941},{"_id":"public/scip/scip(chap2-5)-2019-08-17/index.html","hash":"f45fe41920c5d3e7a0247e8e101c7211b65f1c63","modified":1591840375941},{"_id":"public/js/artOfModule-2019-08-11/index.html","hash":"b26dd07caa94dce2a1a4b95c21ad8ac5fc16d21d","modified":1591840375941},{"_id":"public/scip/scip(chap2-4)-2019-08-03/index.html","hash":"ef5a4a9a2e48a3deca1fc8fd4dbc36395332b4a6","modified":1591840375942},{"_id":"public/scip/scip(chap2-3)-2019-07-21/index.html","hash":"d16f36f8edef53601f0d5b72760385f9c8970fe0","modified":1591840375942},{"_id":"public/scip/scip(chap2-2)-2019-07-14/index.html","hash":"0393ef85d8caaa1bd9071fd5e5245263a362bca5","modified":1591840375942},{"_id":"public/scip/scip(chap2-1)-2019-07-04/index.html","hash":"4d5bf55e6b26ed3cfd2be724d29a742ceaf96cc0","modified":1591840375942},{"_id":"public/nihonngo/nihonngo-1-2019-06-30/index.html","hash":"c65d477df29dd8f29a344141f22688aea89fb2f2","modified":1591840375942},{"_id":"public/js/promise-2019-06-15/index.html","hash":"7d2ac94bf0ee2ed1f1ed52e9859e531a14d395cf","modified":1591840375942},{"_id":"public/others/git-1-2019-06-01/index.html","hash":"a5faf62edb3bece035824f424dc55db71fd370a5","modified":1591840375942},{"_id":"public/scip/sicp(chap1)-2019-05-18/index.html","hash":"fa62e7954d4345a3383b4e8f2624316c363df902","modified":1591840375942},{"_id":"public/scip/scip(start)-2019-05-12/index.html","hash":"b2489786a8734ba2cb66385622d1ef47bdef01f6","modified":1591840375942},{"_id":"public/js/Date-2019-05-04/index.html","hash":"36679891684223449c409bc69d13bf7f6399894b","modified":1591840375942},{"_id":"public/SEO/SEO(chap10-12)-2019-04-08/index.html","hash":"e2765aeb437df27fad96d0d53d135528254fc51f","modified":1591840375942},{"_id":"public/SEO/SEO(chap7-9)-2019-04-05/index.html","hash":"16903fa66385fd1667a86d192eab97c9c26391fb","modified":1591840375943},{"_id":"public/SEO/SEO(chap4-6)-2019-03-30/index.html","hash":"9c288034bf3c4d29b02c055ec934d4b83b629e8d","modified":1591840375943},{"_id":"public/node/whatDoPackageHave-2019-04-05/index.html","hash":"4a054943cc69474942fd6cae8b0192d77ca7242d","modified":1591840375943},{"_id":"public/others/hello-world-2019-03-24/index.html","hash":"e82fd4d6398027f4446d664fd40332b6d4d5e2a9","modified":1591840375943},{"_id":"public/SEO/SEO(chap1-3)-2019-03-24/index.html","hash":"6100877f8ee7b721f94dbcb5b0ee0c74876229c1","modified":1591840375943},{"_id":"public/others/2019-2019-03-24/index.html","hash":"bccc2ef16806db1a7272eef082b42452437e24ef","modified":1591840375943},{"_id":"public/archives/index.html","hash":"9903b2e5ebae060b6b0aad2adbfa99e05e35d3d6","modified":1591840375946},{"_id":"public/archives/page/2/index.html","hash":"d1c06d32b067ab851484e9db09d6140a94c77748","modified":1591840375947},{"_id":"public/archives/page/3/index.html","hash":"f77e71a2d00c279665f34ddcba3689266004a944","modified":1591840375947},{"_id":"public/archives/page/4/index.html","hash":"aa073fe331e199b646ebb933dcf3f89e1299e13a","modified":1591840375947},{"_id":"public/archives/2019/index.html","hash":"25e7ce4d0857c1e07d37a86409ea5063093874f2","modified":1591840375947},{"_id":"public/archives/2019/page/2/index.html","hash":"283da22e2d0510dbcd6d215f1b8b1748d541f8c1","modified":1591840375947},{"_id":"public/archives/2019/page/3/index.html","hash":"d43bbff53b1f3e563d01a113d0e8ecbc65f8c157","modified":1591840375947},{"_id":"public/archives/2019/page/4/index.html","hash":"fd3a5a40d1b99a3745327caf58680eab31cffd96","modified":1591840375947},{"_id":"public/archives/2019/03/index.html","hash":"9f9f7c32cef007c71f4d9a80f18bde6b56f39269","modified":1591840375947},{"_id":"public/archives/2019/04/index.html","hash":"b6eb588fcb50567a5db1189fdae7c50d4967adac","modified":1591840375948},{"_id":"public/archives/2019/05/index.html","hash":"2d32670df9298740348d4baf16b22d3c4c05b52a","modified":1591840375948},{"_id":"public/archives/2019/06/index.html","hash":"f44b89a5ae849f3eb4b7decca3aaf5c1a9778594","modified":1591840375948},{"_id":"public/archives/2019/07/index.html","hash":"582fc5e8aa3968cc950562dfcb5eb87f2b9a6860","modified":1591840375948},{"_id":"public/archives/2019/08/index.html","hash":"61fa972f0ae95a58c5d448e05e9f75f0541d9735","modified":1591840375948},{"_id":"public/archives/2019/10/index.html","hash":"4cb70e8a6d801c2019e3dfbec75fdce862869bb6","modified":1591840375948},{"_id":"public/archives/2019/09/index.html","hash":"1fda399642486bf3989159e57ba1fdbadac81664","modified":1591840375948},{"_id":"public/archives/2019/11/index.html","hash":"0d9035c7b966a777ef28729b6cb5c1bc84c203f6","modified":1591840375948},{"_id":"public/archives/2019/12/index.html","hash":"3f06b16f84922fc7dda64fcf8810df8e2969fa72","modified":1591840375948},{"_id":"public/archives/2020/index.html","hash":"afad43bcfb8153e4cfca9002ae00f08f85d40c95","modified":1591840375948},{"_id":"public/archives/2020/01/index.html","hash":"ae83935ff26f14b0cfdb22f77fae45bed73a2754","modified":1591840375949},{"_id":"public/archives/2020/03/index.html","hash":"961ffdf1c961537130a1d20eec084fc6b8dc5525","modified":1591840375949},{"_id":"public/archives/2020/04/index.html","hash":"5caa9a42b9c4878fadf2d327be1619addb7fe8f3","modified":1591840375949},{"_id":"public/archives/2020/05/index.html","hash":"b196f694a8075a7e96655607bb5882a46d2cb18d","modified":1591840375949},{"_id":"public/categories/读书笔记/index.html","hash":"a07025a1d19dd692f01dc447ca53e81900bb4057","modified":1591840375943},{"_id":"public/categories/读书笔记/page/2/index.html","hash":"d41fb692d1bae924bf381527ec770dba9a238b85","modified":1591840375943},{"_id":"public/categories/读书笔记/SEO深度解析/index.html","hash":"1ab54b03465b518a33a4727b427e1a4e635c309d","modified":1591840375943},{"_id":"public/categories/读书笔记/JS函数式编程指南/index.html","hash":"b5bea089a6c1fad916bdd3550cd52ef7e46be623","modified":1591840375943},{"_id":"public/categories/前端/index.html","hash":"3bf778dd97590c4b8b532ad6af14a1443cb0120d","modified":1591840375943},{"_id":"public/categories/前端/page/2/index.html","hash":"de1a85f42043fb1e0fe04fd5bde03655c7a73f23","modified":1591840375943},{"_id":"public/categories/日语/index.html","hash":"2f321c4b3d819dfa6335913ec6212a2beee758ea","modified":1591840375944},{"_id":"public/categories/生活/index.html","hash":"4e26e677fe660e511ec141297c314bc6559d03ec","modified":1591840375944},{"_id":"public/categories/Ubuntu/index.html","hash":"6bb00e00e12f0ba9416bee38a120957aed821c91","modified":1591840375944},{"_id":"public/categories/git/index.html","hash":"532d715a0c016d2d0deddee9853c8044e6c79143","modified":1591840375944},{"_id":"public/categories/前端/react/index.html","hash":"d9f773b4f53accc3f81ddca1957c38a5b66ccdae","modified":1591840375944},{"_id":"public/categories/前端/JavaScript/index.html","hash":"11b251d70af071e4ef9591fcf499f7f163ec81f5","modified":1591840375944},{"_id":"public/categories/读书笔记/sicp/index.html","hash":"79fc20742a3ecedf6a8e4972a3bf83e658d38e37","modified":1591840375944},{"_id":"public/categories/读书笔记/sicp/page/2/index.html","hash":"2c57a9f95d1bda78644d07f29ed7e11d2a5630c4","modified":1591840375944},{"_id":"public/categories/前端/lodash/index.html","hash":"a8fa3e310398ff789d18a0291fa38695c0b38a23","modified":1591840375944},{"_id":"public/categories/前端/node/index.html","hash":"754d4a5ea15b38ff4339dbd6b003c66c02cb1620","modified":1591840375944},{"_id":"public/categories/日语/标日初级上册/index.html","hash":"301a29cc92febab2524a139730d05433a5557f94","modified":1591840375944},{"_id":"public/categories/日语/标日初级下册/index.html","hash":"316e700774de58ed7098861e316116b37a4fcad1","modified":1591840375944},{"_id":"public/categories/前端/node/npm/index.html","hash":"7ec460476ca36f81ca1f8865c8b61107d65638a5","modified":1591840375945},{"_id":"public/tags/js/index.html","hash":"48dd76d9e19c364bf5c8ea07278ef11e89568263","modified":1591840375945},{"_id":"public/tags/函数式编程/index.html","hash":"06562bf005ebe009f6d1f661e58ff1883c431d88","modified":1591840375945},{"_id":"public/tags/读书笔记/index.html","hash":"ea5c5ff88704dc8212e195aad3b0fefdb48ec4f3","modified":1591840375945},{"_id":"public/tags/读书笔记/page/2/index.html","hash":"c31a1c109fc95492542d1602556c397df51452b0","modified":1591840375946},{"_id":"public/tags/SEO/index.html","hash":"6839024f8451c4bb1610802b73778e7227165ff4","modified":1591840375946},{"_id":"public/tags/知识点整理/index.html","hash":"2f4d627ac7bf6bb60d81b44cf69b177afd477014","modified":1591840375946},{"_id":"public/tags/lodash/index.html","hash":"5a58a68f0198cb386b42aa659a84518b381e8b2e","modified":1591840375946},{"_id":"public/tags/源码阅读/index.html","hash":"5e1d9e5529d293d5d1a9192f086e904b4ed8e384","modified":1591840375946},{"_id":"public/tags/npm/index.html","hash":"a3919cd1bf714437cbb90b852519761752c094fc","modified":1591840375946},{"_id":"public/tags/日语/index.html","hash":"c412760a82f4d12a4c17470d9177e1d4ff3255f6","modified":1591840375946},{"_id":"public/tags/生活/index.html","hash":"62e686aca7d3c54923f405a699640414092799b7","modified":1591840375946},{"_id":"public/tags/环境配置/index.html","hash":"2cd6bfeea3bb3454dff6bdf59c56e84c584bc9a6","modified":1591840375946},{"_id":"public/tags/react/index.html","hash":"f45921709a0f10bec959b91c794349bc560af24e","modified":1591840375946},{"_id":"public/tags/sicp/index.html","hash":"ed8dc9e0192af1789b2e9c77d66e8694d337c287","modified":1591840375946},{"_id":"public/tags/sicp/page/2/index.html","hash":"adf65d5e6b170b99124da2d6a14a48c7fb673d0c","modified":1591840375946},{"_id":"public/index.html","hash":"69918d55d66e24ea15ff96cd9da1bd52d9effcd1","modified":1591840375945},{"_id":"public/page/2/index.html","hash":"bd3065fdfa159e436366bce2c35c29976cd00e66","modified":1591840375945},{"_id":"public/page/3/index.html","hash":"c58f2304e81f2e8544a543bc670a79cfb285f64f","modified":1591840375945},{"_id":"public/page/4/index.html","hash":"9a77d19d321b0597c9e73a0c4a6dbcf416142641","modified":1591840375945},{"_id":"public/page/5/index.html","hash":"b9440e8a60e330dc4e8d790c894177ddcf899a36","modified":1591840375945},{"_id":"public/page/6/index.html","hash":"ddc9c3d73dd0d102340e487eaf2c7015385ed41c","modified":1591840375945},{"_id":"public/page/7/index.html","hash":"165913d9eb861a8a96961cc2742fdaa1550d4ee8","modified":1591840375945},{"_id":"public/page/8/index.html","hash":"a3d4b5adb5943328ae1c40a3cc83a6132ff8562f","modified":1591840375945},{"_id":"public/categories/index.html","hash":"4f7ee02b3f352a8cc23552f280ff434f9842667e","modified":1591840375949},{"_id":"public/tags/index.html","hash":"436244c556bdc0e1787a210f567ce8ca448f1ca2","modified":1591840375949},{"_id":"public/imgs/1.png","hash":"95b734c48598130f9f2ec8d2ebea1a45507cb1f3","modified":1591840191885},{"_id":"public/imgs/git-merg.png","hash":"c6937b6993a2f4bf3728dcd3725744d733fa786c","modified":1591840191885},{"_id":"public/imgs/admin.png","hash":"3cc4733c4a003d9e206f01ee5a1148baacf026c0","modified":1591840192031},{"_id":"public/imgs/titleIcon.gif","hash":"200f385add8a0e2bb156a5f5b3fbf6ce80fe2318","modified":1591840191885},{"_id":"public/imgs/scip/scip2-5.jpg","hash":"1a14e6dff9553268cb8fbd1708aa23556c2b5854","modified":1591840191886},{"_id":"public/imgs/git-snapshot.png","hash":"69f0f2c5bf0ac8538e1f7e562de0b4c8ddbca6b7","modified":1591840191886},{"_id":"public/imgs/scip/scip2-6.jpeg","hash":"b40bdb4ee081504c2c713ce39fc1f32bfead9ef0","modified":1591840191886},{"_id":"public/imgs/reactCode/reactCode1-1.jpg","hash":"24a78da374ac4175f7922c5d70b25da28aabe6c0","modified":1591840191886},{"_id":"public/imgs/scip/scip2-7.jpg","hash":"b6a797fc30ebda8475fd7e34684ca0ca886d1bdf","modified":1591840191886},{"_id":"public/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1591840191886},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1591840191886},{"_id":"public/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1591840191886},{"_id":"public/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1591840191886},{"_id":"public/imgs/SEO/chap1/example.png","hash":"4df20a6de6b1c86abdc7bc1817f4c9d113e16f63","modified":1591840191886},{"_id":"public/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1591840191886},{"_id":"public/imgs/SEO/chap1/example2.png","hash":"fb7c033f81a3f7e8ab9846867807e0693a6582d3","modified":1591840191886},{"_id":"public/imgs/scip/scip2-8.jpg","hash":"ea6e80b6a1650d61742e29bc9448fefd1059c045","modified":1591840192032},{"_id":"public/imgs/scip/scip2-3.jpg","hash":"6abcef453967107aadeb668af9bb1fa3e2aeb527","modified":1591840192032},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1591840192034},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1591840192034},{"_id":"public/css/style.css","hash":"6fd3065ac6a615be7809704b145bad6106847ff5","modified":1591840192034},{"_id":"public/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1591840192034},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1591840192034},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1591840192035},{"_id":"public/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1591840192035},{"_id":"public/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1591840192035},{"_id":"public/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1591840192034},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1591840192035},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1591840192035},{"_id":"public/imgs/avatar.jpg","hash":"f461b959d0313398387e62c310bcae05f53f437c","modified":1591840192037},{"_id":"public/imgs/scip/scip2-2.jpg","hash":"cc8a8f3752e58d635becc04db080f6af7d49d5b3","modified":1591840192039},{"_id":"public/imgs/scip/scip2-4.jpg","hash":"e163f4c862d45e29992d9e2c3bc685220d991fb3","modified":1591840192037},{"_id":"public/imgs/avatar.png","hash":"95324890fed441c312b20be420334dc37e27c9f5","modified":1591840192057},{"_id":"source/_posts/js/async.md","hash":"b114706f675c83901c21f920420b7ebceec51e36","modified":1597058311650},{"_id":"source/_posts/js/external.md","hash":"2960878b3fe849e8c77f682dd108ffa3ffc83749","modified":1600760950190},{"_id":"source/_posts/react/buildyourownreact.md","hash":"92cd8cc9c9f6875f4406be1485fa661707ff5a0c","modified":1601370959950}],"Category":[{"name":"读书笔记","_id":"ckba4hhx800049r2vz849w4u8"},{"name":"SEO深度解析","parent":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxg000f9r2v95ai2t1x"},{"name":"JS函数式编程指南","parent":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxj000l9r2vah6izv77"},{"name":"前端","_id":"ckba4hhxs001b9r2vpty0pjws"},{"name":"日语","_id":"ckba4hhye002v9r2vigha9bu9"},{"name":"生活","_id":"ckba4hhyf002z9r2vd0u9zdgm"},{"name":"Ubuntu","_id":"ckba4hhyf00329r2vvz0gjuh3"},{"name":"git","_id":"ckba4hhyf00349r2vfbo1inl7"},{"name":"JavaScript","parent":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyg00399r2v1vd3vco2"},{"name":"react","parent":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyh003c9r2vg6ibemh7"},{"name":"sicp","parent":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhyl00449r2vrmbiltbr"},{"name":"lodash","parent":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyx005g9r2v9prrd1s2"},{"name":"node","parent":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhz5006e9r2vwptzqiz7"},{"name":"标日初级上册","parent":"ckba4hhye002v9r2vigha9bu9","_id":"ckba4hhz900719r2v5yxhoj2w"},{"name":"标日初级下册","parent":"ckba4hhye002v9r2vigha9bu9","_id":"ckba4hhza00779r2vz66jkyos"},{"name":"npm","parent":"ckba4hhz5006e9r2vwptzqiz7","_id":"ckba4hhzc007d9r2v4vvq2nxi"},{"name":"自翻","parent":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckfdntts20002nq2vu4i9zdey"},{"name":"转载","parent":"ckfdntts20002nq2vu4i9zdey","_id":"ckfdntts30004nq2v2zec7w18"}],"Data":[],"Page":[],"Post":[{"title":"《JavaScript函数式编程》1~3 读后感","date":"2019-12-13T18:40:00.000Z","_content":"&emsp;&emsp;《JavaScript函数式编程》一书从语言，业务场景，程序设计的角度阐述了为什么JS需要函数式编程，JS函数式编程实际使用的场景及优势。\n<!--more-->\n&emsp;&emsp;本书的1-3章，介绍了什么是函数式编程，JS语言中函数式编程的特性，以及如何使用函数式编程解决实际场景。\n\n&emsp;&emsp;**函数式编程**是一种代码组织形式，它相对于**命令式**的编程概念。函数式编程思想简单来说，就是一个纯度的，最小功能化的，通过流方式组织上下文的编程模式。\n\n&emsp;&emsp;**纯度**指的为一个函数的参数和返回值之间的映射关系，通俗来说，相同的参数输入将会得到相同结果的输出，函数内部与外部没有赋值上的交互。简单看一个场景，全局拥有一个变量`count`为0，实现函数`increment`，每次调用得到`count + 1`的结果，然后把`increment`函数调用两次。通常使用**命令式**我们将会这么写:\n\n```JavaScript\nvar count = 0;\nfunction increment() {\n    count++;\n}\nincrement();\nincrement();\n```\n\n&emsp;&emsp;这种**命令式**的写法能够很快直观的完成所需要的功能，但是它有两个问题：\n1. 如果想要知道count的值，你必须记住increment每次的调用。\n2. 直接操作函数外部的变量，当出现多个`increment`之外的函数操作一个变量时，调用顺序稍有问题，结果将达不到预期。\n\n&emsp;&emsp;现在用**函数式编程**来改写这段简易逻辑：\n\n```JavaScript\nvar count = 0;\nfunction increment(count) {\n    return count + 1;\n}\ncount = new Array(2)\n  .fill(undefined)\n  .reduce((accumulator) => increment(accumulator), count);\n```\n\n&emsp;&emsp;首先`increment`函数不再与外部的任何变量存在交互了。它变为了一个非常具有**纯度**的函数，它的输出是可预期的，永远是入参`count + 1`。其次`count`赋值的过程被整合到了一起，以一个清晰的`流式`的概念呈现出来，在操作多的时候，非常的直观，而不用像**命令式**去数执行了几次`increment`。\n\n&emsp;&emsp;**函数式编程**鼓励功能的拆分，实现最小的功能化。然后以一种`流`的方式把功能组合起来。比如我们现在存在一组名字`['alonzo church', 'Haskell curry', 'stephen_kleene', 'John Von Neumann', 'stephen_kleene']`。我们需要把这组名字格式规范化：1.名字开头都是大写；2.名字中间使用空格分开，然后去掉其中重复的名字。使用**命令式**的方式应该是这样的：\n\n```JavaScript\nconst names = ['alonzo church', 'Haskell curry', 'stephen_kleene', 'John Von Neumann', 'stephen_kleene'];\nconst result = [];\nfor (let i = 0; i < names.length; i++) {\n    var n = name[i];\n    // n == null即可判空null和undefined\n    if (n !== undefined && n !== null) {\n        var ns = n.replace(/_/, ' ').split(' ');\n        for (let j = 0; j < ns.length; j++) {\n            var p = ns[j];\n            p = p.charAt(0).toUpperCase() + p.slice(1);\n            ns[j] = p;\n        }\n        // 去重\n        if (result.indexOf(ns.join(' ')) < 0) {\n            result.push(ns.join(' '));\n        }\n    }\n}\n```\n\n&emsp;&emsp;上面这段逻辑中，首先对数组进行**判空**操作，然后把所有带`_`下标的的名字替换成空格，然后利用字符串转数组循环将每一项第一个英文字母变为大写，然后执行去重。在函数式的概念中，这些逻辑应该拆分为一个个的单元块，然后组织起来。\n\n```JavaScript\n// notVoid -> 非空值, uniq -> 过滤数组重复, startCase -> 首字母大写，具体逻辑未实现\nconst result = name\n    .filter(notVoid)\n    .map(s => s.replace(/_/, ' '))\n    .uniq()\n    .map(startCase)\n```\n\n&emsp;&emsp;我们可以看到，name作为一个出发点，数组像流水一样经过`filter -> map -> uniq -> map`，最后得出我们想要的结果。且不论代码量的实现，即使在没有注释的情况下，我们也能根据函数的语义清晰的阅读出`name`是经过哪些数据处理得到`result`这个结果的。\n\n&emsp;&emsp;最小功能化模块设计结构也能为后续的**维护**或者**功能迭代**带来极大的方便。比如我现在更改功能需求，需要筛选出首字母在`a-k`之间的名称。第一种**命令式**的组织方式，就需要在`if`结构中进行维护。第二种维护方式只需要在`filter`这一步把`notVoid`替换为新的功能实现函数即可。\n\n&emsp;&emsp;JavaScript虽然有着`类C`的语法，但是在语法层面上更多借鉴了`scheme`。JS拥有**闭包**，**原型链**等一系列**函数式编程**需要的语言特性。在JS中，函数作为一等公民，可以作为参数传递给另一个函数。这为函数式编程的**柯里化**以及**高阶函数**的概念实现提供了完美的语言环境。","source":"_posts/FunctionalProgrammingInJS/FPinJS(chap1-3).md","raw":"---\ntitle: 《JavaScript函数式编程》1~3 读后感\ndate: 2019/12/14 02:40:00\ncategories:\n- [读书笔记, JS函数式编程指南]\ntags:\n- js\n- 函数式编程\n- 读书笔记\n---\n&emsp;&emsp;《JavaScript函数式编程》一书从语言，业务场景，程序设计的角度阐述了为什么JS需要函数式编程，JS函数式编程实际使用的场景及优势。\n<!--more-->\n&emsp;&emsp;本书的1-3章，介绍了什么是函数式编程，JS语言中函数式编程的特性，以及如何使用函数式编程解决实际场景。\n\n&emsp;&emsp;**函数式编程**是一种代码组织形式，它相对于**命令式**的编程概念。函数式编程思想简单来说，就是一个纯度的，最小功能化的，通过流方式组织上下文的编程模式。\n\n&emsp;&emsp;**纯度**指的为一个函数的参数和返回值之间的映射关系，通俗来说，相同的参数输入将会得到相同结果的输出，函数内部与外部没有赋值上的交互。简单看一个场景，全局拥有一个变量`count`为0，实现函数`increment`，每次调用得到`count + 1`的结果，然后把`increment`函数调用两次。通常使用**命令式**我们将会这么写:\n\n```JavaScript\nvar count = 0;\nfunction increment() {\n    count++;\n}\nincrement();\nincrement();\n```\n\n&emsp;&emsp;这种**命令式**的写法能够很快直观的完成所需要的功能，但是它有两个问题：\n1. 如果想要知道count的值，你必须记住increment每次的调用。\n2. 直接操作函数外部的变量，当出现多个`increment`之外的函数操作一个变量时，调用顺序稍有问题，结果将达不到预期。\n\n&emsp;&emsp;现在用**函数式编程**来改写这段简易逻辑：\n\n```JavaScript\nvar count = 0;\nfunction increment(count) {\n    return count + 1;\n}\ncount = new Array(2)\n  .fill(undefined)\n  .reduce((accumulator) => increment(accumulator), count);\n```\n\n&emsp;&emsp;首先`increment`函数不再与外部的任何变量存在交互了。它变为了一个非常具有**纯度**的函数，它的输出是可预期的，永远是入参`count + 1`。其次`count`赋值的过程被整合到了一起，以一个清晰的`流式`的概念呈现出来，在操作多的时候，非常的直观，而不用像**命令式**去数执行了几次`increment`。\n\n&emsp;&emsp;**函数式编程**鼓励功能的拆分，实现最小的功能化。然后以一种`流`的方式把功能组合起来。比如我们现在存在一组名字`['alonzo church', 'Haskell curry', 'stephen_kleene', 'John Von Neumann', 'stephen_kleene']`。我们需要把这组名字格式规范化：1.名字开头都是大写；2.名字中间使用空格分开，然后去掉其中重复的名字。使用**命令式**的方式应该是这样的：\n\n```JavaScript\nconst names = ['alonzo church', 'Haskell curry', 'stephen_kleene', 'John Von Neumann', 'stephen_kleene'];\nconst result = [];\nfor (let i = 0; i < names.length; i++) {\n    var n = name[i];\n    // n == null即可判空null和undefined\n    if (n !== undefined && n !== null) {\n        var ns = n.replace(/_/, ' ').split(' ');\n        for (let j = 0; j < ns.length; j++) {\n            var p = ns[j];\n            p = p.charAt(0).toUpperCase() + p.slice(1);\n            ns[j] = p;\n        }\n        // 去重\n        if (result.indexOf(ns.join(' ')) < 0) {\n            result.push(ns.join(' '));\n        }\n    }\n}\n```\n\n&emsp;&emsp;上面这段逻辑中，首先对数组进行**判空**操作，然后把所有带`_`下标的的名字替换成空格，然后利用字符串转数组循环将每一项第一个英文字母变为大写，然后执行去重。在函数式的概念中，这些逻辑应该拆分为一个个的单元块，然后组织起来。\n\n```JavaScript\n// notVoid -> 非空值, uniq -> 过滤数组重复, startCase -> 首字母大写，具体逻辑未实现\nconst result = name\n    .filter(notVoid)\n    .map(s => s.replace(/_/, ' '))\n    .uniq()\n    .map(startCase)\n```\n\n&emsp;&emsp;我们可以看到，name作为一个出发点，数组像流水一样经过`filter -> map -> uniq -> map`，最后得出我们想要的结果。且不论代码量的实现，即使在没有注释的情况下，我们也能根据函数的语义清晰的阅读出`name`是经过哪些数据处理得到`result`这个结果的。\n\n&emsp;&emsp;最小功能化模块设计结构也能为后续的**维护**或者**功能迭代**带来极大的方便。比如我现在更改功能需求，需要筛选出首字母在`a-k`之间的名称。第一种**命令式**的组织方式，就需要在`if`结构中进行维护。第二种维护方式只需要在`filter`这一步把`notVoid`替换为新的功能实现函数即可。\n\n&emsp;&emsp;JavaScript虽然有着`类C`的语法，但是在语法层面上更多借鉴了`scheme`。JS拥有**闭包**，**原型链**等一系列**函数式编程**需要的语言特性。在JS中，函数作为一等公民，可以作为参数传递给另一个函数。这为函数式编程的**柯里化**以及**高阶函数**的概念实现提供了完美的语言环境。","slug":"FunctionalProgrammingInJS/FPinJS(chap1-3)","published":1,"updated":"2020-06-11T01:43:32.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhx100009r2vca5qklzi","content":"<p>&emsp;&emsp;《JavaScript函数式编程》一书从语言，业务场景，程序设计的角度阐述了为什么JS需要函数式编程，JS函数式编程实际使用的场景及优势。<br><a id=\"more\"></a><br>&emsp;&emsp;本书的1-3章，介绍了什么是函数式编程，JS语言中函数式编程的特性，以及如何使用函数式编程解决实际场景。</p>\n<p>&emsp;&emsp;<strong>函数式编程</strong>是一种代码组织形式，它相对于<strong>命令式</strong>的编程概念。函数式编程思想简单来说，就是一个纯度的，最小功能化的，通过流方式组织上下文的编程模式。</p>\n<p>&emsp;&emsp;<strong>纯度</strong>指的为一个函数的参数和返回值之间的映射关系，通俗来说，相同的参数输入将会得到相同结果的输出，函数内部与外部没有赋值上的交互。简单看一个场景，全局拥有一个变量<code>count</code>为0，实现函数<code>increment</code>，每次调用得到<code>count + 1</code>的结果，然后把<code>increment</code>函数调用两次。通常使用<strong>命令式</strong>我们将会这么写:</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> count = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increment</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">increment();</span><br><span class=\"line\">increment();</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种<strong>命令式</strong>的写法能够很快直观的完成所需要的功能，但是它有两个问题：</p>\n<ol>\n<li>如果想要知道count的值，你必须记住increment每次的调用。</li>\n<li>直接操作函数外部的变量，当出现多个<code>increment</code>之外的函数操作一个变量时，调用顺序稍有问题，结果将达不到预期。</li>\n</ol>\n<p>&emsp;&emsp;现在用<strong>函数式编程</strong>来改写这段简易逻辑：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> count = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increment</span>(<span class=\"hljs-params\">count</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> count + <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">2</span>)</span><br><span class=\"line\">  .fill(<span class=\"hljs-literal\">undefined</span>)</span><br><span class=\"line\">  .reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator</span>) =&gt;</span> increment(accumulator), count);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;首先<code>increment</code>函数不再与外部的任何变量存在交互了。它变为了一个非常具有<strong>纯度</strong>的函数，它的输出是可预期的，永远是入参<code>count + 1</code>。其次<code>count</code>赋值的过程被整合到了一起，以一个清晰的<code>流式</code>的概念呈现出来，在操作多的时候，非常的直观，而不用像<strong>命令式</strong>去数执行了几次<code>increment</code>。</p>\n<p>&emsp;&emsp;<strong>函数式编程</strong>鼓励功能的拆分，实现最小的功能化。然后以一种<code>流</code>的方式把功能组合起来。比如我们现在存在一组名字<code>[&#39;alonzo church&#39;, &#39;Haskell curry&#39;, &#39;stephen_kleene&#39;, &#39;John Von Neumann&#39;, &#39;stephen_kleene&#39;]</code>。我们需要把这组名字格式规范化：1.名字开头都是大写；2.名字中间使用空格分开，然后去掉其中重复的名字。使用<strong>命令式</strong>的方式应该是这样的：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> names = [<span class=\"hljs-string\">'alonzo church'</span>, <span class=\"hljs-string\">'Haskell curry'</span>, <span class=\"hljs-string\">'stephen_kleene'</span>, <span class=\"hljs-string\">'John Von Neumann'</span>, <span class=\"hljs-string\">'stephen_kleene'</span>];</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> result = [];</span><br><span class=\"line\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; names.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> n = name[i];</span><br><span class=\"line\">    <span class=\"hljs-comment\">// n == null即可判空null和undefined</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (n !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; n !== <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">var</span> ns = n.replace(<span class=\"hljs-regexp\">/_/</span>, <span class=\"hljs-string\">' '</span>).split(<span class=\"hljs-string\">' '</span>);</span><br><span class=\"line\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; ns.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">var</span> p = ns[j];</span><br><span class=\"line\">            p = p.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + p.slice(<span class=\"hljs-number\">1</span>);</span><br><span class=\"line\">            ns[j] = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 去重</span></span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (result.indexOf(ns.join(<span class=\"hljs-string\">' '</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">            result.push(ns.join(<span class=\"hljs-string\">' '</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面这段逻辑中，首先对数组进行<strong>判空</strong>操作，然后把所有带<code>_</code>下标的的名字替换成空格，然后利用字符串转数组循环将每一项第一个英文字母变为大写，然后执行去重。在函数式的概念中，这些逻辑应该拆分为一个个的单元块，然后组织起来。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// notVoid -&gt; 非空值, uniq -&gt; 过滤数组重复, startCase -&gt; 首字母大写，具体逻辑未实现</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> result = name</span><br><span class=\"line\">    .filter(notVoid)</span><br><span class=\"line\">    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">s</span> =&gt;</span> s.replace(<span class=\"hljs-regexp\">/_/</span>, <span class=\"hljs-string\">' '</span>))</span><br><span class=\"line\">    .uniq()</span><br><span class=\"line\">    .map(startCase)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，name作为一个出发点，数组像流水一样经过<code>filter -&gt; map -&gt; uniq -&gt; map</code>，最后得出我们想要的结果。且不论代码量的实现，即使在没有注释的情况下，我们也能根据函数的语义清晰的阅读出<code>name</code>是经过哪些数据处理得到<code>result</code>这个结果的。</p>\n<p>&emsp;&emsp;最小功能化模块设计结构也能为后续的<strong>维护</strong>或者<strong>功能迭代</strong>带来极大的方便。比如我现在更改功能需求，需要筛选出首字母在<code>a-k</code>之间的名称。第一种<strong>命令式</strong>的组织方式，就需要在<code>if</code>结构中进行维护。第二种维护方式只需要在<code>filter</code>这一步把<code>notVoid</code>替换为新的功能实现函数即可。</p>\n<p>&emsp;&emsp;JavaScript虽然有着<code>类C</code>的语法，但是在语法层面上更多借鉴了<code>scheme</code>。JS拥有<strong>闭包</strong>，<strong>原型链</strong>等一系列<strong>函数式编程</strong>需要的语言特性。在JS中，函数作为一等公民，可以作为参数传递给另一个函数。这为函数式编程的<strong>柯里化</strong>以及<strong>高阶函数</strong>的概念实现提供了完美的语言环境。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;《JavaScript函数式编程》一书从语言，业务场景，程序设计的角度阐述了为什么JS需要函数式编程，JS函数式编程实际使用的场景及优势。<br></p>","more":"<br>&emsp;&emsp;本书的1-3章，介绍了什么是函数式编程，JS语言中函数式编程的特性，以及如何使用函数式编程解决实际场景。</p>\n<p>&emsp;&emsp;<strong>函数式编程</strong>是一种代码组织形式，它相对于<strong>命令式</strong>的编程概念。函数式编程思想简单来说，就是一个纯度的，最小功能化的，通过流方式组织上下文的编程模式。</p>\n<p>&emsp;&emsp;<strong>纯度</strong>指的为一个函数的参数和返回值之间的映射关系，通俗来说，相同的参数输入将会得到相同结果的输出，函数内部与外部没有赋值上的交互。简单看一个场景，全局拥有一个变量<code>count</code>为0，实现函数<code>increment</code>，每次调用得到<code>count + 1</code>的结果，然后把<code>increment</code>函数调用两次。通常使用<strong>命令式</strong>我们将会这么写:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">increment();</span><br><span class=\"line\">increment();</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种<strong>命令式</strong>的写法能够很快直观的完成所需要的功能，但是它有两个问题：</p>\n<ol>\n<li>如果想要知道count的值，你必须记住increment每次的调用。</li>\n<li>直接操作函数外部的变量，当出现多个<code>increment</code>之外的函数操作一个变量时，调用顺序稍有问题，结果将达不到预期。</li>\n</ol>\n<p>&emsp;&emsp;现在用<strong>函数式编程</strong>来改写这段简易逻辑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">count</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fill(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">  .reduce(<span class=\"function\">(<span class=\"params\">accumulator</span>) =&gt;</span> increment(accumulator), count);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;首先<code>increment</code>函数不再与外部的任何变量存在交互了。它变为了一个非常具有<strong>纯度</strong>的函数，它的输出是可预期的，永远是入参<code>count + 1</code>。其次<code>count</code>赋值的过程被整合到了一起，以一个清晰的<code>流式</code>的概念呈现出来，在操作多的时候，非常的直观，而不用像<strong>命令式</strong>去数执行了几次<code>increment</code>。</p>\n<p>&emsp;&emsp;<strong>函数式编程</strong>鼓励功能的拆分，实现最小的功能化。然后以一种<code>流</code>的方式把功能组合起来。比如我们现在存在一组名字<code>[&#39;alonzo church&#39;, &#39;Haskell curry&#39;, &#39;stephen_kleene&#39;, &#39;John Von Neumann&#39;, &#39;stephen_kleene&#39;]</code>。我们需要把这组名字格式规范化：1.名字开头都是大写；2.名字中间使用空格分开，然后去掉其中重复的名字。使用<strong>命令式</strong>的方式应该是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">'alonzo church'</span>, <span class=\"string\">'Haskell curry'</span>, <span class=\"string\">'stephen_kleene'</span>, <span class=\"string\">'John Von Neumann'</span>, <span class=\"string\">'stephen_kleene'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; names.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = name[i];</span><br><span class=\"line\">    <span class=\"comment\">// n == null即可判空null和undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n !== <span class=\"literal\">undefined</span> &amp;&amp; n !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ns = n.replace(<span class=\"regexp\">/_/</span>, <span class=\"string\">' '</span>).split(<span class=\"string\">' '</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; ns.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> p = ns[j];</span><br><span class=\"line\">            p = p.charAt(<span class=\"number\">0</span>).toUpperCase() + p.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">            ns[j] = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 去重</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.indexOf(ns.join(<span class=\"string\">' '</span>)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            result.push(ns.join(<span class=\"string\">' '</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面这段逻辑中，首先对数组进行<strong>判空</strong>操作，然后把所有带<code>_</code>下标的的名字替换成空格，然后利用字符串转数组循环将每一项第一个英文字母变为大写，然后执行去重。在函数式的概念中，这些逻辑应该拆分为一个个的单元块，然后组织起来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// notVoid -&gt; 非空值, uniq -&gt; 过滤数组重复, startCase -&gt; 首字母大写，具体逻辑未实现</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = name</span><br><span class=\"line\">    .filter(notVoid)</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> s.replace(<span class=\"regexp\">/_/</span>, <span class=\"string\">' '</span>))</span><br><span class=\"line\">    .uniq()</span><br><span class=\"line\">    .map(startCase)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，name作为一个出发点，数组像流水一样经过<code>filter -&gt; map -&gt; uniq -&gt; map</code>，最后得出我们想要的结果。且不论代码量的实现，即使在没有注释的情况下，我们也能根据函数的语义清晰的阅读出<code>name</code>是经过哪些数据处理得到<code>result</code>这个结果的。</p>\n<p>&emsp;&emsp;最小功能化模块设计结构也能为后续的<strong>维护</strong>或者<strong>功能迭代</strong>带来极大的方便。比如我现在更改功能需求，需要筛选出首字母在<code>a-k</code>之间的名称。第一种<strong>命令式</strong>的组织方式，就需要在<code>if</code>结构中进行维护。第二种维护方式只需要在<code>filter</code>这一步把<code>notVoid</code>替换为新的功能实现函数即可。</p>\n<p>&emsp;&emsp;JavaScript虽然有着<code>类C</code>的语法，但是在语法层面上更多借鉴了<code>scheme</code>。JS拥有<strong>闭包</strong>，<strong>原型链</strong>等一系列<strong>函数式编程</strong>需要的语言特性。在JS中，函数作为一等公民，可以作为参数传递给另一个函数。这为函数式编程的<strong>柯里化</strong>以及<strong>高阶函数</strong>的概念实现提供了完美的语言环境。</p>"},{"title":"《JavaScript函数式编程》4~8 读后感","date":"2019-12-21T14:28:00.000Z","_content":"&emsp;&emsp;《JavaScript函数式编程》4~8章讲了函数式编程通用的几种模式，以及在实际业务场景测试、异步操作的环境下的运用方式。\n<!--more-->\n## 函数的柯里化与管道模式\n&emsp;&emsp; 在<a href=\"../FPinJS(chap1-3)-2019-12-14/\" target=\"_blank\">《JavaScript函数式编程》1~3 读后感</a>中曾经阐述过：在函数式编程思想中，需要把每一个函数功能拆分为最小单元的功能块。即：函数的设计要精简，每个函数实现的功能需要专一，以组合的方式来实现所需要实现的业务逻辑。**函数柯里化**就是这样思想的一个实现。它利用闭包的特性，把函数拆分为最小单元，让拆分函数能够共享入参，共同操作入参，实现预期的效果。\n\n&emsp;&emsp;来看一个最简单的实例，我们现在需要实现一个函数`composeName`，放入`姓`和`名`，输出`姓 名`。比如输入`Curry`，`Haskell`，输出`Curry Haskell`。这也太简单了，不费吹灰之力就能写出来：\n```javascript\nconst composeName = (firstName, lastName) => `${firstName} ${lastName}`;\n// 使用\ncomposeName('Curry', 'Haskell'); // 'Curry Haskell'\n```\n\n&emsp;&emsp;而根据**函数柯里化**的思想，构成名字的`firstName`和`lastName`是两个概念的入参，应该拆开来进行输入的构成。就像这样：\n```javascript\nfunction curry2(fn) {\n  return function(first) {\n    return function(last) {\n      return fn(first, last);\n    }\n  }\n}\n// 这里借用 上面实现的composeName\nconst curryedComposeName = curry2(composeName)\n// 使用\ncurryedComposeName('Curry')('Haskell'); // 'Curry Haskell'\n```\n\n&emsp;&emsp;这里书写了一个最简单的二阶入参**柯里化**函数，来用来便于理解什么是**柯里化**。`curry2`做的事情很简单，接收一个函数`fn`进行包装，让这个函数接收两个参数的过程拆分开来，最后执行函数`fn`。乍一看非常脱裤子放屁的事情，其实**柯里化**做了最重要的事情就是让函数的**每一步**执行都可控制，可方便扩充。\n\n&emsp;&emsp;在实际业务场景中，用户的输入是不可控的。就上面的例子场景，假如存储进后端的名字必须符合**首字母大小，剩余部分小写**的规范，但是用户有可能输入`cuRry`。我们需要给用户输入加一个报错机制，当用户输入姓或者名不符合规范的时候，返回一个姓或者名违规的报错，不去执行`composeName`的拼接。这段逻辑在`composeName`中就需要进行一个逻辑分支的接入。\n\n```javascript\n// isNameError 是用来检测输入的英文单词是否符合首字母大写，剩余部分小写规则的函数，此处省略\nconst composeName = (firstName, lastName) => {\n  if (isNameError(firstName)) {\n    throw new Error('firstName error');\n  } else if (isNameError(firstName)) {\n    throw new Error('lastName error');\n  }\n  return `${firstName} ${lastName}`;\n};\n```\n\n&emsp;&emsp;**柯里化**状态下，已经分层的函数结构能够非常方便的扩充逻辑：\n```javascript\nfunction curry2(fn) {\n  return function(first) {\n    isNameError(first) ?\n      throw new Error('firstName error')\n      :\n      return function(last) {\n        isNameError(last) ?\n          throw new Error('firstName error')\n          :\n          return fn(first, last);\n      }\n  }\n}\n```\n\n&emsp;&emsp;**柯里化**能够便捷的对函数每一步执行进行控制和包装。比如可以绑定函数**执行的作用域**，加入一些**容错**机制，再比如在很多大型库中，对函数执行时间进行一个追踪优化，都能利用到**柯里化**进行处理。**柯里化**使用高阶函数的思路，对拆分的每一步函数进行一个**包装**，可以形成各种通用的工厂模板，比如`trackTimeCurry`，`catchErrorCurry`，进行一个通用函数模板的复用。实现代码的精简化。\n\n&emsp;&emsp;**柯里化**本质上还是使用了**拆分功能快**以及**组合**的模式。这种编程模式，还在函数式编程的另一个思路**管道模式**模式中予以体现。\n\n&emsp;&emsp;**管道模式**和shell上面的管道指令很相似：`ls -al /etc | less`。这段指令中，使用`|`，让`ls -al /etc`列出的`etc`文件夹下的所有文件列表，以`less`的方式展示出来。`|`就像一根`管道`，让`ls -al /etc`得到的结果，接入到`less`指令中。那在**管道模式**中应该存在**compose**的函数，让入参的函数前后衔接，先后处理。\n\n&emsp;&emsp;比如我们实现函数`countWords`，输入任意一段文字，去掉所有的空格，得到段落字数的功能。\n```javascript\nconst explode = str => str.split(/\\s+/);\nconst count = arr => arr.length;\n/**\n * @param {string} str any string\n * @return {number} str length without space\n */\nconst countWords = compose(explode, count);\n\n// 使用\ncountWords(anyStr);\n```\n\n&emsp;&emsp;compose就像一个管道，通过组合`explode`和`count`函数，组成了一个`countWords`的功能，把`countWords`的入参像流水一样注入到前后的函数运行参数中`countWords | explode | count`。而完成了countWords功能之后，`explode`和`count`还可以作为单一的功能函数，嵌入到其它需要实现的功能当中去，实现一个函数最大程度的**复用**。\n\n## 结语与其它\n&emsp;&emsp;书本在后续的章节还提出了几种函数式编程通用的处理模式，函数式编程为测试带来的便利，以及使用Promise的链式优雅的处理异步。过于细节和社区的通用模式这里就不再详细赘述了，这里剩下的部分总结一下阅读下来个人感觉的函数式编程的优缺点吧。\n\n- 优点：\n  1. **最小功能单元**的函数设计思想让代码的维护和复用变得非常方便，在迭代开发的背景下，功能的新增和修改也非常清晰。\n  2. **函数纯度**（与变量非交互）的概念，让编写代码单元测试变得非常的方便和清晰。\n  3. 函数流的概念能够保证代码执行顺序的准确(诸如Promise的设计)。\n\n- 缺点：\n  1. **纯度**的概念，在实际的业务场景很难实践保持，最多实行在一些归并到`utils`中的方法函数。\n  2. **最小功能单元**设计，在大的项目背景下，很容易分散在各个层级的文件中。在前端还是以`view`为主核心的情况下，很难进行实行。","source":"_posts/FunctionalProgrammingInJS/FPinJS(chap4-8).md","raw":"---\ntitle: 《JavaScript函数式编程》4~8 读后感\ndate: 2019/12/21 22:28:00\ncategories:\n- [读书笔记, JS函数式编程指南]\ntags:\n- js\n- 函数式编程\n- 读书笔记\n---\n&emsp;&emsp;《JavaScript函数式编程》4~8章讲了函数式编程通用的几种模式，以及在实际业务场景测试、异步操作的环境下的运用方式。\n<!--more-->\n## 函数的柯里化与管道模式\n&emsp;&emsp; 在<a href=\"../FPinJS(chap1-3)-2019-12-14/\" target=\"_blank\">《JavaScript函数式编程》1~3 读后感</a>中曾经阐述过：在函数式编程思想中，需要把每一个函数功能拆分为最小单元的功能块。即：函数的设计要精简，每个函数实现的功能需要专一，以组合的方式来实现所需要实现的业务逻辑。**函数柯里化**就是这样思想的一个实现。它利用闭包的特性，把函数拆分为最小单元，让拆分函数能够共享入参，共同操作入参，实现预期的效果。\n\n&emsp;&emsp;来看一个最简单的实例，我们现在需要实现一个函数`composeName`，放入`姓`和`名`，输出`姓 名`。比如输入`Curry`，`Haskell`，输出`Curry Haskell`。这也太简单了，不费吹灰之力就能写出来：\n```javascript\nconst composeName = (firstName, lastName) => `${firstName} ${lastName}`;\n// 使用\ncomposeName('Curry', 'Haskell'); // 'Curry Haskell'\n```\n\n&emsp;&emsp;而根据**函数柯里化**的思想，构成名字的`firstName`和`lastName`是两个概念的入参，应该拆开来进行输入的构成。就像这样：\n```javascript\nfunction curry2(fn) {\n  return function(first) {\n    return function(last) {\n      return fn(first, last);\n    }\n  }\n}\n// 这里借用 上面实现的composeName\nconst curryedComposeName = curry2(composeName)\n// 使用\ncurryedComposeName('Curry')('Haskell'); // 'Curry Haskell'\n```\n\n&emsp;&emsp;这里书写了一个最简单的二阶入参**柯里化**函数，来用来便于理解什么是**柯里化**。`curry2`做的事情很简单，接收一个函数`fn`进行包装，让这个函数接收两个参数的过程拆分开来，最后执行函数`fn`。乍一看非常脱裤子放屁的事情，其实**柯里化**做了最重要的事情就是让函数的**每一步**执行都可控制，可方便扩充。\n\n&emsp;&emsp;在实际业务场景中，用户的输入是不可控的。就上面的例子场景，假如存储进后端的名字必须符合**首字母大小，剩余部分小写**的规范，但是用户有可能输入`cuRry`。我们需要给用户输入加一个报错机制，当用户输入姓或者名不符合规范的时候，返回一个姓或者名违规的报错，不去执行`composeName`的拼接。这段逻辑在`composeName`中就需要进行一个逻辑分支的接入。\n\n```javascript\n// isNameError 是用来检测输入的英文单词是否符合首字母大写，剩余部分小写规则的函数，此处省略\nconst composeName = (firstName, lastName) => {\n  if (isNameError(firstName)) {\n    throw new Error('firstName error');\n  } else if (isNameError(firstName)) {\n    throw new Error('lastName error');\n  }\n  return `${firstName} ${lastName}`;\n};\n```\n\n&emsp;&emsp;**柯里化**状态下，已经分层的函数结构能够非常方便的扩充逻辑：\n```javascript\nfunction curry2(fn) {\n  return function(first) {\n    isNameError(first) ?\n      throw new Error('firstName error')\n      :\n      return function(last) {\n        isNameError(last) ?\n          throw new Error('firstName error')\n          :\n          return fn(first, last);\n      }\n  }\n}\n```\n\n&emsp;&emsp;**柯里化**能够便捷的对函数每一步执行进行控制和包装。比如可以绑定函数**执行的作用域**，加入一些**容错**机制，再比如在很多大型库中，对函数执行时间进行一个追踪优化，都能利用到**柯里化**进行处理。**柯里化**使用高阶函数的思路，对拆分的每一步函数进行一个**包装**，可以形成各种通用的工厂模板，比如`trackTimeCurry`，`catchErrorCurry`，进行一个通用函数模板的复用。实现代码的精简化。\n\n&emsp;&emsp;**柯里化**本质上还是使用了**拆分功能快**以及**组合**的模式。这种编程模式，还在函数式编程的另一个思路**管道模式**模式中予以体现。\n\n&emsp;&emsp;**管道模式**和shell上面的管道指令很相似：`ls -al /etc | less`。这段指令中，使用`|`，让`ls -al /etc`列出的`etc`文件夹下的所有文件列表，以`less`的方式展示出来。`|`就像一根`管道`，让`ls -al /etc`得到的结果，接入到`less`指令中。那在**管道模式**中应该存在**compose**的函数，让入参的函数前后衔接，先后处理。\n\n&emsp;&emsp;比如我们实现函数`countWords`，输入任意一段文字，去掉所有的空格，得到段落字数的功能。\n```javascript\nconst explode = str => str.split(/\\s+/);\nconst count = arr => arr.length;\n/**\n * @param {string} str any string\n * @return {number} str length without space\n */\nconst countWords = compose(explode, count);\n\n// 使用\ncountWords(anyStr);\n```\n\n&emsp;&emsp;compose就像一个管道，通过组合`explode`和`count`函数，组成了一个`countWords`的功能，把`countWords`的入参像流水一样注入到前后的函数运行参数中`countWords | explode | count`。而完成了countWords功能之后，`explode`和`count`还可以作为单一的功能函数，嵌入到其它需要实现的功能当中去，实现一个函数最大程度的**复用**。\n\n## 结语与其它\n&emsp;&emsp;书本在后续的章节还提出了几种函数式编程通用的处理模式，函数式编程为测试带来的便利，以及使用Promise的链式优雅的处理异步。过于细节和社区的通用模式这里就不再详细赘述了，这里剩下的部分总结一下阅读下来个人感觉的函数式编程的优缺点吧。\n\n- 优点：\n  1. **最小功能单元**的函数设计思想让代码的维护和复用变得非常方便，在迭代开发的背景下，功能的新增和修改也非常清晰。\n  2. **函数纯度**（与变量非交互）的概念，让编写代码单元测试变得非常的方便和清晰。\n  3. 函数流的概念能够保证代码执行顺序的准确(诸如Promise的设计)。\n\n- 缺点：\n  1. **纯度**的概念，在实际的业务场景很难实践保持，最多实行在一些归并到`utils`中的方法函数。\n  2. **最小功能单元**设计，在大的项目背景下，很容易分散在各个层级的文件中。在前端还是以`view`为主核心的情况下，很难进行实行。","slug":"FunctionalProgrammingInJS/FPinJS(chap4-8)","published":1,"updated":"2020-06-11T01:43:32.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhx400019r2vi5enh7gm","content":"<p>&emsp;&emsp;《JavaScript函数式编程》4~8章讲了函数式编程通用的几种模式，以及在实际业务场景测试、异步操作的环境下的运用方式。<br><a id=\"more\"></a></p>\n<h2 id=\"函数的柯里化与管道模式\"><a href=\"#函数的柯里化与管道模式\" class=\"headerlink\" title=\"函数的柯里化与管道模式\"></a>函数的柯里化与管道模式</h2><p>&emsp;&emsp; 在<a href=\"../FPinJS(chap1-3)-2019-12-14/\" target=\"_blank\">《JavaScript函数式编程》1~3 读后感</a>中曾经阐述过：在函数式编程思想中，需要把每一个函数功能拆分为最小单元的功能块。即：函数的设计要精简，每个函数实现的功能需要专一，以组合的方式来实现所需要实现的业务逻辑。<strong>函数柯里化</strong>就是这样思想的一个实现。它利用闭包的特性，把函数拆分为最小单元，让拆分函数能够共享入参，共同操作入参，实现预期的效果。</p>\n<p>&emsp;&emsp;来看一个最简单的实例，我们现在需要实现一个函数<code>composeName</code>，放入<code>姓</code>和<code>名</code>，输出<code>姓 名</code>。比如输入<code>Curry</code>，<code>Haskell</code>，输出<code>Curry Haskell</code>。这也太简单了，不费吹灰之力就能写出来：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> composeName = <span class=\"hljs-function\">(<span class=\"hljs-params\">firstName, lastName</span>) =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;firstName&#125;</span> <span class=\"hljs-subst\">$&#123;lastName&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 使用</span></span><br><span class=\"line\">composeName(<span class=\"hljs-string\">'Curry'</span>, <span class=\"hljs-string\">'Haskell'</span>); <span class=\"hljs-comment\">// 'Curry Haskell'</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;而根据<strong>函数柯里化</strong>的思想，构成名字的<code>firstName</code>和<code>lastName</code>是两个概念的入参，应该拆开来进行输入的构成。就像这样：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">curry2</span>(<span class=\"hljs-params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">first</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">last</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> fn(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 这里借用 上面实现的composeName</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> curryedComposeName = curry2(composeName)</span><br><span class=\"line\"><span class=\"hljs-comment\">// 使用</span></span><br><span class=\"line\">curryedComposeName(<span class=\"hljs-string\">'Curry'</span>)(<span class=\"hljs-string\">'Haskell'</span>); <span class=\"hljs-comment\">// 'Curry Haskell'</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里书写了一个最简单的二阶入参<strong>柯里化</strong>函数，来用来便于理解什么是<strong>柯里化</strong>。<code>curry2</code>做的事情很简单，接收一个函数<code>fn</code>进行包装，让这个函数接收两个参数的过程拆分开来，最后执行函数<code>fn</code>。乍一看非常脱裤子放屁的事情，其实<strong>柯里化</strong>做了最重要的事情就是让函数的<strong>每一步</strong>执行都可控制，可方便扩充。</p>\n<p>&emsp;&emsp;在实际业务场景中，用户的输入是不可控的。就上面的例子场景，假如存储进后端的名字必须符合<strong>首字母大小，剩余部分小写</strong>的规范，但是用户有可能输入<code>cuRry</code>。我们需要给用户输入加一个报错机制，当用户输入姓或者名不符合规范的时候，返回一个姓或者名违规的报错，不去执行<code>composeName</code>的拼接。这段逻辑在<code>composeName</code>中就需要进行一个逻辑分支的接入。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// isNameError 是用来检测输入的英文单词是否符合首字母大写，剩余部分小写规则的函数，此处省略</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> composeName = <span class=\"hljs-function\">(<span class=\"hljs-params\">firstName, lastName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isNameError(firstName)) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'firstName error'</span>);</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isNameError(firstName)) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'lastName error'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;firstName&#125;</span> <span class=\"hljs-subst\">$&#123;lastName&#125;</span>`</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<strong>柯里化</strong>状态下，已经分层的函数结构能够非常方便的扩充逻辑：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">curry2</span>(<span class=\"hljs-params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">first</span>) </span>&#123;</span><br><span class=\"line\">    isNameError(first) ?</span><br><span class=\"line\">      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'firstName error'</span>)</span><br><span class=\"line\">      :</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">last</span>) </span>&#123;</span><br><span class=\"line\">        isNameError(last) ?</span><br><span class=\"line\">          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'firstName error'</span>)</span><br><span class=\"line\">          :</span><br><span class=\"line\">          <span class=\"hljs-keyword\">return</span> fn(first, last);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<strong>柯里化</strong>能够便捷的对函数每一步执行进行控制和包装。比如可以绑定函数<strong>执行的作用域</strong>，加入一些<strong>容错</strong>机制，再比如在很多大型库中，对函数执行时间进行一个追踪优化，都能利用到<strong>柯里化</strong>进行处理。<strong>柯里化</strong>使用高阶函数的思路，对拆分的每一步函数进行一个<strong>包装</strong>，可以形成各种通用的工厂模板，比如<code>trackTimeCurry</code>，<code>catchErrorCurry</code>，进行一个通用函数模板的复用。实现代码的精简化。</p>\n<p>&emsp;&emsp;<strong>柯里化</strong>本质上还是使用了<strong>拆分功能快</strong>以及<strong>组合</strong>的模式。这种编程模式，还在函数式编程的另一个思路<strong>管道模式</strong>模式中予以体现。</p>\n<p>&emsp;&emsp;<strong>管道模式</strong>和shell上面的管道指令很相似：<code>ls -al /etc | less</code>。这段指令中，使用<code>|</code>，让<code>ls -al /etc</code>列出的<code>etc</code>文件夹下的所有文件列表，以<code>less</code>的方式展示出来。<code>|</code>就像一根<code>管道</code>，让<code>ls -al /etc</code>得到的结果，接入到<code>less</code>指令中。那在<strong>管道模式</strong>中应该存在<strong>compose</strong>的函数，让入参的函数前后衔接，先后处理。</p>\n<p>&emsp;&emsp;比如我们实现函数<code>countWords</code>，输入任意一段文字，去掉所有的空格，得到段落字数的功能。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> explode = <span class=\"hljs-function\"><span class=\"hljs-params\">str</span> =&gt;</span> str.split(<span class=\"hljs-regexp\">/\\s+/</span>);</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-function\"><span class=\"hljs-params\">arr</span> =&gt;</span> arr.length;</span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;string&#125;</span> </span>str any string</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@return <span class=\"hljs-type\">&#123;number&#125;</span> </span>str length without space</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> countWords = compose(explode, count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 使用</span></span><br><span class=\"line\">countWords(anyStr);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;compose就像一个管道，通过组合<code>explode</code>和<code>count</code>函数，组成了一个<code>countWords</code>的功能，把<code>countWords</code>的入参像流水一样注入到前后的函数运行参数中<code>countWords | explode | count</code>。而完成了countWords功能之后，<code>explode</code>和<code>count</code>还可以作为单一的功能函数，嵌入到其它需要实现的功能当中去，实现一个函数最大程度的<strong>复用</strong>。</p>\n<h2 id=\"结语与其它\"><a href=\"#结语与其它\" class=\"headerlink\" title=\"结语与其它\"></a>结语与其它</h2><p>&emsp;&emsp;书本在后续的章节还提出了几种函数式编程通用的处理模式，函数式编程为测试带来的便利，以及使用Promise的链式优雅的处理异步。过于细节和社区的通用模式这里就不再详细赘述了，这里剩下的部分总结一下阅读下来个人感觉的函数式编程的优缺点吧。</p>\n<ul>\n<li><p>优点：</p>\n<ol>\n<li><strong>最小功能单元</strong>的函数设计思想让代码的维护和复用变得非常方便，在迭代开发的背景下，功能的新增和修改也非常清晰。</li>\n<li><strong>函数纯度</strong>（与变量非交互）的概念，让编写代码单元测试变得非常的方便和清晰。</li>\n<li>函数流的概念能够保证代码执行顺序的准确(诸如Promise的设计)。</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><strong>纯度</strong>的概念，在实际的业务场景很难实践保持，最多实行在一些归并到<code>utils</code>中的方法函数。</li>\n<li><strong>最小功能单元</strong>设计，在大的项目背景下，很容易分散在各个层级的文件中。在前端还是以<code>view</code>为主核心的情况下，很难进行实行。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;《JavaScript函数式编程》4~8章讲了函数式编程通用的几种模式，以及在实际业务场景测试、异步操作的环境下的运用方式。<br></p>","more":"</p>\n<h2 id=\"函数的柯里化与管道模式\"><a href=\"#函数的柯里化与管道模式\" class=\"headerlink\" title=\"函数的柯里化与管道模式\"></a>函数的柯里化与管道模式</h2><p>&emsp;&emsp; 在<a href=\"../FPinJS(chap1-3)-2019-12-14/\" target=\"_blank\">《JavaScript函数式编程》1~3 读后感</a>中曾经阐述过：在函数式编程思想中，需要把每一个函数功能拆分为最小单元的功能块。即：函数的设计要精简，每个函数实现的功能需要专一，以组合的方式来实现所需要实现的业务逻辑。<strong>函数柯里化</strong>就是这样思想的一个实现。它利用闭包的特性，把函数拆分为最小单元，让拆分函数能够共享入参，共同操作入参，实现预期的效果。</p>\n<p>&emsp;&emsp;来看一个最简单的实例，我们现在需要实现一个函数<code>composeName</code>，放入<code>姓</code>和<code>名</code>，输出<code>姓 名</code>。比如输入<code>Curry</code>，<code>Haskell</code>，输出<code>Curry Haskell</code>。这也太简单了，不费吹灰之力就能写出来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> composeName = <span class=\"function\">(<span class=\"params\">firstName, lastName</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span> <span class=\"subst\">$&#123;lastName&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">composeName(<span class=\"string\">'Curry'</span>, <span class=\"string\">'Haskell'</span>); <span class=\"comment\">// 'Curry Haskell'</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;而根据<strong>函数柯里化</strong>的思想，构成名字的<code>firstName</code>和<code>lastName</code>是两个概念的入参，应该拆开来进行输入的构成。就像这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry2</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">last</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里借用 上面实现的composeName</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> curryedComposeName = curry2(composeName)</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">curryedComposeName(<span class=\"string\">'Curry'</span>)(<span class=\"string\">'Haskell'</span>); <span class=\"comment\">// 'Curry Haskell'</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里书写了一个最简单的二阶入参<strong>柯里化</strong>函数，来用来便于理解什么是<strong>柯里化</strong>。<code>curry2</code>做的事情很简单，接收一个函数<code>fn</code>进行包装，让这个函数接收两个参数的过程拆分开来，最后执行函数<code>fn</code>。乍一看非常脱裤子放屁的事情，其实<strong>柯里化</strong>做了最重要的事情就是让函数的<strong>每一步</strong>执行都可控制，可方便扩充。</p>\n<p>&emsp;&emsp;在实际业务场景中，用户的输入是不可控的。就上面的例子场景，假如存储进后端的名字必须符合<strong>首字母大小，剩余部分小写</strong>的规范，但是用户有可能输入<code>cuRry</code>。我们需要给用户输入加一个报错机制，当用户输入姓或者名不符合规范的时候，返回一个姓或者名违规的报错，不去执行<code>composeName</code>的拼接。这段逻辑在<code>composeName</code>中就需要进行一个逻辑分支的接入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// isNameError 是用来检测输入的英文单词是否符合首字母大写，剩余部分小写规则的函数，此处省略</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> composeName = <span class=\"function\">(<span class=\"params\">firstName, lastName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNameError(firstName)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'firstName error'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isNameError(firstName)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'lastName error'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span> <span class=\"subst\">$&#123;lastName&#125;</span>`</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<strong>柯里化</strong>状态下，已经分层的函数结构能够非常方便的扩充逻辑：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry2</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first</span>) </span>&#123;</span><br><span class=\"line\">    isNameError(first) ?</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'firstName error'</span>)</span><br><span class=\"line\">      :</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">last</span>) </span>&#123;</span><br><span class=\"line\">        isNameError(last) ?</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'firstName error'</span>)</span><br><span class=\"line\">          :</span><br><span class=\"line\">          <span class=\"keyword\">return</span> fn(first, last);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<strong>柯里化</strong>能够便捷的对函数每一步执行进行控制和包装。比如可以绑定函数<strong>执行的作用域</strong>，加入一些<strong>容错</strong>机制，再比如在很多大型库中，对函数执行时间进行一个追踪优化，都能利用到<strong>柯里化</strong>进行处理。<strong>柯里化</strong>使用高阶函数的思路，对拆分的每一步函数进行一个<strong>包装</strong>，可以形成各种通用的工厂模板，比如<code>trackTimeCurry</code>，<code>catchErrorCurry</code>，进行一个通用函数模板的复用。实现代码的精简化。</p>\n<p>&emsp;&emsp;<strong>柯里化</strong>本质上还是使用了<strong>拆分功能快</strong>以及<strong>组合</strong>的模式。这种编程模式，还在函数式编程的另一个思路<strong>管道模式</strong>模式中予以体现。</p>\n<p>&emsp;&emsp;<strong>管道模式</strong>和shell上面的管道指令很相似：<code>ls -al /etc | less</code>。这段指令中，使用<code>|</code>，让<code>ls -al /etc</code>列出的<code>etc</code>文件夹下的所有文件列表，以<code>less</code>的方式展示出来。<code>|</code>就像一根<code>管道</code>，让<code>ls -al /etc</code>得到的结果，接入到<code>less</code>指令中。那在<strong>管道模式</strong>中应该存在<strong>compose</strong>的函数，让入参的函数前后衔接，先后处理。</p>\n<p>&emsp;&emsp;比如我们实现函数<code>countWords</code>，输入任意一段文字，去掉所有的空格，得到段落字数的功能。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> explode = <span class=\"function\"><span class=\"params\">str</span> =&gt;</span> str.split(<span class=\"regexp\">/\\s+/</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> arr.length;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>str any string</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span> </span>str length without space</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> countWords = compose(explode, count);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">countWords(anyStr);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;compose就像一个管道，通过组合<code>explode</code>和<code>count</code>函数，组成了一个<code>countWords</code>的功能，把<code>countWords</code>的入参像流水一样注入到前后的函数运行参数中<code>countWords | explode | count</code>。而完成了countWords功能之后，<code>explode</code>和<code>count</code>还可以作为单一的功能函数，嵌入到其它需要实现的功能当中去，实现一个函数最大程度的<strong>复用</strong>。</p>\n<h2 id=\"结语与其它\"><a href=\"#结语与其它\" class=\"headerlink\" title=\"结语与其它\"></a>结语与其它</h2><p>&emsp;&emsp;书本在后续的章节还提出了几种函数式编程通用的处理模式，函数式编程为测试带来的便利，以及使用Promise的链式优雅的处理异步。过于细节和社区的通用模式这里就不再详细赘述了，这里剩下的部分总结一下阅读下来个人感觉的函数式编程的优缺点吧。</p>\n<ul>\n<li><p>优点：</p>\n<ol>\n<li><strong>最小功能单元</strong>的函数设计思想让代码的维护和复用变得非常方便，在迭代开发的背景下，功能的新增和修改也非常清晰。</li>\n<li><strong>函数纯度</strong>（与变量非交互）的概念，让编写代码单元测试变得非常的方便和清晰。</li>\n<li>函数流的概念能够保证代码执行顺序的准确(诸如Promise的设计)。</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><strong>纯度</strong>的概念，在实际的业务场景很难实践保持，最多实行在一些归并到<code>utils</code>中的方法函数。</li>\n<li><strong>最小功能单元</strong>设计，在大的项目背景下，很容易分散在各个层级的文件中。在前端还是以<code>view</code>为主核心的情况下，很难进行实行。</li>\n</ol>\n</li>\n</ul>"},{"title":"《SEO深度解析》读书笔记(1-3)","date":"2019-03-24T08:00:00.000Z","_content":"&emsp;&emsp;SEO(Search Engine Optimization),搜索引擎优化，根据搜索引擎(谷歌、百度)的规则来优化自己网站，提升在搜索引擎里面排名的一种技术。是前端技能树比较冷门的一环。\n<!--more-->\n&emsp;&emsp;最开始接触到SEO，是最近自己接的一个外包官网项目，甲方要求SEO上优化几个关键的搜索词，在谷歌上面能够排到前列。至此踏入SEO的坑。在搜索了几个SEO相关的博客网站，看了SEO一些相关介绍之后，得出的明显的感觉就是这个圈子大多数的人**狂妄**，**水平一般**且**不乐意分享**，分享的技术文章充斥着，`说了你也不懂`，`这个明白的都明白`等论调，每几篇文章看下来，干货没多少，自己牛逼倒是吹了不少。很多SEO的技巧论调官方没有放出，大多数人纯粹在瞎猜的阶段，比如site和domain指令的使用。想想还是自己买本书回来认真实践加学习一下，希望日后能自己维护出来一个流量权重还可以的网站。\n\n&emsp;&emsp;选择《SEO深度解析》第二版，主要原因是SEO的书籍都太老了，搜索引擎权重等算法更新很快，选了一本最近的著作，不过也是16年的了。这本书偏向**百度**的国内SEO优化，但是也有涉及到谷歌的一些内容，比较浅显易懂，比较适合SEO的入门和学习。根据章节内容大体切割了一下，计划一个半月左右读完。\n\n打算根据切割的模块写四篇左右的读书笔记：\n1. 1-3章，SEO，SEO名词介绍，搜索引擎原理简单了解\n2. 4-6章，SEO实操技巧，外链，站内优化，关键词优化\n3. 7-9章，SEO分析，对手、自己、数据分析，分析工具介绍\n4. 10-13章，一些SEO的问答和达人的经验分享。\n\n## chap-1 SEO是什么\n&emsp;&emsp;简单说明了作者对SEO的理解，SEO是一门艺术，更是一门技术。阐述了SEO的三个方向(技术方向、运营方向、和产品方向)，希望大家能对SEO有自己的认识。\n\n## chap-2 搜索引擎原理\n&emsp;&emsp;SEO宏观上的技术原理可以分为网站收录(Spider)、查询分析两个部分。大体的步骤可以阐述为：\n1. Spider，也就是常言的爬虫，通过对应的规则爬取互联网上面的网站，并将网站Url，收录到搜索引擎所在的库当中。\n2. 收录到库当中后，会将网站的内容结构拆解，建立对应的**搜索词**表，存取在搜索引擎的数据库当中。\n3. 根据算法的分析(用户体验、网站活跃度、网站收藏量、关联程度)，建立网站权重机制。\n4. 在用户搜索关键词之后，根据关联算法，推演算法，网站权重，返回搜索结果。\n\n&emsp;&emsp;SEO就是根据前三个步骤，用搜索引擎的算法规则，去优化自己的网站，获得第四个步骤上较高的排名。\n### spider的爬取\n&emsp;&emsp;网站收录，是做SEO的前提，网站都没有收录到搜索引擎的数据库中，是根本不可能出现在搜索结果里的。\n\n&emsp;&emsp;spider的爬取分为，网站的收录，网站更新两种形式，其中网站的更新还会包括**降权spider**存在。\n\n网站的收录有两种途径，一种是分布式spider根据深度优先和广度优先综合的爬取方式，爬取各个url，延伸到新的网站，进行去重算法之后，收录到库。大型优质的网站，会优先实行深度优先的爬取策略，尽量爬取全部的链接。我们在日常的搜索结果中不难看到，搜索问题的时候出现知乎，贴吧某个具体的回答，而小一些的网站就是出现网站的首页。第二种是可以自己主动提交自己的网站到搜索引擎相对应的收录方，主动将自己的网站添加收录。\n\n&emsp;&emsp;从这两点，我们不难看出，创建一个新的网站，想要快速被收录到搜索引擎当中，需要把自己网站的链接，挂到大型网站的链接当中。这点不是很现实。所以对于初创型网站，只能乖乖的写好网页结构，提交自己的网站到谷歌和百度对应的收录站点，让自己的网站能够通过收录的要求，被收录进搜索引擎的库中。小型的网站，会优先采用广度优先的爬取原则，用很少的资源，快速的爬完前几个页面，不会浪费很多的资源在深度上。因此，新的网站，不宜采用较深的面包屑导航(如嵌套index-cn-article-chap1)，一般链接层数在3层以内。在首页多方网站的主内容，是比较好的策略。待网站的权重更新高了之后，再逐渐拓深页面的导航。\n\n&emsp;&emsp;如何去看自己的网站是否被收录，其实很简单。只要到对应的搜索引擎，敲入自己的url去进行搜索就可以看到了。简单看一下我的个人网站和我外包的一个官网在百度上搜索url的结果。如果你的网站被收录了，使用www域名去搜索，是能够出现网站信息的。\n\n![个人网站Url百度搜索结果](/blog/public/imgs/SEO/chap1/example.png)\n\n![官网Url百度搜索结果](/blog/public/imgs/SEO/chap1/example2.png)\n\n&emsp;&emsp;每个spider抓取有他自己的收集范围和收录网站类型，在收录一个全新的网站之后，会进入更新spider的抓取阶段。更新spider会有一个由快到慢的频率去对收录的url进行一个信息抓取的更新，来同步获得你网站的更新平率，和建立一个更准确的权重。在数次之后，会对你的网站建立一个规律的时间，去特定的更新你网站的内容。影响更新速率的因素有很多，你网站的类型(新闻类，外链多的有较高的更新速率)，网站的权重(新浪之类的大网站会有很快的更新频率)等。那么spider更新的速率，很对提升你网站的权重有很大的帮助。\n\n&emsp;&emsp;spider是程序访问，和人访问有很大的不同。比如spider会很容易陷入死循环链接爬取，无法延迟获得ajax，iframe的内容，看不到显示的网站读取不到准确的图片信息。因此这几点做的不好的网站，很容易被拉低权重，陷入更新速度慢，权重低的泥潭。针对这一点，减少ajax的页面内容渲染(使用服务器端渲染)，拥有一个良好的语义化页面结构(多使用H5予以标签)，准确的结构分层(比如ul,ol的使用，img的alt标签的使用，b标签等标重标签突出关键词)，是让spider提升网页权重的良好的方式。切忌，不要在自己的网页当中放置无限的死循环，spider爬死之后，很容易把你的url权重拉黑。\n\n## 收录之后的内容处理\n&emsp;&emsp;spider收录回来的网页，要进行**内容清洗**之后，才能放到数据库当中。内容清洗大体上可以分为：\n1. 判断页面的类型——是web，还是pdf，excel文件，不同类型进行不同算法处理。\n2. 获取网页的文本信息，此处提取网站的title、description、keywords的标签信息，用于后续的搜索引擎结果显示。\n3. 去除页面的噪声(广告内容、版权信息、无关导航、废弃导航)，全部删除。\n4. 根据算法去除停止词(的，啊，呀)\n\n&emsp;&emsp;经过这四步之后，让网站剩下关键词的内容，进行基于词典或者分词统计的拆分，建立关键词索引，比如你的网站提炼出了，`计算机，电脑，it`的关键词，那么就会收录到这几个关键词下面数据库当中去，根据网页信息和权重，在用户搜索的时候，返回出对应列表的结果。在这一步当中你所要去优化的部分，就是写好网站的meta标签，多写关键词(页脚，img的alt当中),着重去语义化标注一些关键词(b,ruby等标签)，让你的网站出现在你希望出现的关键词当中。\n\n## 搜索需求分析\n&emsp;&emsp;这里，搜索引擎会根据用户的需求分析，去进一步建立关键词语网站的索引表，完善搜索结果。\n- 搜索意图分析，当用户搜索“霍建华”的时候，返回人物介绍，人物照片还是人物的相关新闻\n- 关键词匹配， 当搜索“计算机”的时候，也会返回“电脑”的相关搜索结果这种相近搜索词的建立\n- 关键词提取， 当搜索“我们的航母”之后，提取“航母”这个关键词的主要内容，而不是一味的去查找“我们的航母”\n- 用户体验优化，优先返回知名度高的大站，优先返回广告少，弹窗少，更新速度快，用户浏览停驻时间长的网站\n- 反作弊和人工干预，无限死链，恶性相互链接等恶意利用SEO算法提高权重的网站，会着重去反作弊降低权重\n\n&emsp;&emsp;这一块和SEO优化的关联程度不大，主要针对反作弊和人工干预这一块，注意一下不要恶意的利用SEO规则去做一些恶化用户体验的事情，导致你的网站被拉黑。在搜索结果出来之后，百度的cookie会记录一个用户访问搜索结果时间。如果用户点开一个结果之后，秒退回百度首页，那么百度会记录下来，次数多了，会降低相应的链接权重。因此，做好维护好网站的内容本身是非常重要的。\n\n## chap-3 常见名词指令讨论\n该章主要介绍了SEO的一些常见名词和一些常用指令的搜索方式。\n- 权重pr(Page Rank)\n&emsp;&emsp;权重是一个页面索引的分数值，用于综合表示网站的质量(关键词排名、外链情况、收录量、alexa排名)，是作为搜索结果排序的标志。针对性的去优化，需要内外兼修，做好外链，增加网站作品和收录量，保持优质的网站建设。\n\n- 链接农场和内容农场\n&emsp;&emsp;`链接农场`指没有实际内容，通过手机网站和交换链接来提升网站pr或权重的网站。`内容农场`指围绕关键词制作大量低质量(抄袭，堆砌关键词)内容的网站。两种都是搜索引擎严厉打击的对象。也表现了SEO两个重要的优化方向，外链数量质量，以及关键词的频率。\n\n- 指令\n&emsp;&emsp;使用`,`来分割多个搜索关键词，使用`+`来搜索同时匹配多个关键词的搜索结果。\n&emsp;&emsp;使用`site:`指令，来进行对应站点内内容搜索。比如我搜索`前端 site:www.bilibili.com`,就是在哔哩哔哩这个网站当中搜索前端的相关内容。也是查看你网站是否被收录的方法之一。如果你网站没被收录，那么这个指令是无效的。而且你的网站被降权的话，搜索结果也会排到关键词结果的后面。是查看网站是否被降权的重要手段。\n&emsp;&emsp;使用`domain:`指令进行文本查询。domain指令能够搜索纯文本的指令(即title，description，页面内容和url中的内容，不会查询js，iframe，ajax中的内容)。这个指令可以用来查看你网站获得的文本链接数和收录量。比如你查找`domain:www.mysite.com`的结果越多，可以侧面说明你网站获得链接越多。如果你专门做SEO，公司以这个数量来考察你的kpi，可以着重在这几个地方加上自己网站的链接，来增加搜索的结果数量。\n&emsp;&emsp;使用`filetype:type`来快速找到对应的文件资源。比如我查找`前端 filetype:ppt`，那么可以帮我返回前端有关的ppt资源。\n\n## 总结\n&emsp;&emsp;前三章对搜索引擎流程做了一个简单剖析，对SEO做了一个梗概的介绍。从中我们可以了解SEO大体需要做哪些方面的内容，根据搜索引擎的原理做一些针对性的优化。对于前端来说SEO更多的像偏门的一个技能点，而不是正统的技能树上的一个内容。SEO本身也是需要一个长期维护优化才能体现出来结果的技术。\n&emsp;&emsp;对于纯前端同学，照理来说应该按照SEO的思维去进行语义化标签的处理和书写。但是由于神棍的浏览器兼容性，在实际工作当中其实不能完全语义化标签去处理(比如button标签)，统一使用div反而更可控一些。如果你有一个长期维护的个人sideproject，那么学习好SEO，总归是没错的。","source":"_posts/SEO/SEO(chap1-3).md","raw":"---\ntitle: 《SEO深度解析》读书笔记(1-3)\ndate: 2019/3/24 16:00:00\ncategories:\n- [读书笔记, SEO深度解析]\ntags:\n- SEO\n- 读书笔记\n---\n&emsp;&emsp;SEO(Search Engine Optimization),搜索引擎优化，根据搜索引擎(谷歌、百度)的规则来优化自己网站，提升在搜索引擎里面排名的一种技术。是前端技能树比较冷门的一环。\n<!--more-->\n&emsp;&emsp;最开始接触到SEO，是最近自己接的一个外包官网项目，甲方要求SEO上优化几个关键的搜索词，在谷歌上面能够排到前列。至此踏入SEO的坑。在搜索了几个SEO相关的博客网站，看了SEO一些相关介绍之后，得出的明显的感觉就是这个圈子大多数的人**狂妄**，**水平一般**且**不乐意分享**，分享的技术文章充斥着，`说了你也不懂`，`这个明白的都明白`等论调，每几篇文章看下来，干货没多少，自己牛逼倒是吹了不少。很多SEO的技巧论调官方没有放出，大多数人纯粹在瞎猜的阶段，比如site和domain指令的使用。想想还是自己买本书回来认真实践加学习一下，希望日后能自己维护出来一个流量权重还可以的网站。\n\n&emsp;&emsp;选择《SEO深度解析》第二版，主要原因是SEO的书籍都太老了，搜索引擎权重等算法更新很快，选了一本最近的著作，不过也是16年的了。这本书偏向**百度**的国内SEO优化，但是也有涉及到谷歌的一些内容，比较浅显易懂，比较适合SEO的入门和学习。根据章节内容大体切割了一下，计划一个半月左右读完。\n\n打算根据切割的模块写四篇左右的读书笔记：\n1. 1-3章，SEO，SEO名词介绍，搜索引擎原理简单了解\n2. 4-6章，SEO实操技巧，外链，站内优化，关键词优化\n3. 7-9章，SEO分析，对手、自己、数据分析，分析工具介绍\n4. 10-13章，一些SEO的问答和达人的经验分享。\n\n## chap-1 SEO是什么\n&emsp;&emsp;简单说明了作者对SEO的理解，SEO是一门艺术，更是一门技术。阐述了SEO的三个方向(技术方向、运营方向、和产品方向)，希望大家能对SEO有自己的认识。\n\n## chap-2 搜索引擎原理\n&emsp;&emsp;SEO宏观上的技术原理可以分为网站收录(Spider)、查询分析两个部分。大体的步骤可以阐述为：\n1. Spider，也就是常言的爬虫，通过对应的规则爬取互联网上面的网站，并将网站Url，收录到搜索引擎所在的库当中。\n2. 收录到库当中后，会将网站的内容结构拆解，建立对应的**搜索词**表，存取在搜索引擎的数据库当中。\n3. 根据算法的分析(用户体验、网站活跃度、网站收藏量、关联程度)，建立网站权重机制。\n4. 在用户搜索关键词之后，根据关联算法，推演算法，网站权重，返回搜索结果。\n\n&emsp;&emsp;SEO就是根据前三个步骤，用搜索引擎的算法规则，去优化自己的网站，获得第四个步骤上较高的排名。\n### spider的爬取\n&emsp;&emsp;网站收录，是做SEO的前提，网站都没有收录到搜索引擎的数据库中，是根本不可能出现在搜索结果里的。\n\n&emsp;&emsp;spider的爬取分为，网站的收录，网站更新两种形式，其中网站的更新还会包括**降权spider**存在。\n\n网站的收录有两种途径，一种是分布式spider根据深度优先和广度优先综合的爬取方式，爬取各个url，延伸到新的网站，进行去重算法之后，收录到库。大型优质的网站，会优先实行深度优先的爬取策略，尽量爬取全部的链接。我们在日常的搜索结果中不难看到，搜索问题的时候出现知乎，贴吧某个具体的回答，而小一些的网站就是出现网站的首页。第二种是可以自己主动提交自己的网站到搜索引擎相对应的收录方，主动将自己的网站添加收录。\n\n&emsp;&emsp;从这两点，我们不难看出，创建一个新的网站，想要快速被收录到搜索引擎当中，需要把自己网站的链接，挂到大型网站的链接当中。这点不是很现实。所以对于初创型网站，只能乖乖的写好网页结构，提交自己的网站到谷歌和百度对应的收录站点，让自己的网站能够通过收录的要求，被收录进搜索引擎的库中。小型的网站，会优先采用广度优先的爬取原则，用很少的资源，快速的爬完前几个页面，不会浪费很多的资源在深度上。因此，新的网站，不宜采用较深的面包屑导航(如嵌套index-cn-article-chap1)，一般链接层数在3层以内。在首页多方网站的主内容，是比较好的策略。待网站的权重更新高了之后，再逐渐拓深页面的导航。\n\n&emsp;&emsp;如何去看自己的网站是否被收录，其实很简单。只要到对应的搜索引擎，敲入自己的url去进行搜索就可以看到了。简单看一下我的个人网站和我外包的一个官网在百度上搜索url的结果。如果你的网站被收录了，使用www域名去搜索，是能够出现网站信息的。\n\n![个人网站Url百度搜索结果](/blog/public/imgs/SEO/chap1/example.png)\n\n![官网Url百度搜索结果](/blog/public/imgs/SEO/chap1/example2.png)\n\n&emsp;&emsp;每个spider抓取有他自己的收集范围和收录网站类型，在收录一个全新的网站之后，会进入更新spider的抓取阶段。更新spider会有一个由快到慢的频率去对收录的url进行一个信息抓取的更新，来同步获得你网站的更新平率，和建立一个更准确的权重。在数次之后，会对你的网站建立一个规律的时间，去特定的更新你网站的内容。影响更新速率的因素有很多，你网站的类型(新闻类，外链多的有较高的更新速率)，网站的权重(新浪之类的大网站会有很快的更新频率)等。那么spider更新的速率，很对提升你网站的权重有很大的帮助。\n\n&emsp;&emsp;spider是程序访问，和人访问有很大的不同。比如spider会很容易陷入死循环链接爬取，无法延迟获得ajax，iframe的内容，看不到显示的网站读取不到准确的图片信息。因此这几点做的不好的网站，很容易被拉低权重，陷入更新速度慢，权重低的泥潭。针对这一点，减少ajax的页面内容渲染(使用服务器端渲染)，拥有一个良好的语义化页面结构(多使用H5予以标签)，准确的结构分层(比如ul,ol的使用，img的alt标签的使用，b标签等标重标签突出关键词)，是让spider提升网页权重的良好的方式。切忌，不要在自己的网页当中放置无限的死循环，spider爬死之后，很容易把你的url权重拉黑。\n\n## 收录之后的内容处理\n&emsp;&emsp;spider收录回来的网页，要进行**内容清洗**之后，才能放到数据库当中。内容清洗大体上可以分为：\n1. 判断页面的类型——是web，还是pdf，excel文件，不同类型进行不同算法处理。\n2. 获取网页的文本信息，此处提取网站的title、description、keywords的标签信息，用于后续的搜索引擎结果显示。\n3. 去除页面的噪声(广告内容、版权信息、无关导航、废弃导航)，全部删除。\n4. 根据算法去除停止词(的，啊，呀)\n\n&emsp;&emsp;经过这四步之后，让网站剩下关键词的内容，进行基于词典或者分词统计的拆分，建立关键词索引，比如你的网站提炼出了，`计算机，电脑，it`的关键词，那么就会收录到这几个关键词下面数据库当中去，根据网页信息和权重，在用户搜索的时候，返回出对应列表的结果。在这一步当中你所要去优化的部分，就是写好网站的meta标签，多写关键词(页脚，img的alt当中),着重去语义化标注一些关键词(b,ruby等标签)，让你的网站出现在你希望出现的关键词当中。\n\n## 搜索需求分析\n&emsp;&emsp;这里，搜索引擎会根据用户的需求分析，去进一步建立关键词语网站的索引表，完善搜索结果。\n- 搜索意图分析，当用户搜索“霍建华”的时候，返回人物介绍，人物照片还是人物的相关新闻\n- 关键词匹配， 当搜索“计算机”的时候，也会返回“电脑”的相关搜索结果这种相近搜索词的建立\n- 关键词提取， 当搜索“我们的航母”之后，提取“航母”这个关键词的主要内容，而不是一味的去查找“我们的航母”\n- 用户体验优化，优先返回知名度高的大站，优先返回广告少，弹窗少，更新速度快，用户浏览停驻时间长的网站\n- 反作弊和人工干预，无限死链，恶性相互链接等恶意利用SEO算法提高权重的网站，会着重去反作弊降低权重\n\n&emsp;&emsp;这一块和SEO优化的关联程度不大，主要针对反作弊和人工干预这一块，注意一下不要恶意的利用SEO规则去做一些恶化用户体验的事情，导致你的网站被拉黑。在搜索结果出来之后，百度的cookie会记录一个用户访问搜索结果时间。如果用户点开一个结果之后，秒退回百度首页，那么百度会记录下来，次数多了，会降低相应的链接权重。因此，做好维护好网站的内容本身是非常重要的。\n\n## chap-3 常见名词指令讨论\n该章主要介绍了SEO的一些常见名词和一些常用指令的搜索方式。\n- 权重pr(Page Rank)\n&emsp;&emsp;权重是一个页面索引的分数值，用于综合表示网站的质量(关键词排名、外链情况、收录量、alexa排名)，是作为搜索结果排序的标志。针对性的去优化，需要内外兼修，做好外链，增加网站作品和收录量，保持优质的网站建设。\n\n- 链接农场和内容农场\n&emsp;&emsp;`链接农场`指没有实际内容，通过手机网站和交换链接来提升网站pr或权重的网站。`内容农场`指围绕关键词制作大量低质量(抄袭，堆砌关键词)内容的网站。两种都是搜索引擎严厉打击的对象。也表现了SEO两个重要的优化方向，外链数量质量，以及关键词的频率。\n\n- 指令\n&emsp;&emsp;使用`,`来分割多个搜索关键词，使用`+`来搜索同时匹配多个关键词的搜索结果。\n&emsp;&emsp;使用`site:`指令，来进行对应站点内内容搜索。比如我搜索`前端 site:www.bilibili.com`,就是在哔哩哔哩这个网站当中搜索前端的相关内容。也是查看你网站是否被收录的方法之一。如果你网站没被收录，那么这个指令是无效的。而且你的网站被降权的话，搜索结果也会排到关键词结果的后面。是查看网站是否被降权的重要手段。\n&emsp;&emsp;使用`domain:`指令进行文本查询。domain指令能够搜索纯文本的指令(即title，description，页面内容和url中的内容，不会查询js，iframe，ajax中的内容)。这个指令可以用来查看你网站获得的文本链接数和收录量。比如你查找`domain:www.mysite.com`的结果越多，可以侧面说明你网站获得链接越多。如果你专门做SEO，公司以这个数量来考察你的kpi，可以着重在这几个地方加上自己网站的链接，来增加搜索的结果数量。\n&emsp;&emsp;使用`filetype:type`来快速找到对应的文件资源。比如我查找`前端 filetype:ppt`，那么可以帮我返回前端有关的ppt资源。\n\n## 总结\n&emsp;&emsp;前三章对搜索引擎流程做了一个简单剖析，对SEO做了一个梗概的介绍。从中我们可以了解SEO大体需要做哪些方面的内容，根据搜索引擎的原理做一些针对性的优化。对于前端来说SEO更多的像偏门的一个技能点，而不是正统的技能树上的一个内容。SEO本身也是需要一个长期维护优化才能体现出来结果的技术。\n&emsp;&emsp;对于纯前端同学，照理来说应该按照SEO的思维去进行语义化标签的处理和书写。但是由于神棍的浏览器兼容性，在实际工作当中其实不能完全语义化标签去处理(比如button标签)，统一使用div反而更可控一些。如果你有一个长期维护的个人sideproject，那么学习好SEO，总归是没错的。","slug":"SEO/SEO(chap1-3)","published":1,"updated":"2020-06-11T01:43:32.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhx700039r2v2agnq8rs","content":"<p>&emsp;&emsp;SEO(Search Engine Optimization),搜索引擎优化，根据搜索引擎(谷歌、百度)的规则来优化自己网站，提升在搜索引擎里面排名的一种技术。是前端技能树比较冷门的一环。<br><a id=\"more\"></a><br>&emsp;&emsp;最开始接触到SEO，是最近自己接的一个外包官网项目，甲方要求SEO上优化几个关键的搜索词，在谷歌上面能够排到前列。至此踏入SEO的坑。在搜索了几个SEO相关的博客网站，看了SEO一些相关介绍之后，得出的明显的感觉就是这个圈子大多数的人<strong>狂妄</strong>，<strong>水平一般</strong>且<strong>不乐意分享</strong>，分享的技术文章充斥着，<code>说了你也不懂</code>，<code>这个明白的都明白</code>等论调，每几篇文章看下来，干货没多少，自己牛逼倒是吹了不少。很多SEO的技巧论调官方没有放出，大多数人纯粹在瞎猜的阶段，比如site和domain指令的使用。想想还是自己买本书回来认真实践加学习一下，希望日后能自己维护出来一个流量权重还可以的网站。</p>\n<p>&emsp;&emsp;选择《SEO深度解析》第二版，主要原因是SEO的书籍都太老了，搜索引擎权重等算法更新很快，选了一本最近的著作，不过也是16年的了。这本书偏向<strong>百度</strong>的国内SEO优化，但是也有涉及到谷歌的一些内容，比较浅显易懂，比较适合SEO的入门和学习。根据章节内容大体切割了一下，计划一个半月左右读完。</p>\n<p>打算根据切割的模块写四篇左右的读书笔记：</p>\n<ol>\n<li>1-3章，SEO，SEO名词介绍，搜索引擎原理简单了解</li>\n<li>4-6章，SEO实操技巧，外链，站内优化，关键词优化</li>\n<li>7-9章，SEO分析，对手、自己、数据分析，分析工具介绍</li>\n<li>10-13章，一些SEO的问答和达人的经验分享。</li>\n</ol>\n<h2 id=\"chap-1-SEO是什么\"><a href=\"#chap-1-SEO是什么\" class=\"headerlink\" title=\"chap-1 SEO是什么\"></a>chap-1 SEO是什么</h2><p>&emsp;&emsp;简单说明了作者对SEO的理解，SEO是一门艺术，更是一门技术。阐述了SEO的三个方向(技术方向、运营方向、和产品方向)，希望大家能对SEO有自己的认识。</p>\n<h2 id=\"chap-2-搜索引擎原理\"><a href=\"#chap-2-搜索引擎原理\" class=\"headerlink\" title=\"chap-2 搜索引擎原理\"></a>chap-2 搜索引擎原理</h2><p>&emsp;&emsp;SEO宏观上的技术原理可以分为网站收录(Spider)、查询分析两个部分。大体的步骤可以阐述为：</p>\n<ol>\n<li>Spider，也就是常言的爬虫，通过对应的规则爬取互联网上面的网站，并将网站Url，收录到搜索引擎所在的库当中。</li>\n<li>收录到库当中后，会将网站的内容结构拆解，建立对应的<strong>搜索词</strong>表，存取在搜索引擎的数据库当中。</li>\n<li>根据算法的分析(用户体验、网站活跃度、网站收藏量、关联程度)，建立网站权重机制。</li>\n<li>在用户搜索关键词之后，根据关联算法，推演算法，网站权重，返回搜索结果。</li>\n</ol>\n<p>&emsp;&emsp;SEO就是根据前三个步骤，用搜索引擎的算法规则，去优化自己的网站，获得第四个步骤上较高的排名。</p>\n<h3 id=\"spider的爬取\"><a href=\"#spider的爬取\" class=\"headerlink\" title=\"spider的爬取\"></a>spider的爬取</h3><p>&emsp;&emsp;网站收录，是做SEO的前提，网站都没有收录到搜索引擎的数据库中，是根本不可能出现在搜索结果里的。</p>\n<p>&emsp;&emsp;spider的爬取分为，网站的收录，网站更新两种形式，其中网站的更新还会包括<strong>降权spider</strong>存在。</p>\n<p>网站的收录有两种途径，一种是分布式spider根据深度优先和广度优先综合的爬取方式，爬取各个url，延伸到新的网站，进行去重算法之后，收录到库。大型优质的网站，会优先实行深度优先的爬取策略，尽量爬取全部的链接。我们在日常的搜索结果中不难看到，搜索问题的时候出现知乎，贴吧某个具体的回答，而小一些的网站就是出现网站的首页。第二种是可以自己主动提交自己的网站到搜索引擎相对应的收录方，主动将自己的网站添加收录。</p>\n<p>&emsp;&emsp;从这两点，我们不难看出，创建一个新的网站，想要快速被收录到搜索引擎当中，需要把自己网站的链接，挂到大型网站的链接当中。这点不是很现实。所以对于初创型网站，只能乖乖的写好网页结构，提交自己的网站到谷歌和百度对应的收录站点，让自己的网站能够通过收录的要求，被收录进搜索引擎的库中。小型的网站，会优先采用广度优先的爬取原则，用很少的资源，快速的爬完前几个页面，不会浪费很多的资源在深度上。因此，新的网站，不宜采用较深的面包屑导航(如嵌套index-cn-article-chap1)，一般链接层数在3层以内。在首页多方网站的主内容，是比较好的策略。待网站的权重更新高了之后，再逐渐拓深页面的导航。</p>\n<p>&emsp;&emsp;如何去看自己的网站是否被收录，其实很简单。只要到对应的搜索引擎，敲入自己的url去进行搜索就可以看到了。简单看一下我的个人网站和我外包的一个官网在百度上搜索url的结果。如果你的网站被收录了，使用www域名去搜索，是能够出现网站信息的。</p>\n<p><img src=\"/blog/public/imgs/SEO/chap1/example.png\" alt=\"个人网站Url百度搜索结果\"></p>\n<p><img src=\"/blog/public/imgs/SEO/chap1/example2.png\" alt=\"官网Url百度搜索结果\"></p>\n<p>&emsp;&emsp;每个spider抓取有他自己的收集范围和收录网站类型，在收录一个全新的网站之后，会进入更新spider的抓取阶段。更新spider会有一个由快到慢的频率去对收录的url进行一个信息抓取的更新，来同步获得你网站的更新平率，和建立一个更准确的权重。在数次之后，会对你的网站建立一个规律的时间，去特定的更新你网站的内容。影响更新速率的因素有很多，你网站的类型(新闻类，外链多的有较高的更新速率)，网站的权重(新浪之类的大网站会有很快的更新频率)等。那么spider更新的速率，很对提升你网站的权重有很大的帮助。</p>\n<p>&emsp;&emsp;spider是程序访问，和人访问有很大的不同。比如spider会很容易陷入死循环链接爬取，无法延迟获得ajax，iframe的内容，看不到显示的网站读取不到准确的图片信息。因此这几点做的不好的网站，很容易被拉低权重，陷入更新速度慢，权重低的泥潭。针对这一点，减少ajax的页面内容渲染(使用服务器端渲染)，拥有一个良好的语义化页面结构(多使用H5予以标签)，准确的结构分层(比如ul,ol的使用，img的alt标签的使用，b标签等标重标签突出关键词)，是让spider提升网页权重的良好的方式。切忌，不要在自己的网页当中放置无限的死循环，spider爬死之后，很容易把你的url权重拉黑。</p>\n<h2 id=\"收录之后的内容处理\"><a href=\"#收录之后的内容处理\" class=\"headerlink\" title=\"收录之后的内容处理\"></a>收录之后的内容处理</h2><p>&emsp;&emsp;spider收录回来的网页，要进行<strong>内容清洗</strong>之后，才能放到数据库当中。内容清洗大体上可以分为：</p>\n<ol>\n<li>判断页面的类型——是web，还是pdf，excel文件，不同类型进行不同算法处理。</li>\n<li>获取网页的文本信息，此处提取网站的title、description、keywords的标签信息，用于后续的搜索引擎结果显示。</li>\n<li>去除页面的噪声(广告内容、版权信息、无关导航、废弃导航)，全部删除。</li>\n<li>根据算法去除停止词(的，啊，呀)</li>\n</ol>\n<p>&emsp;&emsp;经过这四步之后，让网站剩下关键词的内容，进行基于词典或者分词统计的拆分，建立关键词索引，比如你的网站提炼出了，<code>计算机，电脑，it</code>的关键词，那么就会收录到这几个关键词下面数据库当中去，根据网页信息和权重，在用户搜索的时候，返回出对应列表的结果。在这一步当中你所要去优化的部分，就是写好网站的meta标签，多写关键词(页脚，img的alt当中),着重去语义化标注一些关键词(b,ruby等标签)，让你的网站出现在你希望出现的关键词当中。</p>\n<h2 id=\"搜索需求分析\"><a href=\"#搜索需求分析\" class=\"headerlink\" title=\"搜索需求分析\"></a>搜索需求分析</h2><p>&emsp;&emsp;这里，搜索引擎会根据用户的需求分析，去进一步建立关键词语网站的索引表，完善搜索结果。</p>\n<ul>\n<li>搜索意图分析，当用户搜索“霍建华”的时候，返回人物介绍，人物照片还是人物的相关新闻</li>\n<li>关键词匹配， 当搜索“计算机”的时候，也会返回“电脑”的相关搜索结果这种相近搜索词的建立</li>\n<li>关键词提取， 当搜索“我们的航母”之后，提取“航母”这个关键词的主要内容，而不是一味的去查找“我们的航母”</li>\n<li>用户体验优化，优先返回知名度高的大站，优先返回广告少，弹窗少，更新速度快，用户浏览停驻时间长的网站</li>\n<li>反作弊和人工干预，无限死链，恶性相互链接等恶意利用SEO算法提高权重的网站，会着重去反作弊降低权重</li>\n</ul>\n<p>&emsp;&emsp;这一块和SEO优化的关联程度不大，主要针对反作弊和人工干预这一块，注意一下不要恶意的利用SEO规则去做一些恶化用户体验的事情，导致你的网站被拉黑。在搜索结果出来之后，百度的cookie会记录一个用户访问搜索结果时间。如果用户点开一个结果之后，秒退回百度首页，那么百度会记录下来，次数多了，会降低相应的链接权重。因此，做好维护好网站的内容本身是非常重要的。</p>\n<h2 id=\"chap-3-常见名词指令讨论\"><a href=\"#chap-3-常见名词指令讨论\" class=\"headerlink\" title=\"chap-3 常见名词指令讨论\"></a>chap-3 常见名词指令讨论</h2><p>该章主要介绍了SEO的一些常见名词和一些常用指令的搜索方式。</p>\n<ul>\n<li><p>权重pr(Page Rank)<br>&emsp;&emsp;权重是一个页面索引的分数值，用于综合表示网站的质量(关键词排名、外链情况、收录量、alexa排名)，是作为搜索结果排序的标志。针对性的去优化，需要内外兼修，做好外链，增加网站作品和收录量，保持优质的网站建设。</p>\n</li>\n<li><p>链接农场和内容农场<br>&emsp;&emsp;<code>链接农场</code>指没有实际内容，通过手机网站和交换链接来提升网站pr或权重的网站。<code>内容农场</code>指围绕关键词制作大量低质量(抄袭，堆砌关键词)内容的网站。两种都是搜索引擎严厉打击的对象。也表现了SEO两个重要的优化方向，外链数量质量，以及关键词的频率。</p>\n</li>\n<li><p>指令<br>&emsp;&emsp;使用<code>,</code>来分割多个搜索关键词，使用<code>+</code>来搜索同时匹配多个关键词的搜索结果。<br>&emsp;&emsp;使用<code>site:</code>指令，来进行对应站点内内容搜索。比如我搜索<code>前端 site:www.bilibili.com</code>,就是在哔哩哔哩这个网站当中搜索前端的相关内容。也是查看你网站是否被收录的方法之一。如果你网站没被收录，那么这个指令是无效的。而且你的网站被降权的话，搜索结果也会排到关键词结果的后面。是查看网站是否被降权的重要手段。<br>&emsp;&emsp;使用<code>domain:</code>指令进行文本查询。domain指令能够搜索纯文本的指令(即title，description，页面内容和url中的内容，不会查询js，iframe，ajax中的内容)。这个指令可以用来查看你网站获得的文本链接数和收录量。比如你查找<code>domain:www.mysite.com</code>的结果越多，可以侧面说明你网站获得链接越多。如果你专门做SEO，公司以这个数量来考察你的kpi，可以着重在这几个地方加上自己网站的链接，来增加搜索的结果数量。<br>&emsp;&emsp;使用<code>filetype:type</code>来快速找到对应的文件资源。比如我查找<code>前端 filetype:ppt</code>，那么可以帮我返回前端有关的ppt资源。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>&emsp;&emsp;前三章对搜索引擎流程做了一个简单剖析，对SEO做了一个梗概的介绍。从中我们可以了解SEO大体需要做哪些方面的内容，根据搜索引擎的原理做一些针对性的优化。对于前端来说SEO更多的像偏门的一个技能点，而不是正统的技能树上的一个内容。SEO本身也是需要一个长期维护优化才能体现出来结果的技术。<br>&emsp;&emsp;对于纯前端同学，照理来说应该按照SEO的思维去进行语义化标签的处理和书写。但是由于神棍的浏览器兼容性，在实际工作当中其实不能完全语义化标签去处理(比如button标签)，统一使用div反而更可控一些。如果你有一个长期维护的个人sideproject，那么学习好SEO，总归是没错的。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;SEO(Search Engine Optimization),搜索引擎优化，根据搜索引擎(谷歌、百度)的规则来优化自己网站，提升在搜索引擎里面排名的一种技术。是前端技能树比较冷门的一环。<br></p>","more":"<br>&emsp;&emsp;最开始接触到SEO，是最近自己接的一个外包官网项目，甲方要求SEO上优化几个关键的搜索词，在谷歌上面能够排到前列。至此踏入SEO的坑。在搜索了几个SEO相关的博客网站，看了SEO一些相关介绍之后，得出的明显的感觉就是这个圈子大多数的人<strong>狂妄</strong>，<strong>水平一般</strong>且<strong>不乐意分享</strong>，分享的技术文章充斥着，<code>说了你也不懂</code>，<code>这个明白的都明白</code>等论调，每几篇文章看下来，干货没多少，自己牛逼倒是吹了不少。很多SEO的技巧论调官方没有放出，大多数人纯粹在瞎猜的阶段，比如site和domain指令的使用。想想还是自己买本书回来认真实践加学习一下，希望日后能自己维护出来一个流量权重还可以的网站。</p>\n<p>&emsp;&emsp;选择《SEO深度解析》第二版，主要原因是SEO的书籍都太老了，搜索引擎权重等算法更新很快，选了一本最近的著作，不过也是16年的了。这本书偏向<strong>百度</strong>的国内SEO优化，但是也有涉及到谷歌的一些内容，比较浅显易懂，比较适合SEO的入门和学习。根据章节内容大体切割了一下，计划一个半月左右读完。</p>\n<p>打算根据切割的模块写四篇左右的读书笔记：</p>\n<ol>\n<li>1-3章，SEO，SEO名词介绍，搜索引擎原理简单了解</li>\n<li>4-6章，SEO实操技巧，外链，站内优化，关键词优化</li>\n<li>7-9章，SEO分析，对手、自己、数据分析，分析工具介绍</li>\n<li>10-13章，一些SEO的问答和达人的经验分享。</li>\n</ol>\n<h2 id=\"chap-1-SEO是什么\"><a href=\"#chap-1-SEO是什么\" class=\"headerlink\" title=\"chap-1 SEO是什么\"></a>chap-1 SEO是什么</h2><p>&emsp;&emsp;简单说明了作者对SEO的理解，SEO是一门艺术，更是一门技术。阐述了SEO的三个方向(技术方向、运营方向、和产品方向)，希望大家能对SEO有自己的认识。</p>\n<h2 id=\"chap-2-搜索引擎原理\"><a href=\"#chap-2-搜索引擎原理\" class=\"headerlink\" title=\"chap-2 搜索引擎原理\"></a>chap-2 搜索引擎原理</h2><p>&emsp;&emsp;SEO宏观上的技术原理可以分为网站收录(Spider)、查询分析两个部分。大体的步骤可以阐述为：</p>\n<ol>\n<li>Spider，也就是常言的爬虫，通过对应的规则爬取互联网上面的网站，并将网站Url，收录到搜索引擎所在的库当中。</li>\n<li>收录到库当中后，会将网站的内容结构拆解，建立对应的<strong>搜索词</strong>表，存取在搜索引擎的数据库当中。</li>\n<li>根据算法的分析(用户体验、网站活跃度、网站收藏量、关联程度)，建立网站权重机制。</li>\n<li>在用户搜索关键词之后，根据关联算法，推演算法，网站权重，返回搜索结果。</li>\n</ol>\n<p>&emsp;&emsp;SEO就是根据前三个步骤，用搜索引擎的算法规则，去优化自己的网站，获得第四个步骤上较高的排名。</p>\n<h3 id=\"spider的爬取\"><a href=\"#spider的爬取\" class=\"headerlink\" title=\"spider的爬取\"></a>spider的爬取</h3><p>&emsp;&emsp;网站收录，是做SEO的前提，网站都没有收录到搜索引擎的数据库中，是根本不可能出现在搜索结果里的。</p>\n<p>&emsp;&emsp;spider的爬取分为，网站的收录，网站更新两种形式，其中网站的更新还会包括<strong>降权spider</strong>存在。</p>\n<p>网站的收录有两种途径，一种是分布式spider根据深度优先和广度优先综合的爬取方式，爬取各个url，延伸到新的网站，进行去重算法之后，收录到库。大型优质的网站，会优先实行深度优先的爬取策略，尽量爬取全部的链接。我们在日常的搜索结果中不难看到，搜索问题的时候出现知乎，贴吧某个具体的回答，而小一些的网站就是出现网站的首页。第二种是可以自己主动提交自己的网站到搜索引擎相对应的收录方，主动将自己的网站添加收录。</p>\n<p>&emsp;&emsp;从这两点，我们不难看出，创建一个新的网站，想要快速被收录到搜索引擎当中，需要把自己网站的链接，挂到大型网站的链接当中。这点不是很现实。所以对于初创型网站，只能乖乖的写好网页结构，提交自己的网站到谷歌和百度对应的收录站点，让自己的网站能够通过收录的要求，被收录进搜索引擎的库中。小型的网站，会优先采用广度优先的爬取原则，用很少的资源，快速的爬完前几个页面，不会浪费很多的资源在深度上。因此，新的网站，不宜采用较深的面包屑导航(如嵌套index-cn-article-chap1)，一般链接层数在3层以内。在首页多方网站的主内容，是比较好的策略。待网站的权重更新高了之后，再逐渐拓深页面的导航。</p>\n<p>&emsp;&emsp;如何去看自己的网站是否被收录，其实很简单。只要到对应的搜索引擎，敲入自己的url去进行搜索就可以看到了。简单看一下我的个人网站和我外包的一个官网在百度上搜索url的结果。如果你的网站被收录了，使用www域名去搜索，是能够出现网站信息的。</p>\n<p><img src=\"/blog/public/imgs/SEO/chap1/example.png\" alt=\"个人网站Url百度搜索结果\"></p>\n<p><img src=\"/blog/public/imgs/SEO/chap1/example2.png\" alt=\"官网Url百度搜索结果\"></p>\n<p>&emsp;&emsp;每个spider抓取有他自己的收集范围和收录网站类型，在收录一个全新的网站之后，会进入更新spider的抓取阶段。更新spider会有一个由快到慢的频率去对收录的url进行一个信息抓取的更新，来同步获得你网站的更新平率，和建立一个更准确的权重。在数次之后，会对你的网站建立一个规律的时间，去特定的更新你网站的内容。影响更新速率的因素有很多，你网站的类型(新闻类，外链多的有较高的更新速率)，网站的权重(新浪之类的大网站会有很快的更新频率)等。那么spider更新的速率，很对提升你网站的权重有很大的帮助。</p>\n<p>&emsp;&emsp;spider是程序访问，和人访问有很大的不同。比如spider会很容易陷入死循环链接爬取，无法延迟获得ajax，iframe的内容，看不到显示的网站读取不到准确的图片信息。因此这几点做的不好的网站，很容易被拉低权重，陷入更新速度慢，权重低的泥潭。针对这一点，减少ajax的页面内容渲染(使用服务器端渲染)，拥有一个良好的语义化页面结构(多使用H5予以标签)，准确的结构分层(比如ul,ol的使用，img的alt标签的使用，b标签等标重标签突出关键词)，是让spider提升网页权重的良好的方式。切忌，不要在自己的网页当中放置无限的死循环，spider爬死之后，很容易把你的url权重拉黑。</p>\n<h2 id=\"收录之后的内容处理\"><a href=\"#收录之后的内容处理\" class=\"headerlink\" title=\"收录之后的内容处理\"></a>收录之后的内容处理</h2><p>&emsp;&emsp;spider收录回来的网页，要进行<strong>内容清洗</strong>之后，才能放到数据库当中。内容清洗大体上可以分为：</p>\n<ol>\n<li>判断页面的类型——是web，还是pdf，excel文件，不同类型进行不同算法处理。</li>\n<li>获取网页的文本信息，此处提取网站的title、description、keywords的标签信息，用于后续的搜索引擎结果显示。</li>\n<li>去除页面的噪声(广告内容、版权信息、无关导航、废弃导航)，全部删除。</li>\n<li>根据算法去除停止词(的，啊，呀)</li>\n</ol>\n<p>&emsp;&emsp;经过这四步之后，让网站剩下关键词的内容，进行基于词典或者分词统计的拆分，建立关键词索引，比如你的网站提炼出了，<code>计算机，电脑，it</code>的关键词，那么就会收录到这几个关键词下面数据库当中去，根据网页信息和权重，在用户搜索的时候，返回出对应列表的结果。在这一步当中你所要去优化的部分，就是写好网站的meta标签，多写关键词(页脚，img的alt当中),着重去语义化标注一些关键词(b,ruby等标签)，让你的网站出现在你希望出现的关键词当中。</p>\n<h2 id=\"搜索需求分析\"><a href=\"#搜索需求分析\" class=\"headerlink\" title=\"搜索需求分析\"></a>搜索需求分析</h2><p>&emsp;&emsp;这里，搜索引擎会根据用户的需求分析，去进一步建立关键词语网站的索引表，完善搜索结果。</p>\n<ul>\n<li>搜索意图分析，当用户搜索“霍建华”的时候，返回人物介绍，人物照片还是人物的相关新闻</li>\n<li>关键词匹配， 当搜索“计算机”的时候，也会返回“电脑”的相关搜索结果这种相近搜索词的建立</li>\n<li>关键词提取， 当搜索“我们的航母”之后，提取“航母”这个关键词的主要内容，而不是一味的去查找“我们的航母”</li>\n<li>用户体验优化，优先返回知名度高的大站，优先返回广告少，弹窗少，更新速度快，用户浏览停驻时间长的网站</li>\n<li>反作弊和人工干预，无限死链，恶性相互链接等恶意利用SEO算法提高权重的网站，会着重去反作弊降低权重</li>\n</ul>\n<p>&emsp;&emsp;这一块和SEO优化的关联程度不大，主要针对反作弊和人工干预这一块，注意一下不要恶意的利用SEO规则去做一些恶化用户体验的事情，导致你的网站被拉黑。在搜索结果出来之后，百度的cookie会记录一个用户访问搜索结果时间。如果用户点开一个结果之后，秒退回百度首页，那么百度会记录下来，次数多了，会降低相应的链接权重。因此，做好维护好网站的内容本身是非常重要的。</p>\n<h2 id=\"chap-3-常见名词指令讨论\"><a href=\"#chap-3-常见名词指令讨论\" class=\"headerlink\" title=\"chap-3 常见名词指令讨论\"></a>chap-3 常见名词指令讨论</h2><p>该章主要介绍了SEO的一些常见名词和一些常用指令的搜索方式。</p>\n<ul>\n<li><p>权重pr(Page Rank)<br>&emsp;&emsp;权重是一个页面索引的分数值，用于综合表示网站的质量(关键词排名、外链情况、收录量、alexa排名)，是作为搜索结果排序的标志。针对性的去优化，需要内外兼修，做好外链，增加网站作品和收录量，保持优质的网站建设。</p>\n</li>\n<li><p>链接农场和内容农场<br>&emsp;&emsp;<code>链接农场</code>指没有实际内容，通过手机网站和交换链接来提升网站pr或权重的网站。<code>内容农场</code>指围绕关键词制作大量低质量(抄袭，堆砌关键词)内容的网站。两种都是搜索引擎严厉打击的对象。也表现了SEO两个重要的优化方向，外链数量质量，以及关键词的频率。</p>\n</li>\n<li><p>指令<br>&emsp;&emsp;使用<code>,</code>来分割多个搜索关键词，使用<code>+</code>来搜索同时匹配多个关键词的搜索结果。<br>&emsp;&emsp;使用<code>site:</code>指令，来进行对应站点内内容搜索。比如我搜索<code>前端 site:www.bilibili.com</code>,就是在哔哩哔哩这个网站当中搜索前端的相关内容。也是查看你网站是否被收录的方法之一。如果你网站没被收录，那么这个指令是无效的。而且你的网站被降权的话，搜索结果也会排到关键词结果的后面。是查看网站是否被降权的重要手段。<br>&emsp;&emsp;使用<code>domain:</code>指令进行文本查询。domain指令能够搜索纯文本的指令(即title，description，页面内容和url中的内容，不会查询js，iframe，ajax中的内容)。这个指令可以用来查看你网站获得的文本链接数和收录量。比如你查找<code>domain:www.mysite.com</code>的结果越多，可以侧面说明你网站获得链接越多。如果你专门做SEO，公司以这个数量来考察你的kpi，可以着重在这几个地方加上自己网站的链接，来增加搜索的结果数量。<br>&emsp;&emsp;使用<code>filetype:type</code>来快速找到对应的文件资源。比如我查找<code>前端 filetype:ppt</code>，那么可以帮我返回前端有关的ppt资源。</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>&emsp;&emsp;前三章对搜索引擎流程做了一个简单剖析，对SEO做了一个梗概的介绍。从中我们可以了解SEO大体需要做哪些方面的内容，根据搜索引擎的原理做一些针对性的优化。对于前端来说SEO更多的像偏门的一个技能点，而不是正统的技能树上的一个内容。SEO本身也是需要一个长期维护优化才能体现出来结果的技术。<br>&emsp;&emsp;对于纯前端同学，照理来说应该按照SEO的思维去进行语义化标签的处理和书写。但是由于神棍的浏览器兼容性，在实际工作当中其实不能完全语义化标签去处理(比如button标签)，统一使用div反而更可控一些。如果你有一个长期维护的个人sideproject，那么学习好SEO，总归是没错的。</p>"},{"title":"《SEO深度解析》读书笔记(4-6)","date":"2019-03-30T13:00:00.000Z","_content":"&emsp;&emsp;SEO深度解析4-6章主要讲述了关键词、链接的设置取舍，以及具体如何在网站中进行相应的优化\n<!--more-->\n&emsp;&emsp;其实一直比较好奇，为什么SEO的书籍和资料，大多数到2016年开始就浅藏辄止了。这个困惑在本周和一个做竞价的同学聊天中得到了解答。同学告诉我，现在已经没有多少企业去做SEO了，成效实在太慢了，大多数都直接去做SEM了。对于大多数的中小型企业来说没有那么多时间和人力投入到一个为期半年以上，不能保证见效的项目上面去。而当企业本身的知名度出来之后，搜索引擎也会依据知名度相应的往你的网站上面去倾斜。\n&emsp;&emsp;那么SEO在当今互联网场景当中没有其适用场景了么？答案是否定的。我认为SEO在以**做网站本身起家**和**大型网站**当中仍是十分重要的一环。而对前端，对个人来说，产生语义化书写意识，规划合理整洁的路由和网站结构，未免不是一件好事。\n&emsp;&emsp;言归正传，回到我们的读书笔记当中来：\n\n## chap-4 关键词研究\n&emsp;&emsp;本章是对SEO优化中一个重要环节**关键词优化**的讨论。\n&emsp;&emsp;讨论分为两个方向：\n1. 如何为已有网站配置**精准**的关键词，以便在更好获得排名。\n2. 根据关键词配置，指导网站的内容建设。\n\n&emsp;&emsp;无论是哪个方向，挖出关键词，使网站在该**关键词下面获得高排名**是`最终目的`。\n\n&emsp;&emsp;关键词分类：\n&emsp;&emsp;关键词只有分类后，才能根据网站目的来筛选、布局和重点优化关键词。关键词主流的分类方式有三种：\n- 按搜索目的\n- 关键词长短\n- 关键词热度\n\n&emsp;&emsp;通过对关键词的划分，可以根据网站想要高排名的关键词程度，进行关键词的取舍部署。部署当中要遵守一些基本原则：\n1. 每个页面只部署2-3个关键词。(多了会导致搜索引擎在关键词上面平均的权重降低)。\n2. 除内容页面外，页面之间的关键词不可重复，甚至不可太相近。\n3. 对于太相近的关键词进行组合，尽可能分配到一个页面当中。\n4. 除内容页外，部署关键词要简洁规范，没有太多的定语形容词。\n\n## chap-5 站内优化\n&emsp;&emsp;本章是一个大章，针对网站的层级目录，内容结构，优化取舍进行了一个主要的分析，本章也是偏向技术类的一章。\n### 5.1网站结构优化\n- url优化\n&emsp;&emsp;网站的url层级一定要**清晰**，**不宜太长**，使用**小写字符**，**不要使用特殊字符**。\n&emsp;&emsp;举例：一呼百应网站下方，信息将全部放在cp目录下，http://www.youboy.com/cp/wujingongju/。动态的url也不需要特意伪装成静态，搜索引擎能够正确爬取。(?id=xxx，这种属于动态的url)\n&emsp;&emsp;url当中**包含关键词**，在百度的搜索引擎当中，**中文关键词**也是可以被查找到的。这里可以使用百度搜索的inurl:搜索指令，这个指令只会搜索url当中包含搜索关键词内容的网站，也从侧面表示，百度把url当中的中文关键词正确的搜索收录了。\n\n- siteMap相关\n&emsp;&emsp;siteMap是根据搜索引擎的标准，提供的一份网站的\"地图\",标注了网站的页面和相关内容。siteMap根据搜索引擎的不同有不同的标准，也区分格式，诸如xml或者html。但是他们的目的都是相同的，即制作一份网站的目录地图放在站点下面，让搜索引擎的爬虫来获取站点信息，方便爬取。\n&emsp;&emsp;谷歌和百度，都有对应的siteMap提交站点。提交时注意规范即可。\n\n- robots协议\n&emsp;&emsp;国内的搜索引擎在2012年集体签署遵从robots协议。robots协议重点就是通过robots相关html属性设置，告诉爬虫这一块内容不要去爬取。这么做的好处就是保证网站的权重全部放在想要放出的url链接和关键词内容上面。\n&emsp;&emsp;robots协议方法，在网站根目录使用robots.txt文件，或者使用meta标签(`<Meta name=\"robots\" content=\"nofollow\">`)。\n&emsp;&emsp;使用robots协议可以规避死链接，保护网站隐私，防止后台管理站点被抓取，增加关键词权重。\n\n- 导航优化\n&emsp;&emsp;导航优化简单来说，就是让spider爬的放心，爬的舒心，让网站的url能够收录全\n&emsp;&emsp;导航优化主要遵从，多级导航要分类(如按照行业分类，材料分类等)。用户不关注的底部导航部分可以堆内链。使用面包屑导航(首页>博客>读书笔记)，在当前页面能够知道自己所处在站点的位置，并且能够返回。\n\n- 内链与nofollow\n&emsp;&emsp;内链要**高聚合**，**相关性强**。要在站点的某个页面，能够访问到站点的大部分内链。确保每个页面至少有一个文本链接(非ajax，flash形成的链接)能够访问到。同一个页面链接越多，每个链接获得的权重就越小。因此，在一些无关紧要的链接上，可以使用nofollow去优化。使用方法`<a href=\"someurl\" rel=\"nofollow\">灌水</a>`。\n&emsp;&emsp;当存在一些内容相似的网站，其实只需要搜素引擎爬取一个时，可以在head部分创建Canonical标签，来让爬虫只收录标准页的内容，增加标准页的权重。`<link rel=\"Canonical\" href=\"规范页url\">`。\n&emsp;&emsp;除此之外，做好404和500+的http状态码的处理也是十分重要的一环。这两种非成功的状态码会被spider视为影响用户体验状态码，从而去降低网站的权重。因此做好url的清理，即时提交sitemap和robots文件，把这些协议清除出去，就显得十分重要。\n\n### 5.2网站内容建设\n&emsp;&emsp;网站内容建设是整个seo的核心部分，抓住关键词，合理优化网站内容结构，是提高网站权重的关键。\n&emsp;&emsp;网站内容建设要注意分词理论的运用，在文章标题和文章内容上做足功夫。\n&emsp;&emsp;文章标题，显示在搜索结果中，既要存在关键词，又要吸引人：\n1. 疑问性标题： 如果没有房子，会有婚姻吗？\n2. 指定范围型标题： “90后”创业3年买房，让“80”后情何以堪\n3. 包含数字标题： 2012年10大重要新闻盘点\n4. 吹牛攀比型标题：快递员每月可拿12000元工资\n5. 刻意勾上美女帅哥和性\n6. 为醒目的标题加【图文】标识符： 【图文】\n&emsp;&emsp;文章内容，seo爬取的参考，需要做一些关键词的两到三次的堆砌。诸如长尾关键词，刻意在文章内容当中进行放置。此外，也可以使用h系列标签(h2-h4)和strong标签，来标注出来关键词，让浏览器爬取。\n\n### 5.3网站页面优化\n&emsp;&emsp;网站页面，需要有最基本的seo优化事项。\n1. 关键词定位，在titile和description中布局关键词，title放2-3的需要的关键词。\n2. 页面噪声比控制，要有主题内容的突出，不能是一味的广告。\n3. 精简网页的代码，加快spider爬取速度。打包压缩html和css和js等\n4. 图片和视频优化。由于图片和视频是无法被spider辨识为关键词，所以需要在周边的文字进行一些图片和视频内容的描述，方便spider能够辨识爬取。同时，用好img的alt标签。\n\n## chap-6 外链建设\n&emsp;&emsp;seo当中有**内容为王，外链为皇**的说法。做好外链是网站提升seo权重的重要手段之一。可以这么理解，在链接都是客观产生(非人为)的情况下，那么整个互联网当中最优质的内容，就应该是链接最多的内容，所以搜索引擎很倾向于根据外链的数量，去进行页面权重的建立。\n&emsp;&emsp;本章主要对seo外链的一些注意事项和检测方式做了一些科普，简单来说就是没啥干货内容，这里简单进行一个概括。\n&emsp;&emsp;seo外链主要注意对方交换网站，不要和链接农场进行链接交换导致自己网页的权重被降低，也要注意对方网站的相关内容以及rp是否和自己网站rp相匹配。自己在放置外链的一些页面也要时常检查，做好链接可用性的检查工作以及及时沟通。","source":"_posts/SEO/SEO(chap4-6).md","raw":"---\ntitle: 《SEO深度解析》读书笔记(4-6)\ndate: 2019/3/30 21:00:00\ncategories:\n- [读书笔记, SEO深度解析]\ntags:\n- SEO\n- 读书笔记\n---\n&emsp;&emsp;SEO深度解析4-6章主要讲述了关键词、链接的设置取舍，以及具体如何在网站中进行相应的优化\n<!--more-->\n&emsp;&emsp;其实一直比较好奇，为什么SEO的书籍和资料，大多数到2016年开始就浅藏辄止了。这个困惑在本周和一个做竞价的同学聊天中得到了解答。同学告诉我，现在已经没有多少企业去做SEO了，成效实在太慢了，大多数都直接去做SEM了。对于大多数的中小型企业来说没有那么多时间和人力投入到一个为期半年以上，不能保证见效的项目上面去。而当企业本身的知名度出来之后，搜索引擎也会依据知名度相应的往你的网站上面去倾斜。\n&emsp;&emsp;那么SEO在当今互联网场景当中没有其适用场景了么？答案是否定的。我认为SEO在以**做网站本身起家**和**大型网站**当中仍是十分重要的一环。而对前端，对个人来说，产生语义化书写意识，规划合理整洁的路由和网站结构，未免不是一件好事。\n&emsp;&emsp;言归正传，回到我们的读书笔记当中来：\n\n## chap-4 关键词研究\n&emsp;&emsp;本章是对SEO优化中一个重要环节**关键词优化**的讨论。\n&emsp;&emsp;讨论分为两个方向：\n1. 如何为已有网站配置**精准**的关键词，以便在更好获得排名。\n2. 根据关键词配置，指导网站的内容建设。\n\n&emsp;&emsp;无论是哪个方向，挖出关键词，使网站在该**关键词下面获得高排名**是`最终目的`。\n\n&emsp;&emsp;关键词分类：\n&emsp;&emsp;关键词只有分类后，才能根据网站目的来筛选、布局和重点优化关键词。关键词主流的分类方式有三种：\n- 按搜索目的\n- 关键词长短\n- 关键词热度\n\n&emsp;&emsp;通过对关键词的划分，可以根据网站想要高排名的关键词程度，进行关键词的取舍部署。部署当中要遵守一些基本原则：\n1. 每个页面只部署2-3个关键词。(多了会导致搜索引擎在关键词上面平均的权重降低)。\n2. 除内容页面外，页面之间的关键词不可重复，甚至不可太相近。\n3. 对于太相近的关键词进行组合，尽可能分配到一个页面当中。\n4. 除内容页外，部署关键词要简洁规范，没有太多的定语形容词。\n\n## chap-5 站内优化\n&emsp;&emsp;本章是一个大章，针对网站的层级目录，内容结构，优化取舍进行了一个主要的分析，本章也是偏向技术类的一章。\n### 5.1网站结构优化\n- url优化\n&emsp;&emsp;网站的url层级一定要**清晰**，**不宜太长**，使用**小写字符**，**不要使用特殊字符**。\n&emsp;&emsp;举例：一呼百应网站下方，信息将全部放在cp目录下，http://www.youboy.com/cp/wujingongju/。动态的url也不需要特意伪装成静态，搜索引擎能够正确爬取。(?id=xxx，这种属于动态的url)\n&emsp;&emsp;url当中**包含关键词**，在百度的搜索引擎当中，**中文关键词**也是可以被查找到的。这里可以使用百度搜索的inurl:搜索指令，这个指令只会搜索url当中包含搜索关键词内容的网站，也从侧面表示，百度把url当中的中文关键词正确的搜索收录了。\n\n- siteMap相关\n&emsp;&emsp;siteMap是根据搜索引擎的标准，提供的一份网站的\"地图\",标注了网站的页面和相关内容。siteMap根据搜索引擎的不同有不同的标准，也区分格式，诸如xml或者html。但是他们的目的都是相同的，即制作一份网站的目录地图放在站点下面，让搜索引擎的爬虫来获取站点信息，方便爬取。\n&emsp;&emsp;谷歌和百度，都有对应的siteMap提交站点。提交时注意规范即可。\n\n- robots协议\n&emsp;&emsp;国内的搜索引擎在2012年集体签署遵从robots协议。robots协议重点就是通过robots相关html属性设置，告诉爬虫这一块内容不要去爬取。这么做的好处就是保证网站的权重全部放在想要放出的url链接和关键词内容上面。\n&emsp;&emsp;robots协议方法，在网站根目录使用robots.txt文件，或者使用meta标签(`<Meta name=\"robots\" content=\"nofollow\">`)。\n&emsp;&emsp;使用robots协议可以规避死链接，保护网站隐私，防止后台管理站点被抓取，增加关键词权重。\n\n- 导航优化\n&emsp;&emsp;导航优化简单来说，就是让spider爬的放心，爬的舒心，让网站的url能够收录全\n&emsp;&emsp;导航优化主要遵从，多级导航要分类(如按照行业分类，材料分类等)。用户不关注的底部导航部分可以堆内链。使用面包屑导航(首页>博客>读书笔记)，在当前页面能够知道自己所处在站点的位置，并且能够返回。\n\n- 内链与nofollow\n&emsp;&emsp;内链要**高聚合**，**相关性强**。要在站点的某个页面，能够访问到站点的大部分内链。确保每个页面至少有一个文本链接(非ajax，flash形成的链接)能够访问到。同一个页面链接越多，每个链接获得的权重就越小。因此，在一些无关紧要的链接上，可以使用nofollow去优化。使用方法`<a href=\"someurl\" rel=\"nofollow\">灌水</a>`。\n&emsp;&emsp;当存在一些内容相似的网站，其实只需要搜素引擎爬取一个时，可以在head部分创建Canonical标签，来让爬虫只收录标准页的内容，增加标准页的权重。`<link rel=\"Canonical\" href=\"规范页url\">`。\n&emsp;&emsp;除此之外，做好404和500+的http状态码的处理也是十分重要的一环。这两种非成功的状态码会被spider视为影响用户体验状态码，从而去降低网站的权重。因此做好url的清理，即时提交sitemap和robots文件，把这些协议清除出去，就显得十分重要。\n\n### 5.2网站内容建设\n&emsp;&emsp;网站内容建设是整个seo的核心部分，抓住关键词，合理优化网站内容结构，是提高网站权重的关键。\n&emsp;&emsp;网站内容建设要注意分词理论的运用，在文章标题和文章内容上做足功夫。\n&emsp;&emsp;文章标题，显示在搜索结果中，既要存在关键词，又要吸引人：\n1. 疑问性标题： 如果没有房子，会有婚姻吗？\n2. 指定范围型标题： “90后”创业3年买房，让“80”后情何以堪\n3. 包含数字标题： 2012年10大重要新闻盘点\n4. 吹牛攀比型标题：快递员每月可拿12000元工资\n5. 刻意勾上美女帅哥和性\n6. 为醒目的标题加【图文】标识符： 【图文】\n&emsp;&emsp;文章内容，seo爬取的参考，需要做一些关键词的两到三次的堆砌。诸如长尾关键词，刻意在文章内容当中进行放置。此外，也可以使用h系列标签(h2-h4)和strong标签，来标注出来关键词，让浏览器爬取。\n\n### 5.3网站页面优化\n&emsp;&emsp;网站页面，需要有最基本的seo优化事项。\n1. 关键词定位，在titile和description中布局关键词，title放2-3的需要的关键词。\n2. 页面噪声比控制，要有主题内容的突出，不能是一味的广告。\n3. 精简网页的代码，加快spider爬取速度。打包压缩html和css和js等\n4. 图片和视频优化。由于图片和视频是无法被spider辨识为关键词，所以需要在周边的文字进行一些图片和视频内容的描述，方便spider能够辨识爬取。同时，用好img的alt标签。\n\n## chap-6 外链建设\n&emsp;&emsp;seo当中有**内容为王，外链为皇**的说法。做好外链是网站提升seo权重的重要手段之一。可以这么理解，在链接都是客观产生(非人为)的情况下，那么整个互联网当中最优质的内容，就应该是链接最多的内容，所以搜索引擎很倾向于根据外链的数量，去进行页面权重的建立。\n&emsp;&emsp;本章主要对seo外链的一些注意事项和检测方式做了一些科普，简单来说就是没啥干货内容，这里简单进行一个概括。\n&emsp;&emsp;seo外链主要注意对方交换网站，不要和链接农场进行链接交换导致自己网页的权重被降低，也要注意对方网站的相关内容以及rp是否和自己网站rp相匹配。自己在放置外链的一些页面也要时常检查，做好链接可用性的检查工作以及及时沟通。","slug":"SEO/SEO(chap4-6)","published":1,"updated":"2020-06-11T01:43:32.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhx900059r2v9tqu269w","content":"<p>&emsp;&emsp;SEO深度解析4-6章主要讲述了关键词、链接的设置取舍，以及具体如何在网站中进行相应的优化<br><a id=\"more\"></a><br>&emsp;&emsp;其实一直比较好奇，为什么SEO的书籍和资料，大多数到2016年开始就浅藏辄止了。这个困惑在本周和一个做竞价的同学聊天中得到了解答。同学告诉我，现在已经没有多少企业去做SEO了，成效实在太慢了，大多数都直接去做SEM了。对于大多数的中小型企业来说没有那么多时间和人力投入到一个为期半年以上，不能保证见效的项目上面去。而当企业本身的知名度出来之后，搜索引擎也会依据知名度相应的往你的网站上面去倾斜。<br>&emsp;&emsp;那么SEO在当今互联网场景当中没有其适用场景了么？答案是否定的。我认为SEO在以<strong>做网站本身起家</strong>和<strong>大型网站</strong>当中仍是十分重要的一环。而对前端，对个人来说，产生语义化书写意识，规划合理整洁的路由和网站结构，未免不是一件好事。<br>&emsp;&emsp;言归正传，回到我们的读书笔记当中来：</p>\n<h2 id=\"chap-4-关键词研究\"><a href=\"#chap-4-关键词研究\" class=\"headerlink\" title=\"chap-4 关键词研究\"></a>chap-4 关键词研究</h2><p>&emsp;&emsp;本章是对SEO优化中一个重要环节<strong>关键词优化</strong>的讨论。<br>&emsp;&emsp;讨论分为两个方向：</p>\n<ol>\n<li>如何为已有网站配置<strong>精准</strong>的关键词，以便在更好获得排名。</li>\n<li>根据关键词配置，指导网站的内容建设。</li>\n</ol>\n<p>&emsp;&emsp;无论是哪个方向，挖出关键词，使网站在该<strong>关键词下面获得高排名</strong>是<code>最终目的</code>。</p>\n<p>&emsp;&emsp;关键词分类：<br>&emsp;&emsp;关键词只有分类后，才能根据网站目的来筛选、布局和重点优化关键词。关键词主流的分类方式有三种：</p>\n<ul>\n<li>按搜索目的</li>\n<li>关键词长短</li>\n<li>关键词热度</li>\n</ul>\n<p>&emsp;&emsp;通过对关键词的划分，可以根据网站想要高排名的关键词程度，进行关键词的取舍部署。部署当中要遵守一些基本原则：</p>\n<ol>\n<li>每个页面只部署2-3个关键词。(多了会导致搜索引擎在关键词上面平均的权重降低)。</li>\n<li>除内容页面外，页面之间的关键词不可重复，甚至不可太相近。</li>\n<li>对于太相近的关键词进行组合，尽可能分配到一个页面当中。</li>\n<li>除内容页外，部署关键词要简洁规范，没有太多的定语形容词。</li>\n</ol>\n<h2 id=\"chap-5-站内优化\"><a href=\"#chap-5-站内优化\" class=\"headerlink\" title=\"chap-5 站内优化\"></a>chap-5 站内优化</h2><p>&emsp;&emsp;本章是一个大章，针对网站的层级目录，内容结构，优化取舍进行了一个主要的分析，本章也是偏向技术类的一章。</p>\n<h3 id=\"5-1网站结构优化\"><a href=\"#5-1网站结构优化\" class=\"headerlink\" title=\"5.1网站结构优化\"></a>5.1网站结构优化</h3><ul>\n<li><p>url优化<br>&emsp;&emsp;网站的url层级一定要<strong>清晰</strong>，<strong>不宜太长</strong>，使用<strong>小写字符</strong>，<strong>不要使用特殊字符</strong>。<br>&emsp;&emsp;举例：一呼百应网站下方，信息将全部放在cp目录下，<a href=\"http://www.youboy.com/cp/wujingongju/。动态的url也不需要特意伪装成静态，搜索引擎能够正确爬取。(?id=xxx，这种属于动态的url)\" target=\"_blank\" rel=\"noopener\">http://www.youboy.com/cp/wujingongju/。动态的url也不需要特意伪装成静态，搜索引擎能够正确爬取。(?id=xxx，这种属于动态的url)</a><br>&emsp;&emsp;url当中<strong>包含关键词</strong>，在百度的搜索引擎当中，<strong>中文关键词</strong>也是可以被查找到的。这里可以使用百度搜索的inurl:搜索指令，这个指令只会搜索url当中包含搜索关键词内容的网站，也从侧面表示，百度把url当中的中文关键词正确的搜索收录了。</p>\n</li>\n<li><p>siteMap相关<br>&emsp;&emsp;siteMap是根据搜索引擎的标准，提供的一份网站的”地图”,标注了网站的页面和相关内容。siteMap根据搜索引擎的不同有不同的标准，也区分格式，诸如xml或者html。但是他们的目的都是相同的，即制作一份网站的目录地图放在站点下面，让搜索引擎的爬虫来获取站点信息，方便爬取。<br>&emsp;&emsp;谷歌和百度，都有对应的siteMap提交站点。提交时注意规范即可。</p>\n</li>\n<li><p>robots协议<br>&emsp;&emsp;国内的搜索引擎在2012年集体签署遵从robots协议。robots协议重点就是通过robots相关html属性设置，告诉爬虫这一块内容不要去爬取。这么做的好处就是保证网站的权重全部放在想要放出的url链接和关键词内容上面。<br>&emsp;&emsp;robots协议方法，在网站根目录使用robots.txt文件，或者使用meta标签(<code>&lt;Meta name=&quot;robots&quot; content=&quot;nofollow&quot;&gt;</code>)。<br>&emsp;&emsp;使用robots协议可以规避死链接，保护网站隐私，防止后台管理站点被抓取，增加关键词权重。</p>\n</li>\n<li><p>导航优化<br>&emsp;&emsp;导航优化简单来说，就是让spider爬的放心，爬的舒心，让网站的url能够收录全<br>&emsp;&emsp;导航优化主要遵从，多级导航要分类(如按照行业分类，材料分类等)。用户不关注的底部导航部分可以堆内链。使用面包屑导航(首页&gt;博客&gt;读书笔记)，在当前页面能够知道自己所处在站点的位置，并且能够返回。</p>\n</li>\n<li><p>内链与nofollow<br>&emsp;&emsp;内链要<strong>高聚合</strong>，<strong>相关性强</strong>。要在站点的某个页面，能够访问到站点的大部分内链。确保每个页面至少有一个文本链接(非ajax，flash形成的链接)能够访问到。同一个页面链接越多，每个链接获得的权重就越小。因此，在一些无关紧要的链接上，可以使用nofollow去优化。使用方法<code>&lt;a href=&quot;someurl&quot; rel=&quot;nofollow&quot;&gt;灌水&lt;/a&gt;</code>。<br>&emsp;&emsp;当存在一些内容相似的网站，其实只需要搜素引擎爬取一个时，可以在head部分创建Canonical标签，来让爬虫只收录标准页的内容，增加标准页的权重。<code>&lt;link rel=&quot;Canonical&quot; href=&quot;规范页url&quot;&gt;</code>。<br>&emsp;&emsp;除此之外，做好404和500+的http状态码的处理也是十分重要的一环。这两种非成功的状态码会被spider视为影响用户体验状态码，从而去降低网站的权重。因此做好url的清理，即时提交sitemap和robots文件，把这些协议清除出去，就显得十分重要。</p>\n</li>\n</ul>\n<h3 id=\"5-2网站内容建设\"><a href=\"#5-2网站内容建设\" class=\"headerlink\" title=\"5.2网站内容建设\"></a>5.2网站内容建设</h3><p>&emsp;&emsp;网站内容建设是整个seo的核心部分，抓住关键词，合理优化网站内容结构，是提高网站权重的关键。<br>&emsp;&emsp;网站内容建设要注意分词理论的运用，在文章标题和文章内容上做足功夫。<br>&emsp;&emsp;文章标题，显示在搜索结果中，既要存在关键词，又要吸引人：</p>\n<ol>\n<li>疑问性标题： 如果没有房子，会有婚姻吗？</li>\n<li>指定范围型标题： “90后”创业3年买房，让“80”后情何以堪</li>\n<li>包含数字标题： 2012年10大重要新闻盘点</li>\n<li>吹牛攀比型标题：快递员每月可拿12000元工资</li>\n<li>刻意勾上美女帅哥和性</li>\n<li>为醒目的标题加【图文】标识符： 【图文】<br>&emsp;&emsp;文章内容，seo爬取的参考，需要做一些关键词的两到三次的堆砌。诸如长尾关键词，刻意在文章内容当中进行放置。此外，也可以使用h系列标签(h2-h4)和strong标签，来标注出来关键词，让浏览器爬取。</li>\n</ol>\n<h3 id=\"5-3网站页面优化\"><a href=\"#5-3网站页面优化\" class=\"headerlink\" title=\"5.3网站页面优化\"></a>5.3网站页面优化</h3><p>&emsp;&emsp;网站页面，需要有最基本的seo优化事项。</p>\n<ol>\n<li>关键词定位，在titile和description中布局关键词，title放2-3的需要的关键词。</li>\n<li>页面噪声比控制，要有主题内容的突出，不能是一味的广告。</li>\n<li>精简网页的代码，加快spider爬取速度。打包压缩html和css和js等</li>\n<li>图片和视频优化。由于图片和视频是无法被spider辨识为关键词，所以需要在周边的文字进行一些图片和视频内容的描述，方便spider能够辨识爬取。同时，用好img的alt标签。</li>\n</ol>\n<h2 id=\"chap-6-外链建设\"><a href=\"#chap-6-外链建设\" class=\"headerlink\" title=\"chap-6 外链建设\"></a>chap-6 外链建设</h2><p>&emsp;&emsp;seo当中有<strong>内容为王，外链为皇</strong>的说法。做好外链是网站提升seo权重的重要手段之一。可以这么理解，在链接都是客观产生(非人为)的情况下，那么整个互联网当中最优质的内容，就应该是链接最多的内容，所以搜索引擎很倾向于根据外链的数量，去进行页面权重的建立。<br>&emsp;&emsp;本章主要对seo外链的一些注意事项和检测方式做了一些科普，简单来说就是没啥干货内容，这里简单进行一个概括。<br>&emsp;&emsp;seo外链主要注意对方交换网站，不要和链接农场进行链接交换导致自己网页的权重被降低，也要注意对方网站的相关内容以及rp是否和自己网站rp相匹配。自己在放置外链的一些页面也要时常检查，做好链接可用性的检查工作以及及时沟通。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;SEO深度解析4-6章主要讲述了关键词、链接的设置取舍，以及具体如何在网站中进行相应的优化<br></p>","more":"<br>&emsp;&emsp;其实一直比较好奇，为什么SEO的书籍和资料，大多数到2016年开始就浅藏辄止了。这个困惑在本周和一个做竞价的同学聊天中得到了解答。同学告诉我，现在已经没有多少企业去做SEO了，成效实在太慢了，大多数都直接去做SEM了。对于大多数的中小型企业来说没有那么多时间和人力投入到一个为期半年以上，不能保证见效的项目上面去。而当企业本身的知名度出来之后，搜索引擎也会依据知名度相应的往你的网站上面去倾斜。<br>&emsp;&emsp;那么SEO在当今互联网场景当中没有其适用场景了么？答案是否定的。我认为SEO在以<strong>做网站本身起家</strong>和<strong>大型网站</strong>当中仍是十分重要的一环。而对前端，对个人来说，产生语义化书写意识，规划合理整洁的路由和网站结构，未免不是一件好事。<br>&emsp;&emsp;言归正传，回到我们的读书笔记当中来：</p>\n<h2 id=\"chap-4-关键词研究\"><a href=\"#chap-4-关键词研究\" class=\"headerlink\" title=\"chap-4 关键词研究\"></a>chap-4 关键词研究</h2><p>&emsp;&emsp;本章是对SEO优化中一个重要环节<strong>关键词优化</strong>的讨论。<br>&emsp;&emsp;讨论分为两个方向：</p>\n<ol>\n<li>如何为已有网站配置<strong>精准</strong>的关键词，以便在更好获得排名。</li>\n<li>根据关键词配置，指导网站的内容建设。</li>\n</ol>\n<p>&emsp;&emsp;无论是哪个方向，挖出关键词，使网站在该<strong>关键词下面获得高排名</strong>是<code>最终目的</code>。</p>\n<p>&emsp;&emsp;关键词分类：<br>&emsp;&emsp;关键词只有分类后，才能根据网站目的来筛选、布局和重点优化关键词。关键词主流的分类方式有三种：</p>\n<ul>\n<li>按搜索目的</li>\n<li>关键词长短</li>\n<li>关键词热度</li>\n</ul>\n<p>&emsp;&emsp;通过对关键词的划分，可以根据网站想要高排名的关键词程度，进行关键词的取舍部署。部署当中要遵守一些基本原则：</p>\n<ol>\n<li>每个页面只部署2-3个关键词。(多了会导致搜索引擎在关键词上面平均的权重降低)。</li>\n<li>除内容页面外，页面之间的关键词不可重复，甚至不可太相近。</li>\n<li>对于太相近的关键词进行组合，尽可能分配到一个页面当中。</li>\n<li>除内容页外，部署关键词要简洁规范，没有太多的定语形容词。</li>\n</ol>\n<h2 id=\"chap-5-站内优化\"><a href=\"#chap-5-站内优化\" class=\"headerlink\" title=\"chap-5 站内优化\"></a>chap-5 站内优化</h2><p>&emsp;&emsp;本章是一个大章，针对网站的层级目录，内容结构，优化取舍进行了一个主要的分析，本章也是偏向技术类的一章。</p>\n<h3 id=\"5-1网站结构优化\"><a href=\"#5-1网站结构优化\" class=\"headerlink\" title=\"5.1网站结构优化\"></a>5.1网站结构优化</h3><ul>\n<li><p>url优化<br>&emsp;&emsp;网站的url层级一定要<strong>清晰</strong>，<strong>不宜太长</strong>，使用<strong>小写字符</strong>，<strong>不要使用特殊字符</strong>。<br>&emsp;&emsp;举例：一呼百应网站下方，信息将全部放在cp目录下，<a href=\"http://www.youboy.com/cp/wujingongju/。动态的url也不需要特意伪装成静态，搜索引擎能够正确爬取。(?id=xxx，这种属于动态的url)\" target=\"_blank\" rel=\"noopener\">http://www.youboy.com/cp/wujingongju/。动态的url也不需要特意伪装成静态，搜索引擎能够正确爬取。(?id=xxx，这种属于动态的url)</a><br>&emsp;&emsp;url当中<strong>包含关键词</strong>，在百度的搜索引擎当中，<strong>中文关键词</strong>也是可以被查找到的。这里可以使用百度搜索的inurl:搜索指令，这个指令只会搜索url当中包含搜索关键词内容的网站，也从侧面表示，百度把url当中的中文关键词正确的搜索收录了。</p>\n</li>\n<li><p>siteMap相关<br>&emsp;&emsp;siteMap是根据搜索引擎的标准，提供的一份网站的”地图”,标注了网站的页面和相关内容。siteMap根据搜索引擎的不同有不同的标准，也区分格式，诸如xml或者html。但是他们的目的都是相同的，即制作一份网站的目录地图放在站点下面，让搜索引擎的爬虫来获取站点信息，方便爬取。<br>&emsp;&emsp;谷歌和百度，都有对应的siteMap提交站点。提交时注意规范即可。</p>\n</li>\n<li><p>robots协议<br>&emsp;&emsp;国内的搜索引擎在2012年集体签署遵从robots协议。robots协议重点就是通过robots相关html属性设置，告诉爬虫这一块内容不要去爬取。这么做的好处就是保证网站的权重全部放在想要放出的url链接和关键词内容上面。<br>&emsp;&emsp;robots协议方法，在网站根目录使用robots.txt文件，或者使用meta标签(<code>&lt;Meta name=&quot;robots&quot; content=&quot;nofollow&quot;&gt;</code>)。<br>&emsp;&emsp;使用robots协议可以规避死链接，保护网站隐私，防止后台管理站点被抓取，增加关键词权重。</p>\n</li>\n<li><p>导航优化<br>&emsp;&emsp;导航优化简单来说，就是让spider爬的放心，爬的舒心，让网站的url能够收录全<br>&emsp;&emsp;导航优化主要遵从，多级导航要分类(如按照行业分类，材料分类等)。用户不关注的底部导航部分可以堆内链。使用面包屑导航(首页&gt;博客&gt;读书笔记)，在当前页面能够知道自己所处在站点的位置，并且能够返回。</p>\n</li>\n<li><p>内链与nofollow<br>&emsp;&emsp;内链要<strong>高聚合</strong>，<strong>相关性强</strong>。要在站点的某个页面，能够访问到站点的大部分内链。确保每个页面至少有一个文本链接(非ajax，flash形成的链接)能够访问到。同一个页面链接越多，每个链接获得的权重就越小。因此，在一些无关紧要的链接上，可以使用nofollow去优化。使用方法<code>&lt;a href=&quot;someurl&quot; rel=&quot;nofollow&quot;&gt;灌水&lt;/a&gt;</code>。<br>&emsp;&emsp;当存在一些内容相似的网站，其实只需要搜素引擎爬取一个时，可以在head部分创建Canonical标签，来让爬虫只收录标准页的内容，增加标准页的权重。<code>&lt;link rel=&quot;Canonical&quot; href=&quot;规范页url&quot;&gt;</code>。<br>&emsp;&emsp;除此之外，做好404和500+的http状态码的处理也是十分重要的一环。这两种非成功的状态码会被spider视为影响用户体验状态码，从而去降低网站的权重。因此做好url的清理，即时提交sitemap和robots文件，把这些协议清除出去，就显得十分重要。</p>\n</li>\n</ul>\n<h3 id=\"5-2网站内容建设\"><a href=\"#5-2网站内容建设\" class=\"headerlink\" title=\"5.2网站内容建设\"></a>5.2网站内容建设</h3><p>&emsp;&emsp;网站内容建设是整个seo的核心部分，抓住关键词，合理优化网站内容结构，是提高网站权重的关键。<br>&emsp;&emsp;网站内容建设要注意分词理论的运用，在文章标题和文章内容上做足功夫。<br>&emsp;&emsp;文章标题，显示在搜索结果中，既要存在关键词，又要吸引人：</p>\n<ol>\n<li>疑问性标题： 如果没有房子，会有婚姻吗？</li>\n<li>指定范围型标题： “90后”创业3年买房，让“80”后情何以堪</li>\n<li>包含数字标题： 2012年10大重要新闻盘点</li>\n<li>吹牛攀比型标题：快递员每月可拿12000元工资</li>\n<li>刻意勾上美女帅哥和性</li>\n<li>为醒目的标题加【图文】标识符： 【图文】<br>&emsp;&emsp;文章内容，seo爬取的参考，需要做一些关键词的两到三次的堆砌。诸如长尾关键词，刻意在文章内容当中进行放置。此外，也可以使用h系列标签(h2-h4)和strong标签，来标注出来关键词，让浏览器爬取。</li>\n</ol>\n<h3 id=\"5-3网站页面优化\"><a href=\"#5-3网站页面优化\" class=\"headerlink\" title=\"5.3网站页面优化\"></a>5.3网站页面优化</h3><p>&emsp;&emsp;网站页面，需要有最基本的seo优化事项。</p>\n<ol>\n<li>关键词定位，在titile和description中布局关键词，title放2-3的需要的关键词。</li>\n<li>页面噪声比控制，要有主题内容的突出，不能是一味的广告。</li>\n<li>精简网页的代码，加快spider爬取速度。打包压缩html和css和js等</li>\n<li>图片和视频优化。由于图片和视频是无法被spider辨识为关键词，所以需要在周边的文字进行一些图片和视频内容的描述，方便spider能够辨识爬取。同时，用好img的alt标签。</li>\n</ol>\n<h2 id=\"chap-6-外链建设\"><a href=\"#chap-6-外链建设\" class=\"headerlink\" title=\"chap-6 外链建设\"></a>chap-6 外链建设</h2><p>&emsp;&emsp;seo当中有<strong>内容为王，外链为皇</strong>的说法。做好外链是网站提升seo权重的重要手段之一。可以这么理解，在链接都是客观产生(非人为)的情况下，那么整个互联网当中最优质的内容，就应该是链接最多的内容，所以搜索引擎很倾向于根据外链的数量，去进行页面权重的建立。<br>&emsp;&emsp;本章主要对seo外链的一些注意事项和检测方式做了一些科普，简单来说就是没啥干货内容，这里简单进行一个概括。<br>&emsp;&emsp;seo外链主要注意对方交换网站，不要和链接农场进行链接交换导致自己网页的权重被降低，也要注意对方网站的相关内容以及rp是否和自己网站rp相匹配。自己在放置外链的一些页面也要时常检查，做好链接可用性的检查工作以及及时沟通。</p>"},{"title":"《SEO深度解析》读书笔记(7-9)","date":"2019-04-05T11:00:00.000Z","_content":"&emsp;&emsp;SEO深度解析7-9章主要讲述了seo工具，竞争对手分析，网站数据分析\n<!--more-->\n&emsp;&emsp;行吧，介绍几个站点的工具写了60多面，一整个章节。然后把前面的知识点找了个网站举例子抄了个冷饭，美其名曰竞争对手分析，又是一个章节。然后网站数据分析写了半章的日志命令查询使用。能退书嘛，我现在后悔买国内作者这本seo了……我应该买国外那本SEO圣经的。\n&emsp;&emsp;但是还是得坚持写完，这三章没什么营养的部分，我就简单的采用索引的形式写一下梗概吧。\n\n## chap-7 站长工具\n本章介绍了一些站长工具和使用方法。\n- ChinaZ站长工具\n  1. Alexa排名，仅对安装了Alexa工具条的网友统计\n  2. 死链接检测\n  3. 关键词密度检测\n  4. pr输出值\n- 爱站网\n  1. 百度权重查询工具\n  2. 反链接查询工具\n  3. 同IP网站查询工具\n- 百度站长平台\n 1. 网站核心数据分析\n 2. 网页抓取\n 3. 搜索展现\n 4. 站长社区\n\n这种章节放在书里面真的合适么……这感觉，就是官方文档+百度百科的摘抄啊，根本没有什么干货。\n\n## chap-8 竞争对手分析\n这章简而言之，就是拿一呼百应网举了个前6章的实例……\n1. 了解目标网站概况，包括域名和子域名，site指数，title标签和百度指数\n2. 统计分析收录、排名确定流量支\n3. 分析网站结构和内链布局\n4. 分析页面和内容\n5. 分析网站和外链建设情况\n基本上就是把前六章的注意点，找了个网站重新复述了一遍，内链布局小结部分，我也蛮佩服作者把所有链接列一遍的勇气的。\n\n## chap-9 网站数据分析\n1. 流量分析 对一些网站的基本数据进行分析。\n - ip访问量，单位时间ip访问数量\n - uv，独立访客数，依据cookie来进行统计的\n - pv，网站访问量，每刷新一次网站都算\n - 着陆页，网站首次被访问的页面，一般是首页\n - 跳出率， 只浏览一个页面的比率\n2. 日志分析 本章讲了一下w3c规范的日志格式以及http状态码和表示的意思，这里就不做赘述了，感觉这本书面向对象应该不是程序员用户。\n3. 收录、排名。站内搜索数据分析。本章重点阐述了dos命令行去切割搜素日志……简而言之就是讲解了一些dos命令和日志搜索方法。\n\n个人感觉这三章纯粹是用来凑字数的，既然叫SEO深度解析，不是更应该把重点放在SEO的解析上面，而不是知识点东凑一点西拼一点，像极了官方文档说明书的摘抄。感觉这三章很没有营养。本书也快完结了，希望接下来的三章作者不要再有这种方式去写书了。","source":"_posts/SEO/SEO(chap7-9).md","raw":"---\ntitle: 《SEO深度解析》读书笔记(7-9)\ndate: 2019/4/5 19:00:00\ncategories:\n- [读书笔记, SEO深度解析]\ntags:\n- SEO\n- 读书笔记\n---\n&emsp;&emsp;SEO深度解析7-9章主要讲述了seo工具，竞争对手分析，网站数据分析\n<!--more-->\n&emsp;&emsp;行吧，介绍几个站点的工具写了60多面，一整个章节。然后把前面的知识点找了个网站举例子抄了个冷饭，美其名曰竞争对手分析，又是一个章节。然后网站数据分析写了半章的日志命令查询使用。能退书嘛，我现在后悔买国内作者这本seo了……我应该买国外那本SEO圣经的。\n&emsp;&emsp;但是还是得坚持写完，这三章没什么营养的部分，我就简单的采用索引的形式写一下梗概吧。\n\n## chap-7 站长工具\n本章介绍了一些站长工具和使用方法。\n- ChinaZ站长工具\n  1. Alexa排名，仅对安装了Alexa工具条的网友统计\n  2. 死链接检测\n  3. 关键词密度检测\n  4. pr输出值\n- 爱站网\n  1. 百度权重查询工具\n  2. 反链接查询工具\n  3. 同IP网站查询工具\n- 百度站长平台\n 1. 网站核心数据分析\n 2. 网页抓取\n 3. 搜索展现\n 4. 站长社区\n\n这种章节放在书里面真的合适么……这感觉，就是官方文档+百度百科的摘抄啊，根本没有什么干货。\n\n## chap-8 竞争对手分析\n这章简而言之，就是拿一呼百应网举了个前6章的实例……\n1. 了解目标网站概况，包括域名和子域名，site指数，title标签和百度指数\n2. 统计分析收录、排名确定流量支\n3. 分析网站结构和内链布局\n4. 分析页面和内容\n5. 分析网站和外链建设情况\n基本上就是把前六章的注意点，找了个网站重新复述了一遍，内链布局小结部分，我也蛮佩服作者把所有链接列一遍的勇气的。\n\n## chap-9 网站数据分析\n1. 流量分析 对一些网站的基本数据进行分析。\n - ip访问量，单位时间ip访问数量\n - uv，独立访客数，依据cookie来进行统计的\n - pv，网站访问量，每刷新一次网站都算\n - 着陆页，网站首次被访问的页面，一般是首页\n - 跳出率， 只浏览一个页面的比率\n2. 日志分析 本章讲了一下w3c规范的日志格式以及http状态码和表示的意思，这里就不做赘述了，感觉这本书面向对象应该不是程序员用户。\n3. 收录、排名。站内搜索数据分析。本章重点阐述了dos命令行去切割搜素日志……简而言之就是讲解了一些dos命令和日志搜索方法。\n\n个人感觉这三章纯粹是用来凑字数的，既然叫SEO深度解析，不是更应该把重点放在SEO的解析上面，而不是知识点东凑一点西拼一点，像极了官方文档说明书的摘抄。感觉这三章很没有营养。本书也快完结了，希望接下来的三章作者不要再有这种方式去写书了。","slug":"SEO/SEO(chap7-9)","published":1,"updated":"2020-06-11T01:43:32.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhx900069r2vh0w3v8ey","content":"<p>&emsp;&emsp;SEO深度解析7-9章主要讲述了seo工具，竞争对手分析，网站数据分析<br><a id=\"more\"></a><br>&emsp;&emsp;行吧，介绍几个站点的工具写了60多面，一整个章节。然后把前面的知识点找了个网站举例子抄了个冷饭，美其名曰竞争对手分析，又是一个章节。然后网站数据分析写了半章的日志命令查询使用。能退书嘛，我现在后悔买国内作者这本seo了……我应该买国外那本SEO圣经的。<br>&emsp;&emsp;但是还是得坚持写完，这三章没什么营养的部分，我就简单的采用索引的形式写一下梗概吧。</p>\n<h2 id=\"chap-7-站长工具\"><a href=\"#chap-7-站长工具\" class=\"headerlink\" title=\"chap-7 站长工具\"></a>chap-7 站长工具</h2><p>本章介绍了一些站长工具和使用方法。</p>\n<ul>\n<li>ChinaZ站长工具<ol>\n<li>Alexa排名，仅对安装了Alexa工具条的网友统计</li>\n<li>死链接检测</li>\n<li>关键词密度检测</li>\n<li>pr输出值</li>\n</ol>\n</li>\n<li>爱站网<ol>\n<li>百度权重查询工具</li>\n<li>反链接查询工具</li>\n<li>同IP网站查询工具</li>\n</ol>\n</li>\n<li>百度站长平台<ol>\n<li>网站核心数据分析</li>\n<li>网页抓取</li>\n<li>搜索展现</li>\n<li>站长社区</li>\n</ol>\n</li>\n</ul>\n<p>这种章节放在书里面真的合适么……这感觉，就是官方文档+百度百科的摘抄啊，根本没有什么干货。</p>\n<h2 id=\"chap-8-竞争对手分析\"><a href=\"#chap-8-竞争对手分析\" class=\"headerlink\" title=\"chap-8 竞争对手分析\"></a>chap-8 竞争对手分析</h2><p>这章简而言之，就是拿一呼百应网举了个前6章的实例……</p>\n<ol>\n<li>了解目标网站概况，包括域名和子域名，site指数，title标签和百度指数</li>\n<li>统计分析收录、排名确定流量支</li>\n<li>分析网站结构和内链布局</li>\n<li>分析页面和内容</li>\n<li>分析网站和外链建设情况<br>基本上就是把前六章的注意点，找了个网站重新复述了一遍，内链布局小结部分，我也蛮佩服作者把所有链接列一遍的勇气的。</li>\n</ol>\n<h2 id=\"chap-9-网站数据分析\"><a href=\"#chap-9-网站数据分析\" class=\"headerlink\" title=\"chap-9 网站数据分析\"></a>chap-9 网站数据分析</h2><ol>\n<li>流量分析 对一些网站的基本数据进行分析。<ul>\n<li>ip访问量，单位时间ip访问数量</li>\n<li>uv，独立访客数，依据cookie来进行统计的</li>\n<li>pv，网站访问量，每刷新一次网站都算</li>\n<li>着陆页，网站首次被访问的页面，一般是首页</li>\n<li>跳出率， 只浏览一个页面的比率</li>\n</ul>\n</li>\n<li>日志分析 本章讲了一下w3c规范的日志格式以及http状态码和表示的意思，这里就不做赘述了，感觉这本书面向对象应该不是程序员用户。</li>\n<li>收录、排名。站内搜索数据分析。本章重点阐述了dos命令行去切割搜素日志……简而言之就是讲解了一些dos命令和日志搜索方法。</li>\n</ol>\n<p>个人感觉这三章纯粹是用来凑字数的，既然叫SEO深度解析，不是更应该把重点放在SEO的解析上面，而不是知识点东凑一点西拼一点，像极了官方文档说明书的摘抄。感觉这三章很没有营养。本书也快完结了，希望接下来的三章作者不要再有这种方式去写书了。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;SEO深度解析7-9章主要讲述了seo工具，竞争对手分析，网站数据分析<br></p>","more":"<br>&emsp;&emsp;行吧，介绍几个站点的工具写了60多面，一整个章节。然后把前面的知识点找了个网站举例子抄了个冷饭，美其名曰竞争对手分析，又是一个章节。然后网站数据分析写了半章的日志命令查询使用。能退书嘛，我现在后悔买国内作者这本seo了……我应该买国外那本SEO圣经的。<br>&emsp;&emsp;但是还是得坚持写完，这三章没什么营养的部分，我就简单的采用索引的形式写一下梗概吧。</p>\n<h2 id=\"chap-7-站长工具\"><a href=\"#chap-7-站长工具\" class=\"headerlink\" title=\"chap-7 站长工具\"></a>chap-7 站长工具</h2><p>本章介绍了一些站长工具和使用方法。</p>\n<ul>\n<li>ChinaZ站长工具<ol>\n<li>Alexa排名，仅对安装了Alexa工具条的网友统计</li>\n<li>死链接检测</li>\n<li>关键词密度检测</li>\n<li>pr输出值</li>\n</ol>\n</li>\n<li>爱站网<ol>\n<li>百度权重查询工具</li>\n<li>反链接查询工具</li>\n<li>同IP网站查询工具</li>\n</ol>\n</li>\n<li>百度站长平台<ol>\n<li>网站核心数据分析</li>\n<li>网页抓取</li>\n<li>搜索展现</li>\n<li>站长社区</li>\n</ol>\n</li>\n</ul>\n<p>这种章节放在书里面真的合适么……这感觉，就是官方文档+百度百科的摘抄啊，根本没有什么干货。</p>\n<h2 id=\"chap-8-竞争对手分析\"><a href=\"#chap-8-竞争对手分析\" class=\"headerlink\" title=\"chap-8 竞争对手分析\"></a>chap-8 竞争对手分析</h2><p>这章简而言之，就是拿一呼百应网举了个前6章的实例……</p>\n<ol>\n<li>了解目标网站概况，包括域名和子域名，site指数，title标签和百度指数</li>\n<li>统计分析收录、排名确定流量支</li>\n<li>分析网站结构和内链布局</li>\n<li>分析页面和内容</li>\n<li>分析网站和外链建设情况<br>基本上就是把前六章的注意点，找了个网站重新复述了一遍，内链布局小结部分，我也蛮佩服作者把所有链接列一遍的勇气的。</li>\n</ol>\n<h2 id=\"chap-9-网站数据分析\"><a href=\"#chap-9-网站数据分析\" class=\"headerlink\" title=\"chap-9 网站数据分析\"></a>chap-9 网站数据分析</h2><ol>\n<li>流量分析 对一些网站的基本数据进行分析。<ul>\n<li>ip访问量，单位时间ip访问数量</li>\n<li>uv，独立访客数，依据cookie来进行统计的</li>\n<li>pv，网站访问量，每刷新一次网站都算</li>\n<li>着陆页，网站首次被访问的页面，一般是首页</li>\n<li>跳出率， 只浏览一个页面的比率</li>\n</ul>\n</li>\n<li>日志分析 本章讲了一下w3c规范的日志格式以及http状态码和表示的意思，这里就不做赘述了，感觉这本书面向对象应该不是程序员用户。</li>\n<li>收录、排名。站内搜索数据分析。本章重点阐述了dos命令行去切割搜素日志……简而言之就是讲解了一些dos命令和日志搜索方法。</li>\n</ol>\n<p>个人感觉这三章纯粹是用来凑字数的，既然叫SEO深度解析，不是更应该把重点放在SEO的解析上面，而不是知识点东凑一点西拼一点，像极了官方文档说明书的摘抄。感觉这三章很没有营养。本书也快完结了，希望接下来的三章作者不要再有这种方式去写书了。</p>"},{"title":"《SEO深度解析》读书笔记(10-12)","date":"2019-04-08T11:00:00.000Z","_content":"&emsp;&emsp;SEO深度解析10-12章主要讲述了seo主要来源和操作，作者对seo的一些看法，以及一些seo达人的案例分析。\n<!--more-->\n&emsp;&emsp;虽然今天是周一，但是真的想快点把这本书的读书笔记给结束掉了，这本书对于一个技术来说有用的部分不多，我很欣赏作者把怎么喝酒吃饭都抽出来单独讲一节的勇气。SEO还是偏神棍和非技术了一些，感觉一个月左右读下来，收获不是很大。这个行业的人自己都没有摸清楚门道，一半靠猜，一半靠忽悠，也难怪SEO这个行业现在越来越没落了。\n## chap-10 SEO专题\n&emsp;&emsp;移动搜索优化，由于移动端流量越来越大，做SEO需要针对移动端做专门的优化。因为早期网页很少有移动端的部分，所以百度搜索引擎采用的是对web端的网页进行代码的转码优化，然后保存快照的方式保存到自己的搜索库当中。实际上用户在访问的时候，访问的是百度的快照。所以要针对移动端进行特殊的SEO优化，以便带来流量。采用的方法有：\n1. 提交适配关系\n2. meta标注\n```html\n<meta name=\"mobile-agent\" content=\"formate=[wml|xhtml|html5];url=url\">\n<meta name=\"applicable-device\" content=\"pc|mobile\">\n```\n&emsp;&emsp;利用SEO做百度搜索危机公关，思路就是使用权重高的网站内容去掩盖负面信息。主要操作有：\n- 未雨绸缪，做很多子品牌的子网站，使用户搜索时第一面都是自己品牌以及子网站的信息\n- 在百度贴吧，优酷等大平台去主动发一些关于自己品牌的帖子\n\n&emsp;&emsp;seo诊断优化思路：\n1. 原创不等同于有价值，对客户有用才是有价值\n2. 利用权重高网站疏忽做推广，比如部分搜索网站会留下近期用户搜索的相关内容，可以利用这个发送自己的网站链接\n\n## chap-11 一些观点\n&emsp;&emsp;这一章，作者对seo现在怎么样，seo从业者需要做什么，seo从业者怎么做做出了一些自己的看法。有点像是灌水的感觉。\n&emsp;&emsp;首先说明了，seo行业还不是很规范，很多seo从业者都是一知半解。然后列举了seo从业者在几种不同公司里面的地位。\n&emsp;&emsp;其次列举了一下作者认为的seo工作人员的工作内容：\n1. 优化网页结构，包括title标签语义化等\n2. 确定行业关键词(大关键词，短关键词，长尾关键词)\n3. 增加页面布局制作专题的方式来增加关键词\n4. 网站目录结构合理，扁平化\n5. 网站收录之后要时刻注意排名，建立良好的内外链接\n6. 不断监控优化网站数据\n&emsp;&emsp;最后说了一下SEO人员的职业规划和需要的素养。无非是要多实践多交流，逻辑要强这种比较灌水的分析和回答……这里就不赘述。\n\n## chap-12 一线达人分享\n- 余心妍团队：做一个流量的捕捉网\n从一个关键词的案例出发，重点讲述了seo当中关键词优化的思路\n- zero：深入一线SEO的策略思路\n从搜索引擎的原理角度和数据分析，来告诉你seo优化的方向\n- 道哥：seo的瓶颈在瓶口\n从技术角度，网络七层，web交互原理，阐述了技术角度上面的seo优化思路。\n- 肖俊：百度反作弊解析\n讲了百度反作弊的历史算法技术进步，从反作弊的角度，讲了seo优化的思路。\n\n&emsp;&emsp;12章剩下的一下无关痛痒的分享和最后一张100问就省略了吧。总结一下《SEO深度解析》这本书。如果满分10分的，感觉给6.5分到顶了。及格往上一些，算是好好讲了seo是什么，怎么做，然后结合自己的一些看法提出一些思路。全书三分之一的章节感觉有灌水的嫌疑(还专门有一节教你怎么社交，从qqyy上面)，三分之一的内容很空泛，可以套到任何一个行业上面。说是深度解析，剩下的三分之一也浅藏辄止。感觉这本书给人最大的特点就是什么都想讲，但是什么最后都没讲的很深。\n&emsp;&emsp;seo学习下来感觉对前端方面提升不大，但是养成优质的html语义化书写习惯，总是百利而无一害的。这本书适合快速略读，不要在上面浪费太多时间一行行去读。\n","source":"_posts/SEO/SEO(chap10-12).md","raw":"---\ntitle: 《SEO深度解析》读书笔记(10-12)\ndate: 2019/4/8 19:00:00\ncategories:\n- [读书笔记, SEO深度解析]\ntags:\n- SEO\n- 读书笔记\n---\n&emsp;&emsp;SEO深度解析10-12章主要讲述了seo主要来源和操作，作者对seo的一些看法，以及一些seo达人的案例分析。\n<!--more-->\n&emsp;&emsp;虽然今天是周一，但是真的想快点把这本书的读书笔记给结束掉了，这本书对于一个技术来说有用的部分不多，我很欣赏作者把怎么喝酒吃饭都抽出来单独讲一节的勇气。SEO还是偏神棍和非技术了一些，感觉一个月左右读下来，收获不是很大。这个行业的人自己都没有摸清楚门道，一半靠猜，一半靠忽悠，也难怪SEO这个行业现在越来越没落了。\n## chap-10 SEO专题\n&emsp;&emsp;移动搜索优化，由于移动端流量越来越大，做SEO需要针对移动端做专门的优化。因为早期网页很少有移动端的部分，所以百度搜索引擎采用的是对web端的网页进行代码的转码优化，然后保存快照的方式保存到自己的搜索库当中。实际上用户在访问的时候，访问的是百度的快照。所以要针对移动端进行特殊的SEO优化，以便带来流量。采用的方法有：\n1. 提交适配关系\n2. meta标注\n```html\n<meta name=\"mobile-agent\" content=\"formate=[wml|xhtml|html5];url=url\">\n<meta name=\"applicable-device\" content=\"pc|mobile\">\n```\n&emsp;&emsp;利用SEO做百度搜索危机公关，思路就是使用权重高的网站内容去掩盖负面信息。主要操作有：\n- 未雨绸缪，做很多子品牌的子网站，使用户搜索时第一面都是自己品牌以及子网站的信息\n- 在百度贴吧，优酷等大平台去主动发一些关于自己品牌的帖子\n\n&emsp;&emsp;seo诊断优化思路：\n1. 原创不等同于有价值，对客户有用才是有价值\n2. 利用权重高网站疏忽做推广，比如部分搜索网站会留下近期用户搜索的相关内容，可以利用这个发送自己的网站链接\n\n## chap-11 一些观点\n&emsp;&emsp;这一章，作者对seo现在怎么样，seo从业者需要做什么，seo从业者怎么做做出了一些自己的看法。有点像是灌水的感觉。\n&emsp;&emsp;首先说明了，seo行业还不是很规范，很多seo从业者都是一知半解。然后列举了seo从业者在几种不同公司里面的地位。\n&emsp;&emsp;其次列举了一下作者认为的seo工作人员的工作内容：\n1. 优化网页结构，包括title标签语义化等\n2. 确定行业关键词(大关键词，短关键词，长尾关键词)\n3. 增加页面布局制作专题的方式来增加关键词\n4. 网站目录结构合理，扁平化\n5. 网站收录之后要时刻注意排名，建立良好的内外链接\n6. 不断监控优化网站数据\n&emsp;&emsp;最后说了一下SEO人员的职业规划和需要的素养。无非是要多实践多交流，逻辑要强这种比较灌水的分析和回答……这里就不赘述。\n\n## chap-12 一线达人分享\n- 余心妍团队：做一个流量的捕捉网\n从一个关键词的案例出发，重点讲述了seo当中关键词优化的思路\n- zero：深入一线SEO的策略思路\n从搜索引擎的原理角度和数据分析，来告诉你seo优化的方向\n- 道哥：seo的瓶颈在瓶口\n从技术角度，网络七层，web交互原理，阐述了技术角度上面的seo优化思路。\n- 肖俊：百度反作弊解析\n讲了百度反作弊的历史算法技术进步，从反作弊的角度，讲了seo优化的思路。\n\n&emsp;&emsp;12章剩下的一下无关痛痒的分享和最后一张100问就省略了吧。总结一下《SEO深度解析》这本书。如果满分10分的，感觉给6.5分到顶了。及格往上一些，算是好好讲了seo是什么，怎么做，然后结合自己的一些看法提出一些思路。全书三分之一的章节感觉有灌水的嫌疑(还专门有一节教你怎么社交，从qqyy上面)，三分之一的内容很空泛，可以套到任何一个行业上面。说是深度解析，剩下的三分之一也浅藏辄止。感觉这本书给人最大的特点就是什么都想讲，但是什么最后都没讲的很深。\n&emsp;&emsp;seo学习下来感觉对前端方面提升不大，但是养成优质的html语义化书写习惯，总是百利而无一害的。这本书适合快速略读，不要在上面浪费太多时间一行行去读。\n","slug":"SEO/SEO(chap10-12)","published":1,"updated":"2020-06-11T01:43:32.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxc00099r2v946p95wc","content":"<p>&emsp;&emsp;SEO深度解析10-12章主要讲述了seo主要来源和操作，作者对seo的一些看法，以及一些seo达人的案例分析。<br><a id=\"more\"></a><br>&emsp;&emsp;虽然今天是周一，但是真的想快点把这本书的读书笔记给结束掉了，这本书对于一个技术来说有用的部分不多，我很欣赏作者把怎么喝酒吃饭都抽出来单独讲一节的勇气。SEO还是偏神棍和非技术了一些，感觉一个月左右读下来，收获不是很大。这个行业的人自己都没有摸清楚门道，一半靠猜，一半靠忽悠，也难怪SEO这个行业现在越来越没落了。</p>\n<h2 id=\"chap-10-SEO专题\"><a href=\"#chap-10-SEO专题\" class=\"headerlink\" title=\"chap-10 SEO专题\"></a>chap-10 SEO专题</h2><p>&emsp;&emsp;移动搜索优化，由于移动端流量越来越大，做SEO需要针对移动端做专门的优化。因为早期网页很少有移动端的部分，所以百度搜索引擎采用的是对web端的网页进行代码的转码优化，然后保存快照的方式保存到自己的搜索库当中。实际上用户在访问的时候，访问的是百度的快照。所以要针对移动端进行特殊的SEO优化，以便带来流量。采用的方法有：</p>\n<ol>\n<li>提交适配关系</li>\n<li>meta标注<figure class=\"highlight html hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"mobile-agent\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"formate=[wml|xhtml|html5];url=url\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"applicable-device\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"pc|mobile\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>&emsp;&emsp;利用SEO做百度搜索危机公关，思路就是使用权重高的网站内容去掩盖负面信息。主要操作有：</p>\n<ul>\n<li>未雨绸缪，做很多子品牌的子网站，使用户搜索时第一面都是自己品牌以及子网站的信息</li>\n<li>在百度贴吧，优酷等大平台去主动发一些关于自己品牌的帖子</li>\n</ul>\n<p>&emsp;&emsp;seo诊断优化思路：</p>\n<ol>\n<li>原创不等同于有价值，对客户有用才是有价值</li>\n<li>利用权重高网站疏忽做推广，比如部分搜索网站会留下近期用户搜索的相关内容，可以利用这个发送自己的网站链接</li>\n</ol>\n<h2 id=\"chap-11-一些观点\"><a href=\"#chap-11-一些观点\" class=\"headerlink\" title=\"chap-11 一些观点\"></a>chap-11 一些观点</h2><p>&emsp;&emsp;这一章，作者对seo现在怎么样，seo从业者需要做什么，seo从业者怎么做做出了一些自己的看法。有点像是灌水的感觉。<br>&emsp;&emsp;首先说明了，seo行业还不是很规范，很多seo从业者都是一知半解。然后列举了seo从业者在几种不同公司里面的地位。<br>&emsp;&emsp;其次列举了一下作者认为的seo工作人员的工作内容：</p>\n<ol>\n<li>优化网页结构，包括title标签语义化等</li>\n<li>确定行业关键词(大关键词，短关键词，长尾关键词)</li>\n<li>增加页面布局制作专题的方式来增加关键词</li>\n<li>网站目录结构合理，扁平化</li>\n<li>网站收录之后要时刻注意排名，建立良好的内外链接</li>\n<li>不断监控优化网站数据<br>&emsp;&emsp;最后说了一下SEO人员的职业规划和需要的素养。无非是要多实践多交流，逻辑要强这种比较灌水的分析和回答……这里就不赘述。</li>\n</ol>\n<h2 id=\"chap-12-一线达人分享\"><a href=\"#chap-12-一线达人分享\" class=\"headerlink\" title=\"chap-12 一线达人分享\"></a>chap-12 一线达人分享</h2><ul>\n<li>余心妍团队：做一个流量的捕捉网<br>从一个关键词的案例出发，重点讲述了seo当中关键词优化的思路</li>\n<li>zero：深入一线SEO的策略思路<br>从搜索引擎的原理角度和数据分析，来告诉你seo优化的方向</li>\n<li>道哥：seo的瓶颈在瓶口<br>从技术角度，网络七层，web交互原理，阐述了技术角度上面的seo优化思路。</li>\n<li>肖俊：百度反作弊解析<br>讲了百度反作弊的历史算法技术进步，从反作弊的角度，讲了seo优化的思路。</li>\n</ul>\n<p>&emsp;&emsp;12章剩下的一下无关痛痒的分享和最后一张100问就省略了吧。总结一下《SEO深度解析》这本书。如果满分10分的，感觉给6.5分到顶了。及格往上一些，算是好好讲了seo是什么，怎么做，然后结合自己的一些看法提出一些思路。全书三分之一的章节感觉有灌水的嫌疑(还专门有一节教你怎么社交，从qqyy上面)，三分之一的内容很空泛，可以套到任何一个行业上面。说是深度解析，剩下的三分之一也浅藏辄止。感觉这本书给人最大的特点就是什么都想讲，但是什么最后都没讲的很深。<br>&emsp;&emsp;seo学习下来感觉对前端方面提升不大，但是养成优质的html语义化书写习惯，总是百利而无一害的。这本书适合快速略读，不要在上面浪费太多时间一行行去读。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;SEO深度解析10-12章主要讲述了seo主要来源和操作，作者对seo的一些看法，以及一些seo达人的案例分析。<br></p>","more":"<br>&emsp;&emsp;虽然今天是周一，但是真的想快点把这本书的读书笔记给结束掉了，这本书对于一个技术来说有用的部分不多，我很欣赏作者把怎么喝酒吃饭都抽出来单独讲一节的勇气。SEO还是偏神棍和非技术了一些，感觉一个月左右读下来，收获不是很大。这个行业的人自己都没有摸清楚门道，一半靠猜，一半靠忽悠，也难怪SEO这个行业现在越来越没落了。</p>\n<h2 id=\"chap-10-SEO专题\"><a href=\"#chap-10-SEO专题\" class=\"headerlink\" title=\"chap-10 SEO专题\"></a>chap-10 SEO专题</h2><p>&emsp;&emsp;移动搜索优化，由于移动端流量越来越大，做SEO需要针对移动端做专门的优化。因为早期网页很少有移动端的部分，所以百度搜索引擎采用的是对web端的网页进行代码的转码优化，然后保存快照的方式保存到自己的搜索库当中。实际上用户在访问的时候，访问的是百度的快照。所以要针对移动端进行特殊的SEO优化，以便带来流量。采用的方法有：</p>\n<ol>\n<li>提交适配关系</li>\n<li>meta标注<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mobile-agent\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"formate=[wml|xhtml|html5];url=url\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"applicable-device\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"pc|mobile\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>&emsp;&emsp;利用SEO做百度搜索危机公关，思路就是使用权重高的网站内容去掩盖负面信息。主要操作有：</p>\n<ul>\n<li>未雨绸缪，做很多子品牌的子网站，使用户搜索时第一面都是自己品牌以及子网站的信息</li>\n<li>在百度贴吧，优酷等大平台去主动发一些关于自己品牌的帖子</li>\n</ul>\n<p>&emsp;&emsp;seo诊断优化思路：</p>\n<ol>\n<li>原创不等同于有价值，对客户有用才是有价值</li>\n<li>利用权重高网站疏忽做推广，比如部分搜索网站会留下近期用户搜索的相关内容，可以利用这个发送自己的网站链接</li>\n</ol>\n<h2 id=\"chap-11-一些观点\"><a href=\"#chap-11-一些观点\" class=\"headerlink\" title=\"chap-11 一些观点\"></a>chap-11 一些观点</h2><p>&emsp;&emsp;这一章，作者对seo现在怎么样，seo从业者需要做什么，seo从业者怎么做做出了一些自己的看法。有点像是灌水的感觉。<br>&emsp;&emsp;首先说明了，seo行业还不是很规范，很多seo从业者都是一知半解。然后列举了seo从业者在几种不同公司里面的地位。<br>&emsp;&emsp;其次列举了一下作者认为的seo工作人员的工作内容：</p>\n<ol>\n<li>优化网页结构，包括title标签语义化等</li>\n<li>确定行业关键词(大关键词，短关键词，长尾关键词)</li>\n<li>增加页面布局制作专题的方式来增加关键词</li>\n<li>网站目录结构合理，扁平化</li>\n<li>网站收录之后要时刻注意排名，建立良好的内外链接</li>\n<li>不断监控优化网站数据<br>&emsp;&emsp;最后说了一下SEO人员的职业规划和需要的素养。无非是要多实践多交流，逻辑要强这种比较灌水的分析和回答……这里就不赘述。</li>\n</ol>\n<h2 id=\"chap-12-一线达人分享\"><a href=\"#chap-12-一线达人分享\" class=\"headerlink\" title=\"chap-12 一线达人分享\"></a>chap-12 一线达人分享</h2><ul>\n<li>余心妍团队：做一个流量的捕捉网<br>从一个关键词的案例出发，重点讲述了seo当中关键词优化的思路</li>\n<li>zero：深入一线SEO的策略思路<br>从搜索引擎的原理角度和数据分析，来告诉你seo优化的方向</li>\n<li>道哥：seo的瓶颈在瓶口<br>从技术角度，网络七层，web交互原理，阐述了技术角度上面的seo优化思路。</li>\n<li>肖俊：百度反作弊解析<br>讲了百度反作弊的历史算法技术进步，从反作弊的角度，讲了seo优化的思路。</li>\n</ul>\n<p>&emsp;&emsp;12章剩下的一下无关痛痒的分享和最后一张100问就省略了吧。总结一下《SEO深度解析》这本书。如果满分10分的，感觉给6.5分到顶了。及格往上一些，算是好好讲了seo是什么，怎么做，然后结合自己的一些看法提出一些思路。全书三分之一的章节感觉有灌水的嫌疑(还专门有一节教你怎么社交，从qqyy上面)，三分之一的内容很空泛，可以套到任何一个行业上面。说是深度解析，剩下的三分之一也浅藏辄止。感觉这本书给人最大的特点就是什么都想讲，但是什么最后都没讲的很深。<br>&emsp;&emsp;seo学习下来感觉对前端方面提升不大，但是养成优质的html语义化书写习惯，总是百利而无一害的。这本书适合快速略读，不要在上面浪费太多时间一行行去读。</p>"},{"title":"关于JS的Date你所要知道的二三事","date":"2019-05-04T11:00:00.000Z","_content":"&emsp;&emsp;半个多月没更新博文了……鬼知道我经历了什么。连续十几天的班赶项目，在五一加班两天后，终于闲暇一会，整理一下前些时间项目所用到的Date对象进行处理的知识点。\n<!--more-->\n# Date\n&emsp;&emsp;Date是JavaScript中一个**原生构造函数**，可以生成时间对象。但实际上可以使用非构造函数的方式来调用Date，此时生成的是一个当前时间的字符串。\n&emsp;&emsp;与其他原生构造函数不同，Date没有**字面量**的声明方法。\n```JavaScript\nvar newDateObject = new Date(); // Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)\ntypeof newDateObject;  // \"object\"\n\nvar unNewDate = Date(); //  \"Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)\"\ntypeof unNewDate; // \"string\"\n```\n# Date作为构造函数\n&emsp;&emsp;Date构造函数可以接受**时间戳**、**Date格式字符串**、**数字类型的多个参数**来生成你想要生成的时间的**Date对象**。\n&emsp;&emsp;这里的**时间戳**指的是从**1970年1月1日00:00**开始所经历的**毫秒数**。比如`new Date(0);`生成的就是**1970年1月1日00:00**。值得一提的是,这里原点时间是以格林尼治时间为标准的，也就是当我们使用`new Date(0);`生成的实际上是作为东八区偏移了8个小时的时间。可以使用setHours，把偏差的时间纠正回来。\n&emsp;&emsp;当你不传入任何参数时，生成的是**当前时间**的时间对象。\n```JavaScript\nvar zeroPointDate = new Date(0); // Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) 此时时间已经偏移8个小时\nzeroPointDate.setHours(0);\nconsole.log(zeroPointDate); // Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)\n```\n&emsp;&emsp;Date构造函数传入**字符串**的时候，必须要是能被 [Date.parse()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse) 正确解析的字符串格式。\n&emsp;&emsp;Date构造函数传入至少两个数字类型参数的时候，会按照`new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);`的传参模式进行解析。这里之所以是`monthIndex`，是因为在这里month是从0开始计算的。当传的参数不足数量的时候，未传参的按照默认传0来处理。除day外，day默认按照1来处理。\n&emsp;&emsp;实际上，当你传入超出边界的数字参数时，Date构造函数会帮你自动的计算成符合边界的时间对象。比如你在第二个参数传入12(即13月)，会自动帮你生成第二年1月份时间的时间对象。可以利用这个特性，方便的计算天数匹配各个月份，不用再去根据不同月份匹配不同的天数。\n```JavaScript\n// 传入13月，会自动帮你计算到下一年的1月份\nnew Date(1970, 11); // Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)\nnew Date(1970, 12); // Fri Jan 01 1971 00:00:00 GMT+0800 (中国标准时间)\n\n// 2月份并没有30天, 自动计算到了3月份的2号\nnew Date(1970, 2, 30); // Mon Mar 02 1970 00:00:00 GMT+0800 (中国标准时间)\n\n```\n&emsp;&emsp;Date当中严格一天的定位为 86,400,000 毫秒。\n&emsp;&emsp;Date的构造函数以1970年1月1日00:00为起始，能够处理正负 100,000,000 天的时间数据，超出数据会生成一个错误对象。\n```JavaScript\nnew Date(0 + 100000000 * 86400000); // Sat Sep 13 275760 08:00:00 GMT+0800 (中国标准时间)\nnew Date(0 - 100000000 * 86400000); // Tue Apr 20 -271821 08:05:43 GMT+0805 (中国标准时间)\n\nnew Date(0 + 100000000 * 86400001); // Invalid Date\nnew Date(0 - 100000000 * 86400001); // Invalid Date\n```\n\n# Date的prototype(Date的方法)和运算\n&emsp;&emsp;Date的方法可以分为**解析时间对象**(get类)和**操作时间对象**(set类)两大类。在设置时间对象的时候，不要忘了时间对象保存的本质是栈引用，即你操作一个时间对象后，所有引用这个时间对象的变量上的对象都会被改变。\n## 解析时间对象(get类)\n&emsp;&emsp;简而言之就是根据时间对象得到你所需要的各种值。\n```JavaScript\nDate.prototype.getFullYear(); // 返回年份\nDate.prototype.getMonth(); // 返回月份的index，即0表示1月份\nDate.prototype.getDate(); // 返回几号\nDate.prototype.getDay(); // 返回第几周\nDate.prototype.getHours(); // 返回几时\nDate.prototype.getMinutes(); // 返回几分钟\nDate.prototype.getSeconds(); // 返回第几秒\nDate.prototype.getMilliseconds(); //返回毫秒数\nDate.prototype.getTime(); // 返回距1970年1月1日00:00 的时间戳， 在这之前的时间会用负值表示\n```\n## 操作时间对象(set类)\n&emsp;&emsp;设置时间对象的值，改变成你想要的时间。\n```JavaScript\nDate.prototype.setFullYear(); // 设置当前时间对象的年份\nDate.prototype.setMonth(); // 设置当前时间对象的月份的index，即0表示1月份\nDate.prototype.setDate(); // 设置当前时间对象的日期\nDate.prototype.setHours(); // 设置当前时间对象的小时\nDate.prototype.setMinutes(); // 设置当前时间对象的分钟\nDate.prototype.setSeconds(); // 设置当前时间对象的秒\nDate.prototype.setMilliseconds(); // 设置当前时间对象的毫秒数\nDate.prototype.setTime(); // 根据时间戳重新设置当前时间对象\n```\n&emsp;&emsp;操作时间对象遵从超出设置边界自动计算的规则，因此可以方便的计算时间。\n```JavaScript\n// 这里写一个能计算距今任意天数是几月几日的函数\nfunction computedOffsetDaysToNow(days) {\n    var date = new Date();\n    var nowDate = date.getDate();\n    date.setDate(days + nowDate);\n    if (date.toString() === 'Invalid Date') {\n        throw new Error('can\\'t handler Invalid Date');\n    }\n    return date.getMonth() + 1 + '月' + date.getDate() + '号';\n}\n// 我写这篇文章时是19年5月4日\ncomputedOffsetDaysToNow(10); // \"5月14号\"\ncomputedOffsetDaysToNow(100); // \"8月12号\"\n```\n\n## 时间对象的运算\n&emsp;&emsp;时间对象运算之间相减运算返回数字类型的毫秒数。\n\n```JavaScript\nnew Date(1970, 11, 2) - new Date(1970, 11, 1); // 86400000 此时也可以清楚的看到一天的毫秒数是86400000\n\n```\n&emsp;&emsp;时间对象运算之间相加运算，符合JS的加法运算逻辑，对象相加时首先调用对象的 valueOf 方法，如果得到基本类型的值，那么根据基本类型规则相加。valueOf总是返回对象自身，因此再调用对象的toString方法，时间对象相加得到的时间字符串的组合。\n```JavaScript\nnew Date(1970, 11, 2) + new Date(1970, 11, 1); // \"Wed Dec 02 1970 00:00:00 GMT+0800 (中国标准时间)Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)\"\n```","source":"_posts/js/Date.md","raw":"---\ntitle: 关于JS的Date你所要知道的二三事\ndate: 2019/5/4 19:00\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;半个多月没更新博文了……鬼知道我经历了什么。连续十几天的班赶项目，在五一加班两天后，终于闲暇一会，整理一下前些时间项目所用到的Date对象进行处理的知识点。\n<!--more-->\n# Date\n&emsp;&emsp;Date是JavaScript中一个**原生构造函数**，可以生成时间对象。但实际上可以使用非构造函数的方式来调用Date，此时生成的是一个当前时间的字符串。\n&emsp;&emsp;与其他原生构造函数不同，Date没有**字面量**的声明方法。\n```JavaScript\nvar newDateObject = new Date(); // Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)\ntypeof newDateObject;  // \"object\"\n\nvar unNewDate = Date(); //  \"Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)\"\ntypeof unNewDate; // \"string\"\n```\n# Date作为构造函数\n&emsp;&emsp;Date构造函数可以接受**时间戳**、**Date格式字符串**、**数字类型的多个参数**来生成你想要生成的时间的**Date对象**。\n&emsp;&emsp;这里的**时间戳**指的是从**1970年1月1日00:00**开始所经历的**毫秒数**。比如`new Date(0);`生成的就是**1970年1月1日00:00**。值得一提的是,这里原点时间是以格林尼治时间为标准的，也就是当我们使用`new Date(0);`生成的实际上是作为东八区偏移了8个小时的时间。可以使用setHours，把偏差的时间纠正回来。\n&emsp;&emsp;当你不传入任何参数时，生成的是**当前时间**的时间对象。\n```JavaScript\nvar zeroPointDate = new Date(0); // Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) 此时时间已经偏移8个小时\nzeroPointDate.setHours(0);\nconsole.log(zeroPointDate); // Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)\n```\n&emsp;&emsp;Date构造函数传入**字符串**的时候，必须要是能被 [Date.parse()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse) 正确解析的字符串格式。\n&emsp;&emsp;Date构造函数传入至少两个数字类型参数的时候，会按照`new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);`的传参模式进行解析。这里之所以是`monthIndex`，是因为在这里month是从0开始计算的。当传的参数不足数量的时候，未传参的按照默认传0来处理。除day外，day默认按照1来处理。\n&emsp;&emsp;实际上，当你传入超出边界的数字参数时，Date构造函数会帮你自动的计算成符合边界的时间对象。比如你在第二个参数传入12(即13月)，会自动帮你生成第二年1月份时间的时间对象。可以利用这个特性，方便的计算天数匹配各个月份，不用再去根据不同月份匹配不同的天数。\n```JavaScript\n// 传入13月，会自动帮你计算到下一年的1月份\nnew Date(1970, 11); // Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)\nnew Date(1970, 12); // Fri Jan 01 1971 00:00:00 GMT+0800 (中国标准时间)\n\n// 2月份并没有30天, 自动计算到了3月份的2号\nnew Date(1970, 2, 30); // Mon Mar 02 1970 00:00:00 GMT+0800 (中国标准时间)\n\n```\n&emsp;&emsp;Date当中严格一天的定位为 86,400,000 毫秒。\n&emsp;&emsp;Date的构造函数以1970年1月1日00:00为起始，能够处理正负 100,000,000 天的时间数据，超出数据会生成一个错误对象。\n```JavaScript\nnew Date(0 + 100000000 * 86400000); // Sat Sep 13 275760 08:00:00 GMT+0800 (中国标准时间)\nnew Date(0 - 100000000 * 86400000); // Tue Apr 20 -271821 08:05:43 GMT+0805 (中国标准时间)\n\nnew Date(0 + 100000000 * 86400001); // Invalid Date\nnew Date(0 - 100000000 * 86400001); // Invalid Date\n```\n\n# Date的prototype(Date的方法)和运算\n&emsp;&emsp;Date的方法可以分为**解析时间对象**(get类)和**操作时间对象**(set类)两大类。在设置时间对象的时候，不要忘了时间对象保存的本质是栈引用，即你操作一个时间对象后，所有引用这个时间对象的变量上的对象都会被改变。\n## 解析时间对象(get类)\n&emsp;&emsp;简而言之就是根据时间对象得到你所需要的各种值。\n```JavaScript\nDate.prototype.getFullYear(); // 返回年份\nDate.prototype.getMonth(); // 返回月份的index，即0表示1月份\nDate.prototype.getDate(); // 返回几号\nDate.prototype.getDay(); // 返回第几周\nDate.prototype.getHours(); // 返回几时\nDate.prototype.getMinutes(); // 返回几分钟\nDate.prototype.getSeconds(); // 返回第几秒\nDate.prototype.getMilliseconds(); //返回毫秒数\nDate.prototype.getTime(); // 返回距1970年1月1日00:00 的时间戳， 在这之前的时间会用负值表示\n```\n## 操作时间对象(set类)\n&emsp;&emsp;设置时间对象的值，改变成你想要的时间。\n```JavaScript\nDate.prototype.setFullYear(); // 设置当前时间对象的年份\nDate.prototype.setMonth(); // 设置当前时间对象的月份的index，即0表示1月份\nDate.prototype.setDate(); // 设置当前时间对象的日期\nDate.prototype.setHours(); // 设置当前时间对象的小时\nDate.prototype.setMinutes(); // 设置当前时间对象的分钟\nDate.prototype.setSeconds(); // 设置当前时间对象的秒\nDate.prototype.setMilliseconds(); // 设置当前时间对象的毫秒数\nDate.prototype.setTime(); // 根据时间戳重新设置当前时间对象\n```\n&emsp;&emsp;操作时间对象遵从超出设置边界自动计算的规则，因此可以方便的计算时间。\n```JavaScript\n// 这里写一个能计算距今任意天数是几月几日的函数\nfunction computedOffsetDaysToNow(days) {\n    var date = new Date();\n    var nowDate = date.getDate();\n    date.setDate(days + nowDate);\n    if (date.toString() === 'Invalid Date') {\n        throw new Error('can\\'t handler Invalid Date');\n    }\n    return date.getMonth() + 1 + '月' + date.getDate() + '号';\n}\n// 我写这篇文章时是19年5月4日\ncomputedOffsetDaysToNow(10); // \"5月14号\"\ncomputedOffsetDaysToNow(100); // \"8月12号\"\n```\n\n## 时间对象的运算\n&emsp;&emsp;时间对象运算之间相减运算返回数字类型的毫秒数。\n\n```JavaScript\nnew Date(1970, 11, 2) - new Date(1970, 11, 1); // 86400000 此时也可以清楚的看到一天的毫秒数是86400000\n\n```\n&emsp;&emsp;时间对象运算之间相加运算，符合JS的加法运算逻辑，对象相加时首先调用对象的 valueOf 方法，如果得到基本类型的值，那么根据基本类型规则相加。valueOf总是返回对象自身，因此再调用对象的toString方法，时间对象相加得到的时间字符串的组合。\n```JavaScript\nnew Date(1970, 11, 2) + new Date(1970, 11, 1); // \"Wed Dec 02 1970 00:00:00 GMT+0800 (中国标准时间)Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)\"\n```","slug":"js/Date","published":1,"updated":"2020-06-11T01:43:32.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxd000a9r2v77d7bkcc","content":"<p>&emsp;&emsp;半个多月没更新博文了……鬼知道我经历了什么。连续十几天的班赶项目，在五一加班两天后，终于闲暇一会，整理一下前些时间项目所用到的Date对象进行处理的知识点。<br><a id=\"more\"></a></p>\n<h1 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h1><p>&emsp;&emsp;Date是JavaScript中一个<strong>原生构造函数</strong>，可以生成时间对象。但实际上可以使用非构造函数的方式来调用Date，此时生成的是一个当前时间的字符串。<br>&emsp;&emsp;与其他原生构造函数不同，Date没有<strong>字面量</strong>的声明方法。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> newDateObject = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(); <span class=\"hljs-comment\">// Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">typeof</span> newDateObject;  <span class=\"hljs-comment\">// \"object\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> unNewDate = <span class=\"hljs-built_in\">Date</span>(); <span class=\"hljs-comment\">//  \"Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)\"</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">typeof</span> unNewDate; <span class=\"hljs-comment\">// \"string\"</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Date作为构造函数\"><a href=\"#Date作为构造函数\" class=\"headerlink\" title=\"Date作为构造函数\"></a>Date作为构造函数</h1><p>&emsp;&emsp;Date构造函数可以接受<strong>时间戳</strong>、<strong>Date格式字符串</strong>、<strong>数字类型的多个参数</strong>来生成你想要生成的时间的<strong>Date对象</strong>。<br>&emsp;&emsp;这里的<strong>时间戳</strong>指的是从<strong>1970年1月1日00:00</strong>开始所经历的<strong>毫秒数</strong>。比如<code>new Date(0);</code>生成的就是<strong>1970年1月1日00:00</strong>。值得一提的是,这里原点时间是以格林尼治时间为标准的，也就是当我们使用<code>new Date(0);</code>生成的实际上是作为东八区偏移了8个小时的时间。可以使用setHours，把偏差的时间纠正回来。<br>&emsp;&emsp;当你不传入任何参数时，生成的是<strong>当前时间</strong>的时间对象。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> zeroPointDate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) 此时时间已经偏移8个小时</span></span><br><span class=\"line\">zeroPointDate.setHours(<span class=\"hljs-number\">0</span>);</span><br><span class=\"line\"><span class=\"hljs-built_in\">console</span>.log(zeroPointDate); <span class=\"hljs-comment\">// Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;Date构造函数传入<strong>字符串</strong>的时候，必须要是能被 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\" target=\"_blank\" rel=\"noopener\">Date.parse()</a> 正确解析的字符串格式。<br>&emsp;&emsp;Date构造函数传入至少两个数字类型参数的时候，会按照<code>new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);</code>的传参模式进行解析。这里之所以是<code>monthIndex</code>，是因为在这里month是从0开始计算的。当传的参数不足数量的时候，未传参的按照默认传0来处理。除day外，day默认按照1来处理。<br>&emsp;&emsp;实际上，当你传入超出边界的数字参数时，Date构造函数会帮你自动的计算成符合边界的时间对象。比如你在第二个参数传入12(即13月)，会自动帮你生成第二年1月份时间的时间对象。可以利用这个特性，方便的计算天数匹配各个月份，不用再去根据不同月份匹配不同的天数。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 传入13月，会自动帮你计算到下一年的1月份</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">11</span>); <span class=\"hljs-comment\">// Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// Fri Jan 01 1971 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 2月份并没有30天, 自动计算到了3月份的2号</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">30</span>); <span class=\"hljs-comment\">// Mon Mar 02 1970 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;Date当中严格一天的定位为 86,400,000 毫秒。<br>&emsp;&emsp;Date的构造函数以1970年1月1日00:00为起始，能够处理正负 100,000,000 天的时间数据，超出数据会生成一个错误对象。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">0</span> + <span class=\"hljs-number\">100000000</span> * <span class=\"hljs-number\">86400000</span>); <span class=\"hljs-comment\">// Sat Sep 13 275760 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">0</span> - <span class=\"hljs-number\">100000000</span> * <span class=\"hljs-number\">86400000</span>); <span class=\"hljs-comment\">// Tue Apr 20 -271821 08:05:43 GMT+0805 (中国标准时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">0</span> + <span class=\"hljs-number\">100000000</span> * <span class=\"hljs-number\">86400001</span>); <span class=\"hljs-comment\">// Invalid Date</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">0</span> - <span class=\"hljs-number\">100000000</span> * <span class=\"hljs-number\">86400001</span>); <span class=\"hljs-comment\">// Invalid Date</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Date的prototype-Date的方法-和运算\"><a href=\"#Date的prototype-Date的方法-和运算\" class=\"headerlink\" title=\"Date的prototype(Date的方法)和运算\"></a>Date的prototype(Date的方法)和运算</h1><p>&emsp;&emsp;Date的方法可以分为<strong>解析时间对象</strong>(get类)和<strong>操作时间对象</strong>(set类)两大类。在设置时间对象的时候，不要忘了时间对象保存的本质是栈引用，即你操作一个时间对象后，所有引用这个时间对象的变量上的对象都会被改变。</p>\n<h2 id=\"解析时间对象-get类\"><a href=\"#解析时间对象-get类\" class=\"headerlink\" title=\"解析时间对象(get类)\"></a>解析时间对象(get类)</h2><p>&emsp;&emsp;简而言之就是根据时间对象得到你所需要的各种值。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getFullYear(); <span class=\"hljs-comment\">// 返回年份</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getMonth(); <span class=\"hljs-comment\">// 返回月份的index，即0表示1月份</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getDate(); <span class=\"hljs-comment\">// 返回几号</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getDay(); <span class=\"hljs-comment\">// 返回第几周</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getHours(); <span class=\"hljs-comment\">// 返回几时</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getMinutes(); <span class=\"hljs-comment\">// 返回几分钟</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getSeconds(); <span class=\"hljs-comment\">// 返回第几秒</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getMilliseconds(); <span class=\"hljs-comment\">//返回毫秒数</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.getTime(); <span class=\"hljs-comment\">// 返回距1970年1月1日00:00 的时间戳， 在这之前的时间会用负值表示</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"操作时间对象-set类\"><a href=\"#操作时间对象-set类\" class=\"headerlink\" title=\"操作时间对象(set类)\"></a>操作时间对象(set类)</h2><p>&emsp;&emsp;设置时间对象的值，改变成你想要的时间。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setFullYear(); <span class=\"hljs-comment\">// 设置当前时间对象的年份</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setMonth(); <span class=\"hljs-comment\">// 设置当前时间对象的月份的index，即0表示1月份</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setDate(); <span class=\"hljs-comment\">// 设置当前时间对象的日期</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setHours(); <span class=\"hljs-comment\">// 设置当前时间对象的小时</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setMinutes(); <span class=\"hljs-comment\">// 设置当前时间对象的分钟</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setSeconds(); <span class=\"hljs-comment\">// 设置当前时间对象的秒</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setMilliseconds(); <span class=\"hljs-comment\">// 设置当前时间对象的毫秒数</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Date</span>.prototype.setTime(); <span class=\"hljs-comment\">// 根据时间戳重新设置当前时间对象</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;操作时间对象遵从超出设置边界自动计算的规则，因此可以方便的计算时间。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 这里写一个能计算距今任意天数是几月几日的函数</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computedOffsetDaysToNow</span>(<span class=\"hljs-params\">days</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> nowDate = date.getDate();</span><br><span class=\"line\">    date.setDate(days + nowDate);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (date.toString() === <span class=\"hljs-string\">'Invalid Date'</span>) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'can\\'t handler Invalid Date'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> date.getMonth() + <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">'月'</span> + date.getDate() + <span class=\"hljs-string\">'号'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 我写这篇文章时是19年5月4日</span></span><br><span class=\"line\">computedOffsetDaysToNow(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// \"5月14号\"</span></span><br><span class=\"line\">computedOffsetDaysToNow(<span class=\"hljs-number\">100</span>); <span class=\"hljs-comment\">// \"8月12号\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"时间对象的运算\"><a href=\"#时间对象的运算\" class=\"headerlink\" title=\"时间对象的运算\"></a>时间对象的运算</h2><p>&emsp;&emsp;时间对象运算之间相减运算返回数字类型的毫秒数。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">2</span>) - <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 86400000 此时也可以清楚的看到一天的毫秒数是86400000</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;时间对象运算之间相加运算，符合JS的加法运算逻辑，对象相加时首先调用对象的 valueOf 方法，如果得到基本类型的值，那么根据基本类型规则相加。valueOf总是返回对象自身，因此再调用对象的toString方法，时间对象相加得到的时间字符串的组合。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">2</span>) + <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1970</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// \"Wed Dec 02 1970 00:00:00 GMT+0800 (中国标准时间)Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)\"</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;半个多月没更新博文了……鬼知道我经历了什么。连续十几天的班赶项目，在五一加班两天后，终于闲暇一会，整理一下前些时间项目所用到的Date对象进行处理的知识点。<br></p>","more":"</p>\n<h1 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h1><p>&emsp;&emsp;Date是JavaScript中一个<strong>原生构造函数</strong>，可以生成时间对象。但实际上可以使用非构造函数的方式来调用Date，此时生成的是一个当前时间的字符串。<br>&emsp;&emsp;与其他原生构造函数不同，Date没有<strong>字面量</strong>的声明方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newDateObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); <span class=\"comment\">// Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> newDateObject;  <span class=\"comment\">// \"object\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> unNewDate = <span class=\"built_in\">Date</span>(); <span class=\"comment\">//  \"Sat May 04 2019 19:21:19 GMT+0800 (中国标准时间)\"</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> unNewDate; <span class=\"comment\">// \"string\"</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Date作为构造函数\"><a href=\"#Date作为构造函数\" class=\"headerlink\" title=\"Date作为构造函数\"></a>Date作为构造函数</h1><p>&emsp;&emsp;Date构造函数可以接受<strong>时间戳</strong>、<strong>Date格式字符串</strong>、<strong>数字类型的多个参数</strong>来生成你想要生成的时间的<strong>Date对象</strong>。<br>&emsp;&emsp;这里的<strong>时间戳</strong>指的是从<strong>1970年1月1日00:00</strong>开始所经历的<strong>毫秒数</strong>。比如<code>new Date(0);</code>生成的就是<strong>1970年1月1日00:00</strong>。值得一提的是,这里原点时间是以格林尼治时间为标准的，也就是当我们使用<code>new Date(0);</code>生成的实际上是作为东八区偏移了8个小时的时间。可以使用setHours，把偏差的时间纠正回来。<br>&emsp;&emsp;当你不传入任何参数时，生成的是<strong>当前时间</strong>的时间对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> zeroPointDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span>); <span class=\"comment\">// Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) 此时时间已经偏移8个小时</span></span><br><span class=\"line\">zeroPointDate.setHours(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zeroPointDate); <span class=\"comment\">// Thu Jan 01 1970 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;Date构造函数传入<strong>字符串</strong>的时候，必须要是能被 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\" target=\"_blank\" rel=\"noopener\">Date.parse()</a> 正确解析的字符串格式。<br>&emsp;&emsp;Date构造函数传入至少两个数字类型参数的时候，会按照<code>new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);</code>的传参模式进行解析。这里之所以是<code>monthIndex</code>，是因为在这里month是从0开始计算的。当传的参数不足数量的时候，未传参的按照默认传0来处理。除day外，day默认按照1来处理。<br>&emsp;&emsp;实际上，当你传入超出边界的数字参数时，Date构造函数会帮你自动的计算成符合边界的时间对象。比如你在第二个参数传入12(即13月)，会自动帮你生成第二年1月份时间的时间对象。可以利用这个特性，方便的计算天数匹配各个月份，不用再去根据不同月份匹配不同的天数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传入13月，会自动帮你计算到下一年的1月份</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">11</span>); <span class=\"comment\">// Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">12</span>); <span class=\"comment\">// Fri Jan 01 1971 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2月份并没有30天, 自动计算到了3月份的2号</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">2</span>, <span class=\"number\">30</span>); <span class=\"comment\">// Mon Mar 02 1970 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;Date当中严格一天的定位为 86,400,000 毫秒。<br>&emsp;&emsp;Date的构造函数以1970年1月1日00:00为起始，能够处理正负 100,000,000 天的时间数据，超出数据会生成一个错误对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span> + <span class=\"number\">100000000</span> * <span class=\"number\">86400000</span>); <span class=\"comment\">// Sat Sep 13 275760 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span> - <span class=\"number\">100000000</span> * <span class=\"number\">86400000</span>); <span class=\"comment\">// Tue Apr 20 -271821 08:05:43 GMT+0805 (中国标准时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span> + <span class=\"number\">100000000</span> * <span class=\"number\">86400001</span>); <span class=\"comment\">// Invalid Date</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">0</span> - <span class=\"number\">100000000</span> * <span class=\"number\">86400001</span>); <span class=\"comment\">// Invalid Date</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Date的prototype-Date的方法-和运算\"><a href=\"#Date的prototype-Date的方法-和运算\" class=\"headerlink\" title=\"Date的prototype(Date的方法)和运算\"></a>Date的prototype(Date的方法)和运算</h1><p>&emsp;&emsp;Date的方法可以分为<strong>解析时间对象</strong>(get类)和<strong>操作时间对象</strong>(set类)两大类。在设置时间对象的时候，不要忘了时间对象保存的本质是栈引用，即你操作一个时间对象后，所有引用这个时间对象的变量上的对象都会被改变。</p>\n<h2 id=\"解析时间对象-get类\"><a href=\"#解析时间对象-get类\" class=\"headerlink\" title=\"解析时间对象(get类)\"></a>解析时间对象(get类)</h2><p>&emsp;&emsp;简而言之就是根据时间对象得到你所需要的各种值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getFullYear(); <span class=\"comment\">// 返回年份</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getMonth(); <span class=\"comment\">// 返回月份的index，即0表示1月份</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getDate(); <span class=\"comment\">// 返回几号</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getDay(); <span class=\"comment\">// 返回第几周</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getHours(); <span class=\"comment\">// 返回几时</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getMinutes(); <span class=\"comment\">// 返回几分钟</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getSeconds(); <span class=\"comment\">// 返回第几秒</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getMilliseconds(); <span class=\"comment\">//返回毫秒数</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.getTime(); <span class=\"comment\">// 返回距1970年1月1日00:00 的时间戳， 在这之前的时间会用负值表示</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"操作时间对象-set类\"><a href=\"#操作时间对象-set类\" class=\"headerlink\" title=\"操作时间对象(set类)\"></a>操作时间对象(set类)</h2><p>&emsp;&emsp;设置时间对象的值，改变成你想要的时间。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setFullYear(); <span class=\"comment\">// 设置当前时间对象的年份</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setMonth(); <span class=\"comment\">// 设置当前时间对象的月份的index，即0表示1月份</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setDate(); <span class=\"comment\">// 设置当前时间对象的日期</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setHours(); <span class=\"comment\">// 设置当前时间对象的小时</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setMinutes(); <span class=\"comment\">// 设置当前时间对象的分钟</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setSeconds(); <span class=\"comment\">// 设置当前时间对象的秒</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setMilliseconds(); <span class=\"comment\">// 设置当前时间对象的毫秒数</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.setTime(); <span class=\"comment\">// 根据时间戳重新设置当前时间对象</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;操作时间对象遵从超出设置边界自动计算的规则，因此可以方便的计算时间。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里写一个能计算距今任意天数是几月几日的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computedOffsetDaysToNow</span>(<span class=\"params\">days</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> nowDate = date.getDate();</span><br><span class=\"line\">    date.setDate(days + nowDate);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (date.toString() === <span class=\"string\">'Invalid Date'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'can\\'t handler Invalid Date'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> date.getMonth() + <span class=\"number\">1</span> + <span class=\"string\">'月'</span> + date.getDate() + <span class=\"string\">'号'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 我写这篇文章时是19年5月4日</span></span><br><span class=\"line\">computedOffsetDaysToNow(<span class=\"number\">10</span>); <span class=\"comment\">// \"5月14号\"</span></span><br><span class=\"line\">computedOffsetDaysToNow(<span class=\"number\">100</span>); <span class=\"comment\">// \"8月12号\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"时间对象的运算\"><a href=\"#时间对象的运算\" class=\"headerlink\" title=\"时间对象的运算\"></a>时间对象的运算</h2><p>&emsp;&emsp;时间对象运算之间相减运算返回数字类型的毫秒数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">11</span>, <span class=\"number\">2</span>) - <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">11</span>, <span class=\"number\">1</span>); <span class=\"comment\">// 86400000 此时也可以清楚的看到一天的毫秒数是86400000</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;时间对象运算之间相加运算，符合JS的加法运算逻辑，对象相加时首先调用对象的 valueOf 方法，如果得到基本类型的值，那么根据基本类型规则相加。valueOf总是返回对象自身，因此再调用对象的toString方法，时间对象相加得到的时间字符串的组合。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">11</span>, <span class=\"number\">2</span>) + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1970</span>, <span class=\"number\">11</span>, <span class=\"number\">1</span>); <span class=\"comment\">// \"Wed Dec 02 1970 00:00:00 GMT+0800 (中国标准时间)Tue Dec 01 1970 00:00:00 GMT+0800 (中国标准时间)\"</span></span><br></pre></td></tr></table></figure></p>"},{"title":"隐藏在\"==\"后面的JavaScript隐式转换","date":"2019-09-29T04:00:00.000Z","_content":"&emsp;&emsp;逛遍各大程序社区论坛，不少自称编程“大牛”的人最喜欢调侃的语言就是JavaScript。这门被一周创建出来的动态语言被嘲讽没有任何编程的严谨性，其中最为被大家们津津乐道的就是JS中的\"==\"号。实际上你在使用时，经常会发现这样的情况:\n```javascript\n// 一个数字既不是true也不是false\n40 == true // false\n40 == false // false\n// 扑朔迷离的字符0\nnull == false // false\n'0' ==  null // false\n'0' ==  false // true\n```\n&emsp;&emsp;乍一看非常荒谬且不合逻辑的背后，实际上是有一套严谨且规范的隐式转换规则。今天就来总结整理一下隐藏在\"==\"后面的JavaScript隐式类型转换的规律。\n<!--more-->\n\n# 隐式与显式转换的概念\n&emsp;&emsp;所谓类型的`隐式转换`的概念，是相对于`显式转换`而产生的一个概念，不明显的，隐藏的类型转换，是动态语言独有的类型转换的概念。比如我现在要进行一个加法运算，`3 + 3`。正常情况下，在加号两边进行运算的应该是两个`Number`类型的值进行计算。而在JS中，加号两边实际上是可以允许任何类型的值进行计算的，比如字符串，数组。不是`Number`类型的值，甚至不是一个类型的值可以进行加法运算，是因为JS在运算的过程中自动的把加号两边的值进行`类型转换`，使得两边的值可以进行加法的处理。这种自动的类型转换，就被成为`隐式`的类型转换。而在其他静态语言当中，实际上需要手动把加好两边的值转换为`Number`类型，不然计算就会产生错误。这种手动的去操作值进行类型转换就被成为`显式`的类型转换。 \n\n# 引用类型到基本型的转换\n&emsp;&emsp;在整理隐式类型转换的规则前，需要简单过一下引用类型与基本型之间转换规则。JS当中所有的引用类型的prototype都是继承自`Object`，当引用类型需要转换为基本类型的时候，都会调用到`Object`上面的`Symbol.toPrimitive`方法进行类型转换，先把对象转换为**字符串类型**，再进行对应的基本类型转换。我们来看简单的例子：\n\n```javascript\n// 声明数组变量\nconst demoArray = [1, 2];\n// 把对象转换为字符串类型\ndemoArray + ''; // \"1,2\"\n```\n\n&emsp;&emsp;我们现在来改写demoArray的Symbol.toPrimitive。\n```javascript\n// @param {string} type 将要转换的数据类型，string类型将会为default\ndemoArray[Symbol.toPrimitive] = function(type) {\n    console.log(type, 'type');\n    return 'changedValue';\n};\n\n// 转换为字符串\ndemoArray + '';\n// default type\n// changedValue\n\n// 转换为数字\nNumber(demoArray);\n// number type\n// NaN\n```\n&emsp;&emsp;我们可以看到，无论引用类型是转换为字符串还是数字，都会调用`Symbol.toPrimitive`方法，该方法会接收到一个参数（将要转换为的类型），并且返回转换的结果。默认的`Symbol.toPrimitive`方法的逻辑，将会先调用引用类型原型链上的的`valueOf`方法，并返回基本型类的值。如果该方法返回了一个引用类型，将继续调用`toString`方法，并返回其值。我们来通过修改demoArray的`valueOf`和`toString`方法来验证这一段逻辑。\n\n```javascript\ndemoArray.valueOf = function() {\n    console.log('valueOf');\n    return 'changedValueOf';\n}\ndemoArray.toString = function() {\n    console.log('toString');\n    return 'changedtoString';\n}\n\n// 转换为字符串，会发现仅调用了 valueOf 方法\ndemoArray + '';\n// valueOf\n// changedValueOf\n\n// 修改valueOf方法返回值为引用类型\ndemoArray.valueOf = function() {\n    console.log('ObjectValueOf');\n    return {};\n}\n\n// 继续转为字符串\ndemoArray + '';\n// ObjectValueOf\n// 调动到了toString\n// toString\n// changedtoString\n```\n\n# '=='的转换规律\n&emsp;&emsp;'=='的转换规律，简单而言可以按照下面顺序去记性记忆：\n1. 引用类型与基本类型进行比较时，引用类型永远先使用`Symbol.toPrimitive`方法转换为基本类型。\n2. 基本类型下，非布尔值与布尔值比较，布尔值自身永远转换为数字类型。\n3. 数字类型和非数字类型比较，非数字类型永远转为数字类型进行比较。\n\n&emsp;&emsp;根据准则一，我们来简单分析比较一下空数组`[]`和空对象`{}`会和哪些值相等。\n\n&emsp;&emsp;首先等号两端均为引用类型，需要转换为基本类型。我们先来调用数组的`Symbol.toPrimitive`转换。数组上面`valueOf`方法总是返回它自身，`toString`方法，能够返回数组的内容项。因此空数组`[]`，在调用`Symbol.toPrimitive`之后得到的是一个空的字符串'';而对象在进行`Symbol.toPrimitive`转换时，`valueOf`返回对象自身，`toString`方法是返回一个`'[object type]'`的一个字符串。因此两端在进行基本类型转换之后，实际上是`''`和`'[object Object]'`。接下来，根据这个转换原则，我们可以轻松得出`[] == ''`和`'[object Object]' == {}`这两个式值的答案是true。\n\n&emsp;&emsp;我们再来使用`'' == false`，来使用一下规则2和规则3。根据第二条原则，false首先需要转为数字类型，`Number(false)`为0。比较的两端为变更为`'' == 0`。我们再根据规则3，把数字和其他类型比较时，其他类型需要转换为数字类型，来把空字符串变为数字类型`Numer('')`0。这样比较的两端为`0 == 0`，最终结果为true。\n\n&emsp;&emsp;我们现在来综合三条规则，来推测一下`[] == ![]`的结果。这是一个很有趣的等式，根据常理`![]`应该是`[]`的相反值，所以按照常理这个等式结果应该是false。但是根据规则，首先应该计算等式右侧，也就是`![]`的值，所有引用类型转换为布尔值均为ture，因此`![]`的结果为false。等式两边比较变更为`[] == false`。根据规则1，我们需要把引用类型变更为基本类型来和基本类型比较，`[]`通过`Symbol.toPrimitive`转换为空字符串。等式两边变更为`'' == false`。根据规则2，布尔值需要转换为数字。等式两边变更为`'' == 0`。根据规则3，我们需要把空字符串变更为数字0，因此这道结果是`0 == 0`为true。\n\n&emsp;&emsp;记得在高中学习的时候，数学老师最常对我们说得话就是让我们`不要想当然`，一切题目的答案都需要建立在严谨的计算结果和推理上。在不了解严谨规范和定义的情况下，凭着自己其他语言所谓的经验进行理所当然的`想当然`，而肆意在各个公开场所嘲讽诟病JS的“所谓大牛”，不管其技术如何，在做人方面已经已经有所欠缺了。\n\n&emsp;&emsp;JavaScript这门语言动态语言在发展过程中，还需要背负着沉重的历史包袱，每次迭代和更新标准，都需要做到向下兼容，从严格模式引入开始就不难看出这一点。每天数亿计的程序和网页在使用JS解释器进行运转，JS不能像Python一样，能够随随便便就放弃掉2升级到3。作为一个前端开发者，要不断深入到JS的规范和原理当中去，发现JS看似动态不严谨的毛病下都是有着严谨的规范和成熟的思考的，要为自己所使用的的语言发声和感到骄傲。","source":"_posts/js/implicitCall.md","raw":"---\ntitle: 隐藏在\"==\"后面的JavaScript隐式转换\ndate: 2019/9/29 12:00\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;逛遍各大程序社区论坛，不少自称编程“大牛”的人最喜欢调侃的语言就是JavaScript。这门被一周创建出来的动态语言被嘲讽没有任何编程的严谨性，其中最为被大家们津津乐道的就是JS中的\"==\"号。实际上你在使用时，经常会发现这样的情况:\n```javascript\n// 一个数字既不是true也不是false\n40 == true // false\n40 == false // false\n// 扑朔迷离的字符0\nnull == false // false\n'0' ==  null // false\n'0' ==  false // true\n```\n&emsp;&emsp;乍一看非常荒谬且不合逻辑的背后，实际上是有一套严谨且规范的隐式转换规则。今天就来总结整理一下隐藏在\"==\"后面的JavaScript隐式类型转换的规律。\n<!--more-->\n\n# 隐式与显式转换的概念\n&emsp;&emsp;所谓类型的`隐式转换`的概念，是相对于`显式转换`而产生的一个概念，不明显的，隐藏的类型转换，是动态语言独有的类型转换的概念。比如我现在要进行一个加法运算，`3 + 3`。正常情况下，在加号两边进行运算的应该是两个`Number`类型的值进行计算。而在JS中，加号两边实际上是可以允许任何类型的值进行计算的，比如字符串，数组。不是`Number`类型的值，甚至不是一个类型的值可以进行加法运算，是因为JS在运算的过程中自动的把加号两边的值进行`类型转换`，使得两边的值可以进行加法的处理。这种自动的类型转换，就被成为`隐式`的类型转换。而在其他静态语言当中，实际上需要手动把加好两边的值转换为`Number`类型，不然计算就会产生错误。这种手动的去操作值进行类型转换就被成为`显式`的类型转换。 \n\n# 引用类型到基本型的转换\n&emsp;&emsp;在整理隐式类型转换的规则前，需要简单过一下引用类型与基本型之间转换规则。JS当中所有的引用类型的prototype都是继承自`Object`，当引用类型需要转换为基本类型的时候，都会调用到`Object`上面的`Symbol.toPrimitive`方法进行类型转换，先把对象转换为**字符串类型**，再进行对应的基本类型转换。我们来看简单的例子：\n\n```javascript\n// 声明数组变量\nconst demoArray = [1, 2];\n// 把对象转换为字符串类型\ndemoArray + ''; // \"1,2\"\n```\n\n&emsp;&emsp;我们现在来改写demoArray的Symbol.toPrimitive。\n```javascript\n// @param {string} type 将要转换的数据类型，string类型将会为default\ndemoArray[Symbol.toPrimitive] = function(type) {\n    console.log(type, 'type');\n    return 'changedValue';\n};\n\n// 转换为字符串\ndemoArray + '';\n// default type\n// changedValue\n\n// 转换为数字\nNumber(demoArray);\n// number type\n// NaN\n```\n&emsp;&emsp;我们可以看到，无论引用类型是转换为字符串还是数字，都会调用`Symbol.toPrimitive`方法，该方法会接收到一个参数（将要转换为的类型），并且返回转换的结果。默认的`Symbol.toPrimitive`方法的逻辑，将会先调用引用类型原型链上的的`valueOf`方法，并返回基本型类的值。如果该方法返回了一个引用类型，将继续调用`toString`方法，并返回其值。我们来通过修改demoArray的`valueOf`和`toString`方法来验证这一段逻辑。\n\n```javascript\ndemoArray.valueOf = function() {\n    console.log('valueOf');\n    return 'changedValueOf';\n}\ndemoArray.toString = function() {\n    console.log('toString');\n    return 'changedtoString';\n}\n\n// 转换为字符串，会发现仅调用了 valueOf 方法\ndemoArray + '';\n// valueOf\n// changedValueOf\n\n// 修改valueOf方法返回值为引用类型\ndemoArray.valueOf = function() {\n    console.log('ObjectValueOf');\n    return {};\n}\n\n// 继续转为字符串\ndemoArray + '';\n// ObjectValueOf\n// 调动到了toString\n// toString\n// changedtoString\n```\n\n# '=='的转换规律\n&emsp;&emsp;'=='的转换规律，简单而言可以按照下面顺序去记性记忆：\n1. 引用类型与基本类型进行比较时，引用类型永远先使用`Symbol.toPrimitive`方法转换为基本类型。\n2. 基本类型下，非布尔值与布尔值比较，布尔值自身永远转换为数字类型。\n3. 数字类型和非数字类型比较，非数字类型永远转为数字类型进行比较。\n\n&emsp;&emsp;根据准则一，我们来简单分析比较一下空数组`[]`和空对象`{}`会和哪些值相等。\n\n&emsp;&emsp;首先等号两端均为引用类型，需要转换为基本类型。我们先来调用数组的`Symbol.toPrimitive`转换。数组上面`valueOf`方法总是返回它自身，`toString`方法，能够返回数组的内容项。因此空数组`[]`，在调用`Symbol.toPrimitive`之后得到的是一个空的字符串'';而对象在进行`Symbol.toPrimitive`转换时，`valueOf`返回对象自身，`toString`方法是返回一个`'[object type]'`的一个字符串。因此两端在进行基本类型转换之后，实际上是`''`和`'[object Object]'`。接下来，根据这个转换原则，我们可以轻松得出`[] == ''`和`'[object Object]' == {}`这两个式值的答案是true。\n\n&emsp;&emsp;我们再来使用`'' == false`，来使用一下规则2和规则3。根据第二条原则，false首先需要转为数字类型，`Number(false)`为0。比较的两端为变更为`'' == 0`。我们再根据规则3，把数字和其他类型比较时，其他类型需要转换为数字类型，来把空字符串变为数字类型`Numer('')`0。这样比较的两端为`0 == 0`，最终结果为true。\n\n&emsp;&emsp;我们现在来综合三条规则，来推测一下`[] == ![]`的结果。这是一个很有趣的等式，根据常理`![]`应该是`[]`的相反值，所以按照常理这个等式结果应该是false。但是根据规则，首先应该计算等式右侧，也就是`![]`的值，所有引用类型转换为布尔值均为ture，因此`![]`的结果为false。等式两边比较变更为`[] == false`。根据规则1，我们需要把引用类型变更为基本类型来和基本类型比较，`[]`通过`Symbol.toPrimitive`转换为空字符串。等式两边变更为`'' == false`。根据规则2，布尔值需要转换为数字。等式两边变更为`'' == 0`。根据规则3，我们需要把空字符串变更为数字0，因此这道结果是`0 == 0`为true。\n\n&emsp;&emsp;记得在高中学习的时候，数学老师最常对我们说得话就是让我们`不要想当然`，一切题目的答案都需要建立在严谨的计算结果和推理上。在不了解严谨规范和定义的情况下，凭着自己其他语言所谓的经验进行理所当然的`想当然`，而肆意在各个公开场所嘲讽诟病JS的“所谓大牛”，不管其技术如何，在做人方面已经已经有所欠缺了。\n\n&emsp;&emsp;JavaScript这门语言动态语言在发展过程中，还需要背负着沉重的历史包袱，每次迭代和更新标准，都需要做到向下兼容，从严格模式引入开始就不难看出这一点。每天数亿计的程序和网页在使用JS解释器进行运转，JS不能像Python一样，能够随随便便就放弃掉2升级到3。作为一个前端开发者，要不断深入到JS的规范和原理当中去，发现JS看似动态不严谨的毛病下都是有着严谨的规范和成熟的思考的，要为自己所使用的的语言发声和感到骄傲。","slug":"js/implicitCall","published":1,"updated":"2020-06-11T01:43:32.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxf000d9r2v3vu6di5g","content":"<p>&emsp;&emsp;逛遍各大程序社区论坛，不少自称编程“大牛”的人最喜欢调侃的语言就是JavaScript。这门被一周创建出来的动态语言被嘲讽没有任何编程的严谨性，其中最为被大家们津津乐道的就是JS中的”==”号。实际上你在使用时，经常会发现这样的情况:<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 一个数字既不是true也不是false</span></span><br><span class=\"line\"><span class=\"hljs-number\">40</span> == <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-number\">40</span> == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 扑朔迷离的字符0</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-string\">'0'</span> ==  <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-string\">'0'</span> ==  <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;乍一看非常荒谬且不合逻辑的背后，实际上是有一套严谨且规范的隐式转换规则。今天就来总结整理一下隐藏在”==”后面的JavaScript隐式类型转换的规律。<br><a id=\"more\"></a></p>\n<h1 id=\"隐式与显式转换的概念\"><a href=\"#隐式与显式转换的概念\" class=\"headerlink\" title=\"隐式与显式转换的概念\"></a>隐式与显式转换的概念</h1><p>&emsp;&emsp;所谓类型的<code>隐式转换</code>的概念，是相对于<code>显式转换</code>而产生的一个概念，不明显的，隐藏的类型转换，是动态语言独有的类型转换的概念。比如我现在要进行一个加法运算，<code>3 + 3</code>。正常情况下，在加号两边进行运算的应该是两个<code>Number</code>类型的值进行计算。而在JS中，加号两边实际上是可以允许任何类型的值进行计算的，比如字符串，数组。不是<code>Number</code>类型的值，甚至不是一个类型的值可以进行加法运算，是因为JS在运算的过程中自动的把加号两边的值进行<code>类型转换</code>，使得两边的值可以进行加法的处理。这种自动的类型转换，就被成为<code>隐式</code>的类型转换。而在其他静态语言当中，实际上需要手动把加好两边的值转换为<code>Number</code>类型，不然计算就会产生错误。这种手动的去操作值进行类型转换就被成为<code>显式</code>的类型转换。 </p>\n<h1 id=\"引用类型到基本型的转换\"><a href=\"#引用类型到基本型的转换\" class=\"headerlink\" title=\"引用类型到基本型的转换\"></a>引用类型到基本型的转换</h1><p>&emsp;&emsp;在整理隐式类型转换的规则前，需要简单过一下引用类型与基本型之间转换规则。JS当中所有的引用类型的prototype都是继承自<code>Object</code>，当引用类型需要转换为基本类型的时候，都会调用到<code>Object</code>上面的<code>Symbol.toPrimitive</code>方法进行类型转换，先把对象转换为<strong>字符串类型</strong>，再进行对应的基本类型转换。我们来看简单的例子：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 声明数组变量</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> demoArray = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];</span><br><span class=\"line\"><span class=\"hljs-comment\">// 把对象转换为字符串类型</span></span><br><span class=\"line\">demoArray + <span class=\"hljs-string\">''</span>; <span class=\"hljs-comment\">// \"1,2\"</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在来改写demoArray的Symbol.toPrimitive。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// @param &#123;string&#125; type 将要转换的数据类型，string类型将会为default</span></span><br><span class=\"line\">demoArray[<span class=\"hljs-built_in\">Symbol</span>.toPrimitive] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">console</span>.log(type, <span class=\"hljs-string\">'type'</span>);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'changedValue'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 转换为字符串</span></span><br><span class=\"line\">demoArray + <span class=\"hljs-string\">''</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// default type</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// changedValue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 转换为数字</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Number</span>(demoArray);</span><br><span class=\"line\"><span class=\"hljs-comment\">// number type</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// NaN</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们可以看到，无论引用类型是转换为字符串还是数字，都会调用<code>Symbol.toPrimitive</code>方法，该方法会接收到一个参数（将要转换为的类型），并且返回转换的结果。默认的<code>Symbol.toPrimitive</code>方法的逻辑，将会先调用引用类型原型链上的的<code>valueOf</code>方法，并返回基本型类的值。如果该方法返回了一个引用类型，将继续调用<code>toString</code>方法，并返回其值。我们来通过修改demoArray的<code>valueOf</code>和<code>toString</code>方法来验证这一段逻辑。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demoArray.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'valueOf'</span>);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'changedValueOf'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">demoArray.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'toString'</span>);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'changedtoString'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 转换为字符串，会发现仅调用了 valueOf 方法</span></span><br><span class=\"line\">demoArray + <span class=\"hljs-string\">''</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// valueOf</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// changedValueOf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 修改valueOf方法返回值为引用类型</span></span><br><span class=\"line\">demoArray.valueOf = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'ObjectValueOf'</span>);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 继续转为字符串</span></span><br><span class=\"line\">demoArray + <span class=\"hljs-string\">''</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// ObjectValueOf</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 调动到了toString</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// toString</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// changedtoString</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"‘-’的转换规律\"><a href=\"#‘-’的转换规律\" class=\"headerlink\" title=\"‘==’的转换规律\"></a>‘==’的转换规律</h1><p>&emsp;&emsp;’==’的转换规律，简单而言可以按照下面顺序去记性记忆：</p>\n<ol>\n<li>引用类型与基本类型进行比较时，引用类型永远先使用<code>Symbol.toPrimitive</code>方法转换为基本类型。</li>\n<li>基本类型下，非布尔值与布尔值比较，布尔值自身永远转换为数字类型。</li>\n<li>数字类型和非数字类型比较，非数字类型永远转为数字类型进行比较。</li>\n</ol>\n<p>&emsp;&emsp;根据准则一，我们来简单分析比较一下空数组<code>[]</code>和空对象<code>{}</code>会和哪些值相等。</p>\n<p>&emsp;&emsp;首先等号两端均为引用类型，需要转换为基本类型。我们先来调用数组的<code>Symbol.toPrimitive</code>转换。数组上面<code>valueOf</code>方法总是返回它自身，<code>toString</code>方法，能够返回数组的内容项。因此空数组<code>[]</code>，在调用<code>Symbol.toPrimitive</code>之后得到的是一个空的字符串’’;而对象在进行<code>Symbol.toPrimitive</code>转换时，<code>valueOf</code>返回对象自身，<code>toString</code>方法是返回一个<code>&#39;[object type]&#39;</code>的一个字符串。因此两端在进行基本类型转换之后，实际上是<code>&#39;&#39;</code>和<code>&#39;[object Object]&#39;</code>。接下来，根据这个转换原则，我们可以轻松得出<code>[] == &#39;&#39;</code>和<code>&#39;[object Object]&#39; == {}</code>这两个式值的答案是true。</p>\n<p>&emsp;&emsp;我们再来使用<code>&#39;&#39; == false</code>，来使用一下规则2和规则3。根据第二条原则，false首先需要转为数字类型，<code>Number(false)</code>为0。比较的两端为变更为<code>&#39;&#39; == 0</code>。我们再根据规则3，把数字和其他类型比较时，其他类型需要转换为数字类型，来把空字符串变为数字类型<code>Numer(&#39;&#39;)</code>0。这样比较的两端为<code>0 == 0</code>，最终结果为true。</p>\n<p>&emsp;&emsp;我们现在来综合三条规则，来推测一下<code>[] == ![]</code>的结果。这是一个很有趣的等式，根据常理<code>![]</code>应该是<code>[]</code>的相反值，所以按照常理这个等式结果应该是false。但是根据规则，首先应该计算等式右侧，也就是<code>![]</code>的值，所有引用类型转换为布尔值均为ture，因此<code>![]</code>的结果为false。等式两边比较变更为<code>[] == false</code>。根据规则1，我们需要把引用类型变更为基本类型来和基本类型比较，<code>[]</code>通过<code>Symbol.toPrimitive</code>转换为空字符串。等式两边变更为<code>&#39;&#39; == false</code>。根据规则2，布尔值需要转换为数字。等式两边变更为<code>&#39;&#39; == 0</code>。根据规则3，我们需要把空字符串变更为数字0，因此这道结果是<code>0 == 0</code>为true。</p>\n<p>&emsp;&emsp;记得在高中学习的时候，数学老师最常对我们说得话就是让我们<code>不要想当然</code>，一切题目的答案都需要建立在严谨的计算结果和推理上。在不了解严谨规范和定义的情况下，凭着自己其他语言所谓的经验进行理所当然的<code>想当然</code>，而肆意在各个公开场所嘲讽诟病JS的“所谓大牛”，不管其技术如何，在做人方面已经已经有所欠缺了。</p>\n<p>&emsp;&emsp;JavaScript这门语言动态语言在发展过程中，还需要背负着沉重的历史包袱，每次迭代和更新标准，都需要做到向下兼容，从严格模式引入开始就不难看出这一点。每天数亿计的程序和网页在使用JS解释器进行运转，JS不能像Python一样，能够随随便便就放弃掉2升级到3。作为一个前端开发者，要不断深入到JS的规范和原理当中去，发现JS看似动态不严谨的毛病下都是有着严谨的规范和成熟的思考的，要为自己所使用的的语言发声和感到骄傲。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;逛遍各大程序社区论坛，不少自称编程“大牛”的人最喜欢调侃的语言就是JavaScript。这门被一周创建出来的动态语言被嘲讽没有任何编程的严谨性，其中最为被大家们津津乐道的就是JS中的”==”号。实际上你在使用时，经常会发现这样的情况:<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 一个数字既不是true也不是false</span></span><br><span class=\"line\"><span class=\"hljs-number\">40</span> == <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-number\">40</span> == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 扑朔迷离的字符0</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-string\">'0'</span> ==  <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-string\">'0'</span> ==  <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;乍一看非常荒谬且不合逻辑的背后，实际上是有一套严谨且规范的隐式转换规则。今天就来总结整理一下隐藏在”==”后面的JavaScript隐式类型转换的规律。<br></p>","more":"</p>\n<h1 id=\"隐式与显式转换的概念\"><a href=\"#隐式与显式转换的概念\" class=\"headerlink\" title=\"隐式与显式转换的概念\"></a>隐式与显式转换的概念</h1><p>&emsp;&emsp;所谓类型的<code>隐式转换</code>的概念，是相对于<code>显式转换</code>而产生的一个概念，不明显的，隐藏的类型转换，是动态语言独有的类型转换的概念。比如我现在要进行一个加法运算，<code>3 + 3</code>。正常情况下，在加号两边进行运算的应该是两个<code>Number</code>类型的值进行计算。而在JS中，加号两边实际上是可以允许任何类型的值进行计算的，比如字符串，数组。不是<code>Number</code>类型的值，甚至不是一个类型的值可以进行加法运算，是因为JS在运算的过程中自动的把加号两边的值进行<code>类型转换</code>，使得两边的值可以进行加法的处理。这种自动的类型转换，就被成为<code>隐式</code>的类型转换。而在其他静态语言当中，实际上需要手动把加好两边的值转换为<code>Number</code>类型，不然计算就会产生错误。这种手动的去操作值进行类型转换就被成为<code>显式</code>的类型转换。 </p>\n<h1 id=\"引用类型到基本型的转换\"><a href=\"#引用类型到基本型的转换\" class=\"headerlink\" title=\"引用类型到基本型的转换\"></a>引用类型到基本型的转换</h1><p>&emsp;&emsp;在整理隐式类型转换的规则前，需要简单过一下引用类型与基本型之间转换规则。JS当中所有的引用类型的prototype都是继承自<code>Object</code>，当引用类型需要转换为基本类型的时候，都会调用到<code>Object</code>上面的<code>Symbol.toPrimitive</code>方法进行类型转换，先把对象转换为<strong>字符串类型</strong>，再进行对应的基本类型转换。我们来看简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明数组变量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> demoArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"comment\">// 把对象转换为字符串类型</span></span><br><span class=\"line\">demoArray + <span class=\"string\">''</span>; <span class=\"comment\">// \"1,2\"</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在来改写demoArray的Symbol.toPrimitive。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @param &#123;string&#125; type 将要转换的数据类型，string类型将会为default</span></span><br><span class=\"line\">demoArray[<span class=\"built_in\">Symbol</span>.toPrimitive] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(type, <span class=\"string\">'type'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'changedValue'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换为字符串</span></span><br><span class=\"line\">demoArray + <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// default type</span></span><br><span class=\"line\"><span class=\"comment\">// changedValue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换为数字</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(demoArray);</span><br><span class=\"line\"><span class=\"comment\">// number type</span></span><br><span class=\"line\"><span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们可以看到，无论引用类型是转换为字符串还是数字，都会调用<code>Symbol.toPrimitive</code>方法，该方法会接收到一个参数（将要转换为的类型），并且返回转换的结果。默认的<code>Symbol.toPrimitive</code>方法的逻辑，将会先调用引用类型原型链上的的<code>valueOf</code>方法，并返回基本型类的值。如果该方法返回了一个引用类型，将继续调用<code>toString</code>方法，并返回其值。我们来通过修改demoArray的<code>valueOf</code>和<code>toString</code>方法来验证这一段逻辑。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demoArray.valueOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'valueOf'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'changedValueOf'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">demoArray.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'changedtoString'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转换为字符串，会发现仅调用了 valueOf 方法</span></span><br><span class=\"line\">demoArray + <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// valueOf</span></span><br><span class=\"line\"><span class=\"comment\">// changedValueOf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改valueOf方法返回值为引用类型</span></span><br><span class=\"line\">demoArray.valueOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ObjectValueOf'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继续转为字符串</span></span><br><span class=\"line\">demoArray + <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// ObjectValueOf</span></span><br><span class=\"line\"><span class=\"comment\">// 调动到了toString</span></span><br><span class=\"line\"><span class=\"comment\">// toString</span></span><br><span class=\"line\"><span class=\"comment\">// changedtoString</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"‘-’的转换规律\"><a href=\"#‘-’的转换规律\" class=\"headerlink\" title=\"‘==’的转换规律\"></a>‘==’的转换规律</h1><p>&emsp;&emsp;’==’的转换规律，简单而言可以按照下面顺序去记性记忆：</p>\n<ol>\n<li>引用类型与基本类型进行比较时，引用类型永远先使用<code>Symbol.toPrimitive</code>方法转换为基本类型。</li>\n<li>基本类型下，非布尔值与布尔值比较，布尔值自身永远转换为数字类型。</li>\n<li>数字类型和非数字类型比较，非数字类型永远转为数字类型进行比较。</li>\n</ol>\n<p>&emsp;&emsp;根据准则一，我们来简单分析比较一下空数组<code>[]</code>和空对象<code>{}</code>会和哪些值相等。</p>\n<p>&emsp;&emsp;首先等号两端均为引用类型，需要转换为基本类型。我们先来调用数组的<code>Symbol.toPrimitive</code>转换。数组上面<code>valueOf</code>方法总是返回它自身，<code>toString</code>方法，能够返回数组的内容项。因此空数组<code>[]</code>，在调用<code>Symbol.toPrimitive</code>之后得到的是一个空的字符串’’;而对象在进行<code>Symbol.toPrimitive</code>转换时，<code>valueOf</code>返回对象自身，<code>toString</code>方法是返回一个<code>&#39;[object type]&#39;</code>的一个字符串。因此两端在进行基本类型转换之后，实际上是<code>&#39;&#39;</code>和<code>&#39;[object Object]&#39;</code>。接下来，根据这个转换原则，我们可以轻松得出<code>[] == &#39;&#39;</code>和<code>&#39;[object Object]&#39; == {}</code>这两个式值的答案是true。</p>\n<p>&emsp;&emsp;我们再来使用<code>&#39;&#39; == false</code>，来使用一下规则2和规则3。根据第二条原则，false首先需要转为数字类型，<code>Number(false)</code>为0。比较的两端为变更为<code>&#39;&#39; == 0</code>。我们再根据规则3，把数字和其他类型比较时，其他类型需要转换为数字类型，来把空字符串变为数字类型<code>Numer(&#39;&#39;)</code>0。这样比较的两端为<code>0 == 0</code>，最终结果为true。</p>\n<p>&emsp;&emsp;我们现在来综合三条规则，来推测一下<code>[] == ![]</code>的结果。这是一个很有趣的等式，根据常理<code>![]</code>应该是<code>[]</code>的相反值，所以按照常理这个等式结果应该是false。但是根据规则，首先应该计算等式右侧，也就是<code>![]</code>的值，所有引用类型转换为布尔值均为ture，因此<code>![]</code>的结果为false。等式两边比较变更为<code>[] == false</code>。根据规则1，我们需要把引用类型变更为基本类型来和基本类型比较，<code>[]</code>通过<code>Symbol.toPrimitive</code>转换为空字符串。等式两边变更为<code>&#39;&#39; == false</code>。根据规则2，布尔值需要转换为数字。等式两边变更为<code>&#39;&#39; == 0</code>。根据规则3，我们需要把空字符串变更为数字0，因此这道结果是<code>0 == 0</code>为true。</p>\n<p>&emsp;&emsp;记得在高中学习的时候，数学老师最常对我们说得话就是让我们<code>不要想当然</code>，一切题目的答案都需要建立在严谨的计算结果和推理上。在不了解严谨规范和定义的情况下，凭着自己其他语言所谓的经验进行理所当然的<code>想当然</code>，而肆意在各个公开场所嘲讽诟病JS的“所谓大牛”，不管其技术如何，在做人方面已经已经有所欠缺了。</p>\n<p>&emsp;&emsp;JavaScript这门语言动态语言在发展过程中，还需要背负着沉重的历史包袱，每次迭代和更新标准，都需要做到向下兼容，从严格模式引入开始就不难看出这一点。每天数亿计的程序和网页在使用JS解释器进行运转，JS不能像Python一样，能够随随便便就放弃掉2升级到3。作为一个前端开发者，要不断深入到JS的规范和原理当中去，发现JS看似动态不严谨的毛病下都是有着严谨的规范和成熟的思考的，要为自己所使用的的语言发声和感到骄傲。</p>"},{"title":"关于JS中number位(Bit)操作的一些思考","date":"2020-03-30T02:00:00.000Z","_content":"&emsp;&emsp;JavaScript中所有的数字都按照IEEE-754标准储存为64位。但是位操作符却是转换为32位数字进行操作的。关于这一点的可用性进行了一些思考。\n<!--more-->\n## 32带符号整数\n\n&emsp;&emsp;先来复习一下**32带符号整数**的数据表示方式。在计算机中，所有的数据都是被储存为0和1的序列，数字也不例外。比如数字4，通过二进制转换，储存为`100`。但是整数在实际业务场景中是存在正负的，如何用01序列来表示一个负数呢。我们可以拿出一个位置，用0或者1来标志这个数字是整数还是负数。\n\n&emsp;&emsp;在JS的**32带符号整数**中，数字从左边的第一位用于标识正负数（1表示负数，0表示整数）。在用二进制转换完毕后，用0补齐不足32位的部分。比如数字8的二进制为`1000`。我们先用0补齐到31位`0000000000000000000000000001000`，然后在左边第一位放上表示正负的位数，8是正数放上0，因此8在**32带符号整数**中为`00000000000000000000000000001000`。\n\n&emsp;&emsp;而如果我们要表示一个负数，比如`-18`，我们需要先找到该负数的绝对值`18`在**32带符号整数**中的01序列，为`00000000000000000000000000010010`，然我们把所有位上面的数字取反，转为`11111111111111111111111111101101`。然后我们把它加上1，得到`11111111111111111111111111101110`就是18在**32带符号整数**中的表示。我们可以在控制台中验证一下：\n\n```javascript\nconsole.log(0b11111111111111111111111111101110 | 0); // -18\n0b11111111111111111111111111101110; // 4294967278\n```\n&emsp;&emsp;在这里`0b`起头表示后续的数字是以`二进制`方式来储存。`|`位操作，表示同等级位上有1个以及以上的1为1，否则为0，因此` | 0`表示为**取原数值**。但是因为位操作符建立在**32带符号整数**的规则上，这里`| 0`实际上的含义是把前面的数值转换为**32带符号整数**。因此我们看到我们直接运算`0b11111111111111111111111111101110`得到的结果是`4294967278`而不是`-18`。\n\n&emsp;&emsp;位操作符是建立在`32位带符号整数`操作上进行的，我们还可以通过最大值的方式很简单的证明。\n\n```javascript\nconst _32_SIGNAL_BIT_MAX_NUMBER = Math.pow(2, 32 - 1) - 1; // 2147483647\n_32_SIGNAL_BIT_MAX_NUMBER | 0; // 2147483647\n_32_SIGNAL_BIT_MAX_NUMBER + 1 | 0; // -2147483648\n```\n\n&emsp;&emsp;`32位带符号整数`，由于数字的第一位用于标识*正数/负数的*，它所能表示的最大值为2的31次方-1，即`2147483647`。而数字`2147483648`在二进制的表示是`10000000000000000000000000000000`，由于第一位在`32位带符号整数`用于标识正负数，1为负数，因此`2147483647 | 0`转换之后会变为负数的`-2147483648`。\n\n## 位操作的一些思考\n\n### 利用&判断奇偶\n&emsp;&emsp;与操作符`&`是在两个数的二进制*同位都为1*时才会得到1的操作符。当使用`& 1`操作的时候，实际上就是得到被操作数的最后一位二进制是0还是1的一个操作。\n\n```javascript\n/*\n  操作\n  00000000000000000000000000010010\n                                 & \n                                 1\n*/\n18 & 1; // 0\n```\n&emsp;&emsp;而在二进制中，所有的奇数末尾都是1，因为2进制中不存在数字2，偶数势必进一到下一位上了。所以可以利用`& 1`操作来判断被操作数的奇偶。\n\n```javascript\nconst isOdd = number => !!(number & 1);\n```\n\n### 利用|取整\n&emsp;&emsp;前面有讨论过，任意数`| 0`得到的是数的原值，但是位操作是基于`32位带符号整数`的运算，因此被操作数会被转为`32位带符号整数`，这意味着被操作数的浮点数部分会统一被丢失，同时在大于`2147483648`小于`4294967296`部分由于第一位是1会变转为负数，而在大于`4294967296`的数字上，会丢失位数超过32部分。因此使用`| 0`操作，可以在小于`2147483648`处进行求整的操作。\n\n### 使用|&结合的打标模式\n&emsp;&emsp;在阅读`react源码`的时候，代码中多次使用了`|`和`&`的打标模式，来快速标志一个变量是否拥有某一种状态。我们在平常的业务场景中其实很容易遇到多种状态的场景，比如一个账号登陆拥有多种权限。此时我们一般会使用数组来进行操作。\n\n```javascript\n// @enum {string} admin/user/development\nconst ADMIN_ROLE_TYPE = 'admin';\nconst USER_ROLE_TYPE = 'user';\nconst DEVELOPMENT_ROLE_TYPE = 'development';\n\n// 某个业务场景的roleType\nlet exampleRoleType = [ADMIN_ROLE_TYPE, USER_ROLE_TYPE];\n\n// 判断是否拥有 development 权限\nexampleRoleType.includes('development');\n// 添加 development 权限\nexampleRoleType = exampleRoleType.includes('development') ? exampleRoleType : [...exampleRoleType, DEVELOPMENT_ROLE_TYPE];\n// 删除 development 权限\nexampleRoleType = exampleRoleType.filter(roleType => roleType !== 'development');\n```\n&emsp;&emsp;比如在上面的场景中，账号权限有三种情况`admin`、`user`以及`development`，且这三种角色权限可以累加。当我们标识一个账户的roleType的时候通常使用数组进行维护`角色权限的增删改查`。比如我们需要给一个账号添加某个权限的时候，我们首先需要判断roleType数组中是否存在该角色，如果不存在，再把这个角色添加进数组。\n\n&emsp;&emsp;而利用位操作，我们只需要把`roleType`维护为一个数字即可拥有多种权限。\n\n```javascript\n// @enum {string} admin/user/development\nconst ADMIN_ROLE_TYPE = 0b001;\nconst USER_ROLE_TYPE = 0b010;\nconst DEVELOPMENT_ROLE_TYPE = 0b100;\n\nlet exampleRoleType = ADMIN_ROLE_TYPE | USER_ROLE_TYPE;\n\n// 判断是否拥有 development 权限\nexampleRoleType & DEVELOPMENT_ROLE_TYPE;\n// 添加 development 权限\nexampleRoleType |= DEVELOPMENT_ROLE_TYPE;\n// 删除 development 权限\nexampleRoleType ^= DEVELOPMENT_ROLE_TYPE;\n```\n&emsp;&emsp;这种模式很巧妙的让每一种权限类型用二进制上面不同位的1来标识，然后使用位操作符在不同的位上面储存或者删除权限。让原来数组形式维护的增删改查复杂度为`O(n)`的数据结构成功降为`O(1)`。\n","source":"_posts/js/numberStoreInBit.md","raw":"---\ntitle: 关于JS中number位(Bit)操作的一些思考\ndate: 2020/3/30 10:00\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;JavaScript中所有的数字都按照IEEE-754标准储存为64位。但是位操作符却是转换为32位数字进行操作的。关于这一点的可用性进行了一些思考。\n<!--more-->\n## 32带符号整数\n\n&emsp;&emsp;先来复习一下**32带符号整数**的数据表示方式。在计算机中，所有的数据都是被储存为0和1的序列，数字也不例外。比如数字4，通过二进制转换，储存为`100`。但是整数在实际业务场景中是存在正负的，如何用01序列来表示一个负数呢。我们可以拿出一个位置，用0或者1来标志这个数字是整数还是负数。\n\n&emsp;&emsp;在JS的**32带符号整数**中，数字从左边的第一位用于标识正负数（1表示负数，0表示整数）。在用二进制转换完毕后，用0补齐不足32位的部分。比如数字8的二进制为`1000`。我们先用0补齐到31位`0000000000000000000000000001000`，然后在左边第一位放上表示正负的位数，8是正数放上0，因此8在**32带符号整数**中为`00000000000000000000000000001000`。\n\n&emsp;&emsp;而如果我们要表示一个负数，比如`-18`，我们需要先找到该负数的绝对值`18`在**32带符号整数**中的01序列，为`00000000000000000000000000010010`，然我们把所有位上面的数字取反，转为`11111111111111111111111111101101`。然后我们把它加上1，得到`11111111111111111111111111101110`就是18在**32带符号整数**中的表示。我们可以在控制台中验证一下：\n\n```javascript\nconsole.log(0b11111111111111111111111111101110 | 0); // -18\n0b11111111111111111111111111101110; // 4294967278\n```\n&emsp;&emsp;在这里`0b`起头表示后续的数字是以`二进制`方式来储存。`|`位操作，表示同等级位上有1个以及以上的1为1，否则为0，因此` | 0`表示为**取原数值**。但是因为位操作符建立在**32带符号整数**的规则上，这里`| 0`实际上的含义是把前面的数值转换为**32带符号整数**。因此我们看到我们直接运算`0b11111111111111111111111111101110`得到的结果是`4294967278`而不是`-18`。\n\n&emsp;&emsp;位操作符是建立在`32位带符号整数`操作上进行的，我们还可以通过最大值的方式很简单的证明。\n\n```javascript\nconst _32_SIGNAL_BIT_MAX_NUMBER = Math.pow(2, 32 - 1) - 1; // 2147483647\n_32_SIGNAL_BIT_MAX_NUMBER | 0; // 2147483647\n_32_SIGNAL_BIT_MAX_NUMBER + 1 | 0; // -2147483648\n```\n\n&emsp;&emsp;`32位带符号整数`，由于数字的第一位用于标识*正数/负数的*，它所能表示的最大值为2的31次方-1，即`2147483647`。而数字`2147483648`在二进制的表示是`10000000000000000000000000000000`，由于第一位在`32位带符号整数`用于标识正负数，1为负数，因此`2147483647 | 0`转换之后会变为负数的`-2147483648`。\n\n## 位操作的一些思考\n\n### 利用&判断奇偶\n&emsp;&emsp;与操作符`&`是在两个数的二进制*同位都为1*时才会得到1的操作符。当使用`& 1`操作的时候，实际上就是得到被操作数的最后一位二进制是0还是1的一个操作。\n\n```javascript\n/*\n  操作\n  00000000000000000000000000010010\n                                 & \n                                 1\n*/\n18 & 1; // 0\n```\n&emsp;&emsp;而在二进制中，所有的奇数末尾都是1，因为2进制中不存在数字2，偶数势必进一到下一位上了。所以可以利用`& 1`操作来判断被操作数的奇偶。\n\n```javascript\nconst isOdd = number => !!(number & 1);\n```\n\n### 利用|取整\n&emsp;&emsp;前面有讨论过，任意数`| 0`得到的是数的原值，但是位操作是基于`32位带符号整数`的运算，因此被操作数会被转为`32位带符号整数`，这意味着被操作数的浮点数部分会统一被丢失，同时在大于`2147483648`小于`4294967296`部分由于第一位是1会变转为负数，而在大于`4294967296`的数字上，会丢失位数超过32部分。因此使用`| 0`操作，可以在小于`2147483648`处进行求整的操作。\n\n### 使用|&结合的打标模式\n&emsp;&emsp;在阅读`react源码`的时候，代码中多次使用了`|`和`&`的打标模式，来快速标志一个变量是否拥有某一种状态。我们在平常的业务场景中其实很容易遇到多种状态的场景，比如一个账号登陆拥有多种权限。此时我们一般会使用数组来进行操作。\n\n```javascript\n// @enum {string} admin/user/development\nconst ADMIN_ROLE_TYPE = 'admin';\nconst USER_ROLE_TYPE = 'user';\nconst DEVELOPMENT_ROLE_TYPE = 'development';\n\n// 某个业务场景的roleType\nlet exampleRoleType = [ADMIN_ROLE_TYPE, USER_ROLE_TYPE];\n\n// 判断是否拥有 development 权限\nexampleRoleType.includes('development');\n// 添加 development 权限\nexampleRoleType = exampleRoleType.includes('development') ? exampleRoleType : [...exampleRoleType, DEVELOPMENT_ROLE_TYPE];\n// 删除 development 权限\nexampleRoleType = exampleRoleType.filter(roleType => roleType !== 'development');\n```\n&emsp;&emsp;比如在上面的场景中，账号权限有三种情况`admin`、`user`以及`development`，且这三种角色权限可以累加。当我们标识一个账户的roleType的时候通常使用数组进行维护`角色权限的增删改查`。比如我们需要给一个账号添加某个权限的时候，我们首先需要判断roleType数组中是否存在该角色，如果不存在，再把这个角色添加进数组。\n\n&emsp;&emsp;而利用位操作，我们只需要把`roleType`维护为一个数字即可拥有多种权限。\n\n```javascript\n// @enum {string} admin/user/development\nconst ADMIN_ROLE_TYPE = 0b001;\nconst USER_ROLE_TYPE = 0b010;\nconst DEVELOPMENT_ROLE_TYPE = 0b100;\n\nlet exampleRoleType = ADMIN_ROLE_TYPE | USER_ROLE_TYPE;\n\n// 判断是否拥有 development 权限\nexampleRoleType & DEVELOPMENT_ROLE_TYPE;\n// 添加 development 权限\nexampleRoleType |= DEVELOPMENT_ROLE_TYPE;\n// 删除 development 权限\nexampleRoleType ^= DEVELOPMENT_ROLE_TYPE;\n```\n&emsp;&emsp;这种模式很巧妙的让每一种权限类型用二进制上面不同位的1来标识，然后使用位操作符在不同的位上面储存或者删除权限。让原来数组形式维护的增删改查复杂度为`O(n)`的数据结构成功降为`O(1)`。\n","slug":"js/numberStoreInBit","published":1,"updated":"2020-06-11T01:43:32.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxf000e9r2vfug60ga3","content":"<p>&emsp;&emsp;JavaScript中所有的数字都按照IEEE-754标准储存为64位。但是位操作符却是转换为32位数字进行操作的。关于这一点的可用性进行了一些思考。<br><a id=\"more\"></a></p>\n<h2 id=\"32带符号整数\"><a href=\"#32带符号整数\" class=\"headerlink\" title=\"32带符号整数\"></a>32带符号整数</h2><p>&emsp;&emsp;先来复习一下<strong>32带符号整数</strong>的数据表示方式。在计算机中，所有的数据都是被储存为0和1的序列，数字也不例外。比如数字4，通过二进制转换，储存为<code>100</code>。但是整数在实际业务场景中是存在正负的，如何用01序列来表示一个负数呢。我们可以拿出一个位置，用0或者1来标志这个数字是整数还是负数。</p>\n<p>&emsp;&emsp;在JS的<strong>32带符号整数</strong>中，数字从左边的第一位用于标识正负数（1表示负数，0表示整数）。在用二进制转换完毕后，用0补齐不足32位的部分。比如数字8的二进制为<code>1000</code>。我们先用0补齐到31位<code>0000000000000000000000000001000</code>，然后在左边第一位放上表示正负的位数，8是正数放上0，因此8在<strong>32带符号整数</strong>中为<code>00000000000000000000000000001000</code>。</p>\n<p>&emsp;&emsp;而如果我们要表示一个负数，比如<code>-18</code>，我们需要先找到该负数的绝对值<code>18</code>在<strong>32带符号整数</strong>中的01序列，为<code>00000000000000000000000000010010</code>，然我们把所有位上面的数字取反，转为<code>11111111111111111111111111101101</code>。然后我们把它加上1，得到<code>11111111111111111111111111101110</code>就是18在<strong>32带符号整数</strong>中的表示。我们可以在控制台中验证一下：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">0b11111111111111111111111111101110</span> | <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// -18</span></span><br><span class=\"line\"><span class=\"hljs-number\">0b11111111111111111111111111101110</span>; <span class=\"hljs-comment\">// 4294967278</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在这里<code>0b</code>起头表示后续的数字是以<code>二进制</code>方式来储存。<code>|</code>位操作，表示同等级位上有1个以及以上的1为1，否则为0，因此<code>| 0</code>表示为<strong>取原数值</strong>。但是因为位操作符建立在<strong>32带符号整数</strong>的规则上，这里<code>| 0</code>实际上的含义是把前面的数值转换为<strong>32带符号整数</strong>。因此我们看到我们直接运算<code>0b11111111111111111111111111101110</code>得到的结果是<code>4294967278</code>而不是<code>-18</code>。</p>\n<p>&emsp;&emsp;位操作符是建立在<code>32位带符号整数</code>操作上进行的，我们还可以通过最大值的方式很简单的证明。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> _32_SIGNAL_BIT_MAX_NUMBER = <span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">32</span> - <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 2147483647</span></span><br><span class=\"line\">_32_SIGNAL_BIT_MAX_NUMBER | <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 2147483647</span></span><br><span class=\"line\">_32_SIGNAL_BIT_MAX_NUMBER + <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// -2147483648</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>32位带符号整数</code>，由于数字的第一位用于标识<em>正数/负数的</em>，它所能表示的最大值为2的31次方-1，即<code>2147483647</code>。而数字<code>2147483648</code>在二进制的表示是<code>10000000000000000000000000000000</code>，由于第一位在<code>32位带符号整数</code>用于标识正负数，1为负数，因此<code>2147483647 | 0</code>转换之后会变为负数的<code>-2147483648</code>。</p>\n<h2 id=\"位操作的一些思考\"><a href=\"#位操作的一些思考\" class=\"headerlink\" title=\"位操作的一些思考\"></a>位操作的一些思考</h2><h3 id=\"利用-amp-判断奇偶\"><a href=\"#利用-amp-判断奇偶\" class=\"headerlink\" title=\"利用&amp;判断奇偶\"></a>利用&amp;判断奇偶</h3><p>&emsp;&emsp;与操作符<code>&amp;</code>是在两个数的二进制<em>同位都为1</em>时才会得到1的操作符。当使用<code>&amp; 1</code>操作的时候，实际上就是得到被操作数的最后一位二进制是0还是1的一个操作。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  操作</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  00000000000000000000000000010010</span></span><br><span class=\"line\"><span class=\"hljs-comment\">                                 &amp; </span></span><br><span class=\"line\"><span class=\"hljs-comment\">                                 1</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br><span class=\"line\"><span class=\"hljs-number\">18</span> &amp; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;而在二进制中，所有的奇数末尾都是1，因为2进制中不存在数字2，偶数势必进一到下一位上了。所以可以利用<code>&amp; 1</code>操作来判断被操作数的奇偶。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> isOdd = <span class=\"hljs-function\"><span class=\"hljs-params\">number</span> =&gt;</span> !!(number &amp; <span class=\"hljs-number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用-取整\"><a href=\"#利用-取整\" class=\"headerlink\" title=\"利用|取整\"></a>利用|取整</h3><p>&emsp;&emsp;前面有讨论过，任意数<code>| 0</code>得到的是数的原值，但是位操作是基于<code>32位带符号整数</code>的运算，因此被操作数会被转为<code>32位带符号整数</code>，这意味着被操作数的浮点数部分会统一被丢失，同时在大于<code>2147483648</code>小于<code>4294967296</code>部分由于第一位是1会变转为负数，而在大于<code>4294967296</code>的数字上，会丢失位数超过32部分。因此使用<code>| 0</code>操作，可以在小于<code>2147483648</code>处进行求整的操作。</p>\n<h3 id=\"使用-amp-结合的打标模式\"><a href=\"#使用-amp-结合的打标模式\" class=\"headerlink\" title=\"使用|&amp;结合的打标模式\"></a>使用|&amp;结合的打标模式</h3><p>&emsp;&emsp;在阅读<code>react源码</code>的时候，代码中多次使用了<code>|</code>和<code>&amp;</code>的打标模式，来快速标志一个变量是否拥有某一种状态。我们在平常的业务场景中其实很容易遇到多种状态的场景，比如一个账号登陆拥有多种权限。此时我们一般会使用数组来进行操作。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// @enum &#123;string&#125; admin/user/development</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> ADMIN_ROLE_TYPE = <span class=\"hljs-string\">'admin'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> USER_ROLE_TYPE = <span class=\"hljs-string\">'user'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> DEVELOPMENT_ROLE_TYPE = <span class=\"hljs-string\">'development'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 某个业务场景的roleType</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> exampleRoleType = [ADMIN_ROLE_TYPE, USER_ROLE_TYPE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 判断是否拥有 development 权限</span></span><br><span class=\"line\">exampleRoleType.includes(<span class=\"hljs-string\">'development'</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// 添加 development 权限</span></span><br><span class=\"line\">exampleRoleType = exampleRoleType.includes(<span class=\"hljs-string\">'development'</span>) ? exampleRoleType : [...exampleRoleType, DEVELOPMENT_ROLE_TYPE];</span><br><span class=\"line\"><span class=\"hljs-comment\">// 删除 development 权限</span></span><br><span class=\"line\">exampleRoleType = exampleRoleType.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">roleType</span> =&gt;</span> roleType !== <span class=\"hljs-string\">'development'</span>);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;比如在上面的场景中，账号权限有三种情况<code>admin</code>、<code>user</code>以及<code>development</code>，且这三种角色权限可以累加。当我们标识一个账户的roleType的时候通常使用数组进行维护<code>角色权限的增删改查</code>。比如我们需要给一个账号添加某个权限的时候，我们首先需要判断roleType数组中是否存在该角色，如果不存在，再把这个角色添加进数组。</p>\n<p>&emsp;&emsp;而利用位操作，我们只需要把<code>roleType</code>维护为一个数字即可拥有多种权限。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// @enum &#123;string&#125; admin/user/development</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> ADMIN_ROLE_TYPE = <span class=\"hljs-number\">0b001</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> USER_ROLE_TYPE = <span class=\"hljs-number\">0b010</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> DEVELOPMENT_ROLE_TYPE = <span class=\"hljs-number\">0b100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> exampleRoleType = ADMIN_ROLE_TYPE | USER_ROLE_TYPE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 判断是否拥有 development 权限</span></span><br><span class=\"line\">exampleRoleType &amp; DEVELOPMENT_ROLE_TYPE;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 添加 development 权限</span></span><br><span class=\"line\">exampleRoleType |= DEVELOPMENT_ROLE_TYPE;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 删除 development 权限</span></span><br><span class=\"line\">exampleRoleType ^= DEVELOPMENT_ROLE_TYPE;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种模式很巧妙的让每一种权限类型用二进制上面不同位的1来标识，然后使用位操作符在不同的位上面储存或者删除权限。让原来数组形式维护的增删改查复杂度为<code>O(n)</code>的数据结构成功降为<code>O(1)</code>。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;JavaScript中所有的数字都按照IEEE-754标准储存为64位。但是位操作符却是转换为32位数字进行操作的。关于这一点的可用性进行了一些思考。<br></p>","more":"</p>\n<h2 id=\"32带符号整数\"><a href=\"#32带符号整数\" class=\"headerlink\" title=\"32带符号整数\"></a>32带符号整数</h2><p>&emsp;&emsp;先来复习一下<strong>32带符号整数</strong>的数据表示方式。在计算机中，所有的数据都是被储存为0和1的序列，数字也不例外。比如数字4，通过二进制转换，储存为<code>100</code>。但是整数在实际业务场景中是存在正负的，如何用01序列来表示一个负数呢。我们可以拿出一个位置，用0或者1来标志这个数字是整数还是负数。</p>\n<p>&emsp;&emsp;在JS的<strong>32带符号整数</strong>中，数字从左边的第一位用于标识正负数（1表示负数，0表示整数）。在用二进制转换完毕后，用0补齐不足32位的部分。比如数字8的二进制为<code>1000</code>。我们先用0补齐到31位<code>0000000000000000000000000001000</code>，然后在左边第一位放上表示正负的位数，8是正数放上0，因此8在<strong>32带符号整数</strong>中为<code>00000000000000000000000000001000</code>。</p>\n<p>&emsp;&emsp;而如果我们要表示一个负数，比如<code>-18</code>，我们需要先找到该负数的绝对值<code>18</code>在<strong>32带符号整数</strong>中的01序列，为<code>00000000000000000000000000010010</code>，然我们把所有位上面的数字取反，转为<code>11111111111111111111111111101101</code>。然后我们把它加上1，得到<code>11111111111111111111111111101110</code>就是18在<strong>32带符号整数</strong>中的表示。我们可以在控制台中验证一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0b11111111111111111111111111101110</span> | <span class=\"number\">0</span>); <span class=\"comment\">// -18</span></span><br><span class=\"line\"><span class=\"number\">0b11111111111111111111111111101110</span>; <span class=\"comment\">// 4294967278</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在这里<code>0b</code>起头表示后续的数字是以<code>二进制</code>方式来储存。<code>|</code>位操作，表示同等级位上有1个以及以上的1为1，否则为0，因此<code>| 0</code>表示为<strong>取原数值</strong>。但是因为位操作符建立在<strong>32带符号整数</strong>的规则上，这里<code>| 0</code>实际上的含义是把前面的数值转换为<strong>32带符号整数</strong>。因此我们看到我们直接运算<code>0b11111111111111111111111111101110</code>得到的结果是<code>4294967278</code>而不是<code>-18</code>。</p>\n<p>&emsp;&emsp;位操作符是建立在<code>32位带符号整数</code>操作上进行的，我们还可以通过最大值的方式很简单的证明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _32_SIGNAL_BIT_MAX_NUMBER = <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">32</span> - <span class=\"number\">1</span>) - <span class=\"number\">1</span>; <span class=\"comment\">// 2147483647</span></span><br><span class=\"line\">_32_SIGNAL_BIT_MAX_NUMBER | <span class=\"number\">0</span>; <span class=\"comment\">// 2147483647</span></span><br><span class=\"line\">_32_SIGNAL_BIT_MAX_NUMBER + <span class=\"number\">1</span> | <span class=\"number\">0</span>; <span class=\"comment\">// -2147483648</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>32位带符号整数</code>，由于数字的第一位用于标识<em>正数/负数的</em>，它所能表示的最大值为2的31次方-1，即<code>2147483647</code>。而数字<code>2147483648</code>在二进制的表示是<code>10000000000000000000000000000000</code>，由于第一位在<code>32位带符号整数</code>用于标识正负数，1为负数，因此<code>2147483647 | 0</code>转换之后会变为负数的<code>-2147483648</code>。</p>\n<h2 id=\"位操作的一些思考\"><a href=\"#位操作的一些思考\" class=\"headerlink\" title=\"位操作的一些思考\"></a>位操作的一些思考</h2><h3 id=\"利用-amp-判断奇偶\"><a href=\"#利用-amp-判断奇偶\" class=\"headerlink\" title=\"利用&amp;判断奇偶\"></a>利用&amp;判断奇偶</h3><p>&emsp;&emsp;与操作符<code>&amp;</code>是在两个数的二进制<em>同位都为1</em>时才会得到1的操作符。当使用<code>&amp; 1</code>操作的时候，实际上就是得到被操作数的最后一位二进制是0还是1的一个操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  操作</span></span><br><span class=\"line\"><span class=\"comment\">  00000000000000000000000000010010</span></span><br><span class=\"line\"><span class=\"comment\">                                 &amp; </span></span><br><span class=\"line\"><span class=\"comment\">                                 1</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"number\">18</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;而在二进制中，所有的奇数末尾都是1，因为2进制中不存在数字2，偶数势必进一到下一位上了。所以可以利用<code>&amp; 1</code>操作来判断被操作数的奇偶。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isOdd = <span class=\"function\"><span class=\"params\">number</span> =&gt;</span> !!(number &amp; <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用-取整\"><a href=\"#利用-取整\" class=\"headerlink\" title=\"利用|取整\"></a>利用|取整</h3><p>&emsp;&emsp;前面有讨论过，任意数<code>| 0</code>得到的是数的原值，但是位操作是基于<code>32位带符号整数</code>的运算，因此被操作数会被转为<code>32位带符号整数</code>，这意味着被操作数的浮点数部分会统一被丢失，同时在大于<code>2147483648</code>小于<code>4294967296</code>部分由于第一位是1会变转为负数，而在大于<code>4294967296</code>的数字上，会丢失位数超过32部分。因此使用<code>| 0</code>操作，可以在小于<code>2147483648</code>处进行求整的操作。</p>\n<h3 id=\"使用-amp-结合的打标模式\"><a href=\"#使用-amp-结合的打标模式\" class=\"headerlink\" title=\"使用|&amp;结合的打标模式\"></a>使用|&amp;结合的打标模式</h3><p>&emsp;&emsp;在阅读<code>react源码</code>的时候，代码中多次使用了<code>|</code>和<code>&amp;</code>的打标模式，来快速标志一个变量是否拥有某一种状态。我们在平常的业务场景中其实很容易遇到多种状态的场景，比如一个账号登陆拥有多种权限。此时我们一般会使用数组来进行操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @enum &#123;string&#125; admin/user/development</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ADMIN_ROLE_TYPE = <span class=\"string\">'admin'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> USER_ROLE_TYPE = <span class=\"string\">'user'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DEVELOPMENT_ROLE_TYPE = <span class=\"string\">'development'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 某个业务场景的roleType</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> exampleRoleType = [ADMIN_ROLE_TYPE, USER_ROLE_TYPE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断是否拥有 development 权限</span></span><br><span class=\"line\">exampleRoleType.includes(<span class=\"string\">'development'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 添加 development 权限</span></span><br><span class=\"line\">exampleRoleType = exampleRoleType.includes(<span class=\"string\">'development'</span>) ? exampleRoleType : [...exampleRoleType, DEVELOPMENT_ROLE_TYPE];</span><br><span class=\"line\"><span class=\"comment\">// 删除 development 权限</span></span><br><span class=\"line\">exampleRoleType = exampleRoleType.filter(<span class=\"function\"><span class=\"params\">roleType</span> =&gt;</span> roleType !== <span class=\"string\">'development'</span>);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;比如在上面的场景中，账号权限有三种情况<code>admin</code>、<code>user</code>以及<code>development</code>，且这三种角色权限可以累加。当我们标识一个账户的roleType的时候通常使用数组进行维护<code>角色权限的增删改查</code>。比如我们需要给一个账号添加某个权限的时候，我们首先需要判断roleType数组中是否存在该角色，如果不存在，再把这个角色添加进数组。</p>\n<p>&emsp;&emsp;而利用位操作，我们只需要把<code>roleType</code>维护为一个数字即可拥有多种权限。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @enum &#123;string&#125; admin/user/development</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ADMIN_ROLE_TYPE = <span class=\"number\">0b001</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> USER_ROLE_TYPE = <span class=\"number\">0b010</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DEVELOPMENT_ROLE_TYPE = <span class=\"number\">0b100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> exampleRoleType = ADMIN_ROLE_TYPE | USER_ROLE_TYPE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断是否拥有 development 权限</span></span><br><span class=\"line\">exampleRoleType &amp; DEVELOPMENT_ROLE_TYPE;</span><br><span class=\"line\"><span class=\"comment\">// 添加 development 权限</span></span><br><span class=\"line\">exampleRoleType |= DEVELOPMENT_ROLE_TYPE;</span><br><span class=\"line\"><span class=\"comment\">// 删除 development 权限</span></span><br><span class=\"line\">exampleRoleType ^= DEVELOPMENT_ROLE_TYPE;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种模式很巧妙的让每一种权限类型用二进制上面不同位的1来标识，然后使用位操作符在不同的位上面储存或者删除权限。让原来数组形式维护的增删改查复杂度为<code>O(n)</code>的数据结构成功降为<code>O(1)</code>。</p>"},{"title":"Promise","date":"2019-06-15T08:40:00.000Z","_content":"&emsp;&emsp;这篇文章总结一下JS本身单线程异步的局限性(promise出现的原因)，以及实现一个简易的Promise。\n<!--more-->\n\n# 单线程与异步\n&emsp;&emsp;JavaScript是一个单线程执行的语言，在不考虑异步编程的情况下，它执行的顺序就是一个eventLoop的简单循环。比如书写一段简单的JS代码：\n\n```Javascript\n// 声明两个变量，和一个函数\nvar demoVariA = 100;\nvar demoVariB = 200;\n// 函数的功能是把入参的两个数值相加\nfunction addTowNum (a, b) {\n    return a + b;\n}\naddTowNum(demoVariA, demoVariB);\n```\n\n&emsp;&emsp;那么在不考虑预解析的情况下(变量函数作用域提升)，我们试着把上面这段代码执行顺序用一个eventLoop来简单表示出来。\n\n```Javascript\n// 代码的执行队列\neventLoop = [\n    '赋值100给内存demoVariA',\n    '赋值200给内存demoVariB',\n    '申请堆栈内存声明为addTowNum，赋值为一个函数',\n    '执行函数'\n];\n// 现在JS代码需要分析执行\n// 这里不考虑任何异步的情况，包括宏任务和微任务\nwhile (eventLoop.length > 0) {\n    // 这里表示对词法token进行编译借的过程的抽象\n    var event = eventLoop.shift();\n    try {\n        event();\n    } catch (error) {\n        report(error);\n    }\n}\n```\n&emsp;&emsp;我们可以看到，不需要考虑多线程共享数据时线程执行先后对程序造成的影响，不需要使用进程锁的概念，词法的执行顺序是多么的清晰，单线程编程是多么的令人愉快。直到异步进入到我们的编程世界。\n\n&emsp;&emsp;同样是上面的例子，我们把`demoVariA`,`demoVariB`的数据请求改为异步的请求获取值`asyncGetSomeValue`,事情就完全不一样了。\n\n```Javascript\nvar demoVariA = asyncGetSomeValue('pathA');\nvar demoVariB = asyncGetSomeValue('pathB');\nfunction addTowNum (a, b) {\n    return a + b;\n}\naddTowNum(demoVariA, demoVariB); // undefined  + undefined = NaN\n```\n\n&emsp;&emsp;asyncGetSomeValue必须在某个异步操作之后,再获取到值,因此按照JS的常规做法,我们必须把`demoVariA`,`demoVariB`放到回调当中去获取值，我们把代码修改如下:\n\n```Javascript\nvar demoVariA;\nvar demoVariB;\nasyncGetSomeValue('pathA', function (responseValue) {\n    demoVariA = responseValue;\n});\nasyncGetSomeValue('pathB', function (responseValue) {\n    demoVariB = responseValue;\n});\nfunction addTowNum (a, b) {\n    return a + b;\n}\n```\n\n&emsp;&emsp;现在问题来了`addTowNum`，该放到哪里去执行才能a和b同时获取到呢。有的同学此时会说，简单，我把`demoVariB`获取放到`demoVariA`获取的回调下，再去执行`addTowNum`。\n\n```Javascript\nvar demoVariA;\nvar demoVariB;\nasyncGetSomeValue('pathA', function (responseValue) {\n    demoVariA = responseValue;\n    asyncGetSomeValue('pathB', function (responseValue) {\n        demoVariB = responseValue;\n        addTowNum(demoVariA, demoVariB);\n    });\n});\n\nfunction addTowNum (a, b) {\n    return a + b;\n}\n```\n&emsp;&emsp;实际上,`demoVariB`的请求并没有依赖到`demoVariA`,因此把`demoVariB`的取值请求放到`demoVariA`的后面的做法是错误的，这样会导致`addTowNum`这个函数的调用时间将会变成两个异步请求费时的总和。这两个获取值得请求严格意义上应该是**并发**的概念。我们要做的是需要声明一个为`gate`的函数，当你传入的所有变量**存在**的时候，去执行传入的函数。\n```Javascript\n/**\n * @param {function} gateFunction 所有变量存在后执行的函数\n * @param 剩余变量\n  */\nfunction gate (gateFunction) {\n    var testArray = arguments.slice(1);\n    // 全部变量都存在的时候，才执行gateFunction\n    if (testArray.every(variable => variable)) {\n        gateFunction.apply(this, testArray);\n    }\n}\n```\n&emsp;&emsp;此时加入`gate`函数,我们上面的修改为异步的例子才算简单完成。实际业务编程当中，我们还要考虑asyncGetSomeValue的异常抛错等问题。\n\n```Javascript\nvar demoVariA;\nvar demoVariB;\nasyncGetSomeValue('pathA', function (responseValue) {\n    demoVariA = responseValue;\n    gate(addTowNum, a, b);\n});\nasyncGetSomeValue('pathB', function (responseValue) {\n    demoVariB = responseValue;\n    gate(addTowNum, a, b);\n});\nfunction addTowNum (a, b) {\n    return a + b;\n}\n```\n&emsp;&emsp;通过这个简单的例子我们不难发现异步编程的问题：\n1. 多异步返回的执行顺序不可控。\n2. 多异步的异常错误处理非常繁杂。\n3. 多异步嵌套，会导致回调地狱。\n\n&emsp;&emsp;我们急需要一个能够保证异步执行顺序，保证执行和抛出错误的异步处理的**保证**范式来解决这些问题。ES6给我们的答案就是Promise(承诺)。\n\n# Promise的特性\n\n## 都是将来\n&emsp;&emsp;Promise的使用方法不做阐述，想要了解的可以去查询一下[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)。\n\n&emsp;&emsp;Promise的回调than有一个非常重要的特性，那就是无论是**现在**还是**将来**,统一都是**将来**。我们来猜一下下面代码的执行顺序:\n\n```javascript\nvar promise = new Promise(function (resolve, reject) {\n    console.log(1);\n    setTimeout(() => {\n        console.log(2);\n    }, 0)\n    resolve(3);\n});\npromise.then(val => console.log(val));\nconsole.log(4);\n```\n&emsp;&emsp;简单分析一下执行顺序,代码解析按照从上到下进行解析运行。在`new Promise`的过程中，里面的代码会被执行。因此执行`console.log(1)`输出1。然后执行到`setTimeout`,JS按照**宏任务**的逻辑把setTimeout放到本次事件循环结束的**最末端之后**。然后注册`resolve`。\n\n&emsp;&emsp;`new Promise`执行完毕，返回`Promise`的实例对象给变量`promise`。`promise`执行`then`方法。`Promise`的`then`方法是一个**微任务**，不管里面的代码是什么内容，这段代码都会被放到当前事件队列的**最末尾**。\n\n&emsp;&emsp;代码现在跑到`console.log(4)`,正常输出。执行完毕后，到达事件循环的末端，此时执行**微任务**,`promise`的`then`回调执行。本次事件循环结束。事件循环结束后执行**宏任务**的`setTimeout`。\n\n## 其他特性\n&emsp;&emsp;`Promise`本身具有`pending fulfilled rejected`三个状态，它们之间是互相不可逆的。\n&emsp;&emsp;其次，`Promise`通过多次调用 .then()，可以添加多个回调函数，它们会按照插入顺序并且独立运行。`new Promise`的内容只会被执行**一次**。\n\n# 开写Promise\n\n## 搭建框架\n&emsp;&emsp;我们先简单搭建一下需要实现的`myPromise`的大体框架。然后根据`Promise`的特性来实现。首先,`Promise`通过`new`去执行,是一个构造函数的特征。它接受一个函数作为参数，该函数接受`resolve`和`reject`，并且在`new`的时候就被执行。\n\n&emsp;&emsp;其次我们需要有一个`_status`来复现`Promise`的三个状态。\n\n&emsp;&emsp;接着我们实现一下`then catch`方法，这些构造函数也能使用的方法,我们定义在`prototype`上面。\n\n&emsp;&emsp;现在我们能根据这些需求搭建出来`myPromise`的框架。\n\n```javascript\nwindow.myPromise = function (executor) {\n\n    this._resolve = function (value) {\n\n    }\n\n    this._reject = function (error) {\n\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n    // 使用bind来绑定作用域，保证可以访问到实例上面的属性\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\nmyPromise.prototype.then = function (thenCallBack) {\n\n}\n\nmyPromise.prototype.catch = function (errorCallBack) {\n    \n}\n\n```\n\n## 实现then和_reslove。\n\n&emsp;&emsp;我们需要思考一个**核心点**,那就是`then`中的回调，如果保证构造函数存在异步逻辑时，在`reslove`之后去执行。其实很简单，就是在`then`当中传入的回调`thenCallBack`在`then`中不执行，而在`_resolve`当中执行就可以了。\n\n&emsp;&emsp;简单来说,在`then`方法中只进行**事件的注册**,每次调用`then`传入的方法，我们把它保存起来，在`_resolve`中去执行。是一个简单的**发布-订阅**模式。现在我们在`myPromise`中注册一个`thenEventList`,用来保证调用`then`的执行顺序。\n\n&emsp;&emsp;现在在`_resolve`中,我们可以像之前eventLoop的逻辑一样去循环调用`then`注册进来的事件。这里我们使用`setTimeout`来模拟微任务的特性，把`then`注册的回调放到事件队列的最末端去执行。\n\n```javascript\nwindow.myPromise = function (executor) {\n\n    // 保存 then 注册的回调\n    this.thenEventList = [];\n\n    this._resolve = function (value) {\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            this.thenEventList.reduce((accumulator, resolveHandler) => {\n                // 如果已经发生错误,不需要继续执行，直接返回即可\n                if (this._status === 'rejected') return;\n                return resolveHandler(accumulator);\n            }, value);\n            // 全部执行完毕表明状态更改\n            this._status === 'fulfilled'\n        }, 0);\n\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\n\nmyPromise.prototype.then = function (thenCallBack) {\n    this.thenEventList.push(thenCallBack);\n    // 链式调用\n    return this;\n}\n```\n\n## 实现catch和_reject。\n&emsp;&emsp;按照`then`和`_reslove`的实现思路，我们可以很简单的把`catch`和`_reject`写出来。值得一提的是,`catch`不返回`Promise`链,自然也不用像`then`一样去注册一个事件列表,只需要保存一下`errorCallBack`即可。\n\n```javascript\n\nwindow.myPromise = function (executor) {\n\n    this._reject = function (error) {\n        if (this._status === 'fulfilled') return;\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            if (typeof this.errorCallBack === 'function') {\n                this.errorCallBack(error);\n            }\n        }, 0);\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\nmyPromise.prototype.catch = function (errorCallBack) {\n    this.errorCallBack = errorCallBack;\n    this._status = 'rejected';\n}\n\n```\n&emsp;&emsp;`catch`还有一个作用，就是可以抓到`Promise`链中运行的程序错误。所以我们用 `try catch`来抓一下`_resolve`的执行，然后补完`myPromise`。\n\n```javascript\n\nwindow.myPromise = function (executor) {\n\n    this._reject = function (error) {\n        if (this._status === 'fulfilled') return;\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            if (typeof this.errorCallBack === 'function') {\n                this.errorCallBack(error);\n            }\n        }, 0);\n    }\n\n    // 保存 then 注册的回调\n    this.thenEventList = [];\n\n    this._resolve = function (value) {\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            this.thenEventList.reduce((accumulator, resolveHandler) => {\n                if (this._status === 'rejected') return;\n                try {\n                    return resolveHandler(accumulator);\n                } catch (error) {\n                    if (error) {\n                        this._status = 'rejected';\n                        this._reject(error);\n                    }\n                }\n\n            }, value);\n            this._status = 'fulfilled';\n        }, 0);\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\nmyPromise.prototype.then = function (thenCallBack) {\n    this.thenEventList.push(thenCallBack);\n    // 链式调用\n    return this;\n}\n\nmyPromise.prototype.catch = function (errorCallBack) {\n    this.errorCallBack = errorCallBack;\n}\n\n```\n\n# 总结\n&emsp;&emsp;`Promise`产生的意义就是为了解决JS异步回调不可控的问题,它保证了异步回调**执行的顺序**和**执行次数**,完善了异常情况的处理。用**微任务**放置到任务回调末尾的处理方式来解决同步异步代码混用的执行顺序问题,后续精进的使用`Generator函数 + Promise`完成的`async await`语法糖,是社区的终极异步解决方案,其实也就是用同步的方式来处理异步。\n\n&emsp;&emsp;本次简易实现中,我们使用**订阅发布的观察者模式**来处理`than`方法的事件注册,然后在传入的`executor`调用的resolve后去执行。使用数组添加的方式来保证`than`函数注册的执行顺序。使用`setTimeout`略显`hack`的方式,来模拟了**微任务**调度的特性。真实的`Promise`的`prototype`还有诸如`race all`的方法,对应的`reslove`方法也可以展开传入的任意`thanable`结构的对象。但这些方法的实现,都是建立在简易实现的思路根本上,进行一些细节的处理和完善。`Promise`的核心,始终没有变过。","source":"_posts/js/promise.md","raw":"---\ntitle: Promise\ndate: 2019/6/15 16:40\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;这篇文章总结一下JS本身单线程异步的局限性(promise出现的原因)，以及实现一个简易的Promise。\n<!--more-->\n\n# 单线程与异步\n&emsp;&emsp;JavaScript是一个单线程执行的语言，在不考虑异步编程的情况下，它执行的顺序就是一个eventLoop的简单循环。比如书写一段简单的JS代码：\n\n```Javascript\n// 声明两个变量，和一个函数\nvar demoVariA = 100;\nvar demoVariB = 200;\n// 函数的功能是把入参的两个数值相加\nfunction addTowNum (a, b) {\n    return a + b;\n}\naddTowNum(demoVariA, demoVariB);\n```\n\n&emsp;&emsp;那么在不考虑预解析的情况下(变量函数作用域提升)，我们试着把上面这段代码执行顺序用一个eventLoop来简单表示出来。\n\n```Javascript\n// 代码的执行队列\neventLoop = [\n    '赋值100给内存demoVariA',\n    '赋值200给内存demoVariB',\n    '申请堆栈内存声明为addTowNum，赋值为一个函数',\n    '执行函数'\n];\n// 现在JS代码需要分析执行\n// 这里不考虑任何异步的情况，包括宏任务和微任务\nwhile (eventLoop.length > 0) {\n    // 这里表示对词法token进行编译借的过程的抽象\n    var event = eventLoop.shift();\n    try {\n        event();\n    } catch (error) {\n        report(error);\n    }\n}\n```\n&emsp;&emsp;我们可以看到，不需要考虑多线程共享数据时线程执行先后对程序造成的影响，不需要使用进程锁的概念，词法的执行顺序是多么的清晰，单线程编程是多么的令人愉快。直到异步进入到我们的编程世界。\n\n&emsp;&emsp;同样是上面的例子，我们把`demoVariA`,`demoVariB`的数据请求改为异步的请求获取值`asyncGetSomeValue`,事情就完全不一样了。\n\n```Javascript\nvar demoVariA = asyncGetSomeValue('pathA');\nvar demoVariB = asyncGetSomeValue('pathB');\nfunction addTowNum (a, b) {\n    return a + b;\n}\naddTowNum(demoVariA, demoVariB); // undefined  + undefined = NaN\n```\n\n&emsp;&emsp;asyncGetSomeValue必须在某个异步操作之后,再获取到值,因此按照JS的常规做法,我们必须把`demoVariA`,`demoVariB`放到回调当中去获取值，我们把代码修改如下:\n\n```Javascript\nvar demoVariA;\nvar demoVariB;\nasyncGetSomeValue('pathA', function (responseValue) {\n    demoVariA = responseValue;\n});\nasyncGetSomeValue('pathB', function (responseValue) {\n    demoVariB = responseValue;\n});\nfunction addTowNum (a, b) {\n    return a + b;\n}\n```\n\n&emsp;&emsp;现在问题来了`addTowNum`，该放到哪里去执行才能a和b同时获取到呢。有的同学此时会说，简单，我把`demoVariB`获取放到`demoVariA`获取的回调下，再去执行`addTowNum`。\n\n```Javascript\nvar demoVariA;\nvar demoVariB;\nasyncGetSomeValue('pathA', function (responseValue) {\n    demoVariA = responseValue;\n    asyncGetSomeValue('pathB', function (responseValue) {\n        demoVariB = responseValue;\n        addTowNum(demoVariA, demoVariB);\n    });\n});\n\nfunction addTowNum (a, b) {\n    return a + b;\n}\n```\n&emsp;&emsp;实际上,`demoVariB`的请求并没有依赖到`demoVariA`,因此把`demoVariB`的取值请求放到`demoVariA`的后面的做法是错误的，这样会导致`addTowNum`这个函数的调用时间将会变成两个异步请求费时的总和。这两个获取值得请求严格意义上应该是**并发**的概念。我们要做的是需要声明一个为`gate`的函数，当你传入的所有变量**存在**的时候，去执行传入的函数。\n```Javascript\n/**\n * @param {function} gateFunction 所有变量存在后执行的函数\n * @param 剩余变量\n  */\nfunction gate (gateFunction) {\n    var testArray = arguments.slice(1);\n    // 全部变量都存在的时候，才执行gateFunction\n    if (testArray.every(variable => variable)) {\n        gateFunction.apply(this, testArray);\n    }\n}\n```\n&emsp;&emsp;此时加入`gate`函数,我们上面的修改为异步的例子才算简单完成。实际业务编程当中，我们还要考虑asyncGetSomeValue的异常抛错等问题。\n\n```Javascript\nvar demoVariA;\nvar demoVariB;\nasyncGetSomeValue('pathA', function (responseValue) {\n    demoVariA = responseValue;\n    gate(addTowNum, a, b);\n});\nasyncGetSomeValue('pathB', function (responseValue) {\n    demoVariB = responseValue;\n    gate(addTowNum, a, b);\n});\nfunction addTowNum (a, b) {\n    return a + b;\n}\n```\n&emsp;&emsp;通过这个简单的例子我们不难发现异步编程的问题：\n1. 多异步返回的执行顺序不可控。\n2. 多异步的异常错误处理非常繁杂。\n3. 多异步嵌套，会导致回调地狱。\n\n&emsp;&emsp;我们急需要一个能够保证异步执行顺序，保证执行和抛出错误的异步处理的**保证**范式来解决这些问题。ES6给我们的答案就是Promise(承诺)。\n\n# Promise的特性\n\n## 都是将来\n&emsp;&emsp;Promise的使用方法不做阐述，想要了解的可以去查询一下[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)。\n\n&emsp;&emsp;Promise的回调than有一个非常重要的特性，那就是无论是**现在**还是**将来**,统一都是**将来**。我们来猜一下下面代码的执行顺序:\n\n```javascript\nvar promise = new Promise(function (resolve, reject) {\n    console.log(1);\n    setTimeout(() => {\n        console.log(2);\n    }, 0)\n    resolve(3);\n});\npromise.then(val => console.log(val));\nconsole.log(4);\n```\n&emsp;&emsp;简单分析一下执行顺序,代码解析按照从上到下进行解析运行。在`new Promise`的过程中，里面的代码会被执行。因此执行`console.log(1)`输出1。然后执行到`setTimeout`,JS按照**宏任务**的逻辑把setTimeout放到本次事件循环结束的**最末端之后**。然后注册`resolve`。\n\n&emsp;&emsp;`new Promise`执行完毕，返回`Promise`的实例对象给变量`promise`。`promise`执行`then`方法。`Promise`的`then`方法是一个**微任务**，不管里面的代码是什么内容，这段代码都会被放到当前事件队列的**最末尾**。\n\n&emsp;&emsp;代码现在跑到`console.log(4)`,正常输出。执行完毕后，到达事件循环的末端，此时执行**微任务**,`promise`的`then`回调执行。本次事件循环结束。事件循环结束后执行**宏任务**的`setTimeout`。\n\n## 其他特性\n&emsp;&emsp;`Promise`本身具有`pending fulfilled rejected`三个状态，它们之间是互相不可逆的。\n&emsp;&emsp;其次，`Promise`通过多次调用 .then()，可以添加多个回调函数，它们会按照插入顺序并且独立运行。`new Promise`的内容只会被执行**一次**。\n\n# 开写Promise\n\n## 搭建框架\n&emsp;&emsp;我们先简单搭建一下需要实现的`myPromise`的大体框架。然后根据`Promise`的特性来实现。首先,`Promise`通过`new`去执行,是一个构造函数的特征。它接受一个函数作为参数，该函数接受`resolve`和`reject`，并且在`new`的时候就被执行。\n\n&emsp;&emsp;其次我们需要有一个`_status`来复现`Promise`的三个状态。\n\n&emsp;&emsp;接着我们实现一下`then catch`方法，这些构造函数也能使用的方法,我们定义在`prototype`上面。\n\n&emsp;&emsp;现在我们能根据这些需求搭建出来`myPromise`的框架。\n\n```javascript\nwindow.myPromise = function (executor) {\n\n    this._resolve = function (value) {\n\n    }\n\n    this._reject = function (error) {\n\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n    // 使用bind来绑定作用域，保证可以访问到实例上面的属性\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\nmyPromise.prototype.then = function (thenCallBack) {\n\n}\n\nmyPromise.prototype.catch = function (errorCallBack) {\n    \n}\n\n```\n\n## 实现then和_reslove。\n\n&emsp;&emsp;我们需要思考一个**核心点**,那就是`then`中的回调，如果保证构造函数存在异步逻辑时，在`reslove`之后去执行。其实很简单，就是在`then`当中传入的回调`thenCallBack`在`then`中不执行，而在`_resolve`当中执行就可以了。\n\n&emsp;&emsp;简单来说,在`then`方法中只进行**事件的注册**,每次调用`then`传入的方法，我们把它保存起来，在`_resolve`中去执行。是一个简单的**发布-订阅**模式。现在我们在`myPromise`中注册一个`thenEventList`,用来保证调用`then`的执行顺序。\n\n&emsp;&emsp;现在在`_resolve`中,我们可以像之前eventLoop的逻辑一样去循环调用`then`注册进来的事件。这里我们使用`setTimeout`来模拟微任务的特性，把`then`注册的回调放到事件队列的最末端去执行。\n\n```javascript\nwindow.myPromise = function (executor) {\n\n    // 保存 then 注册的回调\n    this.thenEventList = [];\n\n    this._resolve = function (value) {\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            this.thenEventList.reduce((accumulator, resolveHandler) => {\n                // 如果已经发生错误,不需要继续执行，直接返回即可\n                if (this._status === 'rejected') return;\n                return resolveHandler(accumulator);\n            }, value);\n            // 全部执行完毕表明状态更改\n            this._status === 'fulfilled'\n        }, 0);\n\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\n\nmyPromise.prototype.then = function (thenCallBack) {\n    this.thenEventList.push(thenCallBack);\n    // 链式调用\n    return this;\n}\n```\n\n## 实现catch和_reject。\n&emsp;&emsp;按照`then`和`_reslove`的实现思路，我们可以很简单的把`catch`和`_reject`写出来。值得一提的是,`catch`不返回`Promise`链,自然也不用像`then`一样去注册一个事件列表,只需要保存一下`errorCallBack`即可。\n\n```javascript\n\nwindow.myPromise = function (executor) {\n\n    this._reject = function (error) {\n        if (this._status === 'fulfilled') return;\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            if (typeof this.errorCallBack === 'function') {\n                this.errorCallBack(error);\n            }\n        }, 0);\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\nmyPromise.prototype.catch = function (errorCallBack) {\n    this.errorCallBack = errorCallBack;\n    this._status = 'rejected';\n}\n\n```\n&emsp;&emsp;`catch`还有一个作用，就是可以抓到`Promise`链中运行的程序错误。所以我们用 `try catch`来抓一下`_resolve`的执行，然后补完`myPromise`。\n\n```javascript\n\nwindow.myPromise = function (executor) {\n\n    this._reject = function (error) {\n        if (this._status === 'fulfilled') return;\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            if (typeof this.errorCallBack === 'function') {\n                this.errorCallBack(error);\n            }\n        }, 0);\n    }\n\n    // 保存 then 注册的回调\n    this.thenEventList = [];\n\n    this._resolve = function (value) {\n        // 用箭头函数确定this值\n        setTimeout(() => {\n            this.thenEventList.reduce((accumulator, resolveHandler) => {\n                if (this._status === 'rejected') return;\n                try {\n                    return resolveHandler(accumulator);\n                } catch (error) {\n                    if (error) {\n                        this._status = 'rejected';\n                        this._reject(error);\n                    }\n                }\n\n            }, value);\n            this._status = 'fulfilled';\n        }, 0);\n    }\n\n    // pending fulfilled rejected\n    this._status = 'pending';\n\n    executor(this._resolve.bind(this), this._reject.bind(this));\n}\n\nmyPromise.prototype.then = function (thenCallBack) {\n    this.thenEventList.push(thenCallBack);\n    // 链式调用\n    return this;\n}\n\nmyPromise.prototype.catch = function (errorCallBack) {\n    this.errorCallBack = errorCallBack;\n}\n\n```\n\n# 总结\n&emsp;&emsp;`Promise`产生的意义就是为了解决JS异步回调不可控的问题,它保证了异步回调**执行的顺序**和**执行次数**,完善了异常情况的处理。用**微任务**放置到任务回调末尾的处理方式来解决同步异步代码混用的执行顺序问题,后续精进的使用`Generator函数 + Promise`完成的`async await`语法糖,是社区的终极异步解决方案,其实也就是用同步的方式来处理异步。\n\n&emsp;&emsp;本次简易实现中,我们使用**订阅发布的观察者模式**来处理`than`方法的事件注册,然后在传入的`executor`调用的resolve后去执行。使用数组添加的方式来保证`than`函数注册的执行顺序。使用`setTimeout`略显`hack`的方式,来模拟了**微任务**调度的特性。真实的`Promise`的`prototype`还有诸如`race all`的方法,对应的`reslove`方法也可以展开传入的任意`thanable`结构的对象。但这些方法的实现,都是建立在简易实现的思路根本上,进行一些细节的处理和完善。`Promise`的核心,始终没有变过。","slug":"js/promise","published":1,"updated":"2020-06-11T01:43:32.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxh000h9r2vj426si9k","content":"<p>&emsp;&emsp;这篇文章总结一下JS本身单线程异步的局限性(promise出现的原因)，以及实现一个简易的Promise。<br><a id=\"more\"></a></p>\n<h1 id=\"单线程与异步\"><a href=\"#单线程与异步\" class=\"headerlink\" title=\"单线程与异步\"></a>单线程与异步</h1><p>&emsp;&emsp;JavaScript是一个单线程执行的语言，在不考虑异步编程的情况下，它执行的顺序就是一个eventLoop的简单循环。比如书写一段简单的JS代码：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 声明两个变量，和一个函数</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariA = <span class=\"hljs-number\">100</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariB = <span class=\"hljs-number\">200</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 函数的功能是把入参的两个数值相加</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addTowNum</span> (<span class=\"hljs-params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addTowNum(demoVariA, demoVariB);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;那么在不考虑预解析的情况下(变量函数作用域提升)，我们试着把上面这段代码执行顺序用一个eventLoop来简单表示出来。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 代码的执行队列</span></span><br><span class=\"line\">eventLoop = [</span><br><span class=\"line\">    <span class=\"hljs-string\">'赋值100给内存demoVariA'</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">'赋值200给内存demoVariB'</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">'申请堆栈内存声明为addTowNum，赋值为一个函数'</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">'执行函数'</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"hljs-comment\">// 现在JS代码需要分析执行</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 这里不考虑任何异步的情况，包括宏任务和微任务</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">while</span> (eventLoop.length &gt; <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 这里表示对词法token进行编译借的过程的抽象</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> event = eventLoop.shift();</span><br><span class=\"line\">    <span class=\"hljs-keyword\">try</span> &#123;</span><br><span class=\"line\">        event();</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        report(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，不需要考虑多线程共享数据时线程执行先后对程序造成的影响，不需要使用进程锁的概念，词法的执行顺序是多么的清晰，单线程编程是多么的令人愉快。直到异步进入到我们的编程世界。</p>\n<p>&emsp;&emsp;同样是上面的例子，我们把<code>demoVariA</code>,<code>demoVariB</code>的数据请求改为异步的请求获取值<code>asyncGetSomeValue</code>,事情就完全不一样了。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariA = asyncGetSomeValue(<span class=\"hljs-string\">'pathA'</span>);</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariB = asyncGetSomeValue(<span class=\"hljs-string\">'pathB'</span>);</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addTowNum</span> (<span class=\"hljs-params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addTowNum(demoVariA, demoVariB); <span class=\"hljs-comment\">// undefined  + undefined = NaN</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;asyncGetSomeValue必须在某个异步操作之后,再获取到值,因此按照JS的常规做法,我们必须把<code>demoVariA</code>,<code>demoVariB</code>放到回调当中去获取值，我们把代码修改如下:</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariA;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariB;</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"hljs-string\">'pathA'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariA = responseValue;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"hljs-string\">'pathB'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariB = responseValue;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addTowNum</span> (<span class=\"hljs-params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在问题来了<code>addTowNum</code>，该放到哪里去执行才能a和b同时获取到呢。有的同学此时会说，简单，我把<code>demoVariB</code>获取放到<code>demoVariA</code>获取的回调下，再去执行<code>addTowNum</code>。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariA;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariB;</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"hljs-string\">'pathA'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariA = responseValue;</span><br><span class=\"line\">    asyncGetSomeValue(<span class=\"hljs-string\">'pathB'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">        demoVariB = responseValue;</span><br><span class=\"line\">        addTowNum(demoVariA, demoVariB);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addTowNum</span> (<span class=\"hljs-params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;实际上,<code>demoVariB</code>的请求并没有依赖到<code>demoVariA</code>,因此把<code>demoVariB</code>的取值请求放到<code>demoVariA</code>的后面的做法是错误的，这样会导致<code>addTowNum</code>这个函数的调用时间将会变成两个异步请求费时的总和。这两个获取值得请求严格意义上应该是<strong>并发</strong>的概念。我们要做的是需要声明一个为<code>gate</code>的函数，当你传入的所有变量<strong>存在</strong>的时候，去执行传入的函数。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;function&#125;</span> </span>gateFunction 所有变量存在后执行的函数</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param </span>剩余变量</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">gate</span> (<span class=\"hljs-params\">gateFunction</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> testArray = <span class=\"hljs-built_in\">arguments</span>.slice(<span class=\"hljs-number\">1</span>);</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 全部变量都存在的时候，才执行gateFunction</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (testArray.every(<span class=\"hljs-function\"><span class=\"hljs-params\">variable</span> =&gt;</span> variable)) &#123;</span><br><span class=\"line\">        gateFunction.apply(<span class=\"hljs-keyword\">this</span>, testArray);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时加入<code>gate</code>函数,我们上面的修改为异步的例子才算简单完成。实际业务编程当中，我们还要考虑asyncGetSomeValue的异常抛错等问题。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariA;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> demoVariB;</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"hljs-string\">'pathA'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariA = responseValue;</span><br><span class=\"line\">    gate(addTowNum, a, b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"hljs-string\">'pathB'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariB = responseValue;</span><br><span class=\"line\">    gate(addTowNum, a, b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addTowNum</span> (<span class=\"hljs-params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;通过这个简单的例子我们不难发现异步编程的问题：</p>\n<ol>\n<li>多异步返回的执行顺序不可控。</li>\n<li>多异步的异常错误处理非常繁杂。</li>\n<li>多异步嵌套，会导致回调地狱。</li>\n</ol>\n<p>&emsp;&emsp;我们急需要一个能够保证异步执行顺序，保证执行和抛出错误的异步处理的<strong>保证</strong>范式来解决这些问题。ES6给我们的答案就是Promise(承诺)。</p>\n<h1 id=\"Promise的特性\"><a href=\"#Promise的特性\" class=\"headerlink\" title=\"Promise的特性\"></a>Promise的特性</h1><h2 id=\"都是将来\"><a href=\"#都是将来\" class=\"headerlink\" title=\"都是将来\"></a>都是将来</h2><p>&emsp;&emsp;Promise的使用方法不做阐述，想要了解的可以去查询一下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises\" target=\"_blank\" rel=\"noopener\">MDN</a>。</p>\n<p>&emsp;&emsp;Promise的回调than有一个非常重要的特性，那就是无论是<strong>现在</strong>还是<strong>将来</strong>,统一都是<strong>将来</strong>。我们来猜一下下面代码的执行顺序:</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>);</span><br><span class=\"line\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);</span><br><span class=\"line\">    &#125;, <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">    resolve(<span class=\"hljs-number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(val));</span><br><span class=\"line\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;简单分析一下执行顺序,代码解析按照从上到下进行解析运行。在<code>new Promise</code>的过程中，里面的代码会被执行。因此执行<code>console.log(1)</code>输出1。然后执行到<code>setTimeout</code>,JS按照<strong>宏任务</strong>的逻辑把setTimeout放到本次事件循环结束的<strong>最末端之后</strong>。然后注册<code>resolve</code>。</p>\n<p>&emsp;&emsp;<code>new Promise</code>执行完毕，返回<code>Promise</code>的实例对象给变量<code>promise</code>。<code>promise</code>执行<code>then</code>方法。<code>Promise</code>的<code>then</code>方法是一个<strong>微任务</strong>，不管里面的代码是什么内容，这段代码都会被放到当前事件队列的<strong>最末尾</strong>。</p>\n<p>&emsp;&emsp;代码现在跑到<code>console.log(4)</code>,正常输出。执行完毕后，到达事件循环的末端，此时执行<strong>微任务</strong>,<code>promise</code>的<code>then</code>回调执行。本次事件循环结束。事件循环结束后执行<strong>宏任务</strong>的<code>setTimeout</code>。</p>\n<h2 id=\"其他特性\"><a href=\"#其他特性\" class=\"headerlink\" title=\"其他特性\"></a>其他特性</h2><p>&emsp;&emsp;<code>Promise</code>本身具有<code>pending fulfilled rejected</code>三个状态，它们之间是互相不可逆的。<br>&emsp;&emsp;其次，<code>Promise</code>通过多次调用 .then()，可以添加多个回调函数，它们会按照插入顺序并且独立运行。<code>new Promise</code>的内容只会被执行<strong>一次</strong>。</p>\n<h1 id=\"开写Promise\"><a href=\"#开写Promise\" class=\"headerlink\" title=\"开写Promise\"></a>开写Promise</h1><h2 id=\"搭建框架\"><a href=\"#搭建框架\" class=\"headerlink\" title=\"搭建框架\"></a>搭建框架</h2><p>&emsp;&emsp;我们先简单搭建一下需要实现的<code>myPromise</code>的大体框架。然后根据<code>Promise</code>的特性来实现。首先,<code>Promise</code>通过<code>new</code>去执行,是一个构造函数的特征。它接受一个函数作为参数，该函数接受<code>resolve</code>和<code>reject</code>，并且在<code>new</code>的时候就被执行。</p>\n<p>&emsp;&emsp;其次我们需要有一个<code>_status</code>来复现<code>Promise</code>的三个状态。</p>\n<p>&emsp;&emsp;接着我们实现一下<code>then catch</code>方法，这些构造函数也能使用的方法,我们定义在<code>prototype</code>上面。</p>\n<p>&emsp;&emsp;现在我们能根据这些需求搭建出来<code>myPromise</code>的框架。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">window</span>.myPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._resolve = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._reject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'pending'</span>;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 使用bind来绑定作用域，保证可以访问到实例上面的属性</span></span><br><span class=\"line\">    executor(<span class=\"hljs-keyword\">this</span>._resolve.bind(<span class=\"hljs-keyword\">this</span>), <span class=\"hljs-keyword\">this</span>._reject.bind(<span class=\"hljs-keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thenCallBack</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.catch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">errorCallBack</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现then和-reslove。\"><a href=\"#实现then和-reslove。\" class=\"headerlink\" title=\"实现then和_reslove。\"></a>实现then和_reslove。</h2><p>&emsp;&emsp;我们需要思考一个<strong>核心点</strong>,那就是<code>then</code>中的回调，如果保证构造函数存在异步逻辑时，在<code>reslove</code>之后去执行。其实很简单，就是在<code>then</code>当中传入的回调<code>thenCallBack</code>在<code>then</code>中不执行，而在<code>_resolve</code>当中执行就可以了。</p>\n<p>&emsp;&emsp;简单来说,在<code>then</code>方法中只进行<strong>事件的注册</strong>,每次调用<code>then</code>传入的方法，我们把它保存起来，在<code>_resolve</code>中去执行。是一个简单的<strong>发布-订阅</strong>模式。现在我们在<code>myPromise</code>中注册一个<code>thenEventList</code>,用来保证调用<code>then</code>的执行顺序。</p>\n<p>&emsp;&emsp;现在在<code>_resolve</code>中,我们可以像之前eventLoop的逻辑一样去循环调用<code>then</code>注册进来的事件。这里我们使用<code>setTimeout</code>来模拟微任务的特性，把<code>then</code>注册的回调放到事件队列的最末端去执行。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">window</span>.myPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// 保存 then 注册的回调</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.thenEventList = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._resolve = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">this</span>.thenEventList.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator, resolveHandler</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"hljs-comment\">// 如果已经发生错误,不需要继续执行，直接返回即可</span></span><br><span class=\"line\">                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status === <span class=\"hljs-string\">'rejected'</span>) <span class=\"hljs-keyword\">return</span>;</span><br><span class=\"line\">                <span class=\"hljs-keyword\">return</span> resolveHandler(accumulator);</span><br><span class=\"line\">            &#125;, value);</span><br><span class=\"line\">            <span class=\"hljs-comment\">// 全部执行完毕表明状态更改</span></span><br><span class=\"line\">            <span class=\"hljs-keyword\">this</span>._status === <span class=\"hljs-string\">'fulfilled'</span></span><br><span class=\"line\">        &#125;, <span class=\"hljs-number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    executor(<span class=\"hljs-keyword\">this</span>._resolve.bind(<span class=\"hljs-keyword\">this</span>), <span class=\"hljs-keyword\">this</span>._reject.bind(<span class=\"hljs-keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thenCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.thenEventList.push(thenCallBack);</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 链式调用</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现catch和-reject。\"><a href=\"#实现catch和-reject。\" class=\"headerlink\" title=\"实现catch和_reject。\"></a>实现catch和_reject。</h2><p>&emsp;&emsp;按照<code>then</code>和<code>_reslove</code>的实现思路，我们可以很简单的把<code>catch</code>和<code>_reject</code>写出来。值得一提的是,<code>catch</code>不返回<code>Promise</code>链,自然也不用像<code>then</code>一样去注册一个事件列表,只需要保存一下<code>errorCallBack</code>即可。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-built_in\">window</span>.myPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._reject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status === <span class=\"hljs-string\">'fulfilled'</span>) <span class=\"hljs-keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span>.errorCallBack === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"hljs-keyword\">this</span>.errorCallBack(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    executor(<span class=\"hljs-keyword\">this</span>._resolve.bind(<span class=\"hljs-keyword\">this</span>), <span class=\"hljs-keyword\">this</span>._reject.bind(<span class=\"hljs-keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.catch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">errorCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.errorCallBack = errorCallBack;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'rejected'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>catch</code>还有一个作用，就是可以抓到<code>Promise</code>链中运行的程序错误。所以我们用 <code>try catch</code>来抓一下<code>_resolve</code>的执行，然后补完<code>myPromise</code>。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-built_in\">window</span>.myPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._reject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status === <span class=\"hljs-string\">'fulfilled'</span>) <span class=\"hljs-keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">this</span>.errorCallBack === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"hljs-keyword\">this</span>.errorCallBack(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// 保存 then 注册的回调</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.thenEventList = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._resolve = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">this</span>.thenEventList.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">accumulator, resolveHandler</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>._status === <span class=\"hljs-string\">'rejected'</span>) <span class=\"hljs-keyword\">return</span>;</span><br><span class=\"line\">                <span class=\"hljs-keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"hljs-keyword\">return</span> resolveHandler(accumulator);</span><br><span class=\"line\">                &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">                    <span class=\"hljs-keyword\">if</span> (error) &#123;</span><br><span class=\"line\">                        <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'rejected'</span>;</span><br><span class=\"line\">                        <span class=\"hljs-keyword\">this</span>._reject(error);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;, value);</span><br><span class=\"line\">            <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'fulfilled'</span>;</span><br><span class=\"line\">        &#125;, <span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>._status = <span class=\"hljs-string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    executor(<span class=\"hljs-keyword\">this</span>._resolve.bind(<span class=\"hljs-keyword\">this</span>), <span class=\"hljs-keyword\">this</span>._reject.bind(<span class=\"hljs-keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thenCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.thenEventList.push(thenCallBack);</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 链式调用</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.catch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">errorCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.errorCallBack = errorCallBack;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>&emsp;&emsp;<code>Promise</code>产生的意义就是为了解决JS异步回调不可控的问题,它保证了异步回调<strong>执行的顺序</strong>和<strong>执行次数</strong>,完善了异常情况的处理。用<strong>微任务</strong>放置到任务回调末尾的处理方式来解决同步异步代码混用的执行顺序问题,后续精进的使用<code>Generator函数 + Promise</code>完成的<code>async await</code>语法糖,是社区的终极异步解决方案,其实也就是用同步的方式来处理异步。</p>\n<p>&emsp;&emsp;本次简易实现中,我们使用<strong>订阅发布的观察者模式</strong>来处理<code>than</code>方法的事件注册,然后在传入的<code>executor</code>调用的resolve后去执行。使用数组添加的方式来保证<code>than</code>函数注册的执行顺序。使用<code>setTimeout</code>略显<code>hack</code>的方式,来模拟了<strong>微任务</strong>调度的特性。真实的<code>Promise</code>的<code>prototype</code>还有诸如<code>race all</code>的方法,对应的<code>reslove</code>方法也可以展开传入的任意<code>thanable</code>结构的对象。但这些方法的实现,都是建立在简易实现的思路根本上,进行一些细节的处理和完善。<code>Promise</code>的核心,始终没有变过。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;这篇文章总结一下JS本身单线程异步的局限性(promise出现的原因)，以及实现一个简易的Promise。<br></p>","more":"</p>\n<h1 id=\"单线程与异步\"><a href=\"#单线程与异步\" class=\"headerlink\" title=\"单线程与异步\"></a>单线程与异步</h1><p>&emsp;&emsp;JavaScript是一个单线程执行的语言，在不考虑异步编程的情况下，它执行的顺序就是一个eventLoop的简单循环。比如书写一段简单的JS代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明两个变量，和一个函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> demoVariA = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> demoVariB = <span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"comment\">// 函数的功能是把入参的两个数值相加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTowNum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addTowNum(demoVariA, demoVariB);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;那么在不考虑预解析的情况下(变量函数作用域提升)，我们试着把上面这段代码执行顺序用一个eventLoop来简单表示出来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码的执行队列</span></span><br><span class=\"line\">eventLoop = [</span><br><span class=\"line\">    <span class=\"string\">'赋值100给内存demoVariA'</span>,</span><br><span class=\"line\">    <span class=\"string\">'赋值200给内存demoVariB'</span>,</span><br><span class=\"line\">    <span class=\"string\">'申请堆栈内存声明为addTowNum，赋值为一个函数'</span>,</span><br><span class=\"line\">    <span class=\"string\">'执行函数'</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"comment\">// 现在JS代码需要分析执行</span></span><br><span class=\"line\"><span class=\"comment\">// 这里不考虑任何异步的情况，包括宏任务和微任务</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (eventLoop.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里表示对词法token进行编译借的过程的抽象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> event = eventLoop.shift();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        event();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        report(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，不需要考虑多线程共享数据时线程执行先后对程序造成的影响，不需要使用进程锁的概念，词法的执行顺序是多么的清晰，单线程编程是多么的令人愉快。直到异步进入到我们的编程世界。</p>\n<p>&emsp;&emsp;同样是上面的例子，我们把<code>demoVariA</code>,<code>demoVariB</code>的数据请求改为异步的请求获取值<code>asyncGetSomeValue</code>,事情就完全不一样了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> demoVariA = asyncGetSomeValue(<span class=\"string\">'pathA'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> demoVariB = asyncGetSomeValue(<span class=\"string\">'pathB'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTowNum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addTowNum(demoVariA, demoVariB); <span class=\"comment\">// undefined  + undefined = NaN</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;asyncGetSomeValue必须在某个异步操作之后,再获取到值,因此按照JS的常规做法,我们必须把<code>demoVariA</code>,<code>demoVariB</code>放到回调当中去获取值，我们把代码修改如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> demoVariA;</span><br><span class=\"line\"><span class=\"keyword\">var</span> demoVariB;</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"string\">'pathA'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariA = responseValue;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"string\">'pathB'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariB = responseValue;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTowNum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在问题来了<code>addTowNum</code>，该放到哪里去执行才能a和b同时获取到呢。有的同学此时会说，简单，我把<code>demoVariB</code>获取放到<code>demoVariA</code>获取的回调下，再去执行<code>addTowNum</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> demoVariA;</span><br><span class=\"line\"><span class=\"keyword\">var</span> demoVariB;</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"string\">'pathA'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariA = responseValue;</span><br><span class=\"line\">    asyncGetSomeValue(<span class=\"string\">'pathB'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">        demoVariB = responseValue;</span><br><span class=\"line\">        addTowNum(demoVariA, demoVariB);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTowNum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;实际上,<code>demoVariB</code>的请求并没有依赖到<code>demoVariA</code>,因此把<code>demoVariB</code>的取值请求放到<code>demoVariA</code>的后面的做法是错误的，这样会导致<code>addTowNum</code>这个函数的调用时间将会变成两个异步请求费时的总和。这两个获取值得请求严格意义上应该是<strong>并发</strong>的概念。我们要做的是需要声明一个为<code>gate</code>的函数，当你传入的所有变量<strong>存在</strong>的时候，去执行传入的函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;function&#125;</span> </span>gateFunction 所有变量存在后执行的函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>剩余变量</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gate</span> (<span class=\"params\">gateFunction</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> testArray = <span class=\"built_in\">arguments</span>.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 全部变量都存在的时候，才执行gateFunction</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (testArray.every(<span class=\"function\"><span class=\"params\">variable</span> =&gt;</span> variable)) &#123;</span><br><span class=\"line\">        gateFunction.apply(<span class=\"keyword\">this</span>, testArray);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时加入<code>gate</code>函数,我们上面的修改为异步的例子才算简单完成。实际业务编程当中，我们还要考虑asyncGetSomeValue的异常抛错等问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> demoVariA;</span><br><span class=\"line\"><span class=\"keyword\">var</span> demoVariB;</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"string\">'pathA'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariA = responseValue;</span><br><span class=\"line\">    gate(addTowNum, a, b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">asyncGetSomeValue(<span class=\"string\">'pathB'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">responseValue</span>) </span>&#123;</span><br><span class=\"line\">    demoVariB = responseValue;</span><br><span class=\"line\">    gate(addTowNum, a, b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTowNum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;通过这个简单的例子我们不难发现异步编程的问题：</p>\n<ol>\n<li>多异步返回的执行顺序不可控。</li>\n<li>多异步的异常错误处理非常繁杂。</li>\n<li>多异步嵌套，会导致回调地狱。</li>\n</ol>\n<p>&emsp;&emsp;我们急需要一个能够保证异步执行顺序，保证执行和抛出错误的异步处理的<strong>保证</strong>范式来解决这些问题。ES6给我们的答案就是Promise(承诺)。</p>\n<h1 id=\"Promise的特性\"><a href=\"#Promise的特性\" class=\"headerlink\" title=\"Promise的特性\"></a>Promise的特性</h1><h2 id=\"都是将来\"><a href=\"#都是将来\" class=\"headerlink\" title=\"都是将来\"></a>都是将来</h2><p>&emsp;&emsp;Promise的使用方法不做阐述，想要了解的可以去查询一下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises\" target=\"_blank\" rel=\"noopener\">MDN</a>。</p>\n<p>&emsp;&emsp;Promise的回调than有一个非常重要的特性，那就是无论是<strong>现在</strong>还是<strong>将来</strong>,统一都是<strong>将来</strong>。我们来猜一下下面代码的执行顺序:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> <span class=\"built_in\">console</span>.log(val));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;简单分析一下执行顺序,代码解析按照从上到下进行解析运行。在<code>new Promise</code>的过程中，里面的代码会被执行。因此执行<code>console.log(1)</code>输出1。然后执行到<code>setTimeout</code>,JS按照<strong>宏任务</strong>的逻辑把setTimeout放到本次事件循环结束的<strong>最末端之后</strong>。然后注册<code>resolve</code>。</p>\n<p>&emsp;&emsp;<code>new Promise</code>执行完毕，返回<code>Promise</code>的实例对象给变量<code>promise</code>。<code>promise</code>执行<code>then</code>方法。<code>Promise</code>的<code>then</code>方法是一个<strong>微任务</strong>，不管里面的代码是什么内容，这段代码都会被放到当前事件队列的<strong>最末尾</strong>。</p>\n<p>&emsp;&emsp;代码现在跑到<code>console.log(4)</code>,正常输出。执行完毕后，到达事件循环的末端，此时执行<strong>微任务</strong>,<code>promise</code>的<code>then</code>回调执行。本次事件循环结束。事件循环结束后执行<strong>宏任务</strong>的<code>setTimeout</code>。</p>\n<h2 id=\"其他特性\"><a href=\"#其他特性\" class=\"headerlink\" title=\"其他特性\"></a>其他特性</h2><p>&emsp;&emsp;<code>Promise</code>本身具有<code>pending fulfilled rejected</code>三个状态，它们之间是互相不可逆的。<br>&emsp;&emsp;其次，<code>Promise</code>通过多次调用 .then()，可以添加多个回调函数，它们会按照插入顺序并且独立运行。<code>new Promise</code>的内容只会被执行<strong>一次</strong>。</p>\n<h1 id=\"开写Promise\"><a href=\"#开写Promise\" class=\"headerlink\" title=\"开写Promise\"></a>开写Promise</h1><h2 id=\"搭建框架\"><a href=\"#搭建框架\" class=\"headerlink\" title=\"搭建框架\"></a>搭建框架</h2><p>&emsp;&emsp;我们先简单搭建一下需要实现的<code>myPromise</code>的大体框架。然后根据<code>Promise</code>的特性来实现。首先,<code>Promise</code>通过<code>new</code>去执行,是一个构造函数的特征。它接受一个函数作为参数，该函数接受<code>resolve</code>和<code>reject</code>，并且在<code>new</code>的时候就被执行。</p>\n<p>&emsp;&emsp;其次我们需要有一个<code>_status</code>来复现<code>Promise</code>的三个状态。</p>\n<p>&emsp;&emsp;接着我们实现一下<code>then catch</code>方法，这些构造函数也能使用的方法,我们定义在<code>prototype</code>上面。</p>\n<p>&emsp;&emsp;现在我们能根据这些需求搭建出来<code>myPromise</code>的框架。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.myPromise = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 使用bind来绑定作用域，保证可以访问到实例上面的属性</span></span><br><span class=\"line\">    executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thenCallBack</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">errorCallBack</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现then和-reslove。\"><a href=\"#实现then和-reslove。\" class=\"headerlink\" title=\"实现then和_reslove。\"></a>实现then和_reslove。</h2><p>&emsp;&emsp;我们需要思考一个<strong>核心点</strong>,那就是<code>then</code>中的回调，如果保证构造函数存在异步逻辑时，在<code>reslove</code>之后去执行。其实很简单，就是在<code>then</code>当中传入的回调<code>thenCallBack</code>在<code>then</code>中不执行，而在<code>_resolve</code>当中执行就可以了。</p>\n<p>&emsp;&emsp;简单来说,在<code>then</code>方法中只进行<strong>事件的注册</strong>,每次调用<code>then</code>传入的方法，我们把它保存起来，在<code>_resolve</code>中去执行。是一个简单的<strong>发布-订阅</strong>模式。现在我们在<code>myPromise</code>中注册一个<code>thenEventList</code>,用来保证调用<code>then</code>的执行顺序。</p>\n<p>&emsp;&emsp;现在在<code>_resolve</code>中,我们可以像之前eventLoop的逻辑一样去循环调用<code>then</code>注册进来的事件。这里我们使用<code>setTimeout</code>来模拟微任务的特性，把<code>then</code>注册的回调放到事件队列的最末端去执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.myPromise = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存 then 注册的回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thenEventList = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.thenEventList.reduce(<span class=\"function\">(<span class=\"params\">accumulator, resolveHandler</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果已经发生错误,不需要继续执行，直接返回即可</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status === <span class=\"string\">'rejected'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> resolveHandler(accumulator);</span><br><span class=\"line\">            &#125;, value);</span><br><span class=\"line\">            <span class=\"comment\">// 全部执行完毕表明状态更改</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>._status === <span class=\"string\">'fulfilled'</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thenCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thenEventList.push(thenCallBack);</span><br><span class=\"line\">    <span class=\"comment\">// 链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现catch和-reject。\"><a href=\"#实现catch和-reject。\" class=\"headerlink\" title=\"实现catch和_reject。\"></a>实现catch和_reject。</h2><p>&emsp;&emsp;按照<code>then</code>和<code>_reslove</code>的实现思路，我们可以很简单的把<code>catch</code>和<code>_reject</code>写出来。值得一提的是,<code>catch</code>不返回<code>Promise</code>链,自然也不用像<code>then</code>一样去注册一个事件列表,只需要保存一下<code>errorCallBack</code>即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.myPromise = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status === <span class=\"string\">'fulfilled'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>.errorCallBack === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.errorCallBack(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">errorCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.errorCallBack = errorCallBack;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>catch</code>还有一个作用，就是可以抓到<code>Promise</code>链中运行的程序错误。所以我们用 <code>try catch</code>来抓一下<code>_resolve</code>的执行，然后补完<code>myPromise</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.myPromise = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">executor</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status === <span class=\"string\">'fulfilled'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>.errorCallBack === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.errorCallBack(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存 then 注册的回调</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thenEventList = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用箭头函数确定this值</span></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.thenEventList.reduce(<span class=\"function\">(<span class=\"params\">accumulator, resolveHandler</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status === <span class=\"string\">'rejected'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> resolveHandler(accumulator);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>._status = <span class=\"string\">'rejected'</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">this</span>._reject(error);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;, value);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._status = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pending fulfilled rejected</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._status = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    executor(<span class=\"keyword\">this</span>._resolve.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._reject.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thenCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thenEventList.push(thenCallBack);</span><br><span class=\"line\">    <span class=\"comment\">// 链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">errorCallBack</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.errorCallBack = errorCallBack;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>&emsp;&emsp;<code>Promise</code>产生的意义就是为了解决JS异步回调不可控的问题,它保证了异步回调<strong>执行的顺序</strong>和<strong>执行次数</strong>,完善了异常情况的处理。用<strong>微任务</strong>放置到任务回调末尾的处理方式来解决同步异步代码混用的执行顺序问题,后续精进的使用<code>Generator函数 + Promise</code>完成的<code>async await</code>语法糖,是社区的终极异步解决方案,其实也就是用同步的方式来处理异步。</p>\n<p>&emsp;&emsp;本次简易实现中,我们使用<strong>订阅发布的观察者模式</strong>来处理<code>than</code>方法的事件注册,然后在传入的<code>executor</code>调用的resolve后去执行。使用数组添加的方式来保证<code>than</code>函数注册的执行顺序。使用<code>setTimeout</code>略显<code>hack</code>的方式,来模拟了<strong>微任务</strong>调度的特性。真实的<code>Promise</code>的<code>prototype</code>还有诸如<code>race all</code>的方法,对应的<code>reslove</code>方法也可以展开传入的任意<code>thanable</code>结构的对象。但这些方法的实现,都是建立在简易实现的思路根本上,进行一些细节的处理和完善。<code>Promise</code>的核心,始终没有变过。</p>"},{"title":"JS暴露的艺术","date":"2019-08-11T11:00:00.000Z","_content":"&emsp;&emsp;ES6的module导出引入总结。\n<!--more-->\n\n## 基本module语法\n&emsp;&emsp;ES6提供了`export`和`import`语法，给予了JS模块化代码组织形式的能力。`export`语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过`import`语句使用它们。\n\n### export\n&emsp;&emsp;我们假设我们拥有一个`fileA.js`的文件，它向外`export`了这些：\n```javascript\n// fileA.js\nexport const DEMO_VALUE = '123';\nexport function demoFunction(param) { console.log(param); }\nexport default 123\n```\n&emsp;&emsp;`export`有两种导出形式。一种是使用`export`语句接上`const/let/var/function`等声明变量函数的语句向模块外导出值。一个文件内部可以存在多个`export`语句。另一种是使用`export default`直接加上值（不接声明语句）的方式向模块外导出值。一个文件内部只能存在一个`export default`语句。\n\n&emsp;&emsp;我们用`babel`来看一下实际上`export`实际转化成了什么。\n```javascript\n// export const DEMO_VALUE = '123';\n// export default 123\n// babel transform\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.DEMO_VALUE = void 0;\nvar DEMO_VALUE = '123';\nexports.DEMO_VALUE = DEMO_VALUE;\nvar _default = 123;\nexports.default = _default;\n```\n\n&emsp;&emsp;`babel`使用了类似于`commonJS`的模块导入导出规则（nodeJS的模块规则），对`export`语句进行编译。首先声明了一个`exports`的对象，它拥有`__esModule`为`true`的一个标。接着使用`exports.变量名/函数名`的方式，把所有`export`声明的值添加到`exports`对象上。随后添加`export default`的值到`exports`的`default`上。按照上面的例子，我们在该模块会得到下面这个对象:\n```javascript\n{\n    __esModule: true,\n    DEMO_VALUE: '123',\n    default: 123,\n}\n```\n\n### import\n&emsp;&emsp;现在我们新建一个`fileB.js`文件，使用`import`来引入这些`fileA.js`向外暴露的值。`import`也有两种导入值的语法：\n```javascript\n// fileB.js\nimport demoA /* 你要的变量值 */ from 'fileA.js';\nimport { DEMO_VALUE } from 'fileA.js';\n```\n&emsp;&emsp;第一种语法是直接使用`import + 任意变量名 from 文件路径`。该方法能够导入`fileA.js`中使用`export default`暴露的内容。你必须保证导入的文件名拥有\n`export default`向外暴露的内容，否则将会产生错误，我们来看一下`babel`对其的编译：\n\n```javascript\n// import demoA from 'fileA.js';\nvar _fileA = _interopRequireDefault(require(\"fileA.js\"));\n\nfunction _interopRequireDefault(obj) {\n    return\n        obj\n        &&\n        (obj.__esModule ? obj : { default: obj });\n}\n```\n&emsp;&emsp;这边首先声明了一个名为`_interopRequireDefault`的函数，用这个函数来处理`require 文件`进来的值。`_interopRequireDefault`函数对引入的对象做了一个简单判断，如果带有`__esModule`的标志的，说明是使用`export`语法编译过的导出内容，直接返回`obj`，否则应该是`commonJS`导入规则，从`obj`中解构`default`重命名为`obj`，然后返回。\n\n&emsp;&emsp;`import`第二种导入语法是导入`export`暴露的内容。前面说过，一个模块可以使用多个`export`进行声明的导出。因此此时引入这些值，需要名称对应。即你`export const a; export const b;`，在引入时候就需要`import { a, b } from '文件'`，名称`a`必须要对应。\n\n### as 和 * 语法\n&emsp;&emsp;当模块的提供方和使用方不是同一个人的时候，`export`和`import`需要对其声明名称时，有可能会产生一个问题，我使用`export`向外暴露的一些变量名称你已经使用过了，此时你又不方便去修改`node_modules`当中的源码去修改一个变量名称，你可以使用`as`语法来重命名一个`import`进来的模块。\n\n```javascript\n// fileA.js\nexport const DEMO_VALUE = '123';\n// fileB.js\nimport { DEMO_VALUE as FILEA_DEMO } from './fileA.js';\n```\n&emsp;&emsp;你还可以使用`*`语法来导出一个模块的全部导出，这样在使用模块内多方法函数的时候，能够清晰模块的调用。\n\n```javascript\n// fileA.js\nexport function returnName(name) { return name; }\nexport function returnAgePulsOne(age) { return age + 1; }\n// fileB.js\nimport * as utils from './fileA.js';\nutils.returnName('123'); // '123'\nutils.returnAgePulsOne(2); // 3\n```\n\n## 基于模块组织形式的一些语法扩充\n\n&emsp;&emsp;在日常的工作中，实际上还有更多模块化的使用场景和需求。\n\n### 单文件双模式导出\n&emsp;&emsp;诸如像`React`之类的公共库，拥有主模块和很多副模块方法。实际上可以提供`export`和`export default`双模式来方便使用者的引入。在写`React`库的时候，我们经常会出现这些使用场景。\n\n```javascript\n// 仅仅 JSX\nimport React from 'react';\n// Component\nimport { Component } from 'react';\n// 实际上你还可以这样\nimport React, { Component } from 'react';\n```\n&emsp;&emsp;能够使用`React, { Component }`这种语法，是因为`React`向外提供了`export`以及`export default`两种模式的导出声明。我们来举一个简单的例子：\n\n```javascript\n// fileA.js\nexport function formateDate() {}\nexport function getNowDate() {}\nexport default {\n    formateDate,\n    getNowDate,\n};\n\n// fileB.js\nimport utils, { formateDate } from 'fileA.js';\nconsole.log(utils); // { formateDate, getNowDate }\n```\n### 多文件索引\n&emsp;&emsp;在ES6的module语法中，当你在文件路径当中`/文件夹`，确没有指定文件目录的时候，会自动去查找文件夹下的`index.js`。在很多多方法多模块的库中，使用`index.js`文件作为索引来暴露出所有方法的模式是十分常见的。\n\n&emsp;&emsp;我们来举一个实际的场景，我现在在一个项目文件中，拥有一个`utils`的文件夹，存放项目中所有方法类函数，比如像上面的处理`date`的一些方法函数，以及一些ajax请求函数。我的目录层级场景大概是这样的：\n```javascript\n// /utils文件夹\n// /utils/service.js 用于存放ajax一些方法\nexport function ajaxPost(url, data) {}\nexport function ajaxGet(url, query) {}\n// /utils/date.js date处理的一些方法\nfunction formateDate() {}\nfunction getNowDate() {}\nexport default { formateDate, getNowDate }\n```\n\n&emsp;&emsp;我现在需要在`utils文件夹`下面，新建一个`index.js`的文件，来把我`utils`文件夹下所有其它js文件的方法全部暴露出去，让外部引用的时候，只需要`import { something } from 'utils'`即可，而不用继续往下去找到下一层的js文件。此时我们就需要联合`export`和`from`，来把一个模块直接引用暴露出去。\n\n```javascript\n// /utils/index.js\nexport { ajaxPost, ajaxGet } from './service.js';\nexport { default as dateUtils } from './date.js';\n```\n\n&emsp;&emsp;我们关注一下`date.js`这个文件。该文件是通过`export default`来暴露出一个对象，储存了所有的处理函数。这里由于`index.js`是使用`export from`的方式来直接导出引入的声明，所以我们需要对`date.js`文件的引用进行一个命名。我们前面看过使用`export default`暴露出去的值实际上是作为`default`暴露出去的，所以这里是可以通过`as`语法来修改`default`的名称来达到修改。\n","source":"_posts/js/artOfModule.md","raw":"---\ntitle: JS暴露的艺术\ndate: 2019/8/11 19:00:00\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;ES6的module导出引入总结。\n<!--more-->\n\n## 基本module语法\n&emsp;&emsp;ES6提供了`export`和`import`语法，给予了JS模块化代码组织形式的能力。`export`语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过`import`语句使用它们。\n\n### export\n&emsp;&emsp;我们假设我们拥有一个`fileA.js`的文件，它向外`export`了这些：\n```javascript\n// fileA.js\nexport const DEMO_VALUE = '123';\nexport function demoFunction(param) { console.log(param); }\nexport default 123\n```\n&emsp;&emsp;`export`有两种导出形式。一种是使用`export`语句接上`const/let/var/function`等声明变量函数的语句向模块外导出值。一个文件内部可以存在多个`export`语句。另一种是使用`export default`直接加上值（不接声明语句）的方式向模块外导出值。一个文件内部只能存在一个`export default`语句。\n\n&emsp;&emsp;我们用`babel`来看一下实际上`export`实际转化成了什么。\n```javascript\n// export const DEMO_VALUE = '123';\n// export default 123\n// babel transform\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.DEMO_VALUE = void 0;\nvar DEMO_VALUE = '123';\nexports.DEMO_VALUE = DEMO_VALUE;\nvar _default = 123;\nexports.default = _default;\n```\n\n&emsp;&emsp;`babel`使用了类似于`commonJS`的模块导入导出规则（nodeJS的模块规则），对`export`语句进行编译。首先声明了一个`exports`的对象，它拥有`__esModule`为`true`的一个标。接着使用`exports.变量名/函数名`的方式，把所有`export`声明的值添加到`exports`对象上。随后添加`export default`的值到`exports`的`default`上。按照上面的例子，我们在该模块会得到下面这个对象:\n```javascript\n{\n    __esModule: true,\n    DEMO_VALUE: '123',\n    default: 123,\n}\n```\n\n### import\n&emsp;&emsp;现在我们新建一个`fileB.js`文件，使用`import`来引入这些`fileA.js`向外暴露的值。`import`也有两种导入值的语法：\n```javascript\n// fileB.js\nimport demoA /* 你要的变量值 */ from 'fileA.js';\nimport { DEMO_VALUE } from 'fileA.js';\n```\n&emsp;&emsp;第一种语法是直接使用`import + 任意变量名 from 文件路径`。该方法能够导入`fileA.js`中使用`export default`暴露的内容。你必须保证导入的文件名拥有\n`export default`向外暴露的内容，否则将会产生错误，我们来看一下`babel`对其的编译：\n\n```javascript\n// import demoA from 'fileA.js';\nvar _fileA = _interopRequireDefault(require(\"fileA.js\"));\n\nfunction _interopRequireDefault(obj) {\n    return\n        obj\n        &&\n        (obj.__esModule ? obj : { default: obj });\n}\n```\n&emsp;&emsp;这边首先声明了一个名为`_interopRequireDefault`的函数，用这个函数来处理`require 文件`进来的值。`_interopRequireDefault`函数对引入的对象做了一个简单判断，如果带有`__esModule`的标志的，说明是使用`export`语法编译过的导出内容，直接返回`obj`，否则应该是`commonJS`导入规则，从`obj`中解构`default`重命名为`obj`，然后返回。\n\n&emsp;&emsp;`import`第二种导入语法是导入`export`暴露的内容。前面说过，一个模块可以使用多个`export`进行声明的导出。因此此时引入这些值，需要名称对应。即你`export const a; export const b;`，在引入时候就需要`import { a, b } from '文件'`，名称`a`必须要对应。\n\n### as 和 * 语法\n&emsp;&emsp;当模块的提供方和使用方不是同一个人的时候，`export`和`import`需要对其声明名称时，有可能会产生一个问题，我使用`export`向外暴露的一些变量名称你已经使用过了，此时你又不方便去修改`node_modules`当中的源码去修改一个变量名称，你可以使用`as`语法来重命名一个`import`进来的模块。\n\n```javascript\n// fileA.js\nexport const DEMO_VALUE = '123';\n// fileB.js\nimport { DEMO_VALUE as FILEA_DEMO } from './fileA.js';\n```\n&emsp;&emsp;你还可以使用`*`语法来导出一个模块的全部导出，这样在使用模块内多方法函数的时候，能够清晰模块的调用。\n\n```javascript\n// fileA.js\nexport function returnName(name) { return name; }\nexport function returnAgePulsOne(age) { return age + 1; }\n// fileB.js\nimport * as utils from './fileA.js';\nutils.returnName('123'); // '123'\nutils.returnAgePulsOne(2); // 3\n```\n\n## 基于模块组织形式的一些语法扩充\n\n&emsp;&emsp;在日常的工作中，实际上还有更多模块化的使用场景和需求。\n\n### 单文件双模式导出\n&emsp;&emsp;诸如像`React`之类的公共库，拥有主模块和很多副模块方法。实际上可以提供`export`和`export default`双模式来方便使用者的引入。在写`React`库的时候，我们经常会出现这些使用场景。\n\n```javascript\n// 仅仅 JSX\nimport React from 'react';\n// Component\nimport { Component } from 'react';\n// 实际上你还可以这样\nimport React, { Component } from 'react';\n```\n&emsp;&emsp;能够使用`React, { Component }`这种语法，是因为`React`向外提供了`export`以及`export default`两种模式的导出声明。我们来举一个简单的例子：\n\n```javascript\n// fileA.js\nexport function formateDate() {}\nexport function getNowDate() {}\nexport default {\n    formateDate,\n    getNowDate,\n};\n\n// fileB.js\nimport utils, { formateDate } from 'fileA.js';\nconsole.log(utils); // { formateDate, getNowDate }\n```\n### 多文件索引\n&emsp;&emsp;在ES6的module语法中，当你在文件路径当中`/文件夹`，确没有指定文件目录的时候，会自动去查找文件夹下的`index.js`。在很多多方法多模块的库中，使用`index.js`文件作为索引来暴露出所有方法的模式是十分常见的。\n\n&emsp;&emsp;我们来举一个实际的场景，我现在在一个项目文件中，拥有一个`utils`的文件夹，存放项目中所有方法类函数，比如像上面的处理`date`的一些方法函数，以及一些ajax请求函数。我的目录层级场景大概是这样的：\n```javascript\n// /utils文件夹\n// /utils/service.js 用于存放ajax一些方法\nexport function ajaxPost(url, data) {}\nexport function ajaxGet(url, query) {}\n// /utils/date.js date处理的一些方法\nfunction formateDate() {}\nfunction getNowDate() {}\nexport default { formateDate, getNowDate }\n```\n\n&emsp;&emsp;我现在需要在`utils文件夹`下面，新建一个`index.js`的文件，来把我`utils`文件夹下所有其它js文件的方法全部暴露出去，让外部引用的时候，只需要`import { something } from 'utils'`即可，而不用继续往下去找到下一层的js文件。此时我们就需要联合`export`和`from`，来把一个模块直接引用暴露出去。\n\n```javascript\n// /utils/index.js\nexport { ajaxPost, ajaxGet } from './service.js';\nexport { default as dateUtils } from './date.js';\n```\n\n&emsp;&emsp;我们关注一下`date.js`这个文件。该文件是通过`export default`来暴露出一个对象，储存了所有的处理函数。这里由于`index.js`是使用`export from`的方式来直接导出引入的声明，所以我们需要对`date.js`文件的引用进行一个命名。我们前面看过使用`export default`暴露出去的值实际上是作为`default`暴露出去的，所以这里是可以通过`as`语法来修改`default`的名称来达到修改。\n","slug":"js/artOfModule","published":1,"updated":"2020-06-11T01:43:32.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxi000j9r2veypsq97g","content":"<p>&emsp;&emsp;ES6的module导出引入总结。<br><a id=\"more\"></a></p>\n<h2 id=\"基本module语法\"><a href=\"#基本module语法\" class=\"headerlink\" title=\"基本module语法\"></a>基本module语法</h2><p>&emsp;&emsp;ES6提供了<code>export</code>和<code>import</code>语法，给予了JS模块化代码组织形式的能力。<code>export</code>语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过<code>import</code>语句使用它们。</p>\n<h3 id=\"export\"><a href=\"#export\" class=\"headerlink\" title=\"export\"></a>export</h3><p>&emsp;&emsp;我们假设我们拥有一个<code>fileA.js</code>的文件，它向外<code>export</code>了这些：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> DEMO_VALUE = <span class=\"hljs-string\">'123'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">demoFunction</span>(<span class=\"hljs-params\">param</span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(param); &#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">123</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>export</code>有两种导出形式。一种是使用<code>export</code>语句接上<code>const/let/var/function</code>等声明变量函数的语句向模块外导出值。一个文件内部可以存在多个<code>export</code>语句。另一种是使用<code>export default</code>直接加上值（不接声明语句）的方式向模块外导出值。一个文件内部只能存在一个<code>export default</code>语句。</p>\n<p>&emsp;&emsp;我们用<code>babel</code>来看一下实际上<code>export</code>实际转化成了什么。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// export const DEMO_VALUE = '123';</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// export default 123</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// babel transform</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Object</span>.defineProperty(exports, <span class=\"hljs-string\">\"__esModule\"</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">exports.default = exports.DEMO_VALUE = <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> DEMO_VALUE = <span class=\"hljs-string\">'123'</span>;</span><br><span class=\"line\">exports.DEMO_VALUE = DEMO_VALUE;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> _default = <span class=\"hljs-number\">123</span>;</span><br><span class=\"line\">exports.default = _default;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>babel</code>使用了类似于<code>commonJS</code>的模块导入导出规则（nodeJS的模块规则），对<code>export</code>语句进行编译。首先声明了一个<code>exports</code>的对象，它拥有<code>__esModule</code>为<code>true</code>的一个标。接着使用<code>exports.变量名/函数名</code>的方式，把所有<code>export</code>声明的值添加到<code>exports</code>对象上。随后添加<code>export default</code>的值到<code>exports</code>的<code>default</code>上。按照上面的例子，我们在该模块会得到下面这个对象:<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    __esModule: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">    DEMO_VALUE: <span class=\"hljs-string\">'123'</span>,</span><br><span class=\"line\">    <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-number\">123</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>&emsp;&emsp;现在我们新建一个<code>fileB.js</code>文件，使用<code>import</code>来引入这些<code>fileA.js</code>向外暴露的值。<code>import</code>也有两种导入值的语法：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> demoA <span class=\"hljs-comment\">/* 你要的变量值 */</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'fileA.js'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; DEMO_VALUE &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'fileA.js'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;第一种语法是直接使用<code>import + 任意变量名 from 文件路径</code>。该方法能够导入<code>fileA.js</code>中使用<code>export default</code>暴露的内容。你必须保证导入的文件名拥有<br><code>export default</code>向外暴露的内容，否则将会产生错误，我们来看一下<code>babel</code>对其的编译：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// import demoA from 'fileA.js';</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> _fileA = _interopRequireDefault(<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"fileA.js\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_interopRequireDefault</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">        obj</span><br><span class=\"line\">        &amp;&amp;</span><br><span class=\"line\">        (obj.__esModule ? obj : &#123; <span class=\"hljs-attr\">default</span>: obj &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这边首先声明了一个名为<code>_interopRequireDefault</code>的函数，用这个函数来处理<code>require 文件</code>进来的值。<code>_interopRequireDefault</code>函数对引入的对象做了一个简单判断，如果带有<code>__esModule</code>的标志的，说明是使用<code>export</code>语法编译过的导出内容，直接返回<code>obj</code>，否则应该是<code>commonJS</code>导入规则，从<code>obj</code>中解构<code>default</code>重命名为<code>obj</code>，然后返回。</p>\n<p>&emsp;&emsp;<code>import</code>第二种导入语法是导入<code>export</code>暴露的内容。前面说过，一个模块可以使用多个<code>export</code>进行声明的导出。因此此时引入这些值，需要名称对应。即你<code>export const a; export const b;</code>，在引入时候就需要<code>import { a, b } from &#39;文件&#39;</code>，名称<code>a</code>必须要对应。</p>\n<h3 id=\"as-和-语法\"><a href=\"#as-和-语法\" class=\"headerlink\" title=\"as 和 * 语法\"></a>as 和 * 语法</h3><p>&emsp;&emsp;当模块的提供方和使用方不是同一个人的时候，<code>export</code>和<code>import</code>需要对其声明名称时，有可能会产生一个问题，我使用<code>export</code>向外暴露的一些变量名称你已经使用过了，此时你又不方便去修改<code>node_modules</code>当中的源码去修改一个变量名称，你可以使用<code>as</code>语法来重命名一个<code>import</code>进来的模块。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> DEMO_VALUE = <span class=\"hljs-string\">'123'</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; DEMO_VALUE <span class=\"hljs-keyword\">as</span> FILEA_DEMO &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./fileA.js'</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;你还可以使用<code>*</code>语法来导出一个模块的全部导出，这样在使用模块内多方法函数的时候，能够清晰模块的调用。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">returnName</span>(<span class=\"hljs-params\">name</span>) </span>&#123; <span class=\"hljs-keyword\">return</span> name; &#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">returnAgePulsOne</span>(<span class=\"hljs-params\">age</span>) </span>&#123; <span class=\"hljs-keyword\">return</span> age + <span class=\"hljs-number\">1</span>; &#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> utils <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./fileA.js'</span>;</span><br><span class=\"line\">utils.returnName(<span class=\"hljs-string\">'123'</span>); <span class=\"hljs-comment\">// '123'</span></span><br><span class=\"line\">utils.returnAgePulsOne(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"基于模块组织形式的一些语法扩充\"><a href=\"#基于模块组织形式的一些语法扩充\" class=\"headerlink\" title=\"基于模块组织形式的一些语法扩充\"></a>基于模块组织形式的一些语法扩充</h2><p>&emsp;&emsp;在日常的工作中，实际上还有更多模块化的使用场景和需求。</p>\n<h3 id=\"单文件双模式导出\"><a href=\"#单文件双模式导出\" class=\"headerlink\" title=\"单文件双模式导出\"></a>单文件双模式导出</h3><p>&emsp;&emsp;诸如像<code>React</code>之类的公共库，拥有主模块和很多副模块方法。实际上可以提供<code>export</code>和<code>export default</code>双模式来方便使用者的引入。在写<code>React</code>库的时候，我们经常会出现这些使用场景。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 仅仅 JSX</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// Component</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 实际上你还可以这样</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> React, &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;能够使用<code>React, { Component }</code>这种语法，是因为<code>React</code>向外提供了<code>export</code>以及<code>export default</code>两种模式的导出声明。我们来举一个简单的例子：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formateDate</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNowDate</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;</span><br><span class=\"line\">    formateDate,</span><br><span class=\"line\">    getNowDate,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> utils, &#123; formateDate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'fileA.js'</span>;</span><br><span class=\"line\"><span class=\"hljs-built_in\">console</span>.log(utils); <span class=\"hljs-comment\">// &#123; formateDate, getNowDate &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"多文件索引\"><a href=\"#多文件索引\" class=\"headerlink\" title=\"多文件索引\"></a>多文件索引</h3><p>&emsp;&emsp;在ES6的module语法中，当你在文件路径当中<code>/文件夹</code>，确没有指定文件目录的时候，会自动去查找文件夹下的<code>index.js</code>。在很多多方法多模块的库中，使用<code>index.js</code>文件作为索引来暴露出所有方法的模式是十分常见的。</p>\n<p>&emsp;&emsp;我们来举一个实际的场景，我现在在一个项目文件中，拥有一个<code>utils</code>的文件夹，存放项目中所有方法类函数，比如像上面的处理<code>date</code>的一些方法函数，以及一些ajax请求函数。我的目录层级场景大概是这样的：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// /utils文件夹</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// /utils/service.js 用于存放ajax一些方法</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ajaxPost</span>(<span class=\"hljs-params\">url, data</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ajaxGet</span>(<span class=\"hljs-params\">url, query</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// /utils/date.js date处理的一些方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formateDate</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNowDate</span>(<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123; formateDate, getNowDate &#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我现在需要在<code>utils文件夹</code>下面，新建一个<code>index.js</code>的文件，来把我<code>utils</code>文件夹下所有其它js文件的方法全部暴露出去，让外部引用的时候，只需要<code>import { something } from &#39;utils&#39;</code>即可，而不用继续往下去找到下一层的js文件。此时我们就需要联合<code>export</code>和<code>from</code>，来把一个模块直接引用暴露出去。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// /utils/index.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> &#123; ajaxPost, ajaxGet &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service.js'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> dateUtils &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./date.js'</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们关注一下<code>date.js</code>这个文件。该文件是通过<code>export default</code>来暴露出一个对象，储存了所有的处理函数。这里由于<code>index.js</code>是使用<code>export from</code>的方式来直接导出引入的声明，所以我们需要对<code>date.js</code>文件的引用进行一个命名。我们前面看过使用<code>export default</code>暴露出去的值实际上是作为<code>default</code>暴露出去的，所以这里是可以通过<code>as</code>语法来修改<code>default</code>的名称来达到修改。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;ES6的module导出引入总结。<br></p>","more":"</p>\n<h2 id=\"基本module语法\"><a href=\"#基本module语法\" class=\"headerlink\" title=\"基本module语法\"></a>基本module语法</h2><p>&emsp;&emsp;ES6提供了<code>export</code>和<code>import</code>语法，给予了JS模块化代码组织形式的能力。<code>export</code>语句用于从模块中导出函数、对象或原始值，以便其他程序可以通过<code>import</code>语句使用它们。</p>\n<h3 id=\"export\"><a href=\"#export\" class=\"headerlink\" title=\"export\"></a>export</h3><p>&emsp;&emsp;我们假设我们拥有一个<code>fileA.js</code>的文件，它向外<code>export</code>了这些：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DEMO_VALUE = <span class=\"string\">'123'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demoFunction</span>(<span class=\"params\">param</span>) </span>&#123; <span class=\"built_in\">console</span>.log(param); &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"number\">123</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>export</code>有两种导出形式。一种是使用<code>export</code>语句接上<code>const/let/var/function</code>等声明变量函数的语句向模块外导出值。一个文件内部可以存在多个<code>export</code>语句。另一种是使用<code>export default</code>直接加上值（不接声明语句）的方式向模块外导出值。一个文件内部只能存在一个<code>export default</code>语句。</p>\n<p>&emsp;&emsp;我们用<code>babel</code>来看一下实际上<code>export</code>实际转化成了什么。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export const DEMO_VALUE = '123';</span></span><br><span class=\"line\"><span class=\"comment\">// export default 123</span></span><br><span class=\"line\"><span class=\"comment\">// babel transform</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(exports, <span class=\"string\">\"__esModule\"</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">exports.default = exports.DEMO_VALUE = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> DEMO_VALUE = <span class=\"string\">'123'</span>;</span><br><span class=\"line\">exports.DEMO_VALUE = DEMO_VALUE;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _default = <span class=\"number\">123</span>;</span><br><span class=\"line\">exports.default = _default;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>babel</code>使用了类似于<code>commonJS</code>的模块导入导出规则（nodeJS的模块规则），对<code>export</code>语句进行编译。首先声明了一个<code>exports</code>的对象，它拥有<code>__esModule</code>为<code>true</code>的一个标。接着使用<code>exports.变量名/函数名</code>的方式，把所有<code>export</code>声明的值添加到<code>exports</code>对象上。随后添加<code>export default</code>的值到<code>exports</code>的<code>default</code>上。按照上面的例子，我们在该模块会得到下面这个对象:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    __esModule: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    DEMO_VALUE: <span class=\"string\">'123'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>&emsp;&emsp;现在我们新建一个<code>fileB.js</code>文件，使用<code>import</code>来引入这些<code>fileA.js</code>向外暴露的值。<code>import</code>也有两种导入值的语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> demoA <span class=\"comment\">/* 你要的变量值 */</span> <span class=\"keyword\">from</span> <span class=\"string\">'fileA.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; DEMO_VALUE &#125; <span class=\"keyword\">from</span> <span class=\"string\">'fileA.js'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;第一种语法是直接使用<code>import + 任意变量名 from 文件路径</code>。该方法能够导入<code>fileA.js</code>中使用<code>export default</code>暴露的内容。你必须保证导入的文件名拥有<br><code>export default</code>向外暴露的内容，否则将会产生错误，我们来看一下<code>babel</code>对其的编译：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import demoA from 'fileA.js';</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _fileA = _interopRequireDefault(<span class=\"built_in\">require</span>(<span class=\"string\">\"fileA.js\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_interopRequireDefault</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">        obj</span><br><span class=\"line\">        &amp;&amp;</span><br><span class=\"line\">        (obj.__esModule ? obj : &#123; <span class=\"attr\">default</span>: obj &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这边首先声明了一个名为<code>_interopRequireDefault</code>的函数，用这个函数来处理<code>require 文件</code>进来的值。<code>_interopRequireDefault</code>函数对引入的对象做了一个简单判断，如果带有<code>__esModule</code>的标志的，说明是使用<code>export</code>语法编译过的导出内容，直接返回<code>obj</code>，否则应该是<code>commonJS</code>导入规则，从<code>obj</code>中解构<code>default</code>重命名为<code>obj</code>，然后返回。</p>\n<p>&emsp;&emsp;<code>import</code>第二种导入语法是导入<code>export</code>暴露的内容。前面说过，一个模块可以使用多个<code>export</code>进行声明的导出。因此此时引入这些值，需要名称对应。即你<code>export const a; export const b;</code>，在引入时候就需要<code>import { a, b } from &#39;文件&#39;</code>，名称<code>a</code>必须要对应。</p>\n<h3 id=\"as-和-语法\"><a href=\"#as-和-语法\" class=\"headerlink\" title=\"as 和 * 语法\"></a>as 和 * 语法</h3><p>&emsp;&emsp;当模块的提供方和使用方不是同一个人的时候，<code>export</code>和<code>import</code>需要对其声明名称时，有可能会产生一个问题，我使用<code>export</code>向外暴露的一些变量名称你已经使用过了，此时你又不方便去修改<code>node_modules</code>当中的源码去修改一个变量名称，你可以使用<code>as</code>语法来重命名一个<code>import</code>进来的模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> DEMO_VALUE = <span class=\"string\">'123'</span>;</span><br><span class=\"line\"><span class=\"comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; DEMO_VALUE <span class=\"keyword\">as</span> FILEA_DEMO &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./fileA.js'</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;你还可以使用<code>*</code>语法来导出一个模块的全部导出，这样在使用模块内多方法函数的时候，能够清晰模块的调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">returnName</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">returnAgePulsOne</span>(<span class=\"params\">age</span>) </span>&#123; <span class=\"keyword\">return</span> age + <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\"><span class=\"comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> utils <span class=\"keyword\">from</span> <span class=\"string\">'./fileA.js'</span>;</span><br><span class=\"line\">utils.returnName(<span class=\"string\">'123'</span>); <span class=\"comment\">// '123'</span></span><br><span class=\"line\">utils.returnAgePulsOne(<span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"基于模块组织形式的一些语法扩充\"><a href=\"#基于模块组织形式的一些语法扩充\" class=\"headerlink\" title=\"基于模块组织形式的一些语法扩充\"></a>基于模块组织形式的一些语法扩充</h2><p>&emsp;&emsp;在日常的工作中，实际上还有更多模块化的使用场景和需求。</p>\n<h3 id=\"单文件双模式导出\"><a href=\"#单文件双模式导出\" class=\"headerlink\" title=\"单文件双模式导出\"></a>单文件双模式导出</h3><p>&emsp;&emsp;诸如像<code>React</code>之类的公共库，拥有主模块和很多副模块方法。实际上可以提供<code>export</code>和<code>export default</code>双模式来方便使用者的引入。在写<code>React</code>库的时候，我们经常会出现这些使用场景。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 仅仅 JSX</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"comment\">// Component</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 实际上你还可以这样</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;能够使用<code>React, { Component }</code>这种语法，是因为<code>React</code>向外提供了<code>export</code>以及<code>export default</code>两种模式的导出声明。我们来举一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fileA.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formateDate</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNowDate</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    formateDate,</span><br><span class=\"line\">    getNowDate,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fileB.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> utils, &#123; formateDate &#125; <span class=\"keyword\">from</span> <span class=\"string\">'fileA.js'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(utils); <span class=\"comment\">// &#123; formateDate, getNowDate &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"多文件索引\"><a href=\"#多文件索引\" class=\"headerlink\" title=\"多文件索引\"></a>多文件索引</h3><p>&emsp;&emsp;在ES6的module语法中，当你在文件路径当中<code>/文件夹</code>，确没有指定文件目录的时候，会自动去查找文件夹下的<code>index.js</code>。在很多多方法多模块的库中，使用<code>index.js</code>文件作为索引来暴露出所有方法的模式是十分常见的。</p>\n<p>&emsp;&emsp;我们来举一个实际的场景，我现在在一个项目文件中，拥有一个<code>utils</code>的文件夹，存放项目中所有方法类函数，比如像上面的处理<code>date</code>的一些方法函数，以及一些ajax请求函数。我的目录层级场景大概是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /utils文件夹</span></span><br><span class=\"line\"><span class=\"comment\">// /utils/service.js 用于存放ajax一些方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajaxPost</span>(<span class=\"params\">url, data</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajaxGet</span>(<span class=\"params\">url, query</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// /utils/date.js date处理的一些方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formateDate</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNowDate</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123; formateDate, getNowDate &#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我现在需要在<code>utils文件夹</code>下面，新建一个<code>index.js</code>的文件，来把我<code>utils</code>文件夹下所有其它js文件的方法全部暴露出去，让外部引用的时候，只需要<code>import { something } from &#39;utils&#39;</code>即可，而不用继续往下去找到下一层的js文件。此时我们就需要联合<code>export</code>和<code>from</code>，来把一个模块直接引用暴露出去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /utils/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ajaxPost, ajaxGet &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./service.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"keyword\">default</span> <span class=\"keyword\">as</span> dateUtils &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./date.js'</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们关注一下<code>date.js</code>这个文件。该文件是通过<code>export default</code>来暴露出一个对象，储存了所有的处理函数。这里由于<code>index.js</code>是使用<code>export from</code>的方式来直接导出引入的声明，所以我们需要对<code>date.js</code>文件的引用进行一个命名。我们前面看过使用<code>export default</code>暴露出去的值实际上是作为<code>default</code>暴露出去的，所以这里是可以通过<code>as</code>语法来修改<code>default</code>的名称来达到修改。</p>"},{"title":"不定期更新的源码阅读日常——lodash-1","date":"2019-11-23T10:00:00.000Z","_content":"1. 不定期更新的源码阅读日常将不会采用**逐行摘抄源码然后分析阅读**的方式进行源码阅读，而是提炼分享源码中**个人发人深省**的部分进行摘录总结，知识补足。\n2. 不定期更新的源码阅读日常阅读的库都是**模块零碎化**或者**小功能库**。方便灵活，而且不需要连续阅读。\n3. 不定期更新的源码阅读日常将**不定期**更新。\n\n&emsp;&emsp;今天我们来读lodash的Array部分。\n<!--more-->\n## 数组length的边界处理\n\n&emsp;&emsp;lodash中Array部分相关操作，经常需要对入参的取值进行边界处理。比如调用fill方法中`start`和`end`的大小，chunk方法中`size`的大小，以确保函数的正常执行。\n\n&emsp;&emsp;在处理数组的`length`边界时，lodash借助位操作符，仅用一行代码，保证了数组length在0之上，最大值范围之下，我们借`baseSlice`方法中的一段源码来学习一下。\n```javascript\n/**\n  * @param {Array} array The array to slice.\n  * @param {number} [start=0] The start position.\n  * @param {number} [end=array.length] The end position.\n  * @returns {Array} Returns the slice of `array`.\n*/\nfunction baseSlice(array, start, end) {\n    // ....省略不关键部分\n    length = start > end ? 0 : ((end - start) >>> 0);\n    start >>>= 0;\n    var result = Array(length);\n    // ....省略不关键部分\n}\n```\n&emsp;&emsp;`baseSlice`功能和目前Array自带的`slice`方法功能相同，截取数组`start`到`end`部分，返回截取的新数组。截取的代码部分正在进行是根据`start`和`end`的差值长度，生成新的数组对象，后面以便循环推入数据并返回结果。\n\n&emsp;&emsp;`baseSlice`对`length`根据`start`和`end`的差值做了一个边界处理。当`start`比`end`小时，直接判`length`为0；当`end`比`start`大时，取`end - start`的差，并做了一个`>>>`位运算符号，并且在后续，对start做了一个`>>>=`的操作处理。\n\n&emsp;&emsp;要想知道如此处理的原因，首先需要知道Array.length的边界规定，我们引用一下`mdn`上关于Array.length的定义。\n\n> length 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。\n\n&emsp;&emsp;`无符号 32-bit 整数`意味着`32-bit`都可以用来进行数据的储存，而不需要匀第一位出来作为正负符号的标记。因此数组的长度范围应该在`0 ~ Math.pow(2, 32) - 1`长度之间。而在不知道传入`end`和`start`大小的情况下，`length`的长度实际上是有可能超出这个长度的。\n\n&emsp;&emsp;我们接着来看`>>>`操作的定义：\n\n> `a >>> b`将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）\n\n```\n      9 (base 10): 00000000000000000000000000001001 (base 2)\n                   --------------------------------\n9 >>> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)\n```\n&emsp;&emsp;因此，`baseSlice`使用`length >>> 0`的方式保证了length的长度永远在`32-bit`的范围。即当数字大于2的32次方时候，`>>>`会崛弃所有大于`32-bit`的位数部分，即减去`Math.pow(2, 32)`。而小于范围的数字由于位移的是`0`则不受任何影响。之后对`start`也做了一个确保，是因为`baseSlice`需要截取`start`这一位到`end`为止的数组数据，`start`的数字必须也要确保在`length`的范围内。\n\n## 调用优化\n&emsp;&emsp;在`difference`一系列方法源码的时候，`lodash`都使用`baseRest`引导使用的函数重新绑定了作用域到`lodash`的`_`上。而在`baseRest`中，都统一调用了一个`setToString`方法，它能让传入的函数都拥有一个`toString`方法，调用能够直接看到传入函数的函数体，即看到该函数的代码。这在后续的一些需要传入函数的方法中方便使用者调试起到了非常重要的作用。\n\n```javascript\n/**\n  * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n  * @param {Function} func The function to apply a rest parameter to.\n  * @param {number} [start=func.length-1] The start position of the rest parameter.\n  * @returns {Function} Returns the new function.\n  */\nfunction baseRest(func, start) {\n    return setToString(overRest(func, start, identity), func + '');\n}\n/**\n  * Sets the `toString` method of `func` to return `string`.\n  *\n  * @private\n  * @param {Function} func The function to modify.\n  * @param {Function} string The `toString` result.\n  * @returns {Function} Returns `func`.\n  */\nvar setToString = shortOut(baseSetToString);\n```\n\n&emsp;&emsp;但我重点关注的其实是`shortOut`这个函数的代码，很有意思，我们来看一下源码：\n\n```javascript\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/**\n  * Creates a function that'll short out and invoke `identity` instead\n  * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n  * milliseconds.\n  * @param {Function} func The function to restrict.\n  * @returns {Function} Returns the new shortable function.\n  */\nfunction shortOut(func) {\n    var count = 0,\n    lastCalled = 0;\n\n    return function() {\n        // nativeNow 即 Date.now\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n    };\n}\n```\n\n&emsp;&emsp;该方法实际上是使用了一个闭包包裹了一下传入的函数，记录下了函数调用次数`count`以及上次调用时间`lastCalled`。并针对这两个数值，对常用函数调用做了一个调用限制的优化。\n\n&emsp;&emsp;我们可以看到，在每次调用函数前，这个方法都会利用`Date.now`去记录一下**当前调用的时间**，并且和**上一次调动该函数时间(lastCalled)**进行一个比较。当这个差值大于`HOT_SPAN`(当前版本是16，即16ms)的时候，使用apply调用并清空`调用次数(count)`为0。当差值小于`HOT_SPAN`，即两次函数调用之间时间小于`HOT_SPAN`，而且调用次数大于`HOT_COUNT(当前版本为800，即800次)`，就停止调用该函数，而是返回函数入参的第一项，根据注释，这第一项应该是一个函数的`identity`。\n\n&emsp;&emsp;上面有提到过，在诸如`setToString`这样的报错机制处理时，使用了`shortOut`方法进行一个`高阶函数`的包装。`setToString`这个函数本身就是为了服务`lodash`的一些报错机制，让传入的函数都能拥有得到函数体代码的`toString`方法，这样可以保证在大批量数据处理的时候，根据不同的性能情况，进行不同的容错处理。\n\n","source":"_posts/lodash/sourceCode_lodash_1.md","raw":"---\ntitle: 不定期更新的源码阅读日常——lodash-1\ndate: 2019/11/23 18:00:00\ncategories:\n- [前端, lodash]\ntags:\n- lodash\n- 源码阅读\n---\n1. 不定期更新的源码阅读日常将不会采用**逐行摘抄源码然后分析阅读**的方式进行源码阅读，而是提炼分享源码中**个人发人深省**的部分进行摘录总结，知识补足。\n2. 不定期更新的源码阅读日常阅读的库都是**模块零碎化**或者**小功能库**。方便灵活，而且不需要连续阅读。\n3. 不定期更新的源码阅读日常将**不定期**更新。\n\n&emsp;&emsp;今天我们来读lodash的Array部分。\n<!--more-->\n## 数组length的边界处理\n\n&emsp;&emsp;lodash中Array部分相关操作，经常需要对入参的取值进行边界处理。比如调用fill方法中`start`和`end`的大小，chunk方法中`size`的大小，以确保函数的正常执行。\n\n&emsp;&emsp;在处理数组的`length`边界时，lodash借助位操作符，仅用一行代码，保证了数组length在0之上，最大值范围之下，我们借`baseSlice`方法中的一段源码来学习一下。\n```javascript\n/**\n  * @param {Array} array The array to slice.\n  * @param {number} [start=0] The start position.\n  * @param {number} [end=array.length] The end position.\n  * @returns {Array} Returns the slice of `array`.\n*/\nfunction baseSlice(array, start, end) {\n    // ....省略不关键部分\n    length = start > end ? 0 : ((end - start) >>> 0);\n    start >>>= 0;\n    var result = Array(length);\n    // ....省略不关键部分\n}\n```\n&emsp;&emsp;`baseSlice`功能和目前Array自带的`slice`方法功能相同，截取数组`start`到`end`部分，返回截取的新数组。截取的代码部分正在进行是根据`start`和`end`的差值长度，生成新的数组对象，后面以便循环推入数据并返回结果。\n\n&emsp;&emsp;`baseSlice`对`length`根据`start`和`end`的差值做了一个边界处理。当`start`比`end`小时，直接判`length`为0；当`end`比`start`大时，取`end - start`的差，并做了一个`>>>`位运算符号，并且在后续，对start做了一个`>>>=`的操作处理。\n\n&emsp;&emsp;要想知道如此处理的原因，首先需要知道Array.length的边界规定，我们引用一下`mdn`上关于Array.length的定义。\n\n> length 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。\n\n&emsp;&emsp;`无符号 32-bit 整数`意味着`32-bit`都可以用来进行数据的储存，而不需要匀第一位出来作为正负符号的标记。因此数组的长度范围应该在`0 ~ Math.pow(2, 32) - 1`长度之间。而在不知道传入`end`和`start`大小的情况下，`length`的长度实际上是有可能超出这个长度的。\n\n&emsp;&emsp;我们接着来看`>>>`操作的定义：\n\n> `a >>> b`将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）\n\n```\n      9 (base 10): 00000000000000000000000000001001 (base 2)\n                   --------------------------------\n9 >>> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)\n```\n&emsp;&emsp;因此，`baseSlice`使用`length >>> 0`的方式保证了length的长度永远在`32-bit`的范围。即当数字大于2的32次方时候，`>>>`会崛弃所有大于`32-bit`的位数部分，即减去`Math.pow(2, 32)`。而小于范围的数字由于位移的是`0`则不受任何影响。之后对`start`也做了一个确保，是因为`baseSlice`需要截取`start`这一位到`end`为止的数组数据，`start`的数字必须也要确保在`length`的范围内。\n\n## 调用优化\n&emsp;&emsp;在`difference`一系列方法源码的时候，`lodash`都使用`baseRest`引导使用的函数重新绑定了作用域到`lodash`的`_`上。而在`baseRest`中，都统一调用了一个`setToString`方法，它能让传入的函数都拥有一个`toString`方法，调用能够直接看到传入函数的函数体，即看到该函数的代码。这在后续的一些需要传入函数的方法中方便使用者调试起到了非常重要的作用。\n\n```javascript\n/**\n  * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n  * @param {Function} func The function to apply a rest parameter to.\n  * @param {number} [start=func.length-1] The start position of the rest parameter.\n  * @returns {Function} Returns the new function.\n  */\nfunction baseRest(func, start) {\n    return setToString(overRest(func, start, identity), func + '');\n}\n/**\n  * Sets the `toString` method of `func` to return `string`.\n  *\n  * @private\n  * @param {Function} func The function to modify.\n  * @param {Function} string The `toString` result.\n  * @returns {Function} Returns `func`.\n  */\nvar setToString = shortOut(baseSetToString);\n```\n\n&emsp;&emsp;但我重点关注的其实是`shortOut`这个函数的代码，很有意思，我们来看一下源码：\n\n```javascript\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/**\n  * Creates a function that'll short out and invoke `identity` instead\n  * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n  * milliseconds.\n  * @param {Function} func The function to restrict.\n  * @returns {Function} Returns the new shortable function.\n  */\nfunction shortOut(func) {\n    var count = 0,\n    lastCalled = 0;\n\n    return function() {\n        // nativeNow 即 Date.now\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n    };\n}\n```\n\n&emsp;&emsp;该方法实际上是使用了一个闭包包裹了一下传入的函数，记录下了函数调用次数`count`以及上次调用时间`lastCalled`。并针对这两个数值，对常用函数调用做了一个调用限制的优化。\n\n&emsp;&emsp;我们可以看到，在每次调用函数前，这个方法都会利用`Date.now`去记录一下**当前调用的时间**，并且和**上一次调动该函数时间(lastCalled)**进行一个比较。当这个差值大于`HOT_SPAN`(当前版本是16，即16ms)的时候，使用apply调用并清空`调用次数(count)`为0。当差值小于`HOT_SPAN`，即两次函数调用之间时间小于`HOT_SPAN`，而且调用次数大于`HOT_COUNT(当前版本为800，即800次)`，就停止调用该函数，而是返回函数入参的第一项，根据注释，这第一项应该是一个函数的`identity`。\n\n&emsp;&emsp;上面有提到过，在诸如`setToString`这样的报错机制处理时，使用了`shortOut`方法进行一个`高阶函数`的包装。`setToString`这个函数本身就是为了服务`lodash`的一些报错机制，让传入的函数都能拥有得到函数体代码的`toString`方法，这样可以保证在大批量数据处理的时候，根据不同的性能情况，进行不同的容错处理。\n\n","slug":"lodash/sourceCode_lodash_1","published":1,"updated":"2020-06-11T01:43:32.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxk000n9r2vbkzq4kos","content":"<ol>\n<li>不定期更新的源码阅读日常将不会采用<strong>逐行摘抄源码然后分析阅读</strong>的方式进行源码阅读，而是提炼分享源码中<strong>个人发人深省</strong>的部分进行摘录总结，知识补足。</li>\n<li>不定期更新的源码阅读日常阅读的库都是<strong>模块零碎化</strong>或者<strong>小功能库</strong>。方便灵活，而且不需要连续阅读。</li>\n<li>不定期更新的源码阅读日常将<strong>不定期</strong>更新。</li>\n</ol>\n<p>&emsp;&emsp;今天我们来读lodash的Array部分。<br><a id=\"more\"></a></p>\n<h2 id=\"数组length的边界处理\"><a href=\"#数组length的边界处理\" class=\"headerlink\" title=\"数组length的边界处理\"></a>数组length的边界处理</h2><p>&emsp;&emsp;lodash中Array部分相关操作，经常需要对入参的取值进行边界处理。比如调用fill方法中<code>start</code>和<code>end</code>的大小，chunk方法中<code>size</code>的大小，以确保函数的正常执行。</p>\n<p>&emsp;&emsp;在处理数组的<code>length</code>边界时，lodash借助位操作符，仅用一行代码，保证了数组length在0之上，最大值范围之下，我们借<code>baseSlice</code>方法中的一段源码来学习一下。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Array&#125;</span> </span>array The array to slice.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;number&#125;</span> </span>[start=0] The start position.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;number&#125;</span> </span>[end=array.length] The end position.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;Array&#125;</span> </span>Returns the slice of `array`.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseSlice</span>(<span class=\"hljs-params\">array, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// ....省略不关键部分</span></span><br><span class=\"line\">    length = start &gt; end ? <span class=\"hljs-number\">0</span> : ((end - start) &gt;&gt;&gt; <span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">    start &gt;&gt;&gt;= <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-built_in\">Array</span>(length);</span><br><span class=\"line\">    <span class=\"hljs-comment\">// ....省略不关键部分</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>baseSlice</code>功能和目前Array自带的<code>slice</code>方法功能相同，截取数组<code>start</code>到<code>end</code>部分，返回截取的新数组。截取的代码部分正在进行是根据<code>start</code>和<code>end</code>的差值长度，生成新的数组对象，后面以便循环推入数据并返回结果。</p>\n<p>&emsp;&emsp;<code>baseSlice</code>对<code>length</code>根据<code>start</code>和<code>end</code>的差值做了一个边界处理。当<code>start</code>比<code>end</code>小时，直接判<code>length</code>为0；当<code>end</code>比<code>start</code>大时，取<code>end - start</code>的差，并做了一个<code>&gt;&gt;&gt;</code>位运算符号，并且在后续，对start做了一个<code>&gt;&gt;&gt;=</code>的操作处理。</p>\n<p>&emsp;&emsp;要想知道如此处理的原因，首先需要知道Array.length的边界规定，我们引用一下<code>mdn</code>上关于Array.length的定义。</p>\n<blockquote>\n<p>length 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。</p>\n</blockquote>\n<p>&emsp;&emsp;<code>无符号 32-bit 整数</code>意味着<code>32-bit</code>都可以用来进行数据的储存，而不需要匀第一位出来作为正负符号的标记。因此数组的长度范围应该在<code>0 ~ Math.pow(2, 32) - 1</code>长度之间。而在不知道传入<code>end</code>和<code>start</code>大小的情况下，<code>length</code>的长度实际上是有可能超出这个长度的。</p>\n<p>&emsp;&emsp;我们接着来看<code>&gt;&gt;&gt;</code>操作的定义：</p>\n<blockquote>\n<p><code>a &gt;&gt;&gt; b</code>将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</p>\n</blockquote>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      9 (base 10): 00000000000000000000000000001001 (base 2)</span><br><span class=\"line\">                   --------------------------------</span><br><span class=\"line\">9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;因此，<code>baseSlice</code>使用<code>length &gt;&gt;&gt; 0</code>的方式保证了length的长度永远在<code>32-bit</code>的范围。即当数字大于2的32次方时候，<code>&gt;&gt;&gt;</code>会崛弃所有大于<code>32-bit</code>的位数部分，即减去<code>Math.pow(2, 32)</code>。而小于范围的数字由于位移的是<code>0</code>则不受任何影响。之后对<code>start</code>也做了一个确保，是因为<code>baseSlice</code>需要截取<code>start</code>这一位到<code>end</code>为止的数组数据，<code>start</code>的数字必须也要确保在<code>length</code>的范围内。</p>\n<h2 id=\"调用优化\"><a href=\"#调用优化\" class=\"headerlink\" title=\"调用优化\"></a>调用优化</h2><p>&emsp;&emsp;在<code>difference</code>一系列方法源码的时候，<code>lodash</code>都使用<code>baseRest</code>引导使用的函数重新绑定了作用域到<code>lodash</code>的<code>_</code>上。而在<code>baseRest</code>中，都统一调用了一个<code>setToString</code>方法，它能让传入的函数都拥有一个<code>toString</code>方法，调用能够直接看到传入函数的函数体，即看到该函数的代码。这在后续的一些需要传入函数的方法中方便使用者调试起到了非常重要的作用。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * The base implementation of `_.rest` which doesn't validate or coerce arguments.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>func The function to apply a rest parameter to.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;number&#125;</span> </span>[start=func.length-1] The start position of the rest parameter.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;Function&#125;</span> </span>Returns the new function.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseRest</span>(<span class=\"hljs-params\">func, start</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> setToString(overRest(func, start, identity), func + <span class=\"hljs-string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * Sets the `toString` method of `func` to return `string`.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  *</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@private</span></span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>func The function to modify.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>string The `toString` result.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;Function&#125;</span> </span>Returns `func`.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> setToString = shortOut(baseSetToString);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;但我重点关注的其实是<code>shortOut</code>这个函数的代码，很有意思，我们来看一下源码：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** Used to detect hot functions by number of calls within a span of milliseconds. */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> HOT_COUNT = <span class=\"hljs-number\">800</span>,</span><br><span class=\"line\">    HOT_SPAN = <span class=\"hljs-number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * Creates a function that'll short out and invoke `identity` instead</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * milliseconds.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>func The function to restrict.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;Function&#125;</span> </span>Returns the new shortable function.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">shortOut</span>(<span class=\"hljs-params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> count = <span class=\"hljs-number\">0</span>,</span><br><span class=\"line\">    lastCalled = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// nativeNow 即 Date.now</span></span><br><span class=\"line\">        <span class=\"hljs-keyword\">var</span> stamp = nativeNow(),</span><br><span class=\"line\">            remaining = HOT_SPAN - (stamp - lastCalled);</span><br><span class=\"line\"></span><br><span class=\"line\">        lastCalled = stamp;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (remaining &gt; <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"hljs-keyword\">if</span> (++count &gt;= HOT_COUNT) &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">arguments</span>[<span class=\"hljs-number\">0</span>];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">          count = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> func.apply(<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;该方法实际上是使用了一个闭包包裹了一下传入的函数，记录下了函数调用次数<code>count</code>以及上次调用时间<code>lastCalled</code>。并针对这两个数值，对常用函数调用做了一个调用限制的优化。</p>\n<p>&emsp;&emsp;我们可以看到，在每次调用函数前，这个方法都会利用<code>Date.now</code>去记录一下<strong>当前调用的时间</strong>，并且和<strong>上一次调动该函数时间(lastCalled)</strong>进行一个比较。当这个差值大于<code>HOT_SPAN</code>(当前版本是16，即16ms)的时候，使用apply调用并清空<code>调用次数(count)</code>为0。当差值小于<code>HOT_SPAN</code>，即两次函数调用之间时间小于<code>HOT_SPAN</code>，而且调用次数大于<code>HOT_COUNT(当前版本为800，即800次)</code>，就停止调用该函数，而是返回函数入参的第一项，根据注释，这第一项应该是一个函数的<code>identity</code>。</p>\n<p>&emsp;&emsp;上面有提到过，在诸如<code>setToString</code>这样的报错机制处理时，使用了<code>shortOut</code>方法进行一个<code>高阶函数</code>的包装。<code>setToString</code>这个函数本身就是为了服务<code>lodash</code>的一些报错机制，让传入的函数都能拥有得到函数体代码的<code>toString</code>方法，这样可以保证在大批量数据处理的时候，根据不同的性能情况，进行不同的容错处理。</p>\n","site":{"data":{}},"excerpt":"<ol>\n<li>不定期更新的源码阅读日常将不会采用<strong>逐行摘抄源码然后分析阅读</strong>的方式进行源码阅读，而是提炼分享源码中<strong>个人发人深省</strong>的部分进行摘录总结，知识补足。</li>\n<li>不定期更新的源码阅读日常阅读的库都是<strong>模块零碎化</strong>或者<strong>小功能库</strong>。方便灵活，而且不需要连续阅读。</li>\n<li>不定期更新的源码阅读日常将<strong>不定期</strong>更新。</li>\n</ol>\n<p>&emsp;&emsp;今天我们来读lodash的Array部分。<br></p>","more":"</p>\n<h2 id=\"数组length的边界处理\"><a href=\"#数组length的边界处理\" class=\"headerlink\" title=\"数组length的边界处理\"></a>数组length的边界处理</h2><p>&emsp;&emsp;lodash中Array部分相关操作，经常需要对入参的取值进行边界处理。比如调用fill方法中<code>start</code>和<code>end</code>的大小，chunk方法中<code>size</code>的大小，以确保函数的正常执行。</p>\n<p>&emsp;&emsp;在处理数组的<code>length</code>边界时，lodash借助位操作符，仅用一行代码，保证了数组length在0之上，最大值范围之下，我们借<code>baseSlice</code>方法中的一段源码来学习一下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Array&#125;</span> </span>array The array to slice.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[start=0] The start position.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[end=array.length] The end position.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@returns <span class=\"type\">&#123;Array&#125;</span> </span>Returns the slice of `array`.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseSlice</span>(<span class=\"params\">array, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....省略不关键部分</span></span><br><span class=\"line\">    length = start &gt; end ? <span class=\"number\">0</span> : ((end - start) &gt;&gt;&gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    start &gt;&gt;&gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"built_in\">Array</span>(length);</span><br><span class=\"line\">    <span class=\"comment\">// ....省略不关键部分</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>baseSlice</code>功能和目前Array自带的<code>slice</code>方法功能相同，截取数组<code>start</code>到<code>end</code>部分，返回截取的新数组。截取的代码部分正在进行是根据<code>start</code>和<code>end</code>的差值长度，生成新的数组对象，后面以便循环推入数据并返回结果。</p>\n<p>&emsp;&emsp;<code>baseSlice</code>对<code>length</code>根据<code>start</code>和<code>end</code>的差值做了一个边界处理。当<code>start</code>比<code>end</code>小时，直接判<code>length</code>为0；当<code>end</code>比<code>start</code>大时，取<code>end - start</code>的差，并做了一个<code>&gt;&gt;&gt;</code>位运算符号，并且在后续，对start做了一个<code>&gt;&gt;&gt;=</code>的操作处理。</p>\n<p>&emsp;&emsp;要想知道如此处理的原因，首先需要知道Array.length的边界规定，我们引用一下<code>mdn</code>上关于Array.length的定义。</p>\n<blockquote>\n<p>length 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。</p>\n</blockquote>\n<p>&emsp;&emsp;<code>无符号 32-bit 整数</code>意味着<code>32-bit</code>都可以用来进行数据的储存，而不需要匀第一位出来作为正负符号的标记。因此数组的长度范围应该在<code>0 ~ Math.pow(2, 32) - 1</code>长度之间。而在不知道传入<code>end</code>和<code>start</code>大小的情况下，<code>length</code>的长度实际上是有可能超出这个长度的。</p>\n<p>&emsp;&emsp;我们接着来看<code>&gt;&gt;&gt;</code>操作的定义：</p>\n<blockquote>\n<p><code>a &gt;&gt;&gt; b</code>将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      9 (base 10): 00000000000000000000000000001001 (base 2)</span><br><span class=\"line\">                   --------------------------------</span><br><span class=\"line\">9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;因此，<code>baseSlice</code>使用<code>length &gt;&gt;&gt; 0</code>的方式保证了length的长度永远在<code>32-bit</code>的范围。即当数字大于2的32次方时候，<code>&gt;&gt;&gt;</code>会崛弃所有大于<code>32-bit</code>的位数部分，即减去<code>Math.pow(2, 32)</code>。而小于范围的数字由于位移的是<code>0</code>则不受任何影响。之后对<code>start</code>也做了一个确保，是因为<code>baseSlice</code>需要截取<code>start</code>这一位到<code>end</code>为止的数组数据，<code>start</code>的数字必须也要确保在<code>length</code>的范围内。</p>\n<h2 id=\"调用优化\"><a href=\"#调用优化\" class=\"headerlink\" title=\"调用优化\"></a>调用优化</h2><p>&emsp;&emsp;在<code>difference</code>一系列方法源码的时候，<code>lodash</code>都使用<code>baseRest</code>引导使用的函数重新绑定了作用域到<code>lodash</code>的<code>_</code>上。而在<code>baseRest</code>中，都统一调用了一个<code>setToString</code>方法，它能让传入的函数都拥有一个<code>toString</code>方法，调用能够直接看到传入函数的函数体，即看到该函数的代码。这在后续的一些需要传入函数的方法中方便使用者调试起到了非常重要的作用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The base implementation of `_.rest` which doesn't validate or coerce arguments.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>func The function to apply a rest parameter to.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[start=func.length-1] The start position of the rest parameter.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@returns <span class=\"type\">&#123;Function&#125;</span> </span>Returns the new function.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseRest</span>(<span class=\"params\">func, start</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setToString(overRest(func, start, identity), func + <span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Sets the `toString` method of `func` to return `string`.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@private</span></span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>func The function to modify.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>string The `toString` result.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@returns <span class=\"type\">&#123;Function&#125;</span> </span>Returns `func`.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> setToString = shortOut(baseSetToString);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;但我重点关注的其实是<code>shortOut</code>这个函数的代码，很有意思，我们来看一下源码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Used to detect hot functions by number of calls within a span of milliseconds. */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> HOT_COUNT = <span class=\"number\">800</span>,</span><br><span class=\"line\">    HOT_SPAN = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Creates a function that'll short out and invoke `identity` instead</span></span><br><span class=\"line\"><span class=\"comment\">  * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`</span></span><br><span class=\"line\"><span class=\"comment\">  * milliseconds.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>func The function to restrict.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@returns <span class=\"type\">&#123;Function&#125;</span> </span>Returns the new shortable function.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shortOut</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>,</span><br><span class=\"line\">    lastCalled = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// nativeNow 即 Date.now</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> stamp = nativeNow(),</span><br><span class=\"line\">            remaining = HOT_SPAN - (stamp - lastCalled);</span><br><span class=\"line\"></span><br><span class=\"line\">        lastCalled = stamp;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remaining &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (++count &gt;= HOT_COUNT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"literal\">undefined</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;该方法实际上是使用了一个闭包包裹了一下传入的函数，记录下了函数调用次数<code>count</code>以及上次调用时间<code>lastCalled</code>。并针对这两个数值，对常用函数调用做了一个调用限制的优化。</p>\n<p>&emsp;&emsp;我们可以看到，在每次调用函数前，这个方法都会利用<code>Date.now</code>去记录一下<strong>当前调用的时间</strong>，并且和<strong>上一次调动该函数时间(lastCalled)</strong>进行一个比较。当这个差值大于<code>HOT_SPAN</code>(当前版本是16，即16ms)的时候，使用apply调用并清空<code>调用次数(count)</code>为0。当差值小于<code>HOT_SPAN</code>，即两次函数调用之间时间小于<code>HOT_SPAN</code>，而且调用次数大于<code>HOT_COUNT(当前版本为800，即800次)</code>，就停止调用该函数，而是返回函数入参的第一项，根据注释，这第一项应该是一个函数的<code>identity</code>。</p>\n<p>&emsp;&emsp;上面有提到过，在诸如<code>setToString</code>这样的报错机制处理时，使用了<code>shortOut</code>方法进行一个<code>高阶函数</code>的包装。<code>setToString</code>这个函数本身就是为了服务<code>lodash</code>的一些报错机制，让传入的函数都能拥有得到函数体代码的<code>toString</code>方法，这样可以保证在大批量数据处理的时候，根据不同的性能情况，进行不同的容错处理。</p>"},{"title":"不定期更新的源码阅读日常——lodash-2","date":"2020-01-10T13:00:00.000Z","_content":"&emsp;&emsp;今天我们来读lodash的深拷贝部分代码。\n<!--more-->\n&emsp;&emsp;lodash的`clone`和`cloneDeep`两个方法分别对应`浅拷贝`和`深拷贝`。两个函数其实都依赖于`baseClone`方法，通过传入一个`标识`来进行深拷贝或者浅拷贝的区分，我们来简单看一下`baseClone`的入参。\n\n```javascript\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n  \nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\n/**\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // ... 暂时省略内容代码\n}\n```\n来看下函数`baseClone`的入参：\n1. `value`代表需要进行拷贝的对象。\n2. `bitmask`就是深浅拷贝的一个标识，我们可以看到`clone`传入的是4，`cloneDeep`传入的为`1 | 4`为5。\n3. `customizer`这个参数是为`cloneWith`的api进行服务的，是自定义的一个`clone`函数，与深拷贝无关，这里我们先忽略。\n4. `key`对应的为当前拷贝对象的`key`，这是后续递归调用拷贝对象值的时候所用到的。\n5. `object`对应的为`value`的所属对象，也是后续递归所用到的。\n6. `stack`为一个类似于Map数据结构的数组，它以一个二维数组的形式，保存了每次需要进行克隆的值和返回的值，即保存为`[value, result]`的形式。具体的作用到函数代码分析中去查看。\n\n&emsp;&emsp;`baseClone`的深拷贝部分逻辑总体思路很简单，当判断为**基本类型**的时候，直接返回返回需要拷贝的对象。当为**引用类型**的时候，根据为数组或者对象，进行一个循环，递归使用`baseClone`继续进行拷贝，直到基本的数据类型为止。但这种思路会产生一个问题，当两个对象循环引用的时候，代码会无限循环下去，就如下面这种情况:\n```javascript\nvar a = {};\nvar b = { result: a };\na.result = b;\n// a.result.result.result.result.result ....\n```\n&emsp;&emsp;因此`baseClone`中使用`stack`维护了一个每次拷贝的`value`对象数组。每次拷贝值前，先判断`value`是否已经存在过了，如果存在，不继续进行遍历拷贝，直接返回`value`的值。\n\n&emsp;&emsp;了解了深拷贝的总体思路和需要注意的点之后，我们来一点点看`baseClone`的代码。首先是第一部分，标识的创建，和**基本类型**值的返回。\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG;\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n  if (!isObject(value)) {\n    return value;\n  }\n  // ... 省略diamante\n}\n\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n```\n&emsp;&emsp;这里省略掉了源码中关于`customizer`部分的逻辑影响，只留下深拷贝的逻辑。这里初始化了一个`result`返回值，以及`isDeep`来标识当前函数是否是一个深拷贝的表示。这里的`CLONE_DEEP_FLAG`我们在第一部分中得知值为`1`。整数去`& 1`会根据整数为奇偶，会得到`0`或者`1`的结果。奇数为`1`，偶数为`0`。`cloneDeep`传入的`bitmask`为5，`clone`则为4，这里会根据对应的函数，生成一个0/1的`isDeep`的标识。接着通过`isObject`函数进行判断，如果不是**引用类型**的值，直接返回。\n\n&emsp;&emsp;接下来就是**根据数据类型**进行对应的拷贝初始化。\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // ... 省略的第一部分逻辑\n  var isArr = isArray(value);\n  if (isArr) {\n    // 数组进行数组拷贝初始化\n    result = initCloneArray(value);\n  } else {\n    // 得到数据类型标识 如 undefined 就是 undefinedTag\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n    // isBuffer 类型直接cloneBuffer返回值\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    // 对象或者类数组对象(args/arrayLike)，在这里通过initCloneObject初始化克隆值\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n    } else {\n      // 如果不是能够进行拷贝的数据类型，根据是否存在父对象，直接返回value或者空对象\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      // 其他类型，如Set/Map根据tag去对应的初始化\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // ... 省略的下半部分逻辑\n}\n```\n&emsp;&emsp;这里逻辑根据数据类型做了一个初始化值的操作。数组使用了`initCloneArray`，对象（包括类数组对象），使用了`initCloneObject`，`isBuffer`则通过`cloneBuffer`直接返回了结果。这里的两个初始化值其实是做了一些特殊边界的兼容（如`initCloneArray`做了对`RegExp#exec`特殊值的处理）。这里可以简单的理解为，`initCloneArray`就是创建了一个空数组，`initCloneObject`就是创建了一个空对象。\n\n&emsp;&emsp;接着便是对`stack`的操作，来解决循环引用无限递归的问题。\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // ... 省略的1，2部分逻辑\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  // ... 省略的下部分逻辑\n}\n```\n\n&emsp;&emsp;前面提到了，Stack是一个类似于Map的二维数组结构：`[[value1, result1], [value2, result2]]`。这里当`stack`不存在的时候，会初始化一个`Stack`。然后查看是否存在当前`value`的`result`了。如果存在，那么直接返回`result`。否则就注册一个`[result, value]`进入`Stack`。\n\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // 省略上面部分代码\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n    return result;\n  }\n\n  var keysFunc = isFull\n    // 处理特殊对象（是否得到继承的keys），把对象的keys生成一个数组\n    // getAllKeysIn -> Creates an array of own and inherited enumerable property names and\n    // getAllKeys -> Creates an array of own enumerable property names and symbols of `object`.\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n```\n\n&emsp;&emsp;最后，根据`set/map/object/array`去转换对应的数组循环格式，去循环递归的调用`baseClone`，直到到**基本类型**的值为止，完成深拷贝的赋值。","source":"_posts/lodash/sourceCode_lodash_2.md","raw":"---\ntitle: 不定期更新的源码阅读日常——lodash-2\ndate: 2020/1/10 21:00:00\ncategories:\n- [前端, lodash]\ntags:\n- lodash\n- 源码阅读\n---\n&emsp;&emsp;今天我们来读lodash的深拷贝部分代码。\n<!--more-->\n&emsp;&emsp;lodash的`clone`和`cloneDeep`两个方法分别对应`浅拷贝`和`深拷贝`。两个函数其实都依赖于`baseClone`方法，通过传入一个`标识`来进行深拷贝或者浅拷贝的区分，我们来简单看一下`baseClone`的入参。\n\n```javascript\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n  \nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\n/**\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // ... 暂时省略内容代码\n}\n```\n来看下函数`baseClone`的入参：\n1. `value`代表需要进行拷贝的对象。\n2. `bitmask`就是深浅拷贝的一个标识，我们可以看到`clone`传入的是4，`cloneDeep`传入的为`1 | 4`为5。\n3. `customizer`这个参数是为`cloneWith`的api进行服务的，是自定义的一个`clone`函数，与深拷贝无关，这里我们先忽略。\n4. `key`对应的为当前拷贝对象的`key`，这是后续递归调用拷贝对象值的时候所用到的。\n5. `object`对应的为`value`的所属对象，也是后续递归所用到的。\n6. `stack`为一个类似于Map数据结构的数组，它以一个二维数组的形式，保存了每次需要进行克隆的值和返回的值，即保存为`[value, result]`的形式。具体的作用到函数代码分析中去查看。\n\n&emsp;&emsp;`baseClone`的深拷贝部分逻辑总体思路很简单，当判断为**基本类型**的时候，直接返回返回需要拷贝的对象。当为**引用类型**的时候，根据为数组或者对象，进行一个循环，递归使用`baseClone`继续进行拷贝，直到基本的数据类型为止。但这种思路会产生一个问题，当两个对象循环引用的时候，代码会无限循环下去，就如下面这种情况:\n```javascript\nvar a = {};\nvar b = { result: a };\na.result = b;\n// a.result.result.result.result.result ....\n```\n&emsp;&emsp;因此`baseClone`中使用`stack`维护了一个每次拷贝的`value`对象数组。每次拷贝值前，先判断`value`是否已经存在过了，如果存在，不继续进行遍历拷贝，直接返回`value`的值。\n\n&emsp;&emsp;了解了深拷贝的总体思路和需要注意的点之后，我们来一点点看`baseClone`的代码。首先是第一部分，标识的创建，和**基本类型**值的返回。\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG;\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n  if (!isObject(value)) {\n    return value;\n  }\n  // ... 省略diamante\n}\n\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n```\n&emsp;&emsp;这里省略掉了源码中关于`customizer`部分的逻辑影响，只留下深拷贝的逻辑。这里初始化了一个`result`返回值，以及`isDeep`来标识当前函数是否是一个深拷贝的表示。这里的`CLONE_DEEP_FLAG`我们在第一部分中得知值为`1`。整数去`& 1`会根据整数为奇偶，会得到`0`或者`1`的结果。奇数为`1`，偶数为`0`。`cloneDeep`传入的`bitmask`为5，`clone`则为4，这里会根据对应的函数，生成一个0/1的`isDeep`的标识。接着通过`isObject`函数进行判断，如果不是**引用类型**的值，直接返回。\n\n&emsp;&emsp;接下来就是**根据数据类型**进行对应的拷贝初始化。\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // ... 省略的第一部分逻辑\n  var isArr = isArray(value);\n  if (isArr) {\n    // 数组进行数组拷贝初始化\n    result = initCloneArray(value);\n  } else {\n    // 得到数据类型标识 如 undefined 就是 undefinedTag\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n    // isBuffer 类型直接cloneBuffer返回值\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    // 对象或者类数组对象(args/arrayLike)，在这里通过initCloneObject初始化克隆值\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n    } else {\n      // 如果不是能够进行拷贝的数据类型，根据是否存在父对象，直接返回value或者空对象\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      // 其他类型，如Set/Map根据tag去对应的初始化\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // ... 省略的下半部分逻辑\n}\n```\n&emsp;&emsp;这里逻辑根据数据类型做了一个初始化值的操作。数组使用了`initCloneArray`，对象（包括类数组对象），使用了`initCloneObject`，`isBuffer`则通过`cloneBuffer`直接返回了结果。这里的两个初始化值其实是做了一些特殊边界的兼容（如`initCloneArray`做了对`RegExp#exec`特殊值的处理）。这里可以简单的理解为，`initCloneArray`就是创建了一个空数组，`initCloneObject`就是创建了一个空对象。\n\n&emsp;&emsp;接着便是对`stack`的操作，来解决循环引用无限递归的问题。\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // ... 省略的1，2部分逻辑\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  // ... 省略的下部分逻辑\n}\n```\n\n&emsp;&emsp;前面提到了，Stack是一个类似于Map的二维数组结构：`[[value1, result1], [value2, result2]]`。这里当`stack`不存在的时候，会初始化一个`Stack`。然后查看是否存在当前`value`的`result`了。如果存在，那么直接返回`result`。否则就注册一个`[result, value]`进入`Stack`。\n\n```javascript\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  // 省略上面部分代码\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n    return result;\n  }\n\n  var keysFunc = isFull\n    // 处理特殊对象（是否得到继承的keys），把对象的keys生成一个数组\n    // getAllKeysIn -> Creates an array of own and inherited enumerable property names and\n    // getAllKeys -> Creates an array of own enumerable property names and symbols of `object`.\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n```\n\n&emsp;&emsp;最后，根据`set/map/object/array`去转换对应的数组循环格式，去循环递归的调用`baseClone`，直到到**基本类型**的值为止，完成深拷贝的赋值。","slug":"lodash/sourceCode_lodash_2","published":1,"updated":"2020-06-11T01:43:32.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxl000p9r2v507ot6zu","content":"<p>&emsp;&emsp;今天我们来读lodash的深拷贝部分代码。<br><a id=\"more\"></a><br>&emsp;&emsp;lodash的<code>clone</code>和<code>cloneDeep</code>两个方法分别对应<code>浅拷贝</code>和<code>深拷贝</code>。两个函数其实都依赖于<code>baseClone</code>方法，通过传入一个<code>标识</code>来进行深拷贝或者浅拷贝的区分，我们来简单看一下<code>baseClone</code>的入参。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** Used to compose bitmasks for cloning. */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> CLONE_DEEP_FLAG = <span class=\"hljs-number\">1</span>,</span><br><span class=\"line\">    CLONE_FLAT_FLAG = <span class=\"hljs-number\">2</span>,</span><br><span class=\"line\">    CLONE_SYMBOLS_FLAG = <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clone</span>(<span class=\"hljs-params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> baseClone(value, CLONE_SYMBOLS_FLAG);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cloneDeep</span>(<span class=\"hljs-params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;*&#125;</span> </span>value The value to clone.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;boolean&#125;</span> </span>bitmask The bitmask flags.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> *  1 - Deep clone</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> *  2 - Flatten inherited properties</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> *  4 - Clone symbols</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>[customizer] The function to customize cloning.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;string&#125;</span> </span>[key] The key of `value`.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Object&#125;</span> </span>[object] The parent object of `value`.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Object&#125;</span> </span>[stack] Tracks traversed objects and their clone counterparts.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;*&#125;</span> </span>Returns the cloned value.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseClone</span>(<span class=\"hljs-params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 暂时省略内容代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看下函数<code>baseClone</code>的入参：</p>\n<ol>\n<li><code>value</code>代表需要进行拷贝的对象。</li>\n<li><code>bitmask</code>就是深浅拷贝的一个标识，我们可以看到<code>clone</code>传入的是4，<code>cloneDeep</code>传入的为<code>1 | 4</code>为5。</li>\n<li><code>customizer</code>这个参数是为<code>cloneWith</code>的api进行服务的，是自定义的一个<code>clone</code>函数，与深拷贝无关，这里我们先忽略。</li>\n<li><code>key</code>对应的为当前拷贝对象的<code>key</code>，这是后续递归调用拷贝对象值的时候所用到的。</li>\n<li><code>object</code>对应的为<code>value</code>的所属对象，也是后续递归所用到的。</li>\n<li><code>stack</code>为一个类似于Map数据结构的数组，它以一个二维数组的形式，保存了每次需要进行克隆的值和返回的值，即保存为<code>[value, result]</code>的形式。具体的作用到函数代码分析中去查看。</li>\n</ol>\n<p>&emsp;&emsp;<code>baseClone</code>的深拷贝部分逻辑总体思路很简单，当判断为<strong>基本类型</strong>的时候，直接返回返回需要拷贝的对象。当为<strong>引用类型</strong>的时候，根据为数组或者对象，进行一个循环，递归使用<code>baseClone</code>继续进行拷贝，直到基本的数据类型为止。但这种思路会产生一个问题，当两个对象循环引用的时候，代码会无限循环下去，就如下面这种情况:<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> b = &#123; <span class=\"hljs-attr\">result</span>: a &#125;;</span><br><span class=\"line\">a.result = b;</span><br><span class=\"line\"><span class=\"hljs-comment\">// a.result.result.result.result.result ....</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;因此<code>baseClone</code>中使用<code>stack</code>维护了一个每次拷贝的<code>value</code>对象数组。每次拷贝值前，先判断<code>value</code>是否已经存在过了，如果存在，不继续进行遍历拷贝，直接返回<code>value</code>的值。</p>\n<p>&emsp;&emsp;了解了深拷贝的总体思路和需要注意的点之后，我们来一点点看<code>baseClone</code>的代码。首先是第一部分，标识的创建，和<strong>基本类型</strong>值的返回。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseClone</span>(<span class=\"hljs-params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> result,</span><br><span class=\"line\">      isDeep = bitmask &amp; CLONE_DEEP_FLAG;</span><br><span class=\"line\">      isFlat = bitmask &amp; CLONE_FLAT_FLAG,</span><br><span class=\"line\">      isFull = bitmask &amp; CLONE_SYMBOLS_FLAG;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!isObject(value)) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略diamante</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isObject</span>(<span class=\"hljs-params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> type = <span class=\"hljs-keyword\">typeof</span> value;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> value != <span class=\"hljs-literal\">null</span> &amp;&amp; (type == <span class=\"hljs-string\">'object'</span> || type == <span class=\"hljs-string\">'function'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里省略掉了源码中关于<code>customizer</code>部分的逻辑影响，只留下深拷贝的逻辑。这里初始化了一个<code>result</code>返回值，以及<code>isDeep</code>来标识当前函数是否是一个深拷贝的表示。这里的<code>CLONE_DEEP_FLAG</code>我们在第一部分中得知值为<code>1</code>。整数去<code>&amp; 1</code>会根据整数为奇偶，会得到<code>0</code>或者<code>1</code>的结果。奇数为<code>1</code>，偶数为<code>0</code>。<code>cloneDeep</code>传入的<code>bitmask</code>为5，<code>clone</code>则为4，这里会根据对应的函数，生成一个0/1的<code>isDeep</code>的标识。接着通过<code>isObject</code>函数进行判断，如果不是<strong>引用类型</strong>的值，直接返回。</p>\n<p>&emsp;&emsp;接下来就是<strong>根据数据类型</strong>进行对应的拷贝初始化。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseClone</span>(<span class=\"hljs-params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略的第一部分逻辑</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> isArr = isArray(value);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isArr) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 数组进行数组拷贝初始化</span></span><br><span class=\"line\">    result = initCloneArray(value);</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 得到数据类型标识 如 undefined 就是 undefinedTag</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> tag = getTag(value),</span><br><span class=\"line\">        isFunc = tag == funcTag || tag == genTag;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// isBuffer 类型直接cloneBuffer返回值</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (isBuffer(value)) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> cloneBuffer(value, isDeep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 对象或者类数组对象(args/arrayLike)，在这里通过initCloneObject初始化克隆值</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123;</span><br><span class=\"line\">      result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value);</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 如果不是能够进行拷贝的数据类型，根据是否存在父对象，直接返回value或者空对象</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (!cloneableTags[tag]) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> object ? value : &#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 其他类型，如Set/Map根据tag去对应的初始化</span></span><br><span class=\"line\">      result = initCloneByTag(value, tag, isDeep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略的下半部分逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里逻辑根据数据类型做了一个初始化值的操作。数组使用了<code>initCloneArray</code>，对象（包括类数组对象），使用了<code>initCloneObject</code>，<code>isBuffer</code>则通过<code>cloneBuffer</code>直接返回了结果。这里的两个初始化值其实是做了一些特殊边界的兼容（如<code>initCloneArray</code>做了对<code>RegExp#exec</code>特殊值的处理）。这里可以简单的理解为，<code>initCloneArray</code>就是创建了一个空数组，<code>initCloneObject</code>就是创建了一个空对象。</p>\n<p>&emsp;&emsp;接着便是对<code>stack</code>的操作，来解决循环引用无限递归的问题。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseClone</span>(<span class=\"hljs-params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略的1，2部分逻辑</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// Check for circular references and return its corresponding clone.</span></span><br><span class=\"line\">  stack || (stack = <span class=\"hljs-keyword\">new</span> Stack);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> stacked = stack.get(value);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (stacked) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> stacked;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stack.set(value, result);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略的下部分逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;前面提到了，Stack是一个类似于Map的二维数组结构：<code>[[value1, result1], [value2, result2]]</code>。这里当<code>stack</code>不存在的时候，会初始化一个<code>Stack</code>。然后查看是否存在当前<code>value</code>的<code>result</code>了。如果存在，那么直接返回<code>result</code>。否则就注册一个<code>[result, value]</code>进入<code>Stack</code>。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baseClone</span>(<span class=\"hljs-params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 省略上面部分代码</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isSet(value)) &#123;</span><br><span class=\"line\">    value.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">subValue</span>) </span>&#123;</span><br><span class=\"line\">      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isMap(value)) &#123;</span><br><span class=\"line\">    value.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">subValue, key</span>) </span>&#123;</span><br><span class=\"line\">      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> keysFunc = isFull</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 处理特殊对象（是否得到继承的keys），把对象的keys生成一个数组</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// getAllKeysIn -&gt; Creates an array of own and inherited enumerable property names and</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// getAllKeys -&gt; Creates an array of own enumerable property names and symbols of `object`.</span></span><br><span class=\"line\">    ? (isFlat ? getAllKeysIn : getAllKeys)</span><br><span class=\"line\">    : (isFlat ? keysIn : keys);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> props = isArr ? <span class=\"hljs-literal\">undefined</span> : keysFunc(value);</span><br><span class=\"line\">  arrayEach(props || value, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">subValue, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (props) &#123;</span><br><span class=\"line\">      key = subValue;</span><br><span class=\"line\">      subValue = value[key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Recursively populate clone (susceptible to call stack limits).</span></span><br><span class=\"line\">    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后，根据<code>set/map/object/array</code>去转换对应的数组循环格式，去循环递归的调用<code>baseClone</code>，直到到<strong>基本类型</strong>的值为止，完成深拷贝的赋值。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;今天我们来读lodash的深拷贝部分代码。<br></p>","more":"<br>&emsp;&emsp;lodash的<code>clone</code>和<code>cloneDeep</code>两个方法分别对应<code>浅拷贝</code>和<code>深拷贝</code>。两个函数其实都依赖于<code>baseClone</code>方法，通过传入一个<code>标识</code>来进行深拷贝或者浅拷贝的区分，我们来简单看一下<code>baseClone</code>的入参。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Used to compose bitmasks for cloning. */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> CLONE_DEEP_FLAG = <span class=\"number\">1</span>,</span><br><span class=\"line\">    CLONE_FLAT_FLAG = <span class=\"number\">2</span>,</span><br><span class=\"line\">    CLONE_SYMBOLS_FLAG = <span class=\"number\">4</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseClone(value, CLONE_SYMBOLS_FLAG);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>value The value to clone.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;boolean&#125;</span> </span>bitmask The bitmask flags.</span></span><br><span class=\"line\"><span class=\"comment\"> *  1 - Deep clone</span></span><br><span class=\"line\"><span class=\"comment\"> *  2 - Flatten inherited properties</span></span><br><span class=\"line\"><span class=\"comment\"> *  4 - Clone symbols</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>[customizer] The function to customize cloning.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[key] The key of `value`.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>[object] The parent object of `value`.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>[stack] Tracks traversed objects and their clone counterparts.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;*&#125;</span> </span>Returns the cloned value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 暂时省略内容代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看下函数<code>baseClone</code>的入参：</p>\n<ol>\n<li><code>value</code>代表需要进行拷贝的对象。</li>\n<li><code>bitmask</code>就是深浅拷贝的一个标识，我们可以看到<code>clone</code>传入的是4，<code>cloneDeep</code>传入的为<code>1 | 4</code>为5。</li>\n<li><code>customizer</code>这个参数是为<code>cloneWith</code>的api进行服务的，是自定义的一个<code>clone</code>函数，与深拷贝无关，这里我们先忽略。</li>\n<li><code>key</code>对应的为当前拷贝对象的<code>key</code>，这是后续递归调用拷贝对象值的时候所用到的。</li>\n<li><code>object</code>对应的为<code>value</code>的所属对象，也是后续递归所用到的。</li>\n<li><code>stack</code>为一个类似于Map数据结构的数组，它以一个二维数组的形式，保存了每次需要进行克隆的值和返回的值，即保存为<code>[value, result]</code>的形式。具体的作用到函数代码分析中去查看。</li>\n</ol>\n<p>&emsp;&emsp;<code>baseClone</code>的深拷贝部分逻辑总体思路很简单，当判断为<strong>基本类型</strong>的时候，直接返回返回需要拷贝的对象。当为<strong>引用类型</strong>的时候，根据为数组或者对象，进行一个循环，递归使用<code>baseClone</code>继续进行拷贝，直到基本的数据类型为止。但这种思路会产生一个问题，当两个对象循环引用的时候，代码会无限循环下去，就如下面这种情况:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123; <span class=\"attr\">result</span>: a &#125;;</span><br><span class=\"line\">a.result = b;</span><br><span class=\"line\"><span class=\"comment\">// a.result.result.result.result.result ....</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;因此<code>baseClone</code>中使用<code>stack</code>维护了一个每次拷贝的<code>value</code>对象数组。每次拷贝值前，先判断<code>value</code>是否已经存在过了，如果存在，不继续进行遍历拷贝，直接返回<code>value</code>的值。</p>\n<p>&emsp;&emsp;了解了深拷贝的总体思路和需要注意的点之后，我们来一点点看<code>baseClone</code>的代码。首先是第一部分，标识的创建，和<strong>基本类型</strong>值的返回。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result,</span><br><span class=\"line\">      isDeep = bitmask &amp; CLONE_DEEP_FLAG;</span><br><span class=\"line\">      isFlat = bitmask &amp; CLONE_FLAT_FLAG,</span><br><span class=\"line\">      isFull = bitmask &amp; CLONE_SYMBOLS_FLAG;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略diamante</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> type = <span class=\"keyword\">typeof</span> value;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> &amp;&amp; (type == <span class=\"string\">'object'</span> || type == <span class=\"string\">'function'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里省略掉了源码中关于<code>customizer</code>部分的逻辑影响，只留下深拷贝的逻辑。这里初始化了一个<code>result</code>返回值，以及<code>isDeep</code>来标识当前函数是否是一个深拷贝的表示。这里的<code>CLONE_DEEP_FLAG</code>我们在第一部分中得知值为<code>1</code>。整数去<code>&amp; 1</code>会根据整数为奇偶，会得到<code>0</code>或者<code>1</code>的结果。奇数为<code>1</code>，偶数为<code>0</code>。<code>cloneDeep</code>传入的<code>bitmask</code>为5，<code>clone</code>则为4，这里会根据对应的函数，生成一个0/1的<code>isDeep</code>的标识。接着通过<code>isObject</code>函数进行判断，如果不是<strong>引用类型</strong>的值，直接返回。</p>\n<p>&emsp;&emsp;接下来就是<strong>根据数据类型</strong>进行对应的拷贝初始化。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略的第一部分逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isArr = isArray(value);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isArr) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数组进行数组拷贝初始化</span></span><br><span class=\"line\">    result = initCloneArray(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 得到数据类型标识 如 undefined 就是 undefinedTag</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tag = getTag(value),</span><br><span class=\"line\">        isFunc = tag == funcTag || tag == genTag;</span><br><span class=\"line\">    <span class=\"comment\">// isBuffer 类型直接cloneBuffer返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isBuffer(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cloneBuffer(value, isDeep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对象或者类数组对象(args/arrayLike)，在这里通过initCloneObject初始化克隆值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123;</span><br><span class=\"line\">      result = (isFlat || isFunc) ? &#123;&#125; : initCloneObject(value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不是能够进行拷贝的数据类型，根据是否存在父对象，直接返回value或者空对象</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cloneableTags[tag]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object ? value : &#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 其他类型，如Set/Map根据tag去对应的初始化</span></span><br><span class=\"line\">      result = initCloneByTag(value, tag, isDeep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略的下半部分逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里逻辑根据数据类型做了一个初始化值的操作。数组使用了<code>initCloneArray</code>，对象（包括类数组对象），使用了<code>initCloneObject</code>，<code>isBuffer</code>则通过<code>cloneBuffer</code>直接返回了结果。这里的两个初始化值其实是做了一些特殊边界的兼容（如<code>initCloneArray</code>做了对<code>RegExp#exec</code>特殊值的处理）。这里可以简单的理解为，<code>initCloneArray</code>就是创建了一个空数组，<code>initCloneObject</code>就是创建了一个空对象。</p>\n<p>&emsp;&emsp;接着便是对<code>stack</code>的操作，来解决循环引用无限递归的问题。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略的1，2部分逻辑</span></span><br><span class=\"line\">  <span class=\"comment\">// Check for circular references and return its corresponding clone.</span></span><br><span class=\"line\">  stack || (stack = <span class=\"keyword\">new</span> Stack);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stacked = stack.get(value);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stacked) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stacked;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stack.set(value, result);</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略的下部分逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;前面提到了，Stack是一个类似于Map的二维数组结构：<code>[[value1, result1], [value2, result2]]</code>。这里当<code>stack</code>不存在的时候，会初始化一个<code>Stack</code>。然后查看是否存在当前<code>value</code>的<code>result</code>了。如果存在，那么直接返回<code>result</code>。否则就注册一个<code>[result, value]</code>进入<code>Stack</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">value, bitmask, customizer, key, object, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略上面部分代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSet(value)) &#123;</span><br><span class=\"line\">    value.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subValue</span>) </span>&#123;</span><br><span class=\"line\">      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isMap(value)) &#123;</span><br><span class=\"line\">    value.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subValue, key</span>) </span>&#123;</span><br><span class=\"line\">      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> keysFunc = isFull</span><br><span class=\"line\">    <span class=\"comment\">// 处理特殊对象（是否得到继承的keys），把对象的keys生成一个数组</span></span><br><span class=\"line\">    <span class=\"comment\">// getAllKeysIn -&gt; Creates an array of own and inherited enumerable property names and</span></span><br><span class=\"line\">    <span class=\"comment\">// getAllKeys -&gt; Creates an array of own enumerable property names and symbols of `object`.</span></span><br><span class=\"line\">    ? (isFlat ? getAllKeysIn : getAllKeys)</span><br><span class=\"line\">    : (isFlat ? keysIn : keys);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> props = isArr ? <span class=\"literal\">undefined</span> : keysFunc(value);</span><br><span class=\"line\">  arrayEach(props || value, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">subValue, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (props) &#123;</span><br><span class=\"line\">      key = subValue;</span><br><span class=\"line\">      subValue = value[key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Recursively populate clone (susceptible to call stack limits).</span></span><br><span class=\"line\">    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后，根据<code>set/map/object/array</code>去转换对应的数组循环格式，去循环递归的调用<code>baseClone</code>，直到到<strong>基本类型</strong>的值为止，完成深拷贝的赋值。</p>"},{"title":"package.json里面有啥","date":"2019-04-05T06:00:00.000Z","_content":"## 前言\n&emsp;&emsp;今年的2月19日是令我印象深刻的一天，不是因为这天是元宵节，而是因为这天晚上9点我生平头一回直面阿里面试官的面试，问倒了我一半问题。\n&emsp;&emsp;在前端工程化部分他问了我两个问题：\n1. 你知道`1，表示什么版本吗?\n2. depends有四种依赖形式，你知道他们分别是什么吗？知道哪一种depends不会被安装吗?\n\n&emsp;&emsp;对这方面仅仅是了解的我，愣是一个没答上来。\n&emsp;&emsp;今天趁着清明假期，整理一下package.json当中到底有些什么。\n<!--more-->\n## Package.json是个啥\n&emsp;&emsp;package.json到底是啥，它就是一个json文件呗，放在项目的主目录下面。\n那么这个json文件到底用来干嘛，它是用来描述这个项目**相关的一切信息**，方便诸如在npm上发布项目包，使用npm安装项目包依赖。简而言之，就是按照规范写给npm的项目的说明书。让npm根据这份说明书去进行具体的逻辑操作。\n&emsp;&emsp;你可以使用`npm init`命令来创建一个初始化的package.json项目包。\n## 包发布相关字段\n&emsp;&emsp;包发布相关字段，指这些字段用于描述你的项目，以便在npm上面能够查询和使用。\n&emsp;&emsp;核心字段**name、version**。按照npm文档上面的描述，`the most important things in your package.json are the name and version fields as they will be required`。这两个字段是必须的，也是最重要的。用于描述你包的名字和版本号。其他的都可以不要。\n&emsp;&emsp;其中，**name**建议使用`@pacakname/module`的方式进行命名，以免重复。比如babel的包，就采用`@babel/core`这样的@包名/模块名的方式来进行命名。而react就很任性的使用`react-dom`这种`-`的方式来进行命名。\n&emsp;&emsp;**version**则建议使用1.0.0，三段式进行声明，意思为大版本.小版本.小修复。基本上小的一些bug修复都只改第三个数字，兼容这一版本的一些改动，会去修改第二个的小版本号。如果是极大的影响架构兼容性的改动，就放到大版本号。比如著名的angular1到angular2的颠覆式修改。这里的数字就是大版本号。(ps，这也就是angular成为垫底前端框架原因之一吧)。\n## 包描述相关字段\n&emsp;&emsp;这些字段是用来描述你的包一些相关信息，以便在npm上面可以使用标签等搜索到你的包，也可以介绍包的一些相关情况。\n&emsp;&emsp;**description**和**keywords**,就等同于html中meta标签的相关字段。用于npm查询的字段，介绍你的表关键词和一些描述。\n&emsp;&emsp;**homepage**、**bugs**、**repository**、**license**和**people fields**。这些都是一些作者信息，仓库主页，提交bug的地方,包采用的开源协议。这里的**people fields**指的是包作者相关的字段，比如**author**，**email**，不是这个字段名叫做peopke。比较简单，所以看一下react的包示例，不多做介绍了。\n```json\n\"homepage\": \"https://reactjs.org/\",\n\"bugs\": {\n    \"url\": \"https://github.com/facebook/react/issues\"\n},\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/facebook/react.git\",\n    \"directory\": \"packages/react\"\n},\n\"license\": \"MIT\",\n```\n## 操作相关字段\n&emsp;&emsp;操作相关指的是npm在进行包读取或者指令运行时候，设置的一些相关字段。\n- **main**字段接的是一个文件路径的字符串。值得是你这个包引入的时候，主入口是哪里。比如你填写`\"main\": \"./app.js\"`，你的包名为`exm`。那么当别人require或者import你的包的时候，npm会根据这个main字段去自动的查找这个主入口文件。即`require('exm')`，相当于`require('exm/app.js')`。\n- **bin**字段会创建一个bash的全局链接到该字段下设置的路径当中。创建的地方跟随系统的不同而不同。比如使用`{ \"bin\" : { \"myapp\" : \"./cli.js\" } }`，在linux系统下面会创建一个/usr/local/bin/myapp的软链接到cli.js文件当中。\n- **scripts**字段应该是常用字段了，它能够自定义一段脚本，当你使用`npm run 你定义的key`的时候，就能够跑对应的指令。这样就可以避免老是去敲打很多长串的指令。比如：\n```json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n}\n```\n  当我运行`npm run test`的时候，实际上运行`echo \\\"Error: no test specified\\\" && exit 1`的指令。很多包的指令是npm run start，现在就可以去scripts字段当中去看看，实际上到底运行了什么指令了。\n\n## 依赖相关字段\n&emsp;&emsp;依赖相关就是dependencies，也就是上面的我的那两道面试题了。简单来说，你的包依赖了那些npm上的其他轮子，就会定义在dependencies当中。dependencies分为4种，其中比较重要的就是**dependencies**和**devDependencies**。dependencies表现形式就是一个**包名**和**版本号**的**映射对象**。下例：\n```json\n\"dependencies\": {\n    \"loose-envify\": \"^1.1.0\",\n},\n```\n**dependencies**和**devDependencies**区别就是一个运行态(product)的打包相关依赖，另一个是开发状态(dev)的打包相关依赖。举个很简单的例子，比如我在开发状态会用到`babel`包的一些编译，诸如`css-loader`用来处理css的打包工具，这些只有在**开发**的时候才会被需要，而如果用到像`react`这种涉及到整个项目的包，就需要放到dependencies当中去。那么现在你应该知道了，`npm install`的时候，哪个在包中的dependencies不会被安装了吧。\n\n&emsp;&emsp;这里也简单说一下引入包的版本号描述方式。前面说过了，版本号的三个数字分别表示大版本，次版本和小修改号。在项目使用过程当中，很有可能引入的包是需要某个大版本，或者兼容某个版本以下的。所以需要一些特殊的表示符号去表示这些版本号的范围。这里直接拿一下官网上面的例子：\n```json\n{ \"dependencies\" :\n  { \"foo\" : \"1.0.0 - 2.9999.9999\"\n  , \"bar\" : \">=1.0.2 <2.1.2\"\n  , \"baz\" : \">1.0.2 <=2.3.4\"\n  , \"boo\" : \"2.0.1\"\n  , \"qux\" : \"<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0\"\n  , \"asd\" : \"http://asdf.com/asdf.tar.gz\"\n  , \"til\" : \"~1.2\"\n  , \"elf\" : \"~1.2.3\"\n  , \"two\" : \"2.x\"\n  , \"thr\" : \"3.3.x\"\n  , \"lat\" : \"latest\"\n  , \"dyl\" : \"file:../dyl\"\n  }\n}\n```\n\n- `1.1.0` 明确的版本号\n- `>1.1.0` 大于1.1.0的所有版本\n- `>=1.1.0` 大于等于1.1.0的所有版本\n- `<version` 小于1.1.0的所有版本\n- `<=1.1.0` 小于等于1.1.0的所有版本\n- `1.2.x` 表示1.2.下面的任意版本，x为任意版本\n- `~1.1.0` 安装1.1.x 下面最新版本，前两个版本号必须为1.1\n- `^1.1.0` 安装1.x.x 下面最新版本，第一个大版本号必须为1\n- `*` 表示任意版本\n- `\"\"` 空字符串，功能和单个的*一样，表示任意版本\n- `1.1.0 - 1.2.0` 大于1.1.0，小于版本1.2.0\n- `1.1.0 || 1.2.0` 1.1.0或者1.2.0均可\n\n&emsp;&emsp;了解package.json并没有那么难，但这部分知识点属于前端工程化基础知识点，还是需要掌握的。前几天在和同事聊天的时候，发现不少人到现在连lib和src的区别都没搞清楚。平时就执行个`npm install`完成了也就没有过多思考了。还是要多思考，多学习，多总结，争取不做一个curd boy。\n> [本文抽取了一些比较核心的部分，如果想要更多详细内容可以参考npm官方文档](http://caibaojian.com/npm/files/package.json.html)\n","source":"_posts/node/whatDoPackageHave.md","raw":"---\ntitle: package.json里面有啥\ndate: 2019/4/5 14:00\ncategories:\n- [前端, node, npm]\ntags:\n- npm\n- 知识点整理\n---\n## 前言\n&emsp;&emsp;今年的2月19日是令我印象深刻的一天，不是因为这天是元宵节，而是因为这天晚上9点我生平头一回直面阿里面试官的面试，问倒了我一半问题。\n&emsp;&emsp;在前端工程化部分他问了我两个问题：\n1. 你知道`1，表示什么版本吗?\n2. depends有四种依赖形式，你知道他们分别是什么吗？知道哪一种depends不会被安装吗?\n\n&emsp;&emsp;对这方面仅仅是了解的我，愣是一个没答上来。\n&emsp;&emsp;今天趁着清明假期，整理一下package.json当中到底有些什么。\n<!--more-->\n## Package.json是个啥\n&emsp;&emsp;package.json到底是啥，它就是一个json文件呗，放在项目的主目录下面。\n那么这个json文件到底用来干嘛，它是用来描述这个项目**相关的一切信息**，方便诸如在npm上发布项目包，使用npm安装项目包依赖。简而言之，就是按照规范写给npm的项目的说明书。让npm根据这份说明书去进行具体的逻辑操作。\n&emsp;&emsp;你可以使用`npm init`命令来创建一个初始化的package.json项目包。\n## 包发布相关字段\n&emsp;&emsp;包发布相关字段，指这些字段用于描述你的项目，以便在npm上面能够查询和使用。\n&emsp;&emsp;核心字段**name、version**。按照npm文档上面的描述，`the most important things in your package.json are the name and version fields as they will be required`。这两个字段是必须的，也是最重要的。用于描述你包的名字和版本号。其他的都可以不要。\n&emsp;&emsp;其中，**name**建议使用`@pacakname/module`的方式进行命名，以免重复。比如babel的包，就采用`@babel/core`这样的@包名/模块名的方式来进行命名。而react就很任性的使用`react-dom`这种`-`的方式来进行命名。\n&emsp;&emsp;**version**则建议使用1.0.0，三段式进行声明，意思为大版本.小版本.小修复。基本上小的一些bug修复都只改第三个数字，兼容这一版本的一些改动，会去修改第二个的小版本号。如果是极大的影响架构兼容性的改动，就放到大版本号。比如著名的angular1到angular2的颠覆式修改。这里的数字就是大版本号。(ps，这也就是angular成为垫底前端框架原因之一吧)。\n## 包描述相关字段\n&emsp;&emsp;这些字段是用来描述你的包一些相关信息，以便在npm上面可以使用标签等搜索到你的包，也可以介绍包的一些相关情况。\n&emsp;&emsp;**description**和**keywords**,就等同于html中meta标签的相关字段。用于npm查询的字段，介绍你的表关键词和一些描述。\n&emsp;&emsp;**homepage**、**bugs**、**repository**、**license**和**people fields**。这些都是一些作者信息，仓库主页，提交bug的地方,包采用的开源协议。这里的**people fields**指的是包作者相关的字段，比如**author**，**email**，不是这个字段名叫做peopke。比较简单，所以看一下react的包示例，不多做介绍了。\n```json\n\"homepage\": \"https://reactjs.org/\",\n\"bugs\": {\n    \"url\": \"https://github.com/facebook/react/issues\"\n},\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/facebook/react.git\",\n    \"directory\": \"packages/react\"\n},\n\"license\": \"MIT\",\n```\n## 操作相关字段\n&emsp;&emsp;操作相关指的是npm在进行包读取或者指令运行时候，设置的一些相关字段。\n- **main**字段接的是一个文件路径的字符串。值得是你这个包引入的时候，主入口是哪里。比如你填写`\"main\": \"./app.js\"`，你的包名为`exm`。那么当别人require或者import你的包的时候，npm会根据这个main字段去自动的查找这个主入口文件。即`require('exm')`，相当于`require('exm/app.js')`。\n- **bin**字段会创建一个bash的全局链接到该字段下设置的路径当中。创建的地方跟随系统的不同而不同。比如使用`{ \"bin\" : { \"myapp\" : \"./cli.js\" } }`，在linux系统下面会创建一个/usr/local/bin/myapp的软链接到cli.js文件当中。\n- **scripts**字段应该是常用字段了，它能够自定义一段脚本，当你使用`npm run 你定义的key`的时候，就能够跑对应的指令。这样就可以避免老是去敲打很多长串的指令。比如：\n```json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n}\n```\n  当我运行`npm run test`的时候，实际上运行`echo \\\"Error: no test specified\\\" && exit 1`的指令。很多包的指令是npm run start，现在就可以去scripts字段当中去看看，实际上到底运行了什么指令了。\n\n## 依赖相关字段\n&emsp;&emsp;依赖相关就是dependencies，也就是上面的我的那两道面试题了。简单来说，你的包依赖了那些npm上的其他轮子，就会定义在dependencies当中。dependencies分为4种，其中比较重要的就是**dependencies**和**devDependencies**。dependencies表现形式就是一个**包名**和**版本号**的**映射对象**。下例：\n```json\n\"dependencies\": {\n    \"loose-envify\": \"^1.1.0\",\n},\n```\n**dependencies**和**devDependencies**区别就是一个运行态(product)的打包相关依赖，另一个是开发状态(dev)的打包相关依赖。举个很简单的例子，比如我在开发状态会用到`babel`包的一些编译，诸如`css-loader`用来处理css的打包工具，这些只有在**开发**的时候才会被需要，而如果用到像`react`这种涉及到整个项目的包，就需要放到dependencies当中去。那么现在你应该知道了，`npm install`的时候，哪个在包中的dependencies不会被安装了吧。\n\n&emsp;&emsp;这里也简单说一下引入包的版本号描述方式。前面说过了，版本号的三个数字分别表示大版本，次版本和小修改号。在项目使用过程当中，很有可能引入的包是需要某个大版本，或者兼容某个版本以下的。所以需要一些特殊的表示符号去表示这些版本号的范围。这里直接拿一下官网上面的例子：\n```json\n{ \"dependencies\" :\n  { \"foo\" : \"1.0.0 - 2.9999.9999\"\n  , \"bar\" : \">=1.0.2 <2.1.2\"\n  , \"baz\" : \">1.0.2 <=2.3.4\"\n  , \"boo\" : \"2.0.1\"\n  , \"qux\" : \"<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0\"\n  , \"asd\" : \"http://asdf.com/asdf.tar.gz\"\n  , \"til\" : \"~1.2\"\n  , \"elf\" : \"~1.2.3\"\n  , \"two\" : \"2.x\"\n  , \"thr\" : \"3.3.x\"\n  , \"lat\" : \"latest\"\n  , \"dyl\" : \"file:../dyl\"\n  }\n}\n```\n\n- `1.1.0` 明确的版本号\n- `>1.1.0` 大于1.1.0的所有版本\n- `>=1.1.0` 大于等于1.1.0的所有版本\n- `<version` 小于1.1.0的所有版本\n- `<=1.1.0` 小于等于1.1.0的所有版本\n- `1.2.x` 表示1.2.下面的任意版本，x为任意版本\n- `~1.1.0` 安装1.1.x 下面最新版本，前两个版本号必须为1.1\n- `^1.1.0` 安装1.x.x 下面最新版本，第一个大版本号必须为1\n- `*` 表示任意版本\n- `\"\"` 空字符串，功能和单个的*一样，表示任意版本\n- `1.1.0 - 1.2.0` 大于1.1.0，小于版本1.2.0\n- `1.1.0 || 1.2.0` 1.1.0或者1.2.0均可\n\n&emsp;&emsp;了解package.json并没有那么难，但这部分知识点属于前端工程化基础知识点，还是需要掌握的。前几天在和同事聊天的时候，发现不少人到现在连lib和src的区别都没搞清楚。平时就执行个`npm install`完成了也就没有过多思考了。还是要多思考，多学习，多总结，争取不做一个curd boy。\n> [本文抽取了一些比较核心的部分，如果想要更多详细内容可以参考npm官方文档](http://caibaojian.com/npm/files/package.json.html)\n","slug":"node/whatDoPackageHave","published":1,"updated":"2020-06-11T01:43:32.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxm000s9r2voxid41dl","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;今年的2月19日是令我印象深刻的一天，不是因为这天是元宵节，而是因为这天晚上9点我生平头一回直面阿里面试官的面试，问倒了我一半问题。<br>&emsp;&emsp;在前端工程化部分他问了我两个问题：</p>\n<ol>\n<li>你知道`1，表示什么版本吗?</li>\n<li>depends有四种依赖形式，你知道他们分别是什么吗？知道哪一种depends不会被安装吗?</li>\n</ol>\n<p>&emsp;&emsp;对这方面仅仅是了解的我，愣是一个没答上来。<br>&emsp;&emsp;今天趁着清明假期，整理一下package.json当中到底有些什么。<br><a id=\"more\"></a></p>\n<h2 id=\"Package-json是个啥\"><a href=\"#Package-json是个啥\" class=\"headerlink\" title=\"Package.json是个啥\"></a>Package.json是个啥</h2><p>&emsp;&emsp;package.json到底是啥，它就是一个json文件呗，放在项目的主目录下面。<br>那么这个json文件到底用来干嘛，它是用来描述这个项目<strong>相关的一切信息</strong>，方便诸如在npm上发布项目包，使用npm安装项目包依赖。简而言之，就是按照规范写给npm的项目的说明书。让npm根据这份说明书去进行具体的逻辑操作。<br>&emsp;&emsp;你可以使用<code>npm init</code>命令来创建一个初始化的package.json项目包。</p>\n<h2 id=\"包发布相关字段\"><a href=\"#包发布相关字段\" class=\"headerlink\" title=\"包发布相关字段\"></a>包发布相关字段</h2><p>&emsp;&emsp;包发布相关字段，指这些字段用于描述你的项目，以便在npm上面能够查询和使用。<br>&emsp;&emsp;核心字段<strong>name、version</strong>。按照npm文档上面的描述，<code>the most important things in your package.json are the name and version fields as they will be required</code>。这两个字段是必须的，也是最重要的。用于描述你包的名字和版本号。其他的都可以不要。<br>&emsp;&emsp;其中，<strong>name</strong>建议使用<code>@pacakname/module</code>的方式进行命名，以免重复。比如babel的包，就采用<code>@babel/core</code>这样的@包名/模块名的方式来进行命名。而react就很任性的使用<code>react-dom</code>这种<code>-</code>的方式来进行命名。<br>&emsp;&emsp;<strong>version</strong>则建议使用1.0.0，三段式进行声明，意思为大版本.小版本.小修复。基本上小的一些bug修复都只改第三个数字，兼容这一版本的一些改动，会去修改第二个的小版本号。如果是极大的影响架构兼容性的改动，就放到大版本号。比如著名的angular1到angular2的颠覆式修改。这里的数字就是大版本号。(ps，这也就是angular成为垫底前端框架原因之一吧)。</p>\n<h2 id=\"包描述相关字段\"><a href=\"#包描述相关字段\" class=\"headerlink\" title=\"包描述相关字段\"></a>包描述相关字段</h2><p>&emsp;&emsp;这些字段是用来描述你的包一些相关信息，以便在npm上面可以使用标签等搜索到你的包，也可以介绍包的一些相关情况。<br>&emsp;&emsp;<strong>description</strong>和<strong>keywords</strong>,就等同于html中meta标签的相关字段。用于npm查询的字段，介绍你的表关键词和一些描述。<br>&emsp;&emsp;<strong>homepage</strong>、<strong>bugs</strong>、<strong>repository</strong>、<strong>license</strong>和<strong>people fields</strong>。这些都是一些作者信息，仓库主页，提交bug的地方,包采用的开源协议。这里的<strong>people fields</strong>指的是包作者相关的字段，比如<strong>author</strong>，<strong>email</strong>，不是这个字段名叫做peopke。比较简单，所以看一下react的包示例，不多做介绍了。<br><figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"homepage\": \"https://reactjs.org/\",</span><br><span class=\"line\">\"bugs\": &#123;</span><br><span class=\"line\">    \"url\": \"https://github.com/facebook/react/issues\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"repository\": &#123;</span><br><span class=\"line\">    \"type\": \"git\",</span><br><span class=\"line\">    \"url\": \"git+https://github.com/facebook/react.git\",</span><br><span class=\"line\">    \"directory\": \"packages/react\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"license\": \"MIT\",</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"操作相关字段\"><a href=\"#操作相关字段\" class=\"headerlink\" title=\"操作相关字段\"></a>操作相关字段</h2><p>&emsp;&emsp;操作相关指的是npm在进行包读取或者指令运行时候，设置的一些相关字段。</p>\n<ul>\n<li><strong>main</strong>字段接的是一个文件路径的字符串。值得是你这个包引入的时候，主入口是哪里。比如你填写<code>&quot;main&quot;: &quot;./app.js&quot;</code>，你的包名为<code>exm</code>。那么当别人require或者import你的包的时候，npm会根据这个main字段去自动的查找这个主入口文件。即<code>require(&#39;exm&#39;)</code>，相当于<code>require(&#39;exm/app.js&#39;)</code>。</li>\n<li><strong>bin</strong>字段会创建一个bash的全局链接到该字段下设置的路径当中。创建的地方跟随系统的不同而不同。比如使用<code>{ &quot;bin&quot; : { &quot;myapp&quot; : &quot;./cli.js&quot; } }</code>，在linux系统下面会创建一个/usr/local/bin/myapp的软链接到cli.js文件当中。</li>\n<li><p><strong>scripts</strong>字段应该是常用字段了，它能够自定义一段脚本，当你使用<code>npm run 你定义的key</code>的时候，就能够跑对应的指令。这样就可以避免老是去敲打很多长串的指令。比如：</p>\n<figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我运行<code>npm run test</code>的时候，实际上运行<code>echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1</code>的指令。很多包的指令是npm run start，现在就可以去scripts字段当中去看看，实际上到底运行了什么指令了。</p>\n</li>\n</ul>\n<h2 id=\"依赖相关字段\"><a href=\"#依赖相关字段\" class=\"headerlink\" title=\"依赖相关字段\"></a>依赖相关字段</h2><p>&emsp;&emsp;依赖相关就是dependencies，也就是上面的我的那两道面试题了。简单来说，你的包依赖了那些npm上的其他轮子，就会定义在dependencies当中。dependencies分为4种，其中比较重要的就是<strong>dependencies</strong>和<strong>devDependencies</strong>。dependencies表现形式就是一个<strong>包名</strong>和<strong>版本号</strong>的<strong>映射对象</strong>。下例：<br><figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"dependencies\": &#123;</span><br><span class=\"line\">    \"loose-envify\": \"^1.1.0\",</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p><strong>dependencies</strong>和<strong>devDependencies</strong>区别就是一个运行态(product)的打包相关依赖，另一个是开发状态(dev)的打包相关依赖。举个很简单的例子，比如我在开发状态会用到<code>babel</code>包的一些编译，诸如<code>css-loader</code>用来处理css的打包工具，这些只有在<strong>开发</strong>的时候才会被需要，而如果用到像<code>react</code>这种涉及到整个项目的包，就需要放到dependencies当中去。那么现在你应该知道了，<code>npm install</code>的时候，哪个在包中的dependencies不会被安装了吧。</p>\n<p>&emsp;&emsp;这里也简单说一下引入包的版本号描述方式。前面说过了，版本号的三个数字分别表示大版本，次版本和小修改号。在项目使用过程当中，很有可能引入的包是需要某个大版本，或者兼容某个版本以下的。所以需要一些特殊的表示符号去表示这些版本号的范围。这里直接拿一下官网上面的例子：<br><figure class=\"highlight json hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"hljs-attr\">\"dependencies\"</span> :</span><br><span class=\"line\">  &#123; <span class=\"hljs-attr\">\"foo\"</span> : <span class=\"hljs-string\">\"1.0.0 - 2.9999.9999\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"bar\"</span> : <span class=\"hljs-string\">\"&gt;=1.0.2 &lt;2.1.2\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"baz\"</span> : <span class=\"hljs-string\">\"&gt;1.0.2 &lt;=2.3.4\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"boo\"</span> : <span class=\"hljs-string\">\"2.0.1\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"qux\"</span> : <span class=\"hljs-string\">\"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"asd\"</span> : <span class=\"hljs-string\">\"http://asdf.com/asdf.tar.gz\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"til\"</span> : <span class=\"hljs-string\">\"~1.2\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"elf\"</span> : <span class=\"hljs-string\">\"~1.2.3\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"two\"</span> : <span class=\"hljs-string\">\"2.x\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"thr\"</span> : <span class=\"hljs-string\">\"3.3.x\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"lat\"</span> : <span class=\"hljs-string\">\"latest\"</span></span><br><span class=\"line\">  , <span class=\"hljs-attr\">\"dyl\"</span> : <span class=\"hljs-string\">\"file:../dyl\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>1.1.0</code> 明确的版本号</li>\n<li><code>&gt;1.1.0</code> 大于1.1.0的所有版本</li>\n<li><code>&gt;=1.1.0</code> 大于等于1.1.0的所有版本</li>\n<li><code>&lt;version</code> 小于1.1.0的所有版本</li>\n<li><code>&lt;=1.1.0</code> 小于等于1.1.0的所有版本</li>\n<li><code>1.2.x</code> 表示1.2.下面的任意版本，x为任意版本</li>\n<li><code>~1.1.0</code> 安装1.1.x 下面最新版本，前两个版本号必须为1.1</li>\n<li><code>^1.1.0</code> 安装1.x.x 下面最新版本，第一个大版本号必须为1</li>\n<li><code>*</code> 表示任意版本</li>\n<li><code>&quot;&quot;</code> 空字符串，功能和单个的*一样，表示任意版本</li>\n<li><code>1.1.0 - 1.2.0</code> 大于1.1.0，小于版本1.2.0</li>\n<li><code>1.1.0 || 1.2.0</code> 1.1.0或者1.2.0均可</li>\n</ul>\n<p>&emsp;&emsp;了解package.json并没有那么难，但这部分知识点属于前端工程化基础知识点，还是需要掌握的。前几天在和同事聊天的时候，发现不少人到现在连lib和src的区别都没搞清楚。平时就执行个<code>npm install</code>完成了也就没有过多思考了。还是要多思考，多学习，多总结，争取不做一个curd boy。</p>\n<blockquote>\n<p><a href=\"http://caibaojian.com/npm/files/package.json.html\" target=\"_blank\" rel=\"noopener\">本文抽取了一些比较核心的部分，如果想要更多详细内容可以参考npm官方文档</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;今年的2月19日是令我印象深刻的一天，不是因为这天是元宵节，而是因为这天晚上9点我生平头一回直面阿里面试官的面试，问倒了我一半问题。<br>&emsp;&emsp;在前端工程化部分他问了我两个问题：</p>\n<ol>\n<li>你知道`1，表示什么版本吗?</li>\n<li>depends有四种依赖形式，你知道他们分别是什么吗？知道哪一种depends不会被安装吗?</li>\n</ol>\n<p>&emsp;&emsp;对这方面仅仅是了解的我，愣是一个没答上来。<br>&emsp;&emsp;今天趁着清明假期，整理一下package.json当中到底有些什么。<br></p>","more":"</p>\n<h2 id=\"Package-json是个啥\"><a href=\"#Package-json是个啥\" class=\"headerlink\" title=\"Package.json是个啥\"></a>Package.json是个啥</h2><p>&emsp;&emsp;package.json到底是啥，它就是一个json文件呗，放在项目的主目录下面。<br>那么这个json文件到底用来干嘛，它是用来描述这个项目<strong>相关的一切信息</strong>，方便诸如在npm上发布项目包，使用npm安装项目包依赖。简而言之，就是按照规范写给npm的项目的说明书。让npm根据这份说明书去进行具体的逻辑操作。<br>&emsp;&emsp;你可以使用<code>npm init</code>命令来创建一个初始化的package.json项目包。</p>\n<h2 id=\"包发布相关字段\"><a href=\"#包发布相关字段\" class=\"headerlink\" title=\"包发布相关字段\"></a>包发布相关字段</h2><p>&emsp;&emsp;包发布相关字段，指这些字段用于描述你的项目，以便在npm上面能够查询和使用。<br>&emsp;&emsp;核心字段<strong>name、version</strong>。按照npm文档上面的描述，<code>the most important things in your package.json are the name and version fields as they will be required</code>。这两个字段是必须的，也是最重要的。用于描述你包的名字和版本号。其他的都可以不要。<br>&emsp;&emsp;其中，<strong>name</strong>建议使用<code>@pacakname/module</code>的方式进行命名，以免重复。比如babel的包，就采用<code>@babel/core</code>这样的@包名/模块名的方式来进行命名。而react就很任性的使用<code>react-dom</code>这种<code>-</code>的方式来进行命名。<br>&emsp;&emsp;<strong>version</strong>则建议使用1.0.0，三段式进行声明，意思为大版本.小版本.小修复。基本上小的一些bug修复都只改第三个数字，兼容这一版本的一些改动，会去修改第二个的小版本号。如果是极大的影响架构兼容性的改动，就放到大版本号。比如著名的angular1到angular2的颠覆式修改。这里的数字就是大版本号。(ps，这也就是angular成为垫底前端框架原因之一吧)。</p>\n<h2 id=\"包描述相关字段\"><a href=\"#包描述相关字段\" class=\"headerlink\" title=\"包描述相关字段\"></a>包描述相关字段</h2><p>&emsp;&emsp;这些字段是用来描述你的包一些相关信息，以便在npm上面可以使用标签等搜索到你的包，也可以介绍包的一些相关情况。<br>&emsp;&emsp;<strong>description</strong>和<strong>keywords</strong>,就等同于html中meta标签的相关字段。用于npm查询的字段，介绍你的表关键词和一些描述。<br>&emsp;&emsp;<strong>homepage</strong>、<strong>bugs</strong>、<strong>repository</strong>、<strong>license</strong>和<strong>people fields</strong>。这些都是一些作者信息，仓库主页，提交bug的地方,包采用的开源协议。这里的<strong>people fields</strong>指的是包作者相关的字段，比如<strong>author</strong>，<strong>email</strong>，不是这个字段名叫做peopke。比较简单，所以看一下react的包示例，不多做介绍了。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"homepage\": \"https://reactjs.org/\",</span><br><span class=\"line\">\"bugs\": &#123;</span><br><span class=\"line\">    \"url\": \"https://github.com/facebook/react/issues\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"repository\": &#123;</span><br><span class=\"line\">    \"type\": \"git\",</span><br><span class=\"line\">    \"url\": \"git+https://github.com/facebook/react.git\",</span><br><span class=\"line\">    \"directory\": \"packages/react\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"license\": \"MIT\",</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"操作相关字段\"><a href=\"#操作相关字段\" class=\"headerlink\" title=\"操作相关字段\"></a>操作相关字段</h2><p>&emsp;&emsp;操作相关指的是npm在进行包读取或者指令运行时候，设置的一些相关字段。</p>\n<ul>\n<li><strong>main</strong>字段接的是一个文件路径的字符串。值得是你这个包引入的时候，主入口是哪里。比如你填写<code>&quot;main&quot;: &quot;./app.js&quot;</code>，你的包名为<code>exm</code>。那么当别人require或者import你的包的时候，npm会根据这个main字段去自动的查找这个主入口文件。即<code>require(&#39;exm&#39;)</code>，相当于<code>require(&#39;exm/app.js&#39;)</code>。</li>\n<li><strong>bin</strong>字段会创建一个bash的全局链接到该字段下设置的路径当中。创建的地方跟随系统的不同而不同。比如使用<code>{ &quot;bin&quot; : { &quot;myapp&quot; : &quot;./cli.js&quot; } }</code>，在linux系统下面会创建一个/usr/local/bin/myapp的软链接到cli.js文件当中。</li>\n<li><p><strong>scripts</strong>字段应该是常用字段了，它能够自定义一段脚本，当你使用<code>npm run 你定义的key</code>的时候，就能够跑对应的指令。这样就可以避免老是去敲打很多长串的指令。比如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我运行<code>npm run test</code>的时候，实际上运行<code>echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1</code>的指令。很多包的指令是npm run start，现在就可以去scripts字段当中去看看，实际上到底运行了什么指令了。</p>\n</li>\n</ul>\n<h2 id=\"依赖相关字段\"><a href=\"#依赖相关字段\" class=\"headerlink\" title=\"依赖相关字段\"></a>依赖相关字段</h2><p>&emsp;&emsp;依赖相关就是dependencies，也就是上面的我的那两道面试题了。简单来说，你的包依赖了那些npm上的其他轮子，就会定义在dependencies当中。dependencies分为4种，其中比较重要的就是<strong>dependencies</strong>和<strong>devDependencies</strong>。dependencies表现形式就是一个<strong>包名</strong>和<strong>版本号</strong>的<strong>映射对象</strong>。下例：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"dependencies\": &#123;</span><br><span class=\"line\">    \"loose-envify\": \"^1.1.0\",</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p><strong>dependencies</strong>和<strong>devDependencies</strong>区别就是一个运行态(product)的打包相关依赖，另一个是开发状态(dev)的打包相关依赖。举个很简单的例子，比如我在开发状态会用到<code>babel</code>包的一些编译，诸如<code>css-loader</code>用来处理css的打包工具，这些只有在<strong>开发</strong>的时候才会被需要，而如果用到像<code>react</code>这种涉及到整个项目的包，就需要放到dependencies当中去。那么现在你应该知道了，<code>npm install</code>的时候，哪个在包中的dependencies不会被安装了吧。</p>\n<p>&emsp;&emsp;这里也简单说一下引入包的版本号描述方式。前面说过了，版本号的三个数字分别表示大版本，次版本和小修改号。在项目使用过程当中，很有可能引入的包是需要某个大版本，或者兼容某个版本以下的。所以需要一些特殊的表示符号去表示这些版本号的范围。这里直接拿一下官网上面的例子：<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"dependencies\"</span> :</span><br><span class=\"line\">  &#123; <span class=\"attr\">\"foo\"</span> : <span class=\"string\">\"1.0.0 - 2.9999.9999\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"bar\"</span> : <span class=\"string\">\"&gt;=1.0.2 &lt;2.1.2\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"baz\"</span> : <span class=\"string\">\"&gt;1.0.2 &lt;=2.3.4\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"boo\"</span> : <span class=\"string\">\"2.0.1\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"qux\"</span> : <span class=\"string\">\"&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"asd\"</span> : <span class=\"string\">\"http://asdf.com/asdf.tar.gz\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"til\"</span> : <span class=\"string\">\"~1.2\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"elf\"</span> : <span class=\"string\">\"~1.2.3\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"two\"</span> : <span class=\"string\">\"2.x\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"thr\"</span> : <span class=\"string\">\"3.3.x\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"lat\"</span> : <span class=\"string\">\"latest\"</span></span><br><span class=\"line\">  , <span class=\"attr\">\"dyl\"</span> : <span class=\"string\">\"file:../dyl\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>1.1.0</code> 明确的版本号</li>\n<li><code>&gt;1.1.0</code> 大于1.1.0的所有版本</li>\n<li><code>&gt;=1.1.0</code> 大于等于1.1.0的所有版本</li>\n<li><code>&lt;version</code> 小于1.1.0的所有版本</li>\n<li><code>&lt;=1.1.0</code> 小于等于1.1.0的所有版本</li>\n<li><code>1.2.x</code> 表示1.2.下面的任意版本，x为任意版本</li>\n<li><code>~1.1.0</code> 安装1.1.x 下面最新版本，前两个版本号必须为1.1</li>\n<li><code>^1.1.0</code> 安装1.x.x 下面最新版本，第一个大版本号必须为1</li>\n<li><code>*</code> 表示任意版本</li>\n<li><code>&quot;&quot;</code> 空字符串，功能和单个的*一样，表示任意版本</li>\n<li><code>1.1.0 - 1.2.0</code> 大于1.1.0，小于版本1.2.0</li>\n<li><code>1.1.0 || 1.2.0</code> 1.1.0或者1.2.0均可</li>\n</ul>\n<p>&emsp;&emsp;了解package.json并没有那么难，但这部分知识点属于前端工程化基础知识点，还是需要掌握的。前几天在和同事聊天的时候，发现不少人到现在连lib和src的区别都没搞清楚。平时就执行个<code>npm install</code>完成了也就没有过多思考了。还是要多思考，多学习，多总结，争取不做一个curd boy。</p>\n<blockquote>\n<p><a href=\"http://caibaojian.com/npm/files/package.json.html\" target=\"_blank\" rel=\"noopener\">本文抽取了一些比较核心的部分，如果想要更多详细内容可以参考npm官方文档</a></p>\n</blockquote>"},{"title":"不定期更新的源码阅读日常——lodash-3","date":"2020-01-27T09:00:00.000Z","_content":"&emsp;&emsp;今天我们来读lodash的节流防抖部分代码。\n<!--more-->\n&emsp;&emsp;节流和防抖，是限制函数高频执行的一种手段。它们概念的区别在于，`防抖合并多次函数执行为一次`；节流是在`一定的时间内函数只执行一次`。具体的区别可以参考`lodash`官网推荐的[这篇文章](https://css-tricks.com/debouncing-throttling-explained-examples/)。\n\n&emsp;&emsp;虽然明细了概念的区别，但是在`lodash`源码中，这两个方式其实是一个实现。`lodash`中`_.debounce`对应防抖，`_.throttle`则对应节流。我们先来看一下`throttle`部分的代码。\n\n```javascript\n/**\n  * @param {Function} func: 要节流的函数。\n  * @param {Number} wait 需要节流的毫秒\n  * @param {Object} options 选项对象\n  * [options.leading=true] (boolean): 指定调用在节流开始前。\n  *  [options.trailing=true] (boolean): 指定调用在节流结束后。\n  * @returns {Function} Returns the new throttled function.\n*/\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n  // 非函数抛错\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  // options 为对象时，进行 leading 和 trailing 的参数设置\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n```\n\n&emsp;&emsp;`throttle`函数非常的简单，进行默认值选项`leading`和`trailing`的设置。然后对入参类型进行检测，接着直接返回调用`debounce`函数的内容。尽管`lodash`官方上面画了不少篇幅来介绍节流防抖的感念区别，其实`防抖`函数就是直接使用`节流`函数的逻辑来实现的。\n\n&emsp;&emsp;让我们把视线转到`debounce`函数。`debounce`的配置设置是一个高阶函数，放入你**需要防抖的函数**和**调用配置**，返回处理好的函数。先来看一下函数的入参以及入参处理。\n\n```javascript\n/**\n  * @param {Function} func The function to debounce.\n  * @param {number} [wait=0] The number of milliseconds to delay.\n  * @param {Object} [options={}] The options object.\n  * @param {boolean} [options.leading=false]\n  *  Specify invoking on the leading edge of the timeout.\n  * @param {number} [options.maxWait]\n  *  The maximum time `func` is allowed to be delayed before it's invoked.\n  * @param {boolean} [options.trailing=true]\n  *  Specify invoking on the trailing edge of the timeout.\n  * @returns {Function} Returns the new debounced function.\n*/\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n  // 检测func非函数抛错\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  // wait 转number\n  wait = toNumber(wait) || 0;\n  // 根据options配置 leading maxWait 和 trailing\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    // 如果 options 有设置 maxWait ，取 options中的maxWait 以及 wait 的最大值\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  // ...省略代码\n}\n```\n\n&emsp;&emsp;`debounce`函数的前两个入参`func`和`wait`为`需要节流的函数`以及`需要延迟的毫秒数`。第三个入参为防抖配置对象`options`，它存在三个配置项`leading`，`trailing`和`maxWait`。`maxWait`为函数被允许延迟的最大值，`leading`指在延迟前进行调用，`trailing`则对应的在延迟后开始调用函数。\n\n&emsp;&emsp;`debounce`函数剩下的代码逻辑，都是由多个小函数块构成。前面提到过，`debounce`为一个高阶函数，它返回节流逻辑包装处理过的函数。我们可以由`debounce`函数的返回`debounced`开始往上看整个`debounce`函数的逻辑。\n\n```javascript\nfunction debounce(func, wait, options) {\n  // ...省略代码\n  function debounced() {\n    // 返回当前时间戳\n    var time = now(),\n    // 是否应该执行函数\n        isInvoking = shouldInvoke(time);\n    // 记录args和this\n    lastArgs = arguments;\n    lastThis = this;\n    // lastCallTime 为当前的时间戳\n    lastCallTime = time;\n\n    if (isInvoking) {\n      // 这里的timerId为setTimeout执行标识\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      // maxing = 'maxWait' in options\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    // 返回结果\n    return result;\n  }\n  // 注册 cancel 和 flush 接口\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n```\n\n&emsp;&emsp;`debounced`整体函数也很简单，首先是获取到**当前执行时的时间戳**，传入调用`shouldInvoke`方法判断是否应该执行函数。如果应该执行，则根据有无`timerId`进行不同的执行函数逻辑。如果不应该执行函数，直接使用`setTimeout`，调起`timerExpired`执行。最后注册了一下`cancel`和`flush`的接口。`cancel`可以取消`debounced`的调用，`flush`则是立即执行`debounced`函数。我们来看下这两个函数的代码。\n\n```javascript\nfunction cancel() {\n  if (timerId !== undefined) {\n    clearTimeout(timerId);\n  }\n  lastInvokeTime = 0;\n  lastArgs = lastCallTime = lastThis = timerId = undefined;\n}\n\nfunction flush() {\n  return timerId === undefined ? result : trailingEdge(now());\n}\n```\n\n&emsp;&emsp;这两个函数逻辑非常的简单,`cancel`就是清除`timerId`标识的`timeOut`调用，并重置记录的`args`，`this`，以及`lastCallTime`等一些记录值。`flush`则是通过判断一下`timerId`是否存在，如果不存在，表示函数实质上已经调用过了，直接返回函数调用的结果。否则的话，调用`trailingEdge`，传入时间戳。这里的`trailingEdge`加上上一部分在`debounced`函数中的`leadingEdge`，都是进行防抖原函数的调用，我们来看着两个函数的代码。\n\n```javascript\nfunction leadingEdge(time) {\n  lastInvokeTime = time;\n  timerId = setTimeout(timerExpired, wait);\n  return leading ? invokeFunc(time) : result;\n}\n\nfunction trailingEdge(time) {\n  timerId = undefined;\n  if (trailing && lastArgs) {\n    return invokeFunc(time);\n  }\n  lastArgs = lastThis = undefined;\n  return result;\n}\n```\n&emsp;&emsp;`trailingEdge`和`leadingEdge`是根据原`debounce`函数`options`当中的`trailing`和`leading`的不同配置进行的函数调用的逻辑。我们顺着这两个函数，查看下调用防抖原函数的`invokeFunc`以及`setTimeout`调用的`timerExpired`的函数逻辑。\n\n```javascript\nfunction invokeFunc(time) {\n  var args = lastArgs,\n      thisArg = lastThis;\n\n  lastArgs = lastThis = undefined;\n  lastInvokeTime = time;\n  result = func.apply(thisArg, args);\n  return result;\n}\n\nfunction timerExpired() {\n  var time = now();\n  if (shouldInvoke(time)) {\n    return trailingEdge(time);\n  }\n  // Restart the timer.\n  timerId = setTimeout(timerExpired, remainingWait(time));\n}\n```\n\n&emsp;&emsp;`invokeFunc`函数就是通过`debounced`记录的函数入参`args`以及函数的`this`直接调用函数返回结果，并且记录函数调用的时间到`lastInvokeTime`。`timerExpired`是根据当前的时间戳，调用`shouldInvoke`得到函数是否可以进行调用。如果可以调用，直接进行`trailingEdge`的调用。如果还不能进行调用，再使用`setTimeout`再延长需要等待的时间。我们来看最后剩下的两个函数`shouldInvoke`和`remainingWait`。\n\n```javascript\nfunction remainingWait(time) {\n  // lastCallTime debounced调用的时间\n  // lastInvokeTime debounce处理原函数调用的时间\n  var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime,\n      timeWaiting = wait - timeSinceLastCall;\n\n  return maxing\n    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\nfunction shouldInvoke(time) {\n  var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime;\n  return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n    //  maxing = 'maxWait' in options;\n    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n}\n```\n\n&emsp;&emsp;`remainingWait`函数，是根据`options`上面有无`maxWait`进行不同的逻辑计算。首先得到三个时间：\n1. **防抖函数debounced调用的时间**与传入time的差值`timeSinceLastCall`，即这次调用`remainingWait`时`debounced`已经执行多久了。\n2. **防抖原函数调用的时间**与传入time的差值，`timeSinceLastInvoke`；\n3. 以及入参`wait`和第一个值的差值。即`debounced`调用后到执行`remainingWait`与传入的`wait`存在的差值。\n\n&emsp;&emsp;如果不存在`maxWait`的配置，那么直接返回第三个值即可。如果存在差值，就返回计算第三个值以及`maxWait`配置值和第一个值的差值的最小值。\n\n&emsp;&emsp;`shouldInvoke`首先计算出`timeSinceLastCall`以及`timeSinceLastInvoke`，逻辑和`remainingWait`相同。根据以下逻辑判断是否应该执行函数：\n1. `lastCallTime`即`debounced`调用时间是否存在，不存在，直接返回true，否则到2\n2. `timeSinceLastCall`是否大于等于`wait`，即`debounced`调用后是否已经大于需要等待的时间了。大于了返回true，否则到3\n3. `timeSinceLastCall`是否小于0，即传入的`time`小于`lastCallTime`，小于0返回true，否则到4\n4. `maxing`存在的话，`timeSinceLastInvoke`上次调用`debounce`原函数的时间大于`option`的`maxWait`配置的话，返回true，否则返回false\n\n&emsp;&emsp;到这里`debounce`函数的代码就看完了。不得不佩服，整个`debounce`函数逻辑模块拆分非常清晰。整个函数使用高阶函数的形式，包装了一个`debounced`函数。内部通过记录`debounced`调用时间和配置项的比较，利用`setTimeout`实现了节流函数的调用。","source":"_posts/lodash/sourceCode_lodash_3.md","raw":"---\ntitle: 不定期更新的源码阅读日常——lodash-3\ndate: 2020/1/27 17:00:00\ncategories:\n- [前端, lodash]\ntags:\n- lodash\n- 源码阅读\n---\n&emsp;&emsp;今天我们来读lodash的节流防抖部分代码。\n<!--more-->\n&emsp;&emsp;节流和防抖，是限制函数高频执行的一种手段。它们概念的区别在于，`防抖合并多次函数执行为一次`；节流是在`一定的时间内函数只执行一次`。具体的区别可以参考`lodash`官网推荐的[这篇文章](https://css-tricks.com/debouncing-throttling-explained-examples/)。\n\n&emsp;&emsp;虽然明细了概念的区别，但是在`lodash`源码中，这两个方式其实是一个实现。`lodash`中`_.debounce`对应防抖，`_.throttle`则对应节流。我们先来看一下`throttle`部分的代码。\n\n```javascript\n/**\n  * @param {Function} func: 要节流的函数。\n  * @param {Number} wait 需要节流的毫秒\n  * @param {Object} options 选项对象\n  * [options.leading=true] (boolean): 指定调用在节流开始前。\n  *  [options.trailing=true] (boolean): 指定调用在节流结束后。\n  * @returns {Function} Returns the new throttled function.\n*/\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n  // 非函数抛错\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  // options 为对象时，进行 leading 和 trailing 的参数设置\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n```\n\n&emsp;&emsp;`throttle`函数非常的简单，进行默认值选项`leading`和`trailing`的设置。然后对入参类型进行检测，接着直接返回调用`debounce`函数的内容。尽管`lodash`官方上面画了不少篇幅来介绍节流防抖的感念区别，其实`防抖`函数就是直接使用`节流`函数的逻辑来实现的。\n\n&emsp;&emsp;让我们把视线转到`debounce`函数。`debounce`的配置设置是一个高阶函数，放入你**需要防抖的函数**和**调用配置**，返回处理好的函数。先来看一下函数的入参以及入参处理。\n\n```javascript\n/**\n  * @param {Function} func The function to debounce.\n  * @param {number} [wait=0] The number of milliseconds to delay.\n  * @param {Object} [options={}] The options object.\n  * @param {boolean} [options.leading=false]\n  *  Specify invoking on the leading edge of the timeout.\n  * @param {number} [options.maxWait]\n  *  The maximum time `func` is allowed to be delayed before it's invoked.\n  * @param {boolean} [options.trailing=true]\n  *  Specify invoking on the trailing edge of the timeout.\n  * @returns {Function} Returns the new debounced function.\n*/\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n  // 检测func非函数抛错\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  // wait 转number\n  wait = toNumber(wait) || 0;\n  // 根据options配置 leading maxWait 和 trailing\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    // 如果 options 有设置 maxWait ，取 options中的maxWait 以及 wait 的最大值\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  // ...省略代码\n}\n```\n\n&emsp;&emsp;`debounce`函数的前两个入参`func`和`wait`为`需要节流的函数`以及`需要延迟的毫秒数`。第三个入参为防抖配置对象`options`，它存在三个配置项`leading`，`trailing`和`maxWait`。`maxWait`为函数被允许延迟的最大值，`leading`指在延迟前进行调用，`trailing`则对应的在延迟后开始调用函数。\n\n&emsp;&emsp;`debounce`函数剩下的代码逻辑，都是由多个小函数块构成。前面提到过，`debounce`为一个高阶函数，它返回节流逻辑包装处理过的函数。我们可以由`debounce`函数的返回`debounced`开始往上看整个`debounce`函数的逻辑。\n\n```javascript\nfunction debounce(func, wait, options) {\n  // ...省略代码\n  function debounced() {\n    // 返回当前时间戳\n    var time = now(),\n    // 是否应该执行函数\n        isInvoking = shouldInvoke(time);\n    // 记录args和this\n    lastArgs = arguments;\n    lastThis = this;\n    // lastCallTime 为当前的时间戳\n    lastCallTime = time;\n\n    if (isInvoking) {\n      // 这里的timerId为setTimeout执行标识\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      // maxing = 'maxWait' in options\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    // 返回结果\n    return result;\n  }\n  // 注册 cancel 和 flush 接口\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n```\n\n&emsp;&emsp;`debounced`整体函数也很简单，首先是获取到**当前执行时的时间戳**，传入调用`shouldInvoke`方法判断是否应该执行函数。如果应该执行，则根据有无`timerId`进行不同的执行函数逻辑。如果不应该执行函数，直接使用`setTimeout`，调起`timerExpired`执行。最后注册了一下`cancel`和`flush`的接口。`cancel`可以取消`debounced`的调用，`flush`则是立即执行`debounced`函数。我们来看下这两个函数的代码。\n\n```javascript\nfunction cancel() {\n  if (timerId !== undefined) {\n    clearTimeout(timerId);\n  }\n  lastInvokeTime = 0;\n  lastArgs = lastCallTime = lastThis = timerId = undefined;\n}\n\nfunction flush() {\n  return timerId === undefined ? result : trailingEdge(now());\n}\n```\n\n&emsp;&emsp;这两个函数逻辑非常的简单,`cancel`就是清除`timerId`标识的`timeOut`调用，并重置记录的`args`，`this`，以及`lastCallTime`等一些记录值。`flush`则是通过判断一下`timerId`是否存在，如果不存在，表示函数实质上已经调用过了，直接返回函数调用的结果。否则的话，调用`trailingEdge`，传入时间戳。这里的`trailingEdge`加上上一部分在`debounced`函数中的`leadingEdge`，都是进行防抖原函数的调用，我们来看着两个函数的代码。\n\n```javascript\nfunction leadingEdge(time) {\n  lastInvokeTime = time;\n  timerId = setTimeout(timerExpired, wait);\n  return leading ? invokeFunc(time) : result;\n}\n\nfunction trailingEdge(time) {\n  timerId = undefined;\n  if (trailing && lastArgs) {\n    return invokeFunc(time);\n  }\n  lastArgs = lastThis = undefined;\n  return result;\n}\n```\n&emsp;&emsp;`trailingEdge`和`leadingEdge`是根据原`debounce`函数`options`当中的`trailing`和`leading`的不同配置进行的函数调用的逻辑。我们顺着这两个函数，查看下调用防抖原函数的`invokeFunc`以及`setTimeout`调用的`timerExpired`的函数逻辑。\n\n```javascript\nfunction invokeFunc(time) {\n  var args = lastArgs,\n      thisArg = lastThis;\n\n  lastArgs = lastThis = undefined;\n  lastInvokeTime = time;\n  result = func.apply(thisArg, args);\n  return result;\n}\n\nfunction timerExpired() {\n  var time = now();\n  if (shouldInvoke(time)) {\n    return trailingEdge(time);\n  }\n  // Restart the timer.\n  timerId = setTimeout(timerExpired, remainingWait(time));\n}\n```\n\n&emsp;&emsp;`invokeFunc`函数就是通过`debounced`记录的函数入参`args`以及函数的`this`直接调用函数返回结果，并且记录函数调用的时间到`lastInvokeTime`。`timerExpired`是根据当前的时间戳，调用`shouldInvoke`得到函数是否可以进行调用。如果可以调用，直接进行`trailingEdge`的调用。如果还不能进行调用，再使用`setTimeout`再延长需要等待的时间。我们来看最后剩下的两个函数`shouldInvoke`和`remainingWait`。\n\n```javascript\nfunction remainingWait(time) {\n  // lastCallTime debounced调用的时间\n  // lastInvokeTime debounce处理原函数调用的时间\n  var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime,\n      timeWaiting = wait - timeSinceLastCall;\n\n  return maxing\n    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\nfunction shouldInvoke(time) {\n  var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime;\n  return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n    //  maxing = 'maxWait' in options;\n    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n}\n```\n\n&emsp;&emsp;`remainingWait`函数，是根据`options`上面有无`maxWait`进行不同的逻辑计算。首先得到三个时间：\n1. **防抖函数debounced调用的时间**与传入time的差值`timeSinceLastCall`，即这次调用`remainingWait`时`debounced`已经执行多久了。\n2. **防抖原函数调用的时间**与传入time的差值，`timeSinceLastInvoke`；\n3. 以及入参`wait`和第一个值的差值。即`debounced`调用后到执行`remainingWait`与传入的`wait`存在的差值。\n\n&emsp;&emsp;如果不存在`maxWait`的配置，那么直接返回第三个值即可。如果存在差值，就返回计算第三个值以及`maxWait`配置值和第一个值的差值的最小值。\n\n&emsp;&emsp;`shouldInvoke`首先计算出`timeSinceLastCall`以及`timeSinceLastInvoke`，逻辑和`remainingWait`相同。根据以下逻辑判断是否应该执行函数：\n1. `lastCallTime`即`debounced`调用时间是否存在，不存在，直接返回true，否则到2\n2. `timeSinceLastCall`是否大于等于`wait`，即`debounced`调用后是否已经大于需要等待的时间了。大于了返回true，否则到3\n3. `timeSinceLastCall`是否小于0，即传入的`time`小于`lastCallTime`，小于0返回true，否则到4\n4. `maxing`存在的话，`timeSinceLastInvoke`上次调用`debounce`原函数的时间大于`option`的`maxWait`配置的话，返回true，否则返回false\n\n&emsp;&emsp;到这里`debounce`函数的代码就看完了。不得不佩服，整个`debounce`函数逻辑模块拆分非常清晰。整个函数使用高阶函数的形式，包装了一个`debounced`函数。内部通过记录`debounced`调用时间和配置项的比较，利用`setTimeout`实现了节流函数的调用。","slug":"lodash/sourceCode_lodash_3","published":1,"updated":"2020-06-11T01:43:32.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxn000u9r2v13bce5je","content":"<p>&emsp;&emsp;今天我们来读lodash的节流防抖部分代码。<br><a id=\"more\"></a><br>&emsp;&emsp;节流和防抖，是限制函数高频执行的一种手段。它们概念的区别在于，<code>防抖合并多次函数执行为一次</code>；节流是在<code>一定的时间内函数只执行一次</code>。具体的区别可以参考<code>lodash</code>官网推荐的<a href=\"https://css-tricks.com/debouncing-throttling-explained-examples/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>&emsp;&emsp;虽然明细了概念的区别，但是在<code>lodash</code>源码中，这两个方式其实是一个实现。<code>lodash</code>中<code>_.debounce</code>对应防抖，<code>_.throttle</code>则对应节流。我们先来看一下<code>throttle</code>部分的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>func: 要节流的函数。</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Number&#125;</span> </span>wait 需要节流的毫秒</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Object&#125;</span> </span>options 选项对象</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * [options.leading=true] (boolean): 指定调用在节流开始前。</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  *  [options.trailing=true] (boolean): 指定调用在节流结束后。</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;Function&#125;</span> </span>Returns the new throttled function.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">throttle</span>(<span class=\"hljs-params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> leading = <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">      trailing = <span class=\"hljs-literal\">true</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 非函数抛错</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> func != <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(FUNC_ERROR_TEXT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// options 为对象时，进行 leading 和 trailing 的参数设置</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isObject(options)) &#123;</span><br><span class=\"line\">    leading = <span class=\"hljs-string\">'leading'</span> <span class=\"hljs-keyword\">in</span> options ? !!options.leading : leading;</span><br><span class=\"line\">    trailing = <span class=\"hljs-string\">'trailing'</span> <span class=\"hljs-keyword\">in</span> options ? !!options.trailing : trailing;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> debounce(func, wait, &#123;</span><br><span class=\"line\">    <span class=\"hljs-string\">'leading'</span>: leading,</span><br><span class=\"line\">    <span class=\"hljs-string\">'maxWait'</span>: wait,</span><br><span class=\"line\">    <span class=\"hljs-string\">'trailing'</span>: trailing</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>throttle</code>函数非常的简单，进行默认值选项<code>leading</code>和<code>trailing</code>的设置。然后对入参类型进行检测，接着直接返回调用<code>debounce</code>函数的内容。尽管<code>lodash</code>官方上面画了不少篇幅来介绍节流防抖的感念区别，其实<code>防抖</code>函数就是直接使用<code>节流</code>函数的逻辑来实现的。</p>\n<p>&emsp;&emsp;让我们把视线转到<code>debounce</code>函数。<code>debounce</code>的配置设置是一个高阶函数，放入你<strong>需要防抖的函数</strong>和<strong>调用配置</strong>，返回处理好的函数。先来看一下函数的入参以及入参处理。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Function&#125;</span> </span>func The function to debounce.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;number&#125;</span> </span>[wait=0] The number of milliseconds to delay.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;Object&#125;</span> </span>[options=&#123;&#125;] The options object.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;boolean&#125;</span> </span>[options.leading=false]</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  *  Specify invoking on the leading edge of the timeout.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;number&#125;</span> </span>[options.maxWait]</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param <span class=\"hljs-type\">&#123;boolean&#125;</span> </span>[options.trailing=true]</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;Function&#125;</span> </span>Returns the new debounced function.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> lastArgs,</span><br><span class=\"line\">      lastThis,</span><br><span class=\"line\">      maxWait,</span><br><span class=\"line\">      result,</span><br><span class=\"line\">      timerId,</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      lastInvokeTime = <span class=\"hljs-number\">0</span>,</span><br><span class=\"line\">      leading = <span class=\"hljs-literal\">false</span>,</span><br><span class=\"line\">      maxing = <span class=\"hljs-literal\">false</span>,</span><br><span class=\"line\">      trailing = <span class=\"hljs-literal\">true</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 检测func非函数抛错</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> func != <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(FUNC_ERROR_TEXT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// wait 转number</span></span><br><span class=\"line\">  wait = toNumber(wait) || <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 根据options配置 leading maxWait 和 trailing</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isObject(options)) &#123;</span><br><span class=\"line\">    leading = !!options.leading;</span><br><span class=\"line\">    maxing = <span class=\"hljs-string\">'maxWait'</span> <span class=\"hljs-keyword\">in</span> options;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 如果 options 有设置 maxWait ，取 options中的maxWait 以及 wait 的最大值</span></span><br><span class=\"line\">    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || <span class=\"hljs-number\">0</span>, wait) : maxWait;</span><br><span class=\"line\">    trailing = <span class=\"hljs-string\">'trailing'</span> <span class=\"hljs-keyword\">in</span> options ? !!options.trailing : trailing;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>debounce</code>函数的前两个入参<code>func</code>和<code>wait</code>为<code>需要节流的函数</code>以及<code>需要延迟的毫秒数</code>。第三个入参为防抖配置对象<code>options</code>，它存在三个配置项<code>leading</code>，<code>trailing</code>和<code>maxWait</code>。<code>maxWait</code>为函数被允许延迟的最大值，<code>leading</code>指在延迟前进行调用，<code>trailing</code>则对应的在延迟后开始调用函数。</p>\n<p>&emsp;&emsp;<code>debounce</code>函数剩下的代码逻辑，都是由多个小函数块构成。前面提到过，<code>debounce</code>为一个高阶函数，它返回节流逻辑包装处理过的函数。我们可以由<code>debounce</code>函数的返回<code>debounced</code>开始往上看整个<code>debounce</code>函数的逻辑。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...省略代码</span></span><br><span class=\"line\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounced</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 返回当前时间戳</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">var</span> time = now(),</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 是否应该执行函数</span></span><br><span class=\"line\">        isInvoking = shouldInvoke(time);</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 记录args和this</span></span><br><span class=\"line\">    lastArgs = <span class=\"hljs-built_in\">arguments</span>;</span><br><span class=\"line\">    lastThis = <span class=\"hljs-keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// lastCallTime 为当前的时间戳</span></span><br><span class=\"line\">    lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (isInvoking) &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 这里的timerId为setTimeout执行标识</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (timerId === <span class=\"hljs-literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> leadingEdge(lastCallTime);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// maxing = 'maxWait' in options</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (maxing) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// Handle invocations in a tight loop.</span></span><br><span class=\"line\">        timerId = setTimeout(timerExpired, wait);</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> invokeFunc(lastCallTime);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (timerId === <span class=\"hljs-literal\">undefined</span>) &#123;</span><br><span class=\"line\">      timerId = setTimeout(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 返回结果</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 注册 cancel 和 flush 接口</span></span><br><span class=\"line\">  debounced.cancel = cancel;</span><br><span class=\"line\">  debounced.flush = flush;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>debounced</code>整体函数也很简单，首先是获取到<strong>当前执行时的时间戳</strong>，传入调用<code>shouldInvoke</code>方法判断是否应该执行函数。如果应该执行，则根据有无<code>timerId</code>进行不同的执行函数逻辑。如果不应该执行函数，直接使用<code>setTimeout</code>，调起<code>timerExpired</code>执行。最后注册了一下<code>cancel</code>和<code>flush</code>的接口。<code>cancel</code>可以取消<code>debounced</code>的调用，<code>flush</code>则是立即执行<code>debounced</code>函数。我们来看下这两个函数的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cancel</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (timerId !== <span class=\"hljs-literal\">undefined</span>) &#123;</span><br><span class=\"line\">    clearTimeout(timerId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lastInvokeTime = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">  lastArgs = lastCallTime = lastThis = timerId = <span class=\"hljs-literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flush</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> timerId === <span class=\"hljs-literal\">undefined</span> ? result : trailingEdge(now());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这两个函数逻辑非常的简单,<code>cancel</code>就是清除<code>timerId</code>标识的<code>timeOut</code>调用，并重置记录的<code>args</code>，<code>this</code>，以及<code>lastCallTime</code>等一些记录值。<code>flush</code>则是通过判断一下<code>timerId</code>是否存在，如果不存在，表示函数实质上已经调用过了，直接返回函数调用的结果。否则的话，调用<code>trailingEdge</code>，传入时间戳。这里的<code>trailingEdge</code>加上上一部分在<code>debounced</code>函数中的<code>leadingEdge</code>，都是进行防抖原函数的调用，我们来看着两个函数的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">leadingEdge</span>(<span class=\"hljs-params\">time</span>) </span>&#123;</span><br><span class=\"line\">  lastInvokeTime = time;</span><br><span class=\"line\">  timerId = setTimeout(timerExpired, wait);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> leading ? invokeFunc(time) : result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">trailingEdge</span>(<span class=\"hljs-params\">time</span>) </span>&#123;</span><br><span class=\"line\">  timerId = <span class=\"hljs-literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> invokeFunc(time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lastArgs = lastThis = <span class=\"hljs-literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>trailingEdge</code>和<code>leadingEdge</code>是根据原<code>debounce</code>函数<code>options</code>当中的<code>trailing</code>和<code>leading</code>的不同配置进行的函数调用的逻辑。我们顺着这两个函数，查看下调用防抖原函数的<code>invokeFunc</code>以及<code>setTimeout</code>调用的<code>timerExpired</code>的函数逻辑。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">invokeFunc</span>(<span class=\"hljs-params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> args = lastArgs,</span><br><span class=\"line\">      thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">  lastArgs = lastThis = <span class=\"hljs-literal\">undefined</span>;</span><br><span class=\"line\">  lastInvokeTime = time;</span><br><span class=\"line\">  result = func.apply(thisArg, args);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timerExpired</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> time = now();</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (shouldInvoke(time)) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> trailingEdge(time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Restart the timer.</span></span><br><span class=\"line\">  timerId = setTimeout(timerExpired, remainingWait(time));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>invokeFunc</code>函数就是通过<code>debounced</code>记录的函数入参<code>args</code>以及函数的<code>this</code>直接调用函数返回结果，并且记录函数调用的时间到<code>lastInvokeTime</code>。<code>timerExpired</code>是根据当前的时间戳，调用<code>shouldInvoke</code>得到函数是否可以进行调用。如果可以调用，直接进行<code>trailingEdge</code>的调用。如果还不能进行调用，再使用<code>setTimeout</code>再延长需要等待的时间。我们来看最后剩下的两个函数<code>shouldInvoke</code>和<code>remainingWait</code>。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">remainingWait</span>(<span class=\"hljs-params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// lastCallTime debounced调用的时间</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// lastInvokeTime debounce处理原函数调用的时间</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> timeSinceLastCall = time - lastCallTime,</span><br><span class=\"line\">      timeSinceLastInvoke = time - lastInvokeTime,</span><br><span class=\"line\">      timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> maxing</span><br><span class=\"line\">    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">shouldInvoke</span>(<span class=\"hljs-params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">var</span> timeSinceLastCall = time - lastCallTime,</span><br><span class=\"line\">      timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (lastCallTime === <span class=\"hljs-literal\">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class=\"line\">    <span class=\"hljs-comment\">//  maxing = 'maxWait' in options;</span></span><br><span class=\"line\">    (timeSinceLastCall &lt; <span class=\"hljs-number\">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>remainingWait</code>函数，是根据<code>options</code>上面有无<code>maxWait</code>进行不同的逻辑计算。首先得到三个时间：</p>\n<ol>\n<li><strong>防抖函数debounced调用的时间</strong>与传入time的差值<code>timeSinceLastCall</code>，即这次调用<code>remainingWait</code>时<code>debounced</code>已经执行多久了。</li>\n<li><strong>防抖原函数调用的时间</strong>与传入time的差值，<code>timeSinceLastInvoke</code>；</li>\n<li>以及入参<code>wait</code>和第一个值的差值。即<code>debounced</code>调用后到执行<code>remainingWait</code>与传入的<code>wait</code>存在的差值。</li>\n</ol>\n<p>&emsp;&emsp;如果不存在<code>maxWait</code>的配置，那么直接返回第三个值即可。如果存在差值，就返回计算第三个值以及<code>maxWait</code>配置值和第一个值的差值的最小值。</p>\n<p>&emsp;&emsp;<code>shouldInvoke</code>首先计算出<code>timeSinceLastCall</code>以及<code>timeSinceLastInvoke</code>，逻辑和<code>remainingWait</code>相同。根据以下逻辑判断是否应该执行函数：</p>\n<ol>\n<li><code>lastCallTime</code>即<code>debounced</code>调用时间是否存在，不存在，直接返回true，否则到2</li>\n<li><code>timeSinceLastCall</code>是否大于等于<code>wait</code>，即<code>debounced</code>调用后是否已经大于需要等待的时间了。大于了返回true，否则到3</li>\n<li><code>timeSinceLastCall</code>是否小于0，即传入的<code>time</code>小于<code>lastCallTime</code>，小于0返回true，否则到4</li>\n<li><code>maxing</code>存在的话，<code>timeSinceLastInvoke</code>上次调用<code>debounce</code>原函数的时间大于<code>option</code>的<code>maxWait</code>配置的话，返回true，否则返回false</li>\n</ol>\n<p>&emsp;&emsp;到这里<code>debounce</code>函数的代码就看完了。不得不佩服，整个<code>debounce</code>函数逻辑模块拆分非常清晰。整个函数使用高阶函数的形式，包装了一个<code>debounced</code>函数。内部通过记录<code>debounced</code>调用时间和配置项的比较，利用<code>setTimeout</code>实现了节流函数的调用。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;今天我们来读lodash的节流防抖部分代码。<br></p>","more":"<br>&emsp;&emsp;节流和防抖，是限制函数高频执行的一种手段。它们概念的区别在于，<code>防抖合并多次函数执行为一次</code>；节流是在<code>一定的时间内函数只执行一次</code>。具体的区别可以参考<code>lodash</code>官网推荐的<a href=\"https://css-tricks.com/debouncing-throttling-explained-examples/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>&emsp;&emsp;虽然明细了概念的区别，但是在<code>lodash</code>源码中，这两个方式其实是一个实现。<code>lodash</code>中<code>_.debounce</code>对应防抖，<code>_.throttle</code>则对应节流。我们先来看一下<code>throttle</code>部分的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>func: 要节流的函数。</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Number&#125;</span> </span>wait 需要节流的毫秒</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>options 选项对象</span></span><br><span class=\"line\"><span class=\"comment\">  * [options.leading=true] (boolean): 指定调用在节流开始前。</span></span><br><span class=\"line\"><span class=\"comment\">  *  [options.trailing=true] (boolean): 指定调用在节流结束后。</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@returns <span class=\"type\">&#123;Function&#125;</span> </span>Returns the new throttled function.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> leading = <span class=\"literal\">true</span>,</span><br><span class=\"line\">      trailing = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 非函数抛错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> func != <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(FUNC_ERROR_TEXT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// options 为对象时，进行 leading 和 trailing 的参数设置</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isObject(options)) &#123;</span><br><span class=\"line\">    leading = <span class=\"string\">'leading'</span> <span class=\"keyword\">in</span> options ? !!options.leading : leading;</span><br><span class=\"line\">    trailing = <span class=\"string\">'trailing'</span> <span class=\"keyword\">in</span> options ? !!options.trailing : trailing;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounce(func, wait, &#123;</span><br><span class=\"line\">    <span class=\"string\">'leading'</span>: leading,</span><br><span class=\"line\">    <span class=\"string\">'maxWait'</span>: wait,</span><br><span class=\"line\">    <span class=\"string\">'trailing'</span>: trailing</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>throttle</code>函数非常的简单，进行默认值选项<code>leading</code>和<code>trailing</code>的设置。然后对入参类型进行检测，接着直接返回调用<code>debounce</code>函数的内容。尽管<code>lodash</code>官方上面画了不少篇幅来介绍节流防抖的感念区别，其实<code>防抖</code>函数就是直接使用<code>节流</code>函数的逻辑来实现的。</p>\n<p>&emsp;&emsp;让我们把视线转到<code>debounce</code>函数。<code>debounce</code>的配置设置是一个高阶函数，放入你<strong>需要防抖的函数</strong>和<strong>调用配置</strong>，返回处理好的函数。先来看一下函数的入参以及入参处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>func The function to debounce.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[wait=0] The number of milliseconds to delay.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>[options=&#123;&#125;] The options object.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;boolean&#125;</span> </span>[options.leading=false]</span></span><br><span class=\"line\"><span class=\"comment\">  *  Specify invoking on the leading edge of the timeout.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[options.maxWait]</span></span><br><span class=\"line\"><span class=\"comment\">  *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param <span class=\"type\">&#123;boolean&#125;</span> </span>[options.trailing=true]</span></span><br><span class=\"line\"><span class=\"comment\">  *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@returns <span class=\"type\">&#123;Function&#125;</span> </span>Returns the new debounced function.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> lastArgs,</span><br><span class=\"line\">      lastThis,</span><br><span class=\"line\">      maxWait,</span><br><span class=\"line\">      result,</span><br><span class=\"line\">      timerId,</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      lastInvokeTime = <span class=\"number\">0</span>,</span><br><span class=\"line\">      leading = <span class=\"literal\">false</span>,</span><br><span class=\"line\">      maxing = <span class=\"literal\">false</span>,</span><br><span class=\"line\">      trailing = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 检测func非函数抛错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> func != <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(FUNC_ERROR_TEXT);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// wait 转number</span></span><br><span class=\"line\">  wait = toNumber(wait) || <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 根据options配置 leading maxWait 和 trailing</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isObject(options)) &#123;</span><br><span class=\"line\">    leading = !!options.leading;</span><br><span class=\"line\">    maxing = <span class=\"string\">'maxWait'</span> <span class=\"keyword\">in</span> options;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 options 有设置 maxWait ，取 options中的maxWait 以及 wait 的最大值</span></span><br><span class=\"line\">    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || <span class=\"number\">0</span>, wait) : maxWait;</span><br><span class=\"line\">    trailing = <span class=\"string\">'trailing'</span> <span class=\"keyword\">in</span> options ? !!options.trailing : trailing;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>debounce</code>函数的前两个入参<code>func</code>和<code>wait</code>为<code>需要节流的函数</code>以及<code>需要延迟的毫秒数</code>。第三个入参为防抖配置对象<code>options</code>，它存在三个配置项<code>leading</code>，<code>trailing</code>和<code>maxWait</code>。<code>maxWait</code>为函数被允许延迟的最大值，<code>leading</code>指在延迟前进行调用，<code>trailing</code>则对应的在延迟后开始调用函数。</p>\n<p>&emsp;&emsp;<code>debounce</code>函数剩下的代码逻辑，都是由多个小函数块构成。前面提到过，<code>debounce</code>为一个高阶函数，它返回节流逻辑包装处理过的函数。我们可以由<code>debounce</code>函数的返回<code>debounced</code>开始往上看整个<code>debounce</code>函数的逻辑。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounced</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回当前时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> time = now(),</span><br><span class=\"line\">    <span class=\"comment\">// 是否应该执行函数</span></span><br><span class=\"line\">        isInvoking = shouldInvoke(time);</span><br><span class=\"line\">    <span class=\"comment\">// 记录args和this</span></span><br><span class=\"line\">    lastArgs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    lastThis = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// lastCallTime 为当前的时间戳</span></span><br><span class=\"line\">    lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInvoking) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这里的timerId为setTimeout执行标识</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timerId === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leadingEdge(lastCallTime);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// maxing = 'maxWait' in options</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Handle invocations in a tight loop.</span></span><br><span class=\"line\">        timerId = setTimeout(timerExpired, wait);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokeFunc(lastCallTime);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timerId === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      timerId = setTimeout(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 注册 cancel 和 flush 接口</span></span><br><span class=\"line\">  debounced.cancel = cancel;</span><br><span class=\"line\">  debounced.flush = flush;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>debounced</code>整体函数也很简单，首先是获取到<strong>当前执行时的时间戳</strong>，传入调用<code>shouldInvoke</code>方法判断是否应该执行函数。如果应该执行，则根据有无<code>timerId</code>进行不同的执行函数逻辑。如果不应该执行函数，直接使用<code>setTimeout</code>，调起<code>timerExpired</code>执行。最后注册了一下<code>cancel</code>和<code>flush</code>的接口。<code>cancel</code>可以取消<code>debounced</code>的调用，<code>flush</code>则是立即执行<code>debounced</code>函数。我们来看下这两个函数的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cancel</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (timerId !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    clearTimeout(timerId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lastInvokeTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">  lastArgs = lastCallTime = lastThis = timerId = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flush</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> timerId === <span class=\"literal\">undefined</span> ? result : trailingEdge(now());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这两个函数逻辑非常的简单,<code>cancel</code>就是清除<code>timerId</code>标识的<code>timeOut</code>调用，并重置记录的<code>args</code>，<code>this</code>，以及<code>lastCallTime</code>等一些记录值。<code>flush</code>则是通过判断一下<code>timerId</code>是否存在，如果不存在，表示函数实质上已经调用过了，直接返回函数调用的结果。否则的话，调用<code>trailingEdge</code>，传入时间戳。这里的<code>trailingEdge</code>加上上一部分在<code>debounced</code>函数中的<code>leadingEdge</code>，都是进行防抖原函数的调用，我们来看着两个函数的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">leadingEdge</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  lastInvokeTime = time;</span><br><span class=\"line\">  timerId = setTimeout(timerExpired, wait);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> leading ? invokeFunc(time) : result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trailingEdge</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  timerId = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokeFunc(time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lastArgs = lastThis = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>trailingEdge</code>和<code>leadingEdge</code>是根据原<code>debounce</code>函数<code>options</code>当中的<code>trailing</code>和<code>leading</code>的不同配置进行的函数调用的逻辑。我们顺着这两个函数，查看下调用防抖原函数的<code>invokeFunc</code>以及<code>setTimeout</code>调用的<code>timerExpired</code>的函数逻辑。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invokeFunc</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = lastArgs,</span><br><span class=\"line\">      thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">  lastArgs = lastThis = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  lastInvokeTime = time;</span><br><span class=\"line\">  result = func.apply(thisArg, args);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerExpired</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> time = now();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInvoke(time)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> trailingEdge(time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Restart the timer.</span></span><br><span class=\"line\">  timerId = setTimeout(timerExpired, remainingWait(time));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>invokeFunc</code>函数就是通过<code>debounced</code>记录的函数入参<code>args</code>以及函数的<code>this</code>直接调用函数返回结果，并且记录函数调用的时间到<code>lastInvokeTime</code>。<code>timerExpired</code>是根据当前的时间戳，调用<code>shouldInvoke</code>得到函数是否可以进行调用。如果可以调用，直接进行<code>trailingEdge</code>的调用。如果还不能进行调用，再使用<code>setTimeout</code>再延长需要等待的时间。我们来看最后剩下的两个函数<code>shouldInvoke</code>和<code>remainingWait</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remainingWait</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// lastCallTime debounced调用的时间</span></span><br><span class=\"line\">  <span class=\"comment\">// lastInvokeTime debounce处理原函数调用的时间</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeSinceLastCall = time - lastCallTime,</span><br><span class=\"line\">      timeSinceLastInvoke = time - lastInvokeTime,</span><br><span class=\"line\">      timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxing</span><br><span class=\"line\">    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldInvoke</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeSinceLastCall = time - lastCallTime,</span><br><span class=\"line\">      timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (lastCallTime === <span class=\"literal\">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class=\"line\">    <span class=\"comment\">//  maxing = 'maxWait' in options;</span></span><br><span class=\"line\">    (timeSinceLastCall &lt; <span class=\"number\">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>remainingWait</code>函数，是根据<code>options</code>上面有无<code>maxWait</code>进行不同的逻辑计算。首先得到三个时间：</p>\n<ol>\n<li><strong>防抖函数debounced调用的时间</strong>与传入time的差值<code>timeSinceLastCall</code>，即这次调用<code>remainingWait</code>时<code>debounced</code>已经执行多久了。</li>\n<li><strong>防抖原函数调用的时间</strong>与传入time的差值，<code>timeSinceLastInvoke</code>；</li>\n<li>以及入参<code>wait</code>和第一个值的差值。即<code>debounced</code>调用后到执行<code>remainingWait</code>与传入的<code>wait</code>存在的差值。</li>\n</ol>\n<p>&emsp;&emsp;如果不存在<code>maxWait</code>的配置，那么直接返回第三个值即可。如果存在差值，就返回计算第三个值以及<code>maxWait</code>配置值和第一个值的差值的最小值。</p>\n<p>&emsp;&emsp;<code>shouldInvoke</code>首先计算出<code>timeSinceLastCall</code>以及<code>timeSinceLastInvoke</code>，逻辑和<code>remainingWait</code>相同。根据以下逻辑判断是否应该执行函数：</p>\n<ol>\n<li><code>lastCallTime</code>即<code>debounced</code>调用时间是否存在，不存在，直接返回true，否则到2</li>\n<li><code>timeSinceLastCall</code>是否大于等于<code>wait</code>，即<code>debounced</code>调用后是否已经大于需要等待的时间了。大于了返回true，否则到3</li>\n<li><code>timeSinceLastCall</code>是否小于0，即传入的<code>time</code>小于<code>lastCallTime</code>，小于0返回true，否则到4</li>\n<li><code>maxing</code>存在的话，<code>timeSinceLastInvoke</code>上次调用<code>debounce</code>原函数的时间大于<code>option</code>的<code>maxWait</code>配置的话，返回true，否则返回false</li>\n</ol>\n<p>&emsp;&emsp;到这里<code>debounce</code>函数的代码就看完了。不得不佩服，整个<code>debounce</code>函数逻辑模块拆分非常清晰。整个函数使用高阶函数的形式，包装了一个<code>debounced</code>函数。内部通过记录<code>debounced</code>调用时间和配置项的比较，利用<code>setTimeout</code>实现了节流函数的调用。</p>"},{"title":"标日初级上册复习整理总结","date":"2019-06-30T10:30:00.000Z","_content":"&emsp;&emsp;动词、形容词、名词、助词、其它划分语法句型。\n<!--more-->\n# 动词\n\n## 动词的三形\n- 一类动词: \n`ます`形去掉`ます`最后一个音位于`い`段的大部分动词为一类动词(書きます・読みます)。\n- 二类动词:\n最后一个音位于`え`段(食べます・寝ます)，以及位于`い`段的一小部分动词(起きます・見ます)。\n- 三类动词:\n`します`结尾的动词(勉強します・卒業します)，以及来ます。\n\n否定: ません\n过去: ました\n过去否定: ませんでした\n\n## 动词て形\n- 一类动变换为`て`形，为去掉`ます`，变化形态`+て`\nき → いて\nぎ → いで\nび・み・に　→　んで\nち・り・い　→　って\nし → して\n- 二三类动词变化为去掉`ます`直接加上`て`\n\n类别 | ます形 | て形\n---|---|---\n一类动词 | 書**き**ます | 書いて\n一类动词 | 急**ぎ**ます | 急ぎで\n一类动词 | 飛**び**ます | 飛んで\n一类动词 | 読**み**ます | 読んで\n一类动词 | 死**に**ます | 死んで\n一类动词 | 待**ち**ます | 待って\n一类动词 | 売**り**ます | 売って\n一类动词 | 買**い**ます | 買って\n一类动词 | 話**し**ます | 話して\n二类动词 | 食**べ**ます | 食べて\n二类动词 | 見ます | 見て\n三类动词 | 来ます | 来て\n三类动词 | します | して\n\n### 相关语法\n- *相继发生*\n図書館へ　**行って**　本を　借りました。\n\n- *并列*\n息子は　アメリカへ　**留学して**、娘は　東大に　入りました。\n\n- *手段方法方式*\n今日は　**歩いて**　帰ります。\n\n- *弱因果*\nあの　ビルは　エレベーターが　**あって**、便利です。\n\n- *附带状况*\n新しい　洋服を　**着て**　パーティーに　行きました。\n\n- *[(持续性动作)动词]“て形”＋います。[正在进行]*\n森さんは　コーヒーを　**飲んで**　います。\n李さんは　新聞を　**読んで**　います。\n\n- *[(瞬间性动作或表示变化的)动词]“て形”＋います：[结果状态]*　\nあの　犬は　**死んで**　います。\n小野さんは　もう　**結婚して**　いますか。\n\n- *~てから、~：[相继发生]强调先做完前项再做后项*\na: 会議を　始めましょう。\nb: ——いいえ、課長が　**来て**から　始めましょう。\n手を　洗ってから　**食べて**　ください。\n\n- *[动词]“て形”＋ください：要求对方做某事　*\n静かに　**して**　ください。\n`句型比较：[名词]＋を＋ください：请给我……（某物）,是给我什么东西，动词的为请做什么事情。`\n\n- *[动词]“て形”も　いいです：表示许可。“可以……”*\nここに　**座って**も　いいですか。\nこの　美術館では　写真を　**とって**も　いいですか。\n——ええ、撮っても　いいです  大丈夫です。\n——いいえ、いけません   ／駄目（だめ）です。\n\n- *[动词]“て形”は　いけません：表示禁止。“不可以……”*\nこの　美術館では　写真を　**撮って**は　いけません。\n\n## 动词た形\n- 一类动变换为`た`形，为去掉`ます`，变化形态`+た`\nき → いた\nぎ → いだ\nび・み・に　→　んだ\nち・り・い　→　った\nし → した\n- 二三类动词变化为去掉`ます`直接加上`た`\n\n类别 | ます形 | て形\n---|---|---\n一类动词 | 書**き**ます | 書いた\n一类动词 | 急**ぎ**ます | 急ぎだ\n一类动词 | 飛**び**ます | 飛んだ\n一类动词 | 読**み**ます | 読んだ\n一类动词 | 死**に**ます | 死んだ\n一类动词 | 待**ち**ます | 待った\n一类动词 | 売**り**ます | 売った\n一类动词 | 買**い**ます | 買った\n一类动词 | 話**し**ます | 話した\n二类动词 | 食**べ**ます | 食べた\n二类动词 | 見ます | 見た\n三类动词 | 来ます | 来た\n三类动词 | します | した\n\n### 相关语法\n- ~後で\n动(た形)+後で\n\n- *[动た形]＋ことが　あります*\nわたしは　すき焼きを　食べた　ことが　あります。\n日本へ　行った　ことが　ありません。\n\n- *～たり～たり：用于列举*\n简体过去形式＋り、＋り\n即：[动た形]＋り、[动た形]＋り＋します。\n[形1かった]＋り、[形1かった]＋り＋です／小句。\n[名／形2だった]＋り、[名／形2だった]＋り＋です／小句。\n小野さんは　休みの　日、 部屋を　掃除したり　洗濯したり　します。\n飛行機の　チケットは　季節によって　高かったり　安かったりです。\n日本語の　先生は　中国人だったり　日本人だったりです。\n\n- *[动词た形]+ほうが　いいです：表示建议，忠告“~比较好”*\nよく　考えた　ほうが　いいですよ。\n時間が　ありませんから、急いだ　ほうが　いいですよ。\n\n## 动词ない形\n- 一类动变换为`ない`形，去掉`ます`，最后一个音变为`あ段`,后加`ない`。\n如果最后一个音为`い`,则变为`わ`。\n- 二类动词变化为去掉`ます`直接加上`ない`。\n- 三类动词`きます`变为`来ない`，其余同二类型。\n\n类别 | ます形 | ない形\n---|---|---\n一类动词 | 書**き**ます | 書かない\n一类动词 | 急**ぎ**ます | 急がない\n一类动词 | 飛**び**ます | 飛ばない\n一类动词 | 読**み**ます | 読まない\n一类动词 | 死**に**ます | 死なない\n一类动词 | 待**ち**ます | 待たない\n一类动词 | 売**り**ます | 売らない\n一类动词 | 買**い**ます | 買わない\n一类动词 | 話**し**ます | 話さない\n二类动词 | 食**べ**ます | 食べない\n二类动词 | 見ます | 見ない\n三类动词 | 来ます | 来ない\n三类动词 | します | しない\n\n### 相关语法\n- *[动词ない形]＋ほうが　いいです：“最好不要那样做”*\n熱が　ありますから、こんばんは　お風呂に　入らない　ほうが　いいですよ。\n\n- *～ないで　ください：“请不要~”*\n禁煙席で　タバコを　**吸わないで**　ください。\nここに　車を　止めないで　ください。\n\n- *～なくても　いいです：“不必~”*\n明日は　休みですから、早く　**起きなくても**　いいです。\n\n- *～なければ　なりません：“必须~”*\nこれは　図書館の　本ですから、**返さなければ**　なりません。\n\n## 动词基本形\n- 一类动变换为基本形，去掉`ます`，最后一个音`い`变为`う段`。\n- 二类动词变化为去掉`ます`直接加上`る`。\n- 三类动词变为`来る`と`する`。\n\n类别 | ます形 | 基本形\n---|---|---\n一类动词 | 書**き**ます | かく\n一类动词 | 急**ぎ**ます | 急ぐ\n一类动词 | 飛**び**ます | 飛ぶ\n一类动词 | 読**み**ます | 読む\n一类动词 | 死**に**ます | 死ぬ\n一类动词 | 待**ち**ます | 待つ\n一类动词 | 売**り**ます | うる\n一类动词 | 買**い**ます | 買う\n一类动词 | 話**し**ます | 話す\n二类动词 | 食**べ**ます | 食べる\n二类动词 | 見ます | 見る\n三类动词 | 来ます | 来る\n三类动词 | します | する\n\n### 相关语法\n- *（～は）[动(基本形)]＋ことが　できます：①能力；②条件允许。*\n森さんは　料理を　作る　ことが　できますか。\n——はい、できます。／いいえ、できません。\n\n- *[名]+は+[动(基本形)]+ことです*\nわたしの　趣味は　本を　読む　ことです。\n森さんの　夢は　外国で　働く　ことです。\n\n\n\n# 形容词\n\n## 形容词的二形\n\n- 一类形容词 词尾以`い`结尾的形容词\n否定: い → くない\n过去: \b い　→　かった\n过去否定:  い → く なかってです / く　ありませんでした\n\n- 二类形容词 词尾不为`い`结尾的形容词\n否定: でわありませ\n过去和です变化相同，为でした　ではありませんでした\n\n### 相关语法\n- *あまり～[形1／动(否定)]：“不怎么……，不太……”，表示程度不高。*\n昨日の　試験は　あまり　難しく　なかったです。\nわたしは　あまり　コーヒーを　飲みません。\n\n- *形容词谓语句*：\n - 一类形容词　\n①现在将来肯定形式： 今日は　寒いです。\n②现在将来否定形式：今日は　寒く　ないです／ありません。\n③过去肯定形式：昨日は　寒かったです。\n④过去否定形式：昨日は　寒く　なかったです／ありませんでした。\nいい\n→よく　ない   →よかった   →よく   なかった\n\n - 二类形容词　\n①现在将来肯定形式：東京は　にぎやかです。\n②现在将来否定形式：京都は　にぎやかでは　ありません／では　ないです。\n③过去肯定形式：京都は　にぎやかでした。\n④过去否定形式：京都は　にぎやかでは　ありませんでした。\n\n- *～で　[何／だれ／いつ／どれ／どの　名]が　いちばん[形容词]ですか*\n“哪个~最……？”\n季節の　中で、いつが　いちばん　好きですか。\n果物の　中で、何が　いちばん　好きですか。\n\n- 形容词变化句\n - [形1（词尾“い”→“く”）]＋します：使……变得……\n - [形1（词尾“い”→“く”）]＋なります：……变得…… \nだんだん　暖かく　なります。\nテレビの　音を　大きく　します。\n - [名／形2]＋“に”＋“します”：使……变得……，使……成为……　\n - [名／形2]＋“に”＋“なります”：……变得……\n部屋を　きれいに　して　ください。\n部屋は　きれいに　なりました。\n息子を　医者に　します。\n息子は　医者に　なりました。\n\n- *形容词作定语（修饰名词）*\n一类形容词：青い　海\n二类形容词：きれいな　部屋\n\n## 形容词的て形\n- *一类形容词的“て形”：词尾的“い”变成“く”+“て”*\nこの　公園は　**広　くて**　静かです。\n彼女は　優しくて　**きれいで**す。\n\n- *二类形容词的“て形”：词干 +“で”*\n彼女は　**きれいで**　優しいです。\n\n# 名词\nこと：形式名词，起到将前项的动词或形容词小句名词化的作用。\n\n- *[名]＋“に”＋“します” ：表示选择，决定。*\nカレーライスに　します。\nあの　子に　します。\n\n- *[名]（～を）ください：请给我……。*\nコーヒーを　２つ　ください。\n娘さんを　ください。\n\n- *[名]＋が＋欲しい（ほしい）です：想要…（某物），用于表达自己的欲望。*\n新しい　パソコンが　欲しいです。\n否定形式：欲しく　ないです／欲しく　ありません。\n过去形式：欲しかったです\n今は　何も　欲しく　ないです／欲しく　ありません。\n\n- *[名1]は　[名2]を　[动(“ます型”去掉“ます”)]たいです*\n“～たい”的词尾“い”按一类形容词活用。\n映画を　見たいです。\n否定形式：飲みたく　ないです／ありません。\n过去形式：たかったです\n今は　お酒を　飲みたく　ないです／ありません。\n\n- *[名词1]＋“で”＋[名词2]*\n森さんは　企画会社の　社員で、背が　高くて、ハンサムな　人です。\n\n\n- *[名]か　[名]：表示选择，“~或者~”*\n毎朝　パンか　お粥を　食べます。\n休みは　月曜日か　火曜日です。\n\n- *名词谓语句*\n现在将来肯定形式：今日は　いい　天気です。\n现在将来否定形式： 今日は　いい　天気では　ありません／ではないです。\n过去肯定形式：  昨日は　いい　天気でした。\n过去否定形式： 昨日は　いい　天気では　ありませんでした。\n\n- *名词 + の + 後で*\n仕事が　終わった　後で、飲みに　行きます。\n仕事の　後で、飲みに　行きます。\n\n- *[名（场所）]＋を＋（带移动意味的）动词：经过／离开的场所*\nこの　バスは　駅前を　通ります。\nわたしは　来年　大学を　卒業します。\n家を　出ます。\n\n# 助词\n\n## が\n- *[小句]が、[小句]：[转折]*\n３か月　パソコンを　勉強しました**が**、まだ　あまり　できません。\nこの　レストランは　おいしいです**が**、ちょっと　高いです。\n\n- *[小句]が、[小句]：[铺垫]*\n東京タワーへ　行きたいんです**が**、どうやって　行きますか。\n\n- *～が～：提示主语。*\n\n 旧信息用“は”，新信息用“が”。\n 山田さんは　どなたですか。\n 山田さんは　あの　方です。\n あの　方が　山田さんです。\n\n 疑问词作主语时，一定用“が”（新信息）。\n どなたが　山田さんですか。　は（×）\n ——あの　方が　山田さんです。\n\n ～が～：表示感情或能力的对象（对象语）。\n わたしは　犬が　好きです。\n スミスさんは　韓国語が　分かります。\n\n## で\n\n- *名[工具／手段／方式]＋“で”：表示工具或手段、方法、方式。*\n日本語**で**　手紙を　書きます。\nタクシー**で**　帰ります。\n\n- *名词[原材料]＋“で” ：表示原材料。*\n新聞紙**で**　紙飛行機を　作りました。\n\n- *名[场所]+“で”：表示动作或事情发生的场所。*\n来月、この　ホテル**で**　友達の　写真展が　あります。\n\n- *数量词＋“で”：表示总计。*\nこの りんごは　３個**で**　５００円です。\n\n- *名[人数等]＋“で”：表示动作主体的状态。*\n北京では、春節の　前に、家族全員**で**　餃子を　作ります。\n今度　二人**で**　会いましょう。\n\n- *名[场所或范围]＋“で”：表示范围。*\n日本**で**　いちばん　高い山は　富士山です。\n一年**で**　いちばん　寒い月は　２月です。  \n\n## に\n- *具体时间点＋に：具体时间*　\nわたしは　毎晩　**１１時に**　寝ます。\n\n- *间接宾语＋に：动作行为的对象*\n李さん**に**　手紙を　書きます。\n友達**に**　お金を　貸します。\nさっき　駅前で　森さん**に**　会いました。\n\n- *时间段＋に＋次数＋[动词]：频率*\n1年**に**　1回　国へ　帰ります。／**年に**　1回　国へ　帰ります。\n1日**に**　2杯　コーヒーを　飲みます。／**日に**　2杯　コーヒーを　飲みます。\n\n- *[动1,2]“ます形”去掉“ます”／[动3词干]＋に＋移动动词：移动行为的目的*\n友達の　家へ　**遊びに**　行きます。\n渋谷へ　買い物**に**　行きます。\n\n- *附着点＋に：附着点*　　　\nここ**に**　座っても　いいですか。\n電車／バス／飛行機／自転車に　乗ります。\nその品物**に**　触らないで　ください。\n\n- *～前に、～：“……之前，……”*\n[动词基本形]＋前に\n[名词]＋の＋前に\nこちらへ　来る　前に　電話を　かけて　ください。\n会議の　前に　資料を　コピーします。\n\n## と\n- *[名1]と　[名2]：[并列]*\nパン**と**　ミルク\nテレビ**と**　冷蔵庫\n箱の　中に　眼鏡**と**　時計が　あります。\n\n- *[名(人)]と　[动词]ます：表示共同进行动作的对象。*\n昨日　友達**と**　渋谷で　買い物しました。\nA**と**　B**と**、どちらが　～ですか。\n\n## も\n- *～も：[兼提]“~也”*　\n李さんは　中国人です。張さん**も**　中国人です。\n来週の　ハイキング、私**も**　行きたい。\n\n- *[数量词]＋も+肯定形式：强调数量多。*\n何度**も**　転びましたが、とても　おもしろいです。\n\n- *[较少数量]＋も＋否定形式：全面否定。*\n財布の　中に　１円**も**　ありません。\nわたしには　友達が　１人**も**　いません。\n\n## ね\n- *[确认]*　\nあそこに　猫が　いますね。\nこの　新聞は　田中さんのですね。\n\n- *よね：[确认]*　　\n今日　李さんも　来ますよね。\n手作りの　餃子は　皮が　おいしいです**よね**。\n\n- *[确认][缓和语气]*\n日本料理の　中で、何が　いちばん　好きですか。\n——そうですね。やっぱり　おすしです**ね**。\n\n## の\n- *[所属关系、属性、内容、原材料等]*\n中国の　企業\n\n## へ\n- *移动行为的目的地／方向*\n李さんは　中国へ　帰りました。\n- *へ～に行きます／来ます*\n昨日　渋谷へ　買い物に　行きました。\n\n## や\n- *～や～／～や～など：表示不完全列举*　\n昨日、スーパーで　野菜や　果物などを　買いました。\n\n## よ\n- *[提醒、告知、轻微警告]*　\n李さんは　もう　帰りましたよ。\n\n## は\n- *～は～が[感情形容词]です*\n～は：表示感情的主体。　～が：表示感情所指向的对象。 \n一般用于表达第一人称的感情。（日语中一般避免直接说出别人的内心感受）\n（わたしは）日本の　漫画が　好きです。\n（あなたは）どんな　本が　好きですか。\n\n- *～は～が分かります／できます／上手です／下手です[表示能力的词]*\n～は：表示能力的主体。　～が：表示能力的对象。\nスミスさんは　韓国語が　分かります。\n小野さんは　料理が　上手です。\n森さんは　歌が　下手です。\n\n# 其它重点句型\n\n## 引用句型\n- *[简体形小句]と　思います：引用说话人的思考内容。*\n李さんは　もうすぐ　来ると　思います。\n明日は　いい　天気だと　思います。\n\n- *[小句]と　言いました：转述第三人称的说话内容。*\n小野さんは　李さんに　ちょっと　休みたいと　言いました。 \n長島さんは　やめた　ほうが　いいと　言いました。\n長島さんは　「やめた　ほうが　いいですよ」と　言いました。\n\n## 比较句\n\n- *Aは　Bより　[形容词]です：“A比B更……”*\n中国は　日本**より**　広いです。\n中国は　日本**より**　ずっと　広いです。\n\n- *Aより　Bの　ほうが　[形容词]です：“比起A来，B更……”*\n日本**より**　中国**の　ほうが**　広いです。\n\n- *Aは　Bほど　[形1(い→く)]ないです／[形2]ではありません：“A不如B……”*\n大阪は　東京ほど　にぎやか　では　ありません。\n\n- *Aと　Bと　どちらが　[形容词]ですか：“A和B，哪一个更……？”*\n日本語と　英語と　**どちらが**　難しいですか。\n——日本語の　ほうが　難しいです。・どちらも　難しいです。\n\n- *[名1（范围）]の　中で　[名2]が　いちばん　[形容词]です*\n“在～[名1]之中，～[名2]最……”\nスポーツの　中で　サッカーが　いちばん　おもしろいです。\n\n- *[名1（范围）]でいちばん～は[名2]です*\n“在～[名1]之中，[名2]最……”\n日本で　いちばん　高い山は　富士山です。\n\n## 小句+か得包孕句型\n\n- 一*般疑问句→[小句]＋か　どうか（或重复谓语部分的肯定与否定形式）*\n形式：简体＋か　どうか   <注意：二类形／名（不含“だ”）＋か　どうか>\n注意：小句中的主语必须用“が”、不能用“は”。\nわたしは　今年の　夏　北京へ　行きますか。＋わたしは　分かりません。\nわたしは　今年の　夏　北京へ　行くか　どうか　分かりません。\nこの　料理は　辛いですか。＋わたしは　知りません。\nこの　料理が　辛いか　どうか　知りません。\nこの　料理が　辛いか　辛くないか　知りません。\n\n- *特殊疑问句→[带疑问词的小句]＋か*\n形式：[带疑问词的小句]简体形式＋か　<注意：二类形／名（不含だ）＋か>\nかぎが　どこに　ありますか。＋教えて　ください。\nかぎが　どこに　あるか　教えて　ください。\nこの　歌は　だれの　歌ですか＋知って　いますか。\nこの　歌が　だれの　歌か　知って　いますか。　（○）\n\n## 授受动词　\n- *（Aは）Bに　～あげます：A给B~。（B不能是“自己人”）*\n小野さんは　森さんに　チョコレートを　あげました。\n小野：わたしは　森さんに　チョコレートを　あげました。自己人需要使用くれます\n\n- *（Aは）Bに／から～もらいます：A从B处得到~。*\n森さんは　小野さんに／から　チョコレートを　もらいました。\n長島さんから　この　写真集を　もらいました。\n\n## 提议劝诱（礼貌程度依次递增）\n～ましょう：[提议，劝诱] “咱们……吧？”　\n～ましょうか。 [提议，劝诱]　\n～ませんか：[提议，劝诱]“要不要……？”\n\n## 存在句 あります/います\n表存在的句型，人、动物和昆虫用“います”, 非生物和植物用“あります”\n\n- *名[场所]に　名[物／人]が　あります／います：表示某地有某物或某人*\n庭に　桜（さくら）の　木が　あります。\n庭に　犬が　います。\n\n- *名[物／人]は　名[场所]に　あります／います：表示某物或某人在某处*\n事務所は　あの　ビルの　７階に　あります。\n李さんは　どこに　いますか。\n\n- *名[场所]で　名[事件]が　あります：表示在某地发生或举行某事*\nゆうべ、大阪で　地震が　ありました。\n来月、この　ホテルで　友達の　写真展が　あります。\n\n- *名[所有人]（に）は　名[所有物／人]が　あります／います：表示所有／拥有*\n森さんは　車が　２台 　あります。\n森さんは　弟が　２人　 います。\n\n## 疑问词\n- *疑问词＋か：表示不确定*　\n冬休みに　どこかへ　行きたいですね。\nおなかが　すきましたね。何か　食べましょう。\n\n- *疑问词＋でも＋肯定形式：表示全面肯定*　\nいつでも　電話して　ください。\n何を　食べたいですか。 ——何でも　いいです。\n\n- *疑问词＋も＋否定形式：表示全面否定*　\n教室に　だれも　いません。\n冷蔵庫に　何も　ありません。\n\n- *～は　いくらですか：~多少钱？*\n\n- *誰（だれ）ですか／何（なん）ですか。*\n\n- *～かな：放在简体形疑问小句的结尾。*\n用于自言自语。存在听话人的场合下，用于向对方传达一种不太有把握的\n信息或寻求确认。\n期間は　４年か　５年かな。\n\n\n- *～ですか、～ですか：选择疑问句*　　　\nでも～：表示转折\n\n\n- どうしてですか：询问理由。\nどうして～のですか／んですか。　\n来月　また　ここに　来ます。\nどうして　ですか。\nこの　ホテルで　友達の　写真展が　ありますから。\nどうして　食べないのですか／んですか。\nもう　おなかが　いっぱいなんです。\n\n## 指示词(コソアド系)\nこれ／それ／あれ／どれ：用于指代事物\nこの／その／あの／どの＋名：指示连体词，后加名词\nここ／そこ／あそこ／どこ：用于指代场所\nこちら／そちら／あちら／どちら：礼貌说法\nこう／そう／ああ／どう：指代行为方式\n\n## 时间\n- *いつ　[动]　ますか：何时……？*　\nいつ　出かけますか。\n会議は　いつ　終わりますか。\n\n- *今～時～分です。*\n今　４時３０分です。\n\n## 询问对方的感想　\nどうですか\n- *どうでしたか。*\nこの　料理は　どうですか。\n旅行は　どうでしたか。\n- *（～は）どこですか。*\nどれ／どの～　\nどんな＋名词：“怎样的~”\nどんな　音楽が　好きですか。\n\n## 因果\n- *～から和だから：表示因果。*\n[敬体／简体小句（原因）]＋から、……[敬体／简体小句]。\n[句子]。ですから／だから 、……[句子（结果）]。\n森さんは　お酒が　好きですから、 毎日　飲みます。\n窓を　閉めます。 寒いですから。\n キムさんは　野菜が　嫌いです。だから／ですから、あまり　食べません。\nキムさんは　野菜が　嫌いですから、あまり　食べません。\n\n## 否定\n- *まだ～：[否定] “尚未……，还没……”*\nまだ～ていません。\nまだです。\n小野さんは　もう　結婚して　いますか。\n——いいえ、まだ　結婚して　いません。\n——いいえ、まだです。\n李さんは　来ましたか。\n——いいえ、まだ　来て　いません。\n——いいえ、まだです。\n\n## 转折强调\n- *～けど、～：[转折][铺垫]*　多用于简体句\n昨日の　試験、どうだった？\n——ちょっと　難しかったけど、まあまあ　できたよ。\n来週、送別会を　するけど、都合は　どうかな？\n\n- *でも、～：但是……*\nそして、～：而且……\nわたしの　部屋は　狭いです。でも、きれいです。\nわたしの　部屋は　狭いです。そして、汚いです。\n\n- *に／で／へ／から／まで／と＋は：助词叠加【格助词＋提示助词】*\n韓国へは　行きましたが、中国へは　行きませんでした。\n森さんには　会いたく　ないです。\n\n- *“を”→“は”：作为整个句子的话题或表示对比强调*　\nコーヒーを　飲みません。     → コーヒーは　飲みません。\nチケットを　買いましたか。 → チケットは　買いましたか。\n\n- *～のです／～んです：对某前提事态的说明或解释。*\n~のですか／～んですか：寻求对某前提事态的说明或解释。\nあ、雨が　降って　いるんですか。\n何を　探して　いるんですか。\n昨日　学校を　休みました。頭が　痛かったんです。\n東京タワーへ　行きたいんですが、どうやって　行きますか。\n接续：简体形小句＋のです／んです。名／二类形（だ→な）＋のです／んです\n\n- *～から：起点 ～まで：终点*\n時間と空间\nわたしは　９時から　午後５時まで　働きます。\n東京から　広島まで　新幹線で　行きます。\n試験は　９時から　１２時までです。\n\n- *～くらい・ぐらい：前接数量词，表示大概的数量。*\n大阪まで　どのくらい／どれぐらい　かかりますか。\n——２時間ぐらい　かかります。","source":"_posts/nihonngo/nihonngo-1.md","raw":"---\ntitle: 标日初级上册复习整理总结\ndate: 2019/6/30 18:30\ncategories:\n- [日语, 标日初级上册]\ntags:\n- 日语\n---\n&emsp;&emsp;动词、形容词、名词、助词、其它划分语法句型。\n<!--more-->\n# 动词\n\n## 动词的三形\n- 一类动词: \n`ます`形去掉`ます`最后一个音位于`い`段的大部分动词为一类动词(書きます・読みます)。\n- 二类动词:\n最后一个音位于`え`段(食べます・寝ます)，以及位于`い`段的一小部分动词(起きます・見ます)。\n- 三类动词:\n`します`结尾的动词(勉強します・卒業します)，以及来ます。\n\n否定: ません\n过去: ました\n过去否定: ませんでした\n\n## 动词て形\n- 一类动变换为`て`形，为去掉`ます`，变化形态`+て`\nき → いて\nぎ → いで\nび・み・に　→　んで\nち・り・い　→　って\nし → して\n- 二三类动词变化为去掉`ます`直接加上`て`\n\n类别 | ます形 | て形\n---|---|---\n一类动词 | 書**き**ます | 書いて\n一类动词 | 急**ぎ**ます | 急ぎで\n一类动词 | 飛**び**ます | 飛んで\n一类动词 | 読**み**ます | 読んで\n一类动词 | 死**に**ます | 死んで\n一类动词 | 待**ち**ます | 待って\n一类动词 | 売**り**ます | 売って\n一类动词 | 買**い**ます | 買って\n一类动词 | 話**し**ます | 話して\n二类动词 | 食**べ**ます | 食べて\n二类动词 | 見ます | 見て\n三类动词 | 来ます | 来て\n三类动词 | します | して\n\n### 相关语法\n- *相继发生*\n図書館へ　**行って**　本を　借りました。\n\n- *并列*\n息子は　アメリカへ　**留学して**、娘は　東大に　入りました。\n\n- *手段方法方式*\n今日は　**歩いて**　帰ります。\n\n- *弱因果*\nあの　ビルは　エレベーターが　**あって**、便利です。\n\n- *附带状况*\n新しい　洋服を　**着て**　パーティーに　行きました。\n\n- *[(持续性动作)动词]“て形”＋います。[正在进行]*\n森さんは　コーヒーを　**飲んで**　います。\n李さんは　新聞を　**読んで**　います。\n\n- *[(瞬间性动作或表示变化的)动词]“て形”＋います：[结果状态]*　\nあの　犬は　**死んで**　います。\n小野さんは　もう　**結婚して**　いますか。\n\n- *~てから、~：[相继发生]强调先做完前项再做后项*\na: 会議を　始めましょう。\nb: ——いいえ、課長が　**来て**から　始めましょう。\n手を　洗ってから　**食べて**　ください。\n\n- *[动词]“て形”＋ください：要求对方做某事　*\n静かに　**して**　ください。\n`句型比较：[名词]＋を＋ください：请给我……（某物）,是给我什么东西，动词的为请做什么事情。`\n\n- *[动词]“て形”も　いいです：表示许可。“可以……”*\nここに　**座って**も　いいですか。\nこの　美術館では　写真を　**とって**も　いいですか。\n——ええ、撮っても　いいです  大丈夫です。\n——いいえ、いけません   ／駄目（だめ）です。\n\n- *[动词]“て形”は　いけません：表示禁止。“不可以……”*\nこの　美術館では　写真を　**撮って**は　いけません。\n\n## 动词た形\n- 一类动变换为`た`形，为去掉`ます`，变化形态`+た`\nき → いた\nぎ → いだ\nび・み・に　→　んだ\nち・り・い　→　った\nし → した\n- 二三类动词变化为去掉`ます`直接加上`た`\n\n类别 | ます形 | て形\n---|---|---\n一类动词 | 書**き**ます | 書いた\n一类动词 | 急**ぎ**ます | 急ぎだ\n一类动词 | 飛**び**ます | 飛んだ\n一类动词 | 読**み**ます | 読んだ\n一类动词 | 死**に**ます | 死んだ\n一类动词 | 待**ち**ます | 待った\n一类动词 | 売**り**ます | 売った\n一类动词 | 買**い**ます | 買った\n一类动词 | 話**し**ます | 話した\n二类动词 | 食**べ**ます | 食べた\n二类动词 | 見ます | 見た\n三类动词 | 来ます | 来た\n三类动词 | します | した\n\n### 相关语法\n- ~後で\n动(た形)+後で\n\n- *[动た形]＋ことが　あります*\nわたしは　すき焼きを　食べた　ことが　あります。\n日本へ　行った　ことが　ありません。\n\n- *～たり～たり：用于列举*\n简体过去形式＋り、＋り\n即：[动た形]＋り、[动た形]＋り＋します。\n[形1かった]＋り、[形1かった]＋り＋です／小句。\n[名／形2だった]＋り、[名／形2だった]＋り＋です／小句。\n小野さんは　休みの　日、 部屋を　掃除したり　洗濯したり　します。\n飛行機の　チケットは　季節によって　高かったり　安かったりです。\n日本語の　先生は　中国人だったり　日本人だったりです。\n\n- *[动词た形]+ほうが　いいです：表示建议，忠告“~比较好”*\nよく　考えた　ほうが　いいですよ。\n時間が　ありませんから、急いだ　ほうが　いいですよ。\n\n## 动词ない形\n- 一类动变换为`ない`形，去掉`ます`，最后一个音变为`あ段`,后加`ない`。\n如果最后一个音为`い`,则变为`わ`。\n- 二类动词变化为去掉`ます`直接加上`ない`。\n- 三类动词`きます`变为`来ない`，其余同二类型。\n\n类别 | ます形 | ない形\n---|---|---\n一类动词 | 書**き**ます | 書かない\n一类动词 | 急**ぎ**ます | 急がない\n一类动词 | 飛**び**ます | 飛ばない\n一类动词 | 読**み**ます | 読まない\n一类动词 | 死**に**ます | 死なない\n一类动词 | 待**ち**ます | 待たない\n一类动词 | 売**り**ます | 売らない\n一类动词 | 買**い**ます | 買わない\n一类动词 | 話**し**ます | 話さない\n二类动词 | 食**べ**ます | 食べない\n二类动词 | 見ます | 見ない\n三类动词 | 来ます | 来ない\n三类动词 | します | しない\n\n### 相关语法\n- *[动词ない形]＋ほうが　いいです：“最好不要那样做”*\n熱が　ありますから、こんばんは　お風呂に　入らない　ほうが　いいですよ。\n\n- *～ないで　ください：“请不要~”*\n禁煙席で　タバコを　**吸わないで**　ください。\nここに　車を　止めないで　ください。\n\n- *～なくても　いいです：“不必~”*\n明日は　休みですから、早く　**起きなくても**　いいです。\n\n- *～なければ　なりません：“必须~”*\nこれは　図書館の　本ですから、**返さなければ**　なりません。\n\n## 动词基本形\n- 一类动变换为基本形，去掉`ます`，最后一个音`い`变为`う段`。\n- 二类动词变化为去掉`ます`直接加上`る`。\n- 三类动词变为`来る`と`する`。\n\n类别 | ます形 | 基本形\n---|---|---\n一类动词 | 書**き**ます | かく\n一类动词 | 急**ぎ**ます | 急ぐ\n一类动词 | 飛**び**ます | 飛ぶ\n一类动词 | 読**み**ます | 読む\n一类动词 | 死**に**ます | 死ぬ\n一类动词 | 待**ち**ます | 待つ\n一类动词 | 売**り**ます | うる\n一类动词 | 買**い**ます | 買う\n一类动词 | 話**し**ます | 話す\n二类动词 | 食**べ**ます | 食べる\n二类动词 | 見ます | 見る\n三类动词 | 来ます | 来る\n三类动词 | します | する\n\n### 相关语法\n- *（～は）[动(基本形)]＋ことが　できます：①能力；②条件允许。*\n森さんは　料理を　作る　ことが　できますか。\n——はい、できます。／いいえ、できません。\n\n- *[名]+は+[动(基本形)]+ことです*\nわたしの　趣味は　本を　読む　ことです。\n森さんの　夢は　外国で　働く　ことです。\n\n\n\n# 形容词\n\n## 形容词的二形\n\n- 一类形容词 词尾以`い`结尾的形容词\n否定: い → くない\n过去: \b い　→　かった\n过去否定:  い → く なかってです / く　ありませんでした\n\n- 二类形容词 词尾不为`い`结尾的形容词\n否定: でわありませ\n过去和です变化相同，为でした　ではありませんでした\n\n### 相关语法\n- *あまり～[形1／动(否定)]：“不怎么……，不太……”，表示程度不高。*\n昨日の　試験は　あまり　難しく　なかったです。\nわたしは　あまり　コーヒーを　飲みません。\n\n- *形容词谓语句*：\n - 一类形容词　\n①现在将来肯定形式： 今日は　寒いです。\n②现在将来否定形式：今日は　寒く　ないです／ありません。\n③过去肯定形式：昨日は　寒かったです。\n④过去否定形式：昨日は　寒く　なかったです／ありませんでした。\nいい\n→よく　ない   →よかった   →よく   なかった\n\n - 二类形容词　\n①现在将来肯定形式：東京は　にぎやかです。\n②现在将来否定形式：京都は　にぎやかでは　ありません／では　ないです。\n③过去肯定形式：京都は　にぎやかでした。\n④过去否定形式：京都は　にぎやかでは　ありませんでした。\n\n- *～で　[何／だれ／いつ／どれ／どの　名]が　いちばん[形容词]ですか*\n“哪个~最……？”\n季節の　中で、いつが　いちばん　好きですか。\n果物の　中で、何が　いちばん　好きですか。\n\n- 形容词变化句\n - [形1（词尾“い”→“く”）]＋します：使……变得……\n - [形1（词尾“い”→“く”）]＋なります：……变得…… \nだんだん　暖かく　なります。\nテレビの　音を　大きく　します。\n - [名／形2]＋“に”＋“します”：使……变得……，使……成为……　\n - [名／形2]＋“に”＋“なります”：……变得……\n部屋を　きれいに　して　ください。\n部屋は　きれいに　なりました。\n息子を　医者に　します。\n息子は　医者に　なりました。\n\n- *形容词作定语（修饰名词）*\n一类形容词：青い　海\n二类形容词：きれいな　部屋\n\n## 形容词的て形\n- *一类形容词的“て形”：词尾的“い”变成“く”+“て”*\nこの　公園は　**広　くて**　静かです。\n彼女は　優しくて　**きれいで**す。\n\n- *二类形容词的“て形”：词干 +“で”*\n彼女は　**きれいで**　優しいです。\n\n# 名词\nこと：形式名词，起到将前项的动词或形容词小句名词化的作用。\n\n- *[名]＋“に”＋“します” ：表示选择，决定。*\nカレーライスに　します。\nあの　子に　します。\n\n- *[名]（～を）ください：请给我……。*\nコーヒーを　２つ　ください。\n娘さんを　ください。\n\n- *[名]＋が＋欲しい（ほしい）です：想要…（某物），用于表达自己的欲望。*\n新しい　パソコンが　欲しいです。\n否定形式：欲しく　ないです／欲しく　ありません。\n过去形式：欲しかったです\n今は　何も　欲しく　ないです／欲しく　ありません。\n\n- *[名1]は　[名2]を　[动(“ます型”去掉“ます”)]たいです*\n“～たい”的词尾“い”按一类形容词活用。\n映画を　見たいです。\n否定形式：飲みたく　ないです／ありません。\n过去形式：たかったです\n今は　お酒を　飲みたく　ないです／ありません。\n\n- *[名词1]＋“で”＋[名词2]*\n森さんは　企画会社の　社員で、背が　高くて、ハンサムな　人です。\n\n\n- *[名]か　[名]：表示选择，“~或者~”*\n毎朝　パンか　お粥を　食べます。\n休みは　月曜日か　火曜日です。\n\n- *名词谓语句*\n现在将来肯定形式：今日は　いい　天気です。\n现在将来否定形式： 今日は　いい　天気では　ありません／ではないです。\n过去肯定形式：  昨日は　いい　天気でした。\n过去否定形式： 昨日は　いい　天気では　ありませんでした。\n\n- *名词 + の + 後で*\n仕事が　終わった　後で、飲みに　行きます。\n仕事の　後で、飲みに　行きます。\n\n- *[名（场所）]＋を＋（带移动意味的）动词：经过／离开的场所*\nこの　バスは　駅前を　通ります。\nわたしは　来年　大学を　卒業します。\n家を　出ます。\n\n# 助词\n\n## が\n- *[小句]が、[小句]：[转折]*\n３か月　パソコンを　勉強しました**が**、まだ　あまり　できません。\nこの　レストランは　おいしいです**が**、ちょっと　高いです。\n\n- *[小句]が、[小句]：[铺垫]*\n東京タワーへ　行きたいんです**が**、どうやって　行きますか。\n\n- *～が～：提示主语。*\n\n 旧信息用“は”，新信息用“が”。\n 山田さんは　どなたですか。\n 山田さんは　あの　方です。\n あの　方が　山田さんです。\n\n 疑问词作主语时，一定用“が”（新信息）。\n どなたが　山田さんですか。　は（×）\n ——あの　方が　山田さんです。\n\n ～が～：表示感情或能力的对象（对象语）。\n わたしは　犬が　好きです。\n スミスさんは　韓国語が　分かります。\n\n## で\n\n- *名[工具／手段／方式]＋“で”：表示工具或手段、方法、方式。*\n日本語**で**　手紙を　書きます。\nタクシー**で**　帰ります。\n\n- *名词[原材料]＋“で” ：表示原材料。*\n新聞紙**で**　紙飛行機を　作りました。\n\n- *名[场所]+“で”：表示动作或事情发生的场所。*\n来月、この　ホテル**で**　友達の　写真展が　あります。\n\n- *数量词＋“で”：表示总计。*\nこの りんごは　３個**で**　５００円です。\n\n- *名[人数等]＋“で”：表示动作主体的状态。*\n北京では、春節の　前に、家族全員**で**　餃子を　作ります。\n今度　二人**で**　会いましょう。\n\n- *名[场所或范围]＋“で”：表示范围。*\n日本**で**　いちばん　高い山は　富士山です。\n一年**で**　いちばん　寒い月は　２月です。  \n\n## に\n- *具体时间点＋に：具体时间*　\nわたしは　毎晩　**１１時に**　寝ます。\n\n- *间接宾语＋に：动作行为的对象*\n李さん**に**　手紙を　書きます。\n友達**に**　お金を　貸します。\nさっき　駅前で　森さん**に**　会いました。\n\n- *时间段＋に＋次数＋[动词]：频率*\n1年**に**　1回　国へ　帰ります。／**年に**　1回　国へ　帰ります。\n1日**に**　2杯　コーヒーを　飲みます。／**日に**　2杯　コーヒーを　飲みます。\n\n- *[动1,2]“ます形”去掉“ます”／[动3词干]＋に＋移动动词：移动行为的目的*\n友達の　家へ　**遊びに**　行きます。\n渋谷へ　買い物**に**　行きます。\n\n- *附着点＋に：附着点*　　　\nここ**に**　座っても　いいですか。\n電車／バス／飛行機／自転車に　乗ります。\nその品物**に**　触らないで　ください。\n\n- *～前に、～：“……之前，……”*\n[动词基本形]＋前に\n[名词]＋の＋前に\nこちらへ　来る　前に　電話を　かけて　ください。\n会議の　前に　資料を　コピーします。\n\n## と\n- *[名1]と　[名2]：[并列]*\nパン**と**　ミルク\nテレビ**と**　冷蔵庫\n箱の　中に　眼鏡**と**　時計が　あります。\n\n- *[名(人)]と　[动词]ます：表示共同进行动作的对象。*\n昨日　友達**と**　渋谷で　買い物しました。\nA**と**　B**と**、どちらが　～ですか。\n\n## も\n- *～も：[兼提]“~也”*　\n李さんは　中国人です。張さん**も**　中国人です。\n来週の　ハイキング、私**も**　行きたい。\n\n- *[数量词]＋も+肯定形式：强调数量多。*\n何度**も**　転びましたが、とても　おもしろいです。\n\n- *[较少数量]＋も＋否定形式：全面否定。*\n財布の　中に　１円**も**　ありません。\nわたしには　友達が　１人**も**　いません。\n\n## ね\n- *[确认]*　\nあそこに　猫が　いますね。\nこの　新聞は　田中さんのですね。\n\n- *よね：[确认]*　　\n今日　李さんも　来ますよね。\n手作りの　餃子は　皮が　おいしいです**よね**。\n\n- *[确认][缓和语气]*\n日本料理の　中で、何が　いちばん　好きですか。\n——そうですね。やっぱり　おすしです**ね**。\n\n## の\n- *[所属关系、属性、内容、原材料等]*\n中国の　企業\n\n## へ\n- *移动行为的目的地／方向*\n李さんは　中国へ　帰りました。\n- *へ～に行きます／来ます*\n昨日　渋谷へ　買い物に　行きました。\n\n## や\n- *～や～／～や～など：表示不完全列举*　\n昨日、スーパーで　野菜や　果物などを　買いました。\n\n## よ\n- *[提醒、告知、轻微警告]*　\n李さんは　もう　帰りましたよ。\n\n## は\n- *～は～が[感情形容词]です*\n～は：表示感情的主体。　～が：表示感情所指向的对象。 \n一般用于表达第一人称的感情。（日语中一般避免直接说出别人的内心感受）\n（わたしは）日本の　漫画が　好きです。\n（あなたは）どんな　本が　好きですか。\n\n- *～は～が分かります／できます／上手です／下手です[表示能力的词]*\n～は：表示能力的主体。　～が：表示能力的对象。\nスミスさんは　韓国語が　分かります。\n小野さんは　料理が　上手です。\n森さんは　歌が　下手です。\n\n# 其它重点句型\n\n## 引用句型\n- *[简体形小句]と　思います：引用说话人的思考内容。*\n李さんは　もうすぐ　来ると　思います。\n明日は　いい　天気だと　思います。\n\n- *[小句]と　言いました：转述第三人称的说话内容。*\n小野さんは　李さんに　ちょっと　休みたいと　言いました。 \n長島さんは　やめた　ほうが　いいと　言いました。\n長島さんは　「やめた　ほうが　いいですよ」と　言いました。\n\n## 比较句\n\n- *Aは　Bより　[形容词]です：“A比B更……”*\n中国は　日本**より**　広いです。\n中国は　日本**より**　ずっと　広いです。\n\n- *Aより　Bの　ほうが　[形容词]です：“比起A来，B更……”*\n日本**より**　中国**の　ほうが**　広いです。\n\n- *Aは　Bほど　[形1(い→く)]ないです／[形2]ではありません：“A不如B……”*\n大阪は　東京ほど　にぎやか　では　ありません。\n\n- *Aと　Bと　どちらが　[形容词]ですか：“A和B，哪一个更……？”*\n日本語と　英語と　**どちらが**　難しいですか。\n——日本語の　ほうが　難しいです。・どちらも　難しいです。\n\n- *[名1（范围）]の　中で　[名2]が　いちばん　[形容词]です*\n“在～[名1]之中，～[名2]最……”\nスポーツの　中で　サッカーが　いちばん　おもしろいです。\n\n- *[名1（范围）]でいちばん～は[名2]です*\n“在～[名1]之中，[名2]最……”\n日本で　いちばん　高い山は　富士山です。\n\n## 小句+か得包孕句型\n\n- 一*般疑问句→[小句]＋か　どうか（或重复谓语部分的肯定与否定形式）*\n形式：简体＋か　どうか   <注意：二类形／名（不含“だ”）＋か　どうか>\n注意：小句中的主语必须用“が”、不能用“は”。\nわたしは　今年の　夏　北京へ　行きますか。＋わたしは　分かりません。\nわたしは　今年の　夏　北京へ　行くか　どうか　分かりません。\nこの　料理は　辛いですか。＋わたしは　知りません。\nこの　料理が　辛いか　どうか　知りません。\nこの　料理が　辛いか　辛くないか　知りません。\n\n- *特殊疑问句→[带疑问词的小句]＋か*\n形式：[带疑问词的小句]简体形式＋か　<注意：二类形／名（不含だ）＋か>\nかぎが　どこに　ありますか。＋教えて　ください。\nかぎが　どこに　あるか　教えて　ください。\nこの　歌は　だれの　歌ですか＋知って　いますか。\nこの　歌が　だれの　歌か　知って　いますか。　（○）\n\n## 授受动词　\n- *（Aは）Bに　～あげます：A给B~。（B不能是“自己人”）*\n小野さんは　森さんに　チョコレートを　あげました。\n小野：わたしは　森さんに　チョコレートを　あげました。自己人需要使用くれます\n\n- *（Aは）Bに／から～もらいます：A从B处得到~。*\n森さんは　小野さんに／から　チョコレートを　もらいました。\n長島さんから　この　写真集を　もらいました。\n\n## 提议劝诱（礼貌程度依次递增）\n～ましょう：[提议，劝诱] “咱们……吧？”　\n～ましょうか。 [提议，劝诱]　\n～ませんか：[提议，劝诱]“要不要……？”\n\n## 存在句 あります/います\n表存在的句型，人、动物和昆虫用“います”, 非生物和植物用“あります”\n\n- *名[场所]に　名[物／人]が　あります／います：表示某地有某物或某人*\n庭に　桜（さくら）の　木が　あります。\n庭に　犬が　います。\n\n- *名[物／人]は　名[场所]に　あります／います：表示某物或某人在某处*\n事務所は　あの　ビルの　７階に　あります。\n李さんは　どこに　いますか。\n\n- *名[场所]で　名[事件]が　あります：表示在某地发生或举行某事*\nゆうべ、大阪で　地震が　ありました。\n来月、この　ホテルで　友達の　写真展が　あります。\n\n- *名[所有人]（に）は　名[所有物／人]が　あります／います：表示所有／拥有*\n森さんは　車が　２台 　あります。\n森さんは　弟が　２人　 います。\n\n## 疑问词\n- *疑问词＋か：表示不确定*　\n冬休みに　どこかへ　行きたいですね。\nおなかが　すきましたね。何か　食べましょう。\n\n- *疑问词＋でも＋肯定形式：表示全面肯定*　\nいつでも　電話して　ください。\n何を　食べたいですか。 ——何でも　いいです。\n\n- *疑问词＋も＋否定形式：表示全面否定*　\n教室に　だれも　いません。\n冷蔵庫に　何も　ありません。\n\n- *～は　いくらですか：~多少钱？*\n\n- *誰（だれ）ですか／何（なん）ですか。*\n\n- *～かな：放在简体形疑问小句的结尾。*\n用于自言自语。存在听话人的场合下，用于向对方传达一种不太有把握的\n信息或寻求确认。\n期間は　４年か　５年かな。\n\n\n- *～ですか、～ですか：选择疑问句*　　　\nでも～：表示转折\n\n\n- どうしてですか：询问理由。\nどうして～のですか／んですか。　\n来月　また　ここに　来ます。\nどうして　ですか。\nこの　ホテルで　友達の　写真展が　ありますから。\nどうして　食べないのですか／んですか。\nもう　おなかが　いっぱいなんです。\n\n## 指示词(コソアド系)\nこれ／それ／あれ／どれ：用于指代事物\nこの／その／あの／どの＋名：指示连体词，后加名词\nここ／そこ／あそこ／どこ：用于指代场所\nこちら／そちら／あちら／どちら：礼貌说法\nこう／そう／ああ／どう：指代行为方式\n\n## 时间\n- *いつ　[动]　ますか：何时……？*　\nいつ　出かけますか。\n会議は　いつ　終わりますか。\n\n- *今～時～分です。*\n今　４時３０分です。\n\n## 询问对方的感想　\nどうですか\n- *どうでしたか。*\nこの　料理は　どうですか。\n旅行は　どうでしたか。\n- *（～は）どこですか。*\nどれ／どの～　\nどんな＋名词：“怎样的~”\nどんな　音楽が　好きですか。\n\n## 因果\n- *～から和だから：表示因果。*\n[敬体／简体小句（原因）]＋から、……[敬体／简体小句]。\n[句子]。ですから／だから 、……[句子（结果）]。\n森さんは　お酒が　好きですから、 毎日　飲みます。\n窓を　閉めます。 寒いですから。\n キムさんは　野菜が　嫌いです。だから／ですから、あまり　食べません。\nキムさんは　野菜が　嫌いですから、あまり　食べません。\n\n## 否定\n- *まだ～：[否定] “尚未……，还没……”*\nまだ～ていません。\nまだです。\n小野さんは　もう　結婚して　いますか。\n——いいえ、まだ　結婚して　いません。\n——いいえ、まだです。\n李さんは　来ましたか。\n——いいえ、まだ　来て　いません。\n——いいえ、まだです。\n\n## 转折强调\n- *～けど、～：[转折][铺垫]*　多用于简体句\n昨日の　試験、どうだった？\n——ちょっと　難しかったけど、まあまあ　できたよ。\n来週、送別会を　するけど、都合は　どうかな？\n\n- *でも、～：但是……*\nそして、～：而且……\nわたしの　部屋は　狭いです。でも、きれいです。\nわたしの　部屋は　狭いです。そして、汚いです。\n\n- *に／で／へ／から／まで／と＋は：助词叠加【格助词＋提示助词】*\n韓国へは　行きましたが、中国へは　行きませんでした。\n森さんには　会いたく　ないです。\n\n- *“を”→“は”：作为整个句子的话题或表示对比强调*　\nコーヒーを　飲みません。     → コーヒーは　飲みません。\nチケットを　買いましたか。 → チケットは　買いましたか。\n\n- *～のです／～んです：对某前提事态的说明或解释。*\n~のですか／～んですか：寻求对某前提事态的说明或解释。\nあ、雨が　降って　いるんですか。\n何を　探して　いるんですか。\n昨日　学校を　休みました。頭が　痛かったんです。\n東京タワーへ　行きたいんですが、どうやって　行きますか。\n接续：简体形小句＋のです／んです。名／二类形（だ→な）＋のです／んです\n\n- *～から：起点 ～まで：终点*\n時間と空间\nわたしは　９時から　午後５時まで　働きます。\n東京から　広島まで　新幹線で　行きます。\n試験は　９時から　１２時までです。\n\n- *～くらい・ぐらい：前接数量词，表示大概的数量。*\n大阪まで　どのくらい／どれぐらい　かかりますか。\n——２時間ぐらい　かかります。","slug":"nihonngo/nihonngo-1","published":1,"updated":"2020-06-11T01:43:32.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxo000y9r2vhh3188e5","content":"<p>&emsp;&emsp;动词、形容词、名词、助词、其它划分语法句型。<br><a id=\"more\"></a></p>\n<h1 id=\"动词\"><a href=\"#动词\" class=\"headerlink\" title=\"动词\"></a>动词</h1><h2 id=\"动词的三形\"><a href=\"#动词的三形\" class=\"headerlink\" title=\"动词的三形\"></a>动词的三形</h2><ul>\n<li>一类动词:<br><code>ます</code>形去掉<code>ます</code>最后一个音位于<code>い</code>段的大部分动词为一类动词(書きます・読みます)。</li>\n<li>二类动词:<br>最后一个音位于<code>え</code>段(食べます・寝ます)，以及位于<code>い</code>段的一小部分动词(起きます・見ます)。</li>\n<li>三类动词:<br><code>します</code>结尾的动词(勉強します・卒業します)，以及来ます。</li>\n</ul>\n<p>否定: ません<br>过去: ました<br>过去否定: ませんでした</p>\n<h2 id=\"动词て形\"><a href=\"#动词て形\" class=\"headerlink\" title=\"动词て形\"></a>动词て形</h2><ul>\n<li>一类动变换为<code>て</code>形，为去掉<code>ます</code>，变化形态<code>+て</code><br>き → いて<br>ぎ → いで<br>び・み・に　→　んで<br>ち・り・い　→　って<br>し → して</li>\n<li>二三类动词变化为去掉<code>ます</code>直接加上<code>て</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>て形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>書いて</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急ぎで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛んで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読んで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死んで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待って</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>売って</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買って</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話して</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べて</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見て</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来て</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>して</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法\"><a href=\"#相关语法\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>相继发生</em><br>図書館へ　<strong>行って</strong>　本を　借りました。</p>\n</li>\n<li><p><em>并列</em><br>息子は　アメリカへ　<strong>留学して</strong>、娘は　東大に　入りました。</p>\n</li>\n<li><p><em>手段方法方式</em><br>今日は　<strong>歩いて</strong>　帰ります。</p>\n</li>\n<li><p><em>弱因果</em><br>あの　ビルは　エレベーターが　<strong>あって</strong>、便利です。</p>\n</li>\n<li><p><em>附带状况</em><br>新しい　洋服を　<strong>着て</strong>　パーティーに　行きました。</p>\n</li>\n<li><p><em>[(持续性动作)动词]“て形”＋います。[正在进行]</em><br>森さんは　コーヒーを　<strong>飲んで</strong>　います。<br>李さんは　新聞を　<strong>読んで</strong>　います。</p>\n</li>\n<li><p><em>[(瞬间性动作或表示变化的)动词]“て形”＋います：[结果状态]</em>　<br>あの　犬は　<strong>死んで</strong>　います。<br>小野さんは　もう　<strong>結婚して</strong>　いますか。</p>\n</li>\n<li><p><em>~てから、~：[相继发生]强调先做完前项再做后项</em><br>a: 会議を　始めましょう。<br>b: ——いいえ、課長が　<strong>来て</strong>から　始めましょう。<br>手を　洗ってから　<strong>食べて</strong>　ください。</p>\n</li>\n<li><p><em>[动词]“て形”＋ください：要求对方做某事　</em><br>静かに　<strong>して</strong>　ください。<br><code>句型比较：[名词]＋を＋ください：请给我……（某物）,是给我什么东西，动词的为请做什么事情。</code></p>\n</li>\n<li><p><em>[动词]“て形”も　いいです：表示许可。“可以……”</em><br>ここに　<strong>座って</strong>も　いいですか。<br>この　美術館では　写真を　<strong>とって</strong>も　いいですか。<br>——ええ、撮っても　いいです  大丈夫です。<br>——いいえ、いけません   ／駄目（だめ）です。</p>\n</li>\n<li><p><em>[动词]“て形”は　いけません：表示禁止。“不可以……”</em><br>この　美術館では　写真を　<strong>撮って</strong>は　いけません。</p>\n</li>\n</ul>\n<h2 id=\"动词た形\"><a href=\"#动词た形\" class=\"headerlink\" title=\"动词た形\"></a>动词た形</h2><ul>\n<li>一类动变换为<code>た</code>形，为去掉<code>ます</code>，变化形态<code>+た</code><br>き → いた<br>ぎ → いだ<br>び・み・に　→　んだ<br>ち・り・い　→　った<br>し → した</li>\n<li>二三类动词变化为去掉<code>ます</code>直接加上<code>た</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>て形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>書いた</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急ぎだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛んだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読んだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死んだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待った</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>売った</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買った</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話した</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べた</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見た</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来た</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>した</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法-1\"><a href=\"#相关语法-1\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p>~後で<br>动(た形)+後で</p>\n</li>\n<li><p><em>[动た形]＋ことが　あります</em><br>わたしは　すき焼きを　食べた　ことが　あります。<br>日本へ　行った　ことが　ありません。</p>\n</li>\n<li><p><em>～たり～たり：用于列举</em><br>简体过去形式＋り、＋り<br>即：[动た形]＋り、[动た形]＋り＋します。<br>[形1かった]＋り、[形1かった]＋り＋です／小句。<br>[名／形2だった]＋り、[名／形2だった]＋り＋です／小句。<br>小野さんは　休みの　日、 部屋を　掃除したり　洗濯したり　します。<br>飛行機の　チケットは　季節によって　高かったり　安かったりです。<br>日本語の　先生は　中国人だったり　日本人だったりです。</p>\n</li>\n<li><p><em>[动词た形]+ほうが　いいです：表示建议，忠告“~比较好”</em><br>よく　考えた　ほうが　いいですよ。<br>時間が　ありませんから、急いだ　ほうが　いいですよ。</p>\n</li>\n</ul>\n<h2 id=\"动词ない形\"><a href=\"#动词ない形\" class=\"headerlink\" title=\"动词ない形\"></a>动词ない形</h2><ul>\n<li>一类动变换为<code>ない</code>形，去掉<code>ます</code>，最后一个音变为<code>あ段</code>,后加<code>ない</code>。<br>如果最后一个音为<code>い</code>,则变为<code>わ</code>。</li>\n<li>二类动词变化为去掉<code>ます</code>直接加上<code>ない</code>。</li>\n<li>三类动词<code>きます</code>变为<code>来ない</code>，其余同二类型。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>ない形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>書かない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急がない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛ばない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読まない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死なない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待たない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>売らない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買わない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話さない</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べない</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見ない</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来ない</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>しない</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法-2\"><a href=\"#相关语法-2\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>[动词ない形]＋ほうが　いいです：“最好不要那样做”</em><br>熱が　ありますから、こんばんは　お風呂に　入らない　ほうが　いいですよ。</p>\n</li>\n<li><p><em>～ないで　ください：“请不要~”</em><br>禁煙席で　タバコを　<strong>吸わないで</strong>　ください。<br>ここに　車を　止めないで　ください。</p>\n</li>\n<li><p><em>～なくても　いいです：“不必~”</em><br>明日は　休みですから、早く　<strong>起きなくても</strong>　いいです。</p>\n</li>\n<li><p><em>～なければ　なりません：“必须~”</em><br>これは　図書館の　本ですから、<strong>返さなければ</strong>　なりません。</p>\n</li>\n</ul>\n<h2 id=\"动词基本形\"><a href=\"#动词基本形\" class=\"headerlink\" title=\"动词基本形\"></a>动词基本形</h2><ul>\n<li>一类动变换为基本形，去掉<code>ます</code>，最后一个音<code>い</code>变为<code>う段</code>。</li>\n<li>二类动词变化为去掉<code>ます</code>直接加上<code>る</code>。</li>\n<li>三类动词变为<code>来る</code>と<code>する</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>基本形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>かく</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急ぐ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛ぶ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読む</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死ぬ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待つ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>うる</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買う</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話す</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べる</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見る</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来る</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>する</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法-3\"><a href=\"#相关语法-3\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>（～は）[动(基本形)]＋ことが　できます：①能力；②条件允许。</em><br>森さんは　料理を　作る　ことが　できますか。<br>——はい、できます。／いいえ、できません。</p>\n</li>\n<li><p><em>[名]+は+[动(基本形)]+ことです</em><br>わたしの　趣味は　本を　読む　ことです。<br>森さんの　夢は　外国で　働く　ことです。</p>\n</li>\n</ul>\n<h1 id=\"形容词\"><a href=\"#形容词\" class=\"headerlink\" title=\"形容词\"></a>形容词</h1><h2 id=\"形容词的二形\"><a href=\"#形容词的二形\" class=\"headerlink\" title=\"形容词的二形\"></a>形容词的二形</h2><ul>\n<li><p>一类形容词 词尾以<code>い</code>结尾的形容词<br>否定: い → くない<br>过去: \b い　→　かった<br>过去否定:  い → く なかってです / く　ありませんでした</p>\n</li>\n<li><p>二类形容词 词尾不为<code>い</code>结尾的形容词<br>否定: でわありませ<br>过去和です变化相同，为でした　ではありませんでした</p>\n</li>\n</ul>\n<h3 id=\"相关语法-4\"><a href=\"#相关语法-4\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>あまり～[形1／动(否定)]：“不怎么……，不太……”，表示程度不高。</em><br>昨日の　試験は　あまり　難しく　なかったです。<br>わたしは　あまり　コーヒーを　飲みません。</p>\n</li>\n<li><p><em>形容词谓语句</em>：</p>\n<ul>\n<li><p>一类形容词　<br>①现在将来肯定形式： 今日は　寒いです。<br>②现在将来否定形式：今日は　寒く　ないです／ありません。<br>③过去肯定形式：昨日は　寒かったです。<br>④过去否定形式：昨日は　寒く　なかったです／ありませんでした。<br>いい<br>→よく　ない   →よかった   →よく   なかった</p>\n</li>\n<li><p>二类形容词　<br>①现在将来肯定形式：東京は　にぎやかです。<br>②现在将来否定形式：京都は　にぎやかでは　ありません／では　ないです。<br>③过去肯定形式：京都は　にぎやかでした。<br>④过去否定形式：京都は　にぎやかでは　ありませんでした。</p>\n</li>\n</ul>\n</li>\n<li><p><em>～で　[何／だれ／いつ／どれ／どの　名]が　いちばん[形容词]ですか</em><br>“哪个~最……？”<br>季節の　中で、いつが　いちばん　好きですか。<br>果物の　中で、何が　いちばん　好きですか。</p>\n</li>\n<li><p>形容词变化句</p>\n<ul>\n<li>[形1（词尾“い”→“く”）]＋します：使……变得……</li>\n<li>[形1（词尾“い”→“く”）]＋なります：……变得……<br>だんだん　暖かく　なります。<br>テレビの　音を　大きく　します。</li>\n<li>[名／形2]＋“に”＋“します”：使……变得……，使……成为……　</li>\n<li>[名／形2]＋“に”＋“なります”：……变得……<br>部屋を　きれいに　して　ください。<br>部屋は　きれいに　なりました。<br>息子を　医者に　します。<br>息子は　医者に　なりました。</li>\n</ul>\n</li>\n<li><p><em>形容词作定语（修饰名词）</em><br>一类形容词：青い　海<br>二类形容词：きれいな　部屋</p>\n</li>\n</ul>\n<h2 id=\"形容词的て形\"><a href=\"#形容词的て形\" class=\"headerlink\" title=\"形容词的て形\"></a>形容词的て形</h2><ul>\n<li><p><em>一类形容词的“て形”：词尾的“い”变成“く”+“て”</em><br>この　公園は　<strong>広　くて</strong>　静かです。<br>彼女は　優しくて　<strong>きれいで</strong>す。</p>\n</li>\n<li><p><em>二类形容词的“て形”：词干 +“で”</em><br>彼女は　<strong>きれいで</strong>　優しいです。</p>\n</li>\n</ul>\n<h1 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h1><p>こと：形式名词，起到将前项的动词或形容词小句名词化的作用。</p>\n<ul>\n<li><p><em>[名]＋“に”＋“します” ：表示选择，决定。</em><br>カレーライスに　します。<br>あの　子に　します。</p>\n</li>\n<li><p><em>[名]（～を）ください：请给我……。</em><br>コーヒーを　２つ　ください。<br>娘さんを　ください。</p>\n</li>\n<li><p><em>[名]＋が＋欲しい（ほしい）です：想要…（某物），用于表达自己的欲望。</em><br>新しい　パソコンが　欲しいです。<br>否定形式：欲しく　ないです／欲しく　ありません。<br>过去形式：欲しかったです<br>今は　何も　欲しく　ないです／欲しく　ありません。</p>\n</li>\n<li><p><em>[名1]は　[名2]を　[动(“ます型”去掉“ます”)]たいです</em><br>“～たい”的词尾“い”按一类形容词活用。<br>映画を　見たいです。<br>否定形式：飲みたく　ないです／ありません。<br>过去形式：たかったです<br>今は　お酒を　飲みたく　ないです／ありません。</p>\n</li>\n<li><p><em>[名词1]＋“で”＋[名词2]</em><br>森さんは　企画会社の　社員で、背が　高くて、ハンサムな　人です。</p>\n</li>\n</ul>\n<ul>\n<li><p><em>[名]か　[名]：表示选择，“~或者~”</em><br>毎朝　パンか　お粥を　食べます。<br>休みは　月曜日か　火曜日です。</p>\n</li>\n<li><p><em>名词谓语句</em><br>现在将来肯定形式：今日は　いい　天気です。<br>现在将来否定形式： 今日は　いい　天気では　ありません／ではないです。<br>过去肯定形式：  昨日は　いい　天気でした。<br>过去否定形式： 昨日は　いい　天気では　ありませんでした。</p>\n</li>\n<li><p><em>名词 + の + 後で</em><br>仕事が　終わった　後で、飲みに　行きます。<br>仕事の　後で、飲みに　行きます。</p>\n</li>\n<li><p><em>[名（场所）]＋を＋（带移动意味的）动词：经过／离开的场所</em><br>この　バスは　駅前を　通ります。<br>わたしは　来年　大学を　卒業します。<br>家を　出ます。</p>\n</li>\n</ul>\n<h1 id=\"助词\"><a href=\"#助词\" class=\"headerlink\" title=\"助词\"></a>助词</h1><h2 id=\"が\"><a href=\"#が\" class=\"headerlink\" title=\"が\"></a>が</h2><ul>\n<li><p><em>[小句]が、[小句]：[转折]</em><br>３か月　パソコンを　勉強しました<strong>が</strong>、まだ　あまり　できません。<br>この　レストランは　おいしいです<strong>が</strong>、ちょっと　高いです。</p>\n</li>\n<li><p><em>[小句]が、[小句]：[铺垫]</em><br>東京タワーへ　行きたいんです<strong>が</strong>、どうやって　行きますか。</p>\n</li>\n<li><p><em>～が～：提示主语。</em></p>\n<p>旧信息用“は”，新信息用“が”。<br>山田さんは　どなたですか。<br>山田さんは　あの　方です。<br>あの　方が　山田さんです。</p>\n<p>疑问词作主语时，一定用“が”（新信息）。<br>どなたが　山田さんですか。　は（×）<br>——あの　方が　山田さんです。</p>\n<p>～が～：表示感情或能力的对象（对象语）。<br>わたしは　犬が　好きです。<br>スミスさんは　韓国語が　分かります。</p>\n</li>\n</ul>\n<h2 id=\"で\"><a href=\"#で\" class=\"headerlink\" title=\"で\"></a>で</h2><ul>\n<li><p><em>名[工具／手段／方式]＋“で”：表示工具或手段、方法、方式。</em><br>日本語<strong>で</strong>　手紙を　書きます。<br>タクシー<strong>で</strong>　帰ります。</p>\n</li>\n<li><p><em>名词[原材料]＋“で” ：表示原材料。</em><br>新聞紙<strong>で</strong>　紙飛行機を　作りました。</p>\n</li>\n<li><p><em>名[场所]+“で”：表示动作或事情发生的场所。</em><br>来月、この　ホテル<strong>で</strong>　友達の　写真展が　あります。</p>\n</li>\n<li><p><em>数量词＋“で”：表示总计。</em><br>この りんごは　３個<strong>で</strong>　５００円です。</p>\n</li>\n<li><p><em>名[人数等]＋“で”：表示动作主体的状态。</em><br>北京では、春節の　前に、家族全員<strong>で</strong>　餃子を　作ります。<br>今度　二人<strong>で</strong>　会いましょう。</p>\n</li>\n<li><p><em>名[场所或范围]＋“で”：表示范围。</em><br>日本<strong>で</strong>　いちばん　高い山は　富士山です。<br>一年<strong>で</strong>　いちばん　寒い月は　２月です。  </p>\n</li>\n</ul>\n<h2 id=\"に\"><a href=\"#に\" class=\"headerlink\" title=\"に\"></a>に</h2><ul>\n<li><p><em>具体时间点＋に：具体时间</em>　<br>わたしは　毎晩　<strong>１１時に</strong>　寝ます。</p>\n</li>\n<li><p><em>间接宾语＋に：动作行为的对象</em><br>李さん<strong>に</strong>　手紙を　書きます。<br>友達<strong>に</strong>　お金を　貸します。<br>さっき　駅前で　森さん<strong>に</strong>　会いました。</p>\n</li>\n<li><p><em>时间段＋に＋次数＋[动词]：频率</em><br>1年<strong>に</strong>　1回　国へ　帰ります。／<strong>年に</strong>　1回　国へ　帰ります。<br>1日<strong>に</strong>　2杯　コーヒーを　飲みます。／<strong>日に</strong>　2杯　コーヒーを　飲みます。</p>\n</li>\n<li><p><em>[动1,2]“ます形”去掉“ます”／[动3词干]＋に＋移动动词：移动行为的目的</em><br>友達の　家へ　<strong>遊びに</strong>　行きます。<br>渋谷へ　買い物<strong>に</strong>　行きます。</p>\n</li>\n<li><p><em>附着点＋に：附着点</em>　　　<br>ここ<strong>に</strong>　座っても　いいですか。<br>電車／バス／飛行機／自転車に　乗ります。<br>その品物<strong>に</strong>　触らないで　ください。</p>\n</li>\n<li><p><em>～前に、～：“……之前，……”</em><br>[动词基本形]＋前に<br>[名词]＋の＋前に<br>こちらへ　来る　前に　電話を　かけて　ください。<br>会議の　前に　資料を　コピーします。</p>\n</li>\n</ul>\n<h2 id=\"と\"><a href=\"#と\" class=\"headerlink\" title=\"と\"></a>と</h2><ul>\n<li><p><em>[名1]と　[名2]：[并列]</em><br>パン<strong>と</strong>　ミルク<br>テレビ<strong>と</strong>　冷蔵庫<br>箱の　中に　眼鏡<strong>と</strong>　時計が　あります。</p>\n</li>\n<li><p><em>[名(人)]と　[动词]ます：表示共同进行动作的对象。</em><br>昨日　友達<strong>と</strong>　渋谷で　買い物しました。<br>A<strong>と</strong>　B<strong>と</strong>、どちらが　～ですか。</p>\n</li>\n</ul>\n<h2 id=\"も\"><a href=\"#も\" class=\"headerlink\" title=\"も\"></a>も</h2><ul>\n<li><p><em>～も：[兼提]“~也”</em>　<br>李さんは　中国人です。張さん<strong>も</strong>　中国人です。<br>来週の　ハイキング、私<strong>も</strong>　行きたい。</p>\n</li>\n<li><p><em>[数量词]＋も+肯定形式：强调数量多。</em><br>何度<strong>も</strong>　転びましたが、とても　おもしろいです。</p>\n</li>\n<li><p><em>[较少数量]＋も＋否定形式：全面否定。</em><br>財布の　中に　１円<strong>も</strong>　ありません。<br>わたしには　友達が　１人<strong>も</strong>　いません。</p>\n</li>\n</ul>\n<h2 id=\"ね\"><a href=\"#ね\" class=\"headerlink\" title=\"ね\"></a>ね</h2><ul>\n<li><p><em>[确认]</em>　<br>あそこに　猫が　いますね。<br>この　新聞は　田中さんのですね。</p>\n</li>\n<li><p><em>よね：[确认]</em>　　<br>今日　李さんも　来ますよね。<br>手作りの　餃子は　皮が　おいしいです<strong>よね</strong>。</p>\n</li>\n<li><p><em>[确认][缓和语气]</em><br>日本料理の　中で、何が　いちばん　好きですか。<br>——そうですね。やっぱり　おすしです<strong>ね</strong>。</p>\n</li>\n</ul>\n<h2 id=\"の\"><a href=\"#の\" class=\"headerlink\" title=\"の\"></a>の</h2><ul>\n<li><em>[所属关系、属性、内容、原材料等]</em><br>中国の　企業</li>\n</ul>\n<h2 id=\"へ\"><a href=\"#へ\" class=\"headerlink\" title=\"へ\"></a>へ</h2><ul>\n<li><em>移动行为的目的地／方向</em><br>李さんは　中国へ　帰りました。</li>\n<li><em>へ～に行きます／来ます</em><br>昨日　渋谷へ　買い物に　行きました。</li>\n</ul>\n<h2 id=\"や\"><a href=\"#や\" class=\"headerlink\" title=\"や\"></a>や</h2><ul>\n<li><em>～や～／～や～など：表示不完全列举</em>　<br>昨日、スーパーで　野菜や　果物などを　買いました。</li>\n</ul>\n<h2 id=\"よ\"><a href=\"#よ\" class=\"headerlink\" title=\"よ\"></a>よ</h2><ul>\n<li><em>[提醒、告知、轻微警告]</em>　<br>李さんは　もう　帰りましたよ。</li>\n</ul>\n<h2 id=\"は\"><a href=\"#は\" class=\"headerlink\" title=\"は\"></a>は</h2><ul>\n<li><p><em>～は～が[感情形容词]です</em><br>～は：表示感情的主体。　～が：表示感情所指向的对象。<br>一般用于表达第一人称的感情。（日语中一般避免直接说出别人的内心感受）<br>（わたしは）日本の　漫画が　好きです。<br>（あなたは）どんな　本が　好きですか。</p>\n</li>\n<li><p><em>～は～が分かります／できます／上手です／下手です[表示能力的词]</em><br>～は：表示能力的主体。　～が：表示能力的对象。<br>スミスさんは　韓国語が　分かります。<br>小野さんは　料理が　上手です。<br>森さんは　歌が　下手です。</p>\n</li>\n</ul>\n<h1 id=\"其它重点句型\"><a href=\"#其它重点句型\" class=\"headerlink\" title=\"其它重点句型\"></a>其它重点句型</h1><h2 id=\"引用句型\"><a href=\"#引用句型\" class=\"headerlink\" title=\"引用句型\"></a>引用句型</h2><ul>\n<li><p><em>[简体形小句]と　思います：引用说话人的思考内容。</em><br>李さんは　もうすぐ　来ると　思います。<br>明日は　いい　天気だと　思います。</p>\n</li>\n<li><p><em>[小句]と　言いました：转述第三人称的说话内容。</em><br>小野さんは　李さんに　ちょっと　休みたいと　言いました。<br>長島さんは　やめた　ほうが　いいと　言いました。<br>長島さんは　「やめた　ほうが　いいですよ」と　言いました。</p>\n</li>\n</ul>\n<h2 id=\"比较句\"><a href=\"#比较句\" class=\"headerlink\" title=\"比较句\"></a>比较句</h2><ul>\n<li><p><em>Aは　Bより　[形容词]です：“A比B更……”</em><br>中国は　日本<strong>より</strong>　広いです。<br>中国は　日本<strong>より</strong>　ずっと　広いです。</p>\n</li>\n<li><p><em>Aより　Bの　ほうが　[形容词]です：“比起A来，B更……”</em><br>日本<strong>より</strong>　中国<strong>の　ほうが</strong>　広いです。</p>\n</li>\n<li><p><em>Aは　Bほど　[形1(い→く)]ないです／[形2]ではありません：“A不如B……”</em><br>大阪は　東京ほど　にぎやか　では　ありません。</p>\n</li>\n<li><p><em>Aと　Bと　どちらが　[形容词]ですか：“A和B，哪一个更……？”</em><br>日本語と　英語と　<strong>どちらが</strong>　難しいですか。<br>——日本語の　ほうが　難しいです。・どちらも　難しいです。</p>\n</li>\n<li><p><em>[名1（范围）]の　中で　[名2]が　いちばん　[形容词]です</em><br>“在～[名1]之中，～[名2]最……”<br>スポーツの　中で　サッカーが　いちばん　おもしろいです。</p>\n</li>\n<li><p><em>[名1（范围）]でいちばん～は[名2]です</em><br>“在～[名1]之中，[名2]最……”<br>日本で　いちばん　高い山は　富士山です。</p>\n</li>\n</ul>\n<h2 id=\"小句-か得包孕句型\"><a href=\"#小句-か得包孕句型\" class=\"headerlink\" title=\"小句+か得包孕句型\"></a>小句+か得包孕句型</h2><ul>\n<li><p>一<em>般疑问句→[小句]＋か　どうか（或重复谓语部分的肯定与否定形式）</em><br>形式：简体＋か　どうか   &lt;注意：二类形／名（不含“だ”）＋か　どうか&gt;<br>注意：小句中的主语必须用“が”、不能用“は”。<br>わたしは　今年の　夏　北京へ　行きますか。＋わたしは　分かりません。<br>わたしは　今年の　夏　北京へ　行くか　どうか　分かりません。<br>この　料理は　辛いですか。＋わたしは　知りません。<br>この　料理が　辛いか　どうか　知りません。<br>この　料理が　辛いか　辛くないか　知りません。</p>\n</li>\n<li><p><em>特殊疑问句→[带疑问词的小句]＋か</em><br>形式：[带疑问词的小句]简体形式＋か　&lt;注意：二类形／名（不含だ）＋か&gt;<br>かぎが　どこに　ありますか。＋教えて　ください。<br>かぎが　どこに　あるか　教えて　ください。<br>この　歌は　だれの　歌ですか＋知って　いますか。<br>この　歌が　だれの　歌か　知って　いますか。　（○）</p>\n</li>\n</ul>\n<h2 id=\"授受动词\"><a href=\"#授受动词\" class=\"headerlink\" title=\"授受动词　\"></a>授受动词　</h2><ul>\n<li><p><em>（Aは）Bに　～あげます：A给B~。（B不能是“自己人”）</em><br>小野さんは　森さんに　チョコレートを　あげました。<br>小野：わたしは　森さんに　チョコレートを　あげました。自己人需要使用くれます</p>\n</li>\n<li><p><em>（Aは）Bに／から～もらいます：A从B处得到~。</em><br>森さんは　小野さんに／から　チョコレートを　もらいました。<br>長島さんから　この　写真集を　もらいました。</p>\n</li>\n</ul>\n<h2 id=\"提议劝诱（礼貌程度依次递增）\"><a href=\"#提议劝诱（礼貌程度依次递增）\" class=\"headerlink\" title=\"提议劝诱（礼貌程度依次递增）\"></a>提议劝诱（礼貌程度依次递增）</h2><p>～ましょう：[提议，劝诱] “咱们……吧？”　<br>～ましょうか。 [提议，劝诱]　<br>～ませんか：[提议，劝诱]“要不要……？”</p>\n<h2 id=\"存在句-あります-います\"><a href=\"#存在句-あります-います\" class=\"headerlink\" title=\"存在句 あります/います\"></a>存在句 あります/います</h2><p>表存在的句型，人、动物和昆虫用“います”, 非生物和植物用“あります”</p>\n<ul>\n<li><p><em>名[场所]に　名[物／人]が　あります／います：表示某地有某物或某人</em><br>庭に　桜（さくら）の　木が　あります。<br>庭に　犬が　います。</p>\n</li>\n<li><p><em>名[物／人]は　名[场所]に　あります／います：表示某物或某人在某处</em><br>事務所は　あの　ビルの　７階に　あります。<br>李さんは　どこに　いますか。</p>\n</li>\n<li><p><em>名[场所]で　名[事件]が　あります：表示在某地发生或举行某事</em><br>ゆうべ、大阪で　地震が　ありました。<br>来月、この　ホテルで　友達の　写真展が　あります。</p>\n</li>\n<li><p><em>名[所有人]（に）は　名[所有物／人]が　あります／います：表示所有／拥有</em><br>森さんは　車が　２台 　あります。<br>森さんは　弟が　２人　 います。</p>\n</li>\n</ul>\n<h2 id=\"疑问词\"><a href=\"#疑问词\" class=\"headerlink\" title=\"疑问词\"></a>疑问词</h2><ul>\n<li><p><em>疑问词＋か：表示不确定</em>　<br>冬休みに　どこかへ　行きたいですね。<br>おなかが　すきましたね。何か　食べましょう。</p>\n</li>\n<li><p><em>疑问词＋でも＋肯定形式：表示全面肯定</em>　<br>いつでも　電話して　ください。<br>何を　食べたいですか。 ——何でも　いいです。</p>\n</li>\n<li><p><em>疑问词＋も＋否定形式：表示全面否定</em>　<br>教室に　だれも　いません。<br>冷蔵庫に　何も　ありません。</p>\n</li>\n<li><p><em>～は　いくらですか：~多少钱？</em></p>\n</li>\n<li><p><em>誰（だれ）ですか／何（なん）ですか。</em></p>\n</li>\n<li><p><em>～かな：放在简体形疑问小句的结尾。</em><br>用于自言自语。存在听话人的场合下，用于向对方传达一种不太有把握的<br>信息或寻求确认。<br>期間は　４年か　５年かな。</p>\n</li>\n</ul>\n<ul>\n<li><em>～ですか、～ですか：选择疑问句</em>　　　<br>でも～：表示转折</li>\n</ul>\n<ul>\n<li>どうしてですか：询问理由。<br>どうして～のですか／んですか。　<br>来月　また　ここに　来ます。<br>どうして　ですか。<br>この　ホテルで　友達の　写真展が　ありますから。<br>どうして　食べないのですか／んですか。<br>もう　おなかが　いっぱいなんです。</li>\n</ul>\n<h2 id=\"指示词-コソアド系\"><a href=\"#指示词-コソアド系\" class=\"headerlink\" title=\"指示词(コソアド系)\"></a>指示词(コソアド系)</h2><p>これ／それ／あれ／どれ：用于指代事物<br>この／その／あの／どの＋名：指示连体词，后加名词<br>ここ／そこ／あそこ／どこ：用于指代场所<br>こちら／そちら／あちら／どちら：礼貌说法<br>こう／そう／ああ／どう：指代行为方式</p>\n<h2 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h2><ul>\n<li><p><em>いつ　[动]　ますか：何时……？</em>　<br>いつ　出かけますか。<br>会議は　いつ　終わりますか。</p>\n</li>\n<li><p><em>今～時～分です。</em><br>今　４時３０分です。</p>\n</li>\n</ul>\n<h2 id=\"询问对方的感想\"><a href=\"#询问对方的感想\" class=\"headerlink\" title=\"询问对方的感想　\"></a>询问对方的感想　</h2><p>どうですか</p>\n<ul>\n<li><em>どうでしたか。</em><br>この　料理は　どうですか。<br>旅行は　どうでしたか。</li>\n<li><em>（～は）どこですか。</em><br>どれ／どの～　<br>どんな＋名词：“怎样的~”<br>どんな　音楽が　好きですか。</li>\n</ul>\n<h2 id=\"因果\"><a href=\"#因果\" class=\"headerlink\" title=\"因果\"></a>因果</h2><ul>\n<li><em>～から和だから：表示因果。</em><br>[敬体／简体小句（原因）]＋から、……[敬体／简体小句]。<br>[句子]。ですから／だから 、……[句子（结果）]。<br>森さんは　お酒が　好きですから、 毎日　飲みます。<br>窓を　閉めます。 寒いですから。<br>キムさんは　野菜が　嫌いです。だから／ですから、あまり　食べません。<br>キムさんは　野菜が　嫌いですから、あまり　食べません。</li>\n</ul>\n<h2 id=\"否定\"><a href=\"#否定\" class=\"headerlink\" title=\"否定\"></a>否定</h2><ul>\n<li><em>まだ～：[否定] “尚未……，还没……”</em><br>まだ～ていません。<br>まだです。<br>小野さんは　もう　結婚して　いますか。<br>——いいえ、まだ　結婚して　いません。<br>——いいえ、まだです。<br>李さんは　来ましたか。<br>——いいえ、まだ　来て　いません。<br>——いいえ、まだです。</li>\n</ul>\n<h2 id=\"转折强调\"><a href=\"#转折强调\" class=\"headerlink\" title=\"转折强调\"></a>转折强调</h2><ul>\n<li><p><em>～けど、～：[转折][铺垫]</em>　多用于简体句<br>昨日の　試験、どうだった？<br>——ちょっと　難しかったけど、まあまあ　できたよ。<br>来週、送別会を　するけど、都合は　どうかな？</p>\n</li>\n<li><p><em>でも、～：但是……</em><br>そして、～：而且……<br>わたしの　部屋は　狭いです。でも、きれいです。<br>わたしの　部屋は　狭いです。そして、汚いです。</p>\n</li>\n<li><p><em>に／で／へ／から／まで／と＋は：助词叠加【格助词＋提示助词】</em><br>韓国へは　行きましたが、中国へは　行きませんでした。<br>森さんには　会いたく　ないです。</p>\n</li>\n<li><p><em>“を”→“は”：作为整个句子的话题或表示对比强调</em>　<br>コーヒーを　飲みません。     → コーヒーは　飲みません。<br>チケットを　買いましたか。 → チケットは　買いましたか。</p>\n</li>\n<li><p><em>～のです／～んです：对某前提事态的说明或解释。</em><br>~のですか／～んですか：寻求对某前提事态的说明或解释。<br>あ、雨が　降って　いるんですか。<br>何を　探して　いるんですか。<br>昨日　学校を　休みました。頭が　痛かったんです。<br>東京タワーへ　行きたいんですが、どうやって　行きますか。<br>接续：简体形小句＋のです／んです。名／二类形（だ→な）＋のです／んです</p>\n</li>\n<li><p><em>～から：起点 ～まで：终点</em><br>時間と空间<br>わたしは　９時から　午後５時まで　働きます。<br>東京から　広島まで　新幹線で　行きます。<br>試験は　９時から　１２時までです。</p>\n</li>\n<li><p><em>～くらい・ぐらい：前接数量词，表示大概的数量。</em><br>大阪まで　どのくらい／どれぐらい　かかりますか。<br>——２時間ぐらい　かかります。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;动词、形容词、名词、助词、其它划分语法句型。<br></p>","more":"</p>\n<h1 id=\"动词\"><a href=\"#动词\" class=\"headerlink\" title=\"动词\"></a>动词</h1><h2 id=\"动词的三形\"><a href=\"#动词的三形\" class=\"headerlink\" title=\"动词的三形\"></a>动词的三形</h2><ul>\n<li>一类动词:<br><code>ます</code>形去掉<code>ます</code>最后一个音位于<code>い</code>段的大部分动词为一类动词(書きます・読みます)。</li>\n<li>二类动词:<br>最后一个音位于<code>え</code>段(食べます・寝ます)，以及位于<code>い</code>段的一小部分动词(起きます・見ます)。</li>\n<li>三类动词:<br><code>します</code>结尾的动词(勉強します・卒業します)，以及来ます。</li>\n</ul>\n<p>否定: ません<br>过去: ました<br>过去否定: ませんでした</p>\n<h2 id=\"动词て形\"><a href=\"#动词て形\" class=\"headerlink\" title=\"动词て形\"></a>动词て形</h2><ul>\n<li>一类动变换为<code>て</code>形，为去掉<code>ます</code>，变化形态<code>+て</code><br>き → いて<br>ぎ → いで<br>び・み・に　→　んで<br>ち・り・い　→　って<br>し → して</li>\n<li>二三类动词变化为去掉<code>ます</code>直接加上<code>て</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>て形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>書いて</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急ぎで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛んで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読んで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死んで</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待って</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>売って</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買って</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話して</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べて</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見て</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来て</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>して</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法\"><a href=\"#相关语法\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>相继发生</em><br>図書館へ　<strong>行って</strong>　本を　借りました。</p>\n</li>\n<li><p><em>并列</em><br>息子は　アメリカへ　<strong>留学して</strong>、娘は　東大に　入りました。</p>\n</li>\n<li><p><em>手段方法方式</em><br>今日は　<strong>歩いて</strong>　帰ります。</p>\n</li>\n<li><p><em>弱因果</em><br>あの　ビルは　エレベーターが　<strong>あって</strong>、便利です。</p>\n</li>\n<li><p><em>附带状况</em><br>新しい　洋服を　<strong>着て</strong>　パーティーに　行きました。</p>\n</li>\n<li><p><em>[(持续性动作)动词]“て形”＋います。[正在进行]</em><br>森さんは　コーヒーを　<strong>飲んで</strong>　います。<br>李さんは　新聞を　<strong>読んで</strong>　います。</p>\n</li>\n<li><p><em>[(瞬间性动作或表示变化的)动词]“て形”＋います：[结果状态]</em>　<br>あの　犬は　<strong>死んで</strong>　います。<br>小野さんは　もう　<strong>結婚して</strong>　いますか。</p>\n</li>\n<li><p><em>~てから、~：[相继发生]强调先做完前项再做后项</em><br>a: 会議を　始めましょう。<br>b: ——いいえ、課長が　<strong>来て</strong>から　始めましょう。<br>手を　洗ってから　<strong>食べて</strong>　ください。</p>\n</li>\n<li><p><em>[动词]“て形”＋ください：要求对方做某事　</em><br>静かに　<strong>して</strong>　ください。<br><code>句型比较：[名词]＋を＋ください：请给我……（某物）,是给我什么东西，动词的为请做什么事情。</code></p>\n</li>\n<li><p><em>[动词]“て形”も　いいです：表示许可。“可以……”</em><br>ここに　<strong>座って</strong>も　いいですか。<br>この　美術館では　写真を　<strong>とって</strong>も　いいですか。<br>——ええ、撮っても　いいです  大丈夫です。<br>——いいえ、いけません   ／駄目（だめ）です。</p>\n</li>\n<li><p><em>[动词]“て形”は　いけません：表示禁止。“不可以……”</em><br>この　美術館では　写真を　<strong>撮って</strong>は　いけません。</p>\n</li>\n</ul>\n<h2 id=\"动词た形\"><a href=\"#动词た形\" class=\"headerlink\" title=\"动词た形\"></a>动词た形</h2><ul>\n<li>一类动变换为<code>た</code>形，为去掉<code>ます</code>，变化形态<code>+た</code><br>き → いた<br>ぎ → いだ<br>び・み・に　→　んだ<br>ち・り・い　→　った<br>し → した</li>\n<li>二三类动词变化为去掉<code>ます</code>直接加上<code>た</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>て形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>書いた</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急ぎだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛んだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読んだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死んだ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待った</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>売った</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買った</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話した</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べた</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見た</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来た</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>した</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法-1\"><a href=\"#相关语法-1\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p>~後で<br>动(た形)+後で</p>\n</li>\n<li><p><em>[动た形]＋ことが　あります</em><br>わたしは　すき焼きを　食べた　ことが　あります。<br>日本へ　行った　ことが　ありません。</p>\n</li>\n<li><p><em>～たり～たり：用于列举</em><br>简体过去形式＋り、＋り<br>即：[动た形]＋り、[动た形]＋り＋します。<br>[形1かった]＋り、[形1かった]＋り＋です／小句。<br>[名／形2だった]＋り、[名／形2だった]＋り＋です／小句。<br>小野さんは　休みの　日、 部屋を　掃除したり　洗濯したり　します。<br>飛行機の　チケットは　季節によって　高かったり　安かったりです。<br>日本語の　先生は　中国人だったり　日本人だったりです。</p>\n</li>\n<li><p><em>[动词た形]+ほうが　いいです：表示建议，忠告“~比较好”</em><br>よく　考えた　ほうが　いいですよ。<br>時間が　ありませんから、急いだ　ほうが　いいですよ。</p>\n</li>\n</ul>\n<h2 id=\"动词ない形\"><a href=\"#动词ない形\" class=\"headerlink\" title=\"动词ない形\"></a>动词ない形</h2><ul>\n<li>一类动变换为<code>ない</code>形，去掉<code>ます</code>，最后一个音变为<code>あ段</code>,后加<code>ない</code>。<br>如果最后一个音为<code>い</code>,则变为<code>わ</code>。</li>\n<li>二类动词变化为去掉<code>ます</code>直接加上<code>ない</code>。</li>\n<li>三类动词<code>きます</code>变为<code>来ない</code>，其余同二类型。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>ない形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>書かない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急がない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛ばない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読まない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死なない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待たない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>売らない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買わない</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話さない</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べない</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見ない</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来ない</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>しない</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法-2\"><a href=\"#相关语法-2\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>[动词ない形]＋ほうが　いいです：“最好不要那样做”</em><br>熱が　ありますから、こんばんは　お風呂に　入らない　ほうが　いいですよ。</p>\n</li>\n<li><p><em>～ないで　ください：“请不要~”</em><br>禁煙席で　タバコを　<strong>吸わないで</strong>　ください。<br>ここに　車を　止めないで　ください。</p>\n</li>\n<li><p><em>～なくても　いいです：“不必~”</em><br>明日は　休みですから、早く　<strong>起きなくても</strong>　いいです。</p>\n</li>\n<li><p><em>～なければ　なりません：“必须~”</em><br>これは　図書館の　本ですから、<strong>返さなければ</strong>　なりません。</p>\n</li>\n</ul>\n<h2 id=\"动词基本形\"><a href=\"#动词基本形\" class=\"headerlink\" title=\"动词基本形\"></a>动词基本形</h2><ul>\n<li>一类动变换为基本形，去掉<code>ます</code>，最后一个音<code>い</code>变为<code>う段</code>。</li>\n<li>二类动词变化为去掉<code>ます</code>直接加上<code>る</code>。</li>\n<li>三类动词变为<code>来る</code>と<code>する</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>ます形</th>\n<th>基本形</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>一类动词</td>\n<td>書<strong>き</strong>ます</td>\n<td>かく</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>急<strong>ぎ</strong>ます</td>\n<td>急ぐ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>飛<strong>び</strong>ます</td>\n<td>飛ぶ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>読<strong>み</strong>ます</td>\n<td>読む</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>死<strong>に</strong>ます</td>\n<td>死ぬ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>待<strong>ち</strong>ます</td>\n<td>待つ</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>売<strong>り</strong>ます</td>\n<td>うる</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>買<strong>い</strong>ます</td>\n<td>買う</td>\n</tr>\n<tr>\n<td>一类动词</td>\n<td>話<strong>し</strong>ます</td>\n<td>話す</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>食<strong>べ</strong>ます</td>\n<td>食べる</td>\n</tr>\n<tr>\n<td>二类动词</td>\n<td>見ます</td>\n<td>見る</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>来ます</td>\n<td>来る</td>\n</tr>\n<tr>\n<td>三类动词</td>\n<td>します</td>\n<td>する</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关语法-3\"><a href=\"#相关语法-3\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>（～は）[动(基本形)]＋ことが　できます：①能力；②条件允许。</em><br>森さんは　料理を　作る　ことが　できますか。<br>——はい、できます。／いいえ、できません。</p>\n</li>\n<li><p><em>[名]+は+[动(基本形)]+ことです</em><br>わたしの　趣味は　本を　読む　ことです。<br>森さんの　夢は　外国で　働く　ことです。</p>\n</li>\n</ul>\n<h1 id=\"形容词\"><a href=\"#形容词\" class=\"headerlink\" title=\"形容词\"></a>形容词</h1><h2 id=\"形容词的二形\"><a href=\"#形容词的二形\" class=\"headerlink\" title=\"形容词的二形\"></a>形容词的二形</h2><ul>\n<li><p>一类形容词 词尾以<code>い</code>结尾的形容词<br>否定: い → くない<br>过去: \b い　→　かった<br>过去否定:  い → く なかってです / く　ありませんでした</p>\n</li>\n<li><p>二类形容词 词尾不为<code>い</code>结尾的形容词<br>否定: でわありませ<br>过去和です变化相同，为でした　ではありませんでした</p>\n</li>\n</ul>\n<h3 id=\"相关语法-4\"><a href=\"#相关语法-4\" class=\"headerlink\" title=\"相关语法\"></a>相关语法</h3><ul>\n<li><p><em>あまり～[形1／动(否定)]：“不怎么……，不太……”，表示程度不高。</em><br>昨日の　試験は　あまり　難しく　なかったです。<br>わたしは　あまり　コーヒーを　飲みません。</p>\n</li>\n<li><p><em>形容词谓语句</em>：</p>\n<ul>\n<li><p>一类形容词　<br>①现在将来肯定形式： 今日は　寒いです。<br>②现在将来否定形式：今日は　寒く　ないです／ありません。<br>③过去肯定形式：昨日は　寒かったです。<br>④过去否定形式：昨日は　寒く　なかったです／ありませんでした。<br>いい<br>→よく　ない   →よかった   →よく   なかった</p>\n</li>\n<li><p>二类形容词　<br>①现在将来肯定形式：東京は　にぎやかです。<br>②现在将来否定形式：京都は　にぎやかでは　ありません／では　ないです。<br>③过去肯定形式：京都は　にぎやかでした。<br>④过去否定形式：京都は　にぎやかでは　ありませんでした。</p>\n</li>\n</ul>\n</li>\n<li><p><em>～で　[何／だれ／いつ／どれ／どの　名]が　いちばん[形容词]ですか</em><br>“哪个~最……？”<br>季節の　中で、いつが　いちばん　好きですか。<br>果物の　中で、何が　いちばん　好きですか。</p>\n</li>\n<li><p>形容词变化句</p>\n<ul>\n<li>[形1（词尾“い”→“く”）]＋します：使……变得……</li>\n<li>[形1（词尾“い”→“く”）]＋なります：……变得……<br>だんだん　暖かく　なります。<br>テレビの　音を　大きく　します。</li>\n<li>[名／形2]＋“に”＋“します”：使……变得……，使……成为……　</li>\n<li>[名／形2]＋“に”＋“なります”：……变得……<br>部屋を　きれいに　して　ください。<br>部屋は　きれいに　なりました。<br>息子を　医者に　します。<br>息子は　医者に　なりました。</li>\n</ul>\n</li>\n<li><p><em>形容词作定语（修饰名词）</em><br>一类形容词：青い　海<br>二类形容词：きれいな　部屋</p>\n</li>\n</ul>\n<h2 id=\"形容词的て形\"><a href=\"#形容词的て形\" class=\"headerlink\" title=\"形容词的て形\"></a>形容词的て形</h2><ul>\n<li><p><em>一类形容词的“て形”：词尾的“い”变成“く”+“て”</em><br>この　公園は　<strong>広　くて</strong>　静かです。<br>彼女は　優しくて　<strong>きれいで</strong>す。</p>\n</li>\n<li><p><em>二类形容词的“て形”：词干 +“で”</em><br>彼女は　<strong>きれいで</strong>　優しいです。</p>\n</li>\n</ul>\n<h1 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h1><p>こと：形式名词，起到将前项的动词或形容词小句名词化的作用。</p>\n<ul>\n<li><p><em>[名]＋“に”＋“します” ：表示选择，决定。</em><br>カレーライスに　します。<br>あの　子に　します。</p>\n</li>\n<li><p><em>[名]（～を）ください：请给我……。</em><br>コーヒーを　２つ　ください。<br>娘さんを　ください。</p>\n</li>\n<li><p><em>[名]＋が＋欲しい（ほしい）です：想要…（某物），用于表达自己的欲望。</em><br>新しい　パソコンが　欲しいです。<br>否定形式：欲しく　ないです／欲しく　ありません。<br>过去形式：欲しかったです<br>今は　何も　欲しく　ないです／欲しく　ありません。</p>\n</li>\n<li><p><em>[名1]は　[名2]を　[动(“ます型”去掉“ます”)]たいです</em><br>“～たい”的词尾“い”按一类形容词活用。<br>映画を　見たいです。<br>否定形式：飲みたく　ないです／ありません。<br>过去形式：たかったです<br>今は　お酒を　飲みたく　ないです／ありません。</p>\n</li>\n<li><p><em>[名词1]＋“で”＋[名词2]</em><br>森さんは　企画会社の　社員で、背が　高くて、ハンサムな　人です。</p>\n</li>\n</ul>\n<ul>\n<li><p><em>[名]か　[名]：表示选择，“~或者~”</em><br>毎朝　パンか　お粥を　食べます。<br>休みは　月曜日か　火曜日です。</p>\n</li>\n<li><p><em>名词谓语句</em><br>现在将来肯定形式：今日は　いい　天気です。<br>现在将来否定形式： 今日は　いい　天気では　ありません／ではないです。<br>过去肯定形式：  昨日は　いい　天気でした。<br>过去否定形式： 昨日は　いい　天気では　ありませんでした。</p>\n</li>\n<li><p><em>名词 + の + 後で</em><br>仕事が　終わった　後で、飲みに　行きます。<br>仕事の　後で、飲みに　行きます。</p>\n</li>\n<li><p><em>[名（场所）]＋を＋（带移动意味的）动词：经过／离开的场所</em><br>この　バスは　駅前を　通ります。<br>わたしは　来年　大学を　卒業します。<br>家を　出ます。</p>\n</li>\n</ul>\n<h1 id=\"助词\"><a href=\"#助词\" class=\"headerlink\" title=\"助词\"></a>助词</h1><h2 id=\"が\"><a href=\"#が\" class=\"headerlink\" title=\"が\"></a>が</h2><ul>\n<li><p><em>[小句]が、[小句]：[转折]</em><br>３か月　パソコンを　勉強しました<strong>が</strong>、まだ　あまり　できません。<br>この　レストランは　おいしいです<strong>が</strong>、ちょっと　高いです。</p>\n</li>\n<li><p><em>[小句]が、[小句]：[铺垫]</em><br>東京タワーへ　行きたいんです<strong>が</strong>、どうやって　行きますか。</p>\n</li>\n<li><p><em>～が～：提示主语。</em></p>\n<p>旧信息用“は”，新信息用“が”。<br>山田さんは　どなたですか。<br>山田さんは　あの　方です。<br>あの　方が　山田さんです。</p>\n<p>疑问词作主语时，一定用“が”（新信息）。<br>どなたが　山田さんですか。　は（×）<br>——あの　方が　山田さんです。</p>\n<p>～が～：表示感情或能力的对象（对象语）。<br>わたしは　犬が　好きです。<br>スミスさんは　韓国語が　分かります。</p>\n</li>\n</ul>\n<h2 id=\"で\"><a href=\"#で\" class=\"headerlink\" title=\"で\"></a>で</h2><ul>\n<li><p><em>名[工具／手段／方式]＋“で”：表示工具或手段、方法、方式。</em><br>日本語<strong>で</strong>　手紙を　書きます。<br>タクシー<strong>で</strong>　帰ります。</p>\n</li>\n<li><p><em>名词[原材料]＋“で” ：表示原材料。</em><br>新聞紙<strong>で</strong>　紙飛行機を　作りました。</p>\n</li>\n<li><p><em>名[场所]+“で”：表示动作或事情发生的场所。</em><br>来月、この　ホテル<strong>で</strong>　友達の　写真展が　あります。</p>\n</li>\n<li><p><em>数量词＋“で”：表示总计。</em><br>この りんごは　３個<strong>で</strong>　５００円です。</p>\n</li>\n<li><p><em>名[人数等]＋“で”：表示动作主体的状态。</em><br>北京では、春節の　前に、家族全員<strong>で</strong>　餃子を　作ります。<br>今度　二人<strong>で</strong>　会いましょう。</p>\n</li>\n<li><p><em>名[场所或范围]＋“で”：表示范围。</em><br>日本<strong>で</strong>　いちばん　高い山は　富士山です。<br>一年<strong>で</strong>　いちばん　寒い月は　２月です。  </p>\n</li>\n</ul>\n<h2 id=\"に\"><a href=\"#に\" class=\"headerlink\" title=\"に\"></a>に</h2><ul>\n<li><p><em>具体时间点＋に：具体时间</em>　<br>わたしは　毎晩　<strong>１１時に</strong>　寝ます。</p>\n</li>\n<li><p><em>间接宾语＋に：动作行为的对象</em><br>李さん<strong>に</strong>　手紙を　書きます。<br>友達<strong>に</strong>　お金を　貸します。<br>さっき　駅前で　森さん<strong>に</strong>　会いました。</p>\n</li>\n<li><p><em>时间段＋に＋次数＋[动词]：频率</em><br>1年<strong>に</strong>　1回　国へ　帰ります。／<strong>年に</strong>　1回　国へ　帰ります。<br>1日<strong>に</strong>　2杯　コーヒーを　飲みます。／<strong>日に</strong>　2杯　コーヒーを　飲みます。</p>\n</li>\n<li><p><em>[动1,2]“ます形”去掉“ます”／[动3词干]＋に＋移动动词：移动行为的目的</em><br>友達の　家へ　<strong>遊びに</strong>　行きます。<br>渋谷へ　買い物<strong>に</strong>　行きます。</p>\n</li>\n<li><p><em>附着点＋に：附着点</em>　　　<br>ここ<strong>に</strong>　座っても　いいですか。<br>電車／バス／飛行機／自転車に　乗ります。<br>その品物<strong>に</strong>　触らないで　ください。</p>\n</li>\n<li><p><em>～前に、～：“……之前，……”</em><br>[动词基本形]＋前に<br>[名词]＋の＋前に<br>こちらへ　来る　前に　電話を　かけて　ください。<br>会議の　前に　資料を　コピーします。</p>\n</li>\n</ul>\n<h2 id=\"と\"><a href=\"#と\" class=\"headerlink\" title=\"と\"></a>と</h2><ul>\n<li><p><em>[名1]と　[名2]：[并列]</em><br>パン<strong>と</strong>　ミルク<br>テレビ<strong>と</strong>　冷蔵庫<br>箱の　中に　眼鏡<strong>と</strong>　時計が　あります。</p>\n</li>\n<li><p><em>[名(人)]と　[动词]ます：表示共同进行动作的对象。</em><br>昨日　友達<strong>と</strong>　渋谷で　買い物しました。<br>A<strong>と</strong>　B<strong>と</strong>、どちらが　～ですか。</p>\n</li>\n</ul>\n<h2 id=\"も\"><a href=\"#も\" class=\"headerlink\" title=\"も\"></a>も</h2><ul>\n<li><p><em>～も：[兼提]“~也”</em>　<br>李さんは　中国人です。張さん<strong>も</strong>　中国人です。<br>来週の　ハイキング、私<strong>も</strong>　行きたい。</p>\n</li>\n<li><p><em>[数量词]＋も+肯定形式：强调数量多。</em><br>何度<strong>も</strong>　転びましたが、とても　おもしろいです。</p>\n</li>\n<li><p><em>[较少数量]＋も＋否定形式：全面否定。</em><br>財布の　中に　１円<strong>も</strong>　ありません。<br>わたしには　友達が　１人<strong>も</strong>　いません。</p>\n</li>\n</ul>\n<h2 id=\"ね\"><a href=\"#ね\" class=\"headerlink\" title=\"ね\"></a>ね</h2><ul>\n<li><p><em>[确认]</em>　<br>あそこに　猫が　いますね。<br>この　新聞は　田中さんのですね。</p>\n</li>\n<li><p><em>よね：[确认]</em>　　<br>今日　李さんも　来ますよね。<br>手作りの　餃子は　皮が　おいしいです<strong>よね</strong>。</p>\n</li>\n<li><p><em>[确认][缓和语气]</em><br>日本料理の　中で、何が　いちばん　好きですか。<br>——そうですね。やっぱり　おすしです<strong>ね</strong>。</p>\n</li>\n</ul>\n<h2 id=\"の\"><a href=\"#の\" class=\"headerlink\" title=\"の\"></a>の</h2><ul>\n<li><em>[所属关系、属性、内容、原材料等]</em><br>中国の　企業</li>\n</ul>\n<h2 id=\"へ\"><a href=\"#へ\" class=\"headerlink\" title=\"へ\"></a>へ</h2><ul>\n<li><em>移动行为的目的地／方向</em><br>李さんは　中国へ　帰りました。</li>\n<li><em>へ～に行きます／来ます</em><br>昨日　渋谷へ　買い物に　行きました。</li>\n</ul>\n<h2 id=\"や\"><a href=\"#や\" class=\"headerlink\" title=\"や\"></a>や</h2><ul>\n<li><em>～や～／～や～など：表示不完全列举</em>　<br>昨日、スーパーで　野菜や　果物などを　買いました。</li>\n</ul>\n<h2 id=\"よ\"><a href=\"#よ\" class=\"headerlink\" title=\"よ\"></a>よ</h2><ul>\n<li><em>[提醒、告知、轻微警告]</em>　<br>李さんは　もう　帰りましたよ。</li>\n</ul>\n<h2 id=\"は\"><a href=\"#は\" class=\"headerlink\" title=\"は\"></a>は</h2><ul>\n<li><p><em>～は～が[感情形容词]です</em><br>～は：表示感情的主体。　～が：表示感情所指向的对象。<br>一般用于表达第一人称的感情。（日语中一般避免直接说出别人的内心感受）<br>（わたしは）日本の　漫画が　好きです。<br>（あなたは）どんな　本が　好きですか。</p>\n</li>\n<li><p><em>～は～が分かります／できます／上手です／下手です[表示能力的词]</em><br>～は：表示能力的主体。　～が：表示能力的对象。<br>スミスさんは　韓国語が　分かります。<br>小野さんは　料理が　上手です。<br>森さんは　歌が　下手です。</p>\n</li>\n</ul>\n<h1 id=\"其它重点句型\"><a href=\"#其它重点句型\" class=\"headerlink\" title=\"其它重点句型\"></a>其它重点句型</h1><h2 id=\"引用句型\"><a href=\"#引用句型\" class=\"headerlink\" title=\"引用句型\"></a>引用句型</h2><ul>\n<li><p><em>[简体形小句]と　思います：引用说话人的思考内容。</em><br>李さんは　もうすぐ　来ると　思います。<br>明日は　いい　天気だと　思います。</p>\n</li>\n<li><p><em>[小句]と　言いました：转述第三人称的说话内容。</em><br>小野さんは　李さんに　ちょっと　休みたいと　言いました。<br>長島さんは　やめた　ほうが　いいと　言いました。<br>長島さんは　「やめた　ほうが　いいですよ」と　言いました。</p>\n</li>\n</ul>\n<h2 id=\"比较句\"><a href=\"#比较句\" class=\"headerlink\" title=\"比较句\"></a>比较句</h2><ul>\n<li><p><em>Aは　Bより　[形容词]です：“A比B更……”</em><br>中国は　日本<strong>より</strong>　広いです。<br>中国は　日本<strong>より</strong>　ずっと　広いです。</p>\n</li>\n<li><p><em>Aより　Bの　ほうが　[形容词]です：“比起A来，B更……”</em><br>日本<strong>より</strong>　中国<strong>の　ほうが</strong>　広いです。</p>\n</li>\n<li><p><em>Aは　Bほど　[形1(い→く)]ないです／[形2]ではありません：“A不如B……”</em><br>大阪は　東京ほど　にぎやか　では　ありません。</p>\n</li>\n<li><p><em>Aと　Bと　どちらが　[形容词]ですか：“A和B，哪一个更……？”</em><br>日本語と　英語と　<strong>どちらが</strong>　難しいですか。<br>——日本語の　ほうが　難しいです。・どちらも　難しいです。</p>\n</li>\n<li><p><em>[名1（范围）]の　中で　[名2]が　いちばん　[形容词]です</em><br>“在～[名1]之中，～[名2]最……”<br>スポーツの　中で　サッカーが　いちばん　おもしろいです。</p>\n</li>\n<li><p><em>[名1（范围）]でいちばん～は[名2]です</em><br>“在～[名1]之中，[名2]最……”<br>日本で　いちばん　高い山は　富士山です。</p>\n</li>\n</ul>\n<h2 id=\"小句-か得包孕句型\"><a href=\"#小句-か得包孕句型\" class=\"headerlink\" title=\"小句+か得包孕句型\"></a>小句+か得包孕句型</h2><ul>\n<li><p>一<em>般疑问句→[小句]＋か　どうか（或重复谓语部分的肯定与否定形式）</em><br>形式：简体＋か　どうか   &lt;注意：二类形／名（不含“だ”）＋か　どうか&gt;<br>注意：小句中的主语必须用“が”、不能用“は”。<br>わたしは　今年の　夏　北京へ　行きますか。＋わたしは　分かりません。<br>わたしは　今年の　夏　北京へ　行くか　どうか　分かりません。<br>この　料理は　辛いですか。＋わたしは　知りません。<br>この　料理が　辛いか　どうか　知りません。<br>この　料理が　辛いか　辛くないか　知りません。</p>\n</li>\n<li><p><em>特殊疑问句→[带疑问词的小句]＋か</em><br>形式：[带疑问词的小句]简体形式＋か　&lt;注意：二类形／名（不含だ）＋か&gt;<br>かぎが　どこに　ありますか。＋教えて　ください。<br>かぎが　どこに　あるか　教えて　ください。<br>この　歌は　だれの　歌ですか＋知って　いますか。<br>この　歌が　だれの　歌か　知って　いますか。　（○）</p>\n</li>\n</ul>\n<h2 id=\"授受动词\"><a href=\"#授受动词\" class=\"headerlink\" title=\"授受动词　\"></a>授受动词　</h2><ul>\n<li><p><em>（Aは）Bに　～あげます：A给B~。（B不能是“自己人”）</em><br>小野さんは　森さんに　チョコレートを　あげました。<br>小野：わたしは　森さんに　チョコレートを　あげました。自己人需要使用くれます</p>\n</li>\n<li><p><em>（Aは）Bに／から～もらいます：A从B处得到~。</em><br>森さんは　小野さんに／から　チョコレートを　もらいました。<br>長島さんから　この　写真集を　もらいました。</p>\n</li>\n</ul>\n<h2 id=\"提议劝诱（礼貌程度依次递增）\"><a href=\"#提议劝诱（礼貌程度依次递增）\" class=\"headerlink\" title=\"提议劝诱（礼貌程度依次递增）\"></a>提议劝诱（礼貌程度依次递增）</h2><p>～ましょう：[提议，劝诱] “咱们……吧？”　<br>～ましょうか。 [提议，劝诱]　<br>～ませんか：[提议，劝诱]“要不要……？”</p>\n<h2 id=\"存在句-あります-います\"><a href=\"#存在句-あります-います\" class=\"headerlink\" title=\"存在句 あります/います\"></a>存在句 あります/います</h2><p>表存在的句型，人、动物和昆虫用“います”, 非生物和植物用“あります”</p>\n<ul>\n<li><p><em>名[场所]に　名[物／人]が　あります／います：表示某地有某物或某人</em><br>庭に　桜（さくら）の　木が　あります。<br>庭に　犬が　います。</p>\n</li>\n<li><p><em>名[物／人]は　名[场所]に　あります／います：表示某物或某人在某处</em><br>事務所は　あの　ビルの　７階に　あります。<br>李さんは　どこに　いますか。</p>\n</li>\n<li><p><em>名[场所]で　名[事件]が　あります：表示在某地发生或举行某事</em><br>ゆうべ、大阪で　地震が　ありました。<br>来月、この　ホテルで　友達の　写真展が　あります。</p>\n</li>\n<li><p><em>名[所有人]（に）は　名[所有物／人]が　あります／います：表示所有／拥有</em><br>森さんは　車が　２台 　あります。<br>森さんは　弟が　２人　 います。</p>\n</li>\n</ul>\n<h2 id=\"疑问词\"><a href=\"#疑问词\" class=\"headerlink\" title=\"疑问词\"></a>疑问词</h2><ul>\n<li><p><em>疑问词＋か：表示不确定</em>　<br>冬休みに　どこかへ　行きたいですね。<br>おなかが　すきましたね。何か　食べましょう。</p>\n</li>\n<li><p><em>疑问词＋でも＋肯定形式：表示全面肯定</em>　<br>いつでも　電話して　ください。<br>何を　食べたいですか。 ——何でも　いいです。</p>\n</li>\n<li><p><em>疑问词＋も＋否定形式：表示全面否定</em>　<br>教室に　だれも　いません。<br>冷蔵庫に　何も　ありません。</p>\n</li>\n<li><p><em>～は　いくらですか：~多少钱？</em></p>\n</li>\n<li><p><em>誰（だれ）ですか／何（なん）ですか。</em></p>\n</li>\n<li><p><em>～かな：放在简体形疑问小句的结尾。</em><br>用于自言自语。存在听话人的场合下，用于向对方传达一种不太有把握的<br>信息或寻求确认。<br>期間は　４年か　５年かな。</p>\n</li>\n</ul>\n<ul>\n<li><em>～ですか、～ですか：选择疑问句</em>　　　<br>でも～：表示转折</li>\n</ul>\n<ul>\n<li>どうしてですか：询问理由。<br>どうして～のですか／んですか。　<br>来月　また　ここに　来ます。<br>どうして　ですか。<br>この　ホテルで　友達の　写真展が　ありますから。<br>どうして　食べないのですか／んですか。<br>もう　おなかが　いっぱいなんです。</li>\n</ul>\n<h2 id=\"指示词-コソアド系\"><a href=\"#指示词-コソアド系\" class=\"headerlink\" title=\"指示词(コソアド系)\"></a>指示词(コソアド系)</h2><p>これ／それ／あれ／どれ：用于指代事物<br>この／その／あの／どの＋名：指示连体词，后加名词<br>ここ／そこ／あそこ／どこ：用于指代场所<br>こちら／そちら／あちら／どちら：礼貌说法<br>こう／そう／ああ／どう：指代行为方式</p>\n<h2 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h2><ul>\n<li><p><em>いつ　[动]　ますか：何时……？</em>　<br>いつ　出かけますか。<br>会議は　いつ　終わりますか。</p>\n</li>\n<li><p><em>今～時～分です。</em><br>今　４時３０分です。</p>\n</li>\n</ul>\n<h2 id=\"询问对方的感想\"><a href=\"#询问对方的感想\" class=\"headerlink\" title=\"询问对方的感想　\"></a>询问对方的感想　</h2><p>どうですか</p>\n<ul>\n<li><em>どうでしたか。</em><br>この　料理は　どうですか。<br>旅行は　どうでしたか。</li>\n<li><em>（～は）どこですか。</em><br>どれ／どの～　<br>どんな＋名词：“怎样的~”<br>どんな　音楽が　好きですか。</li>\n</ul>\n<h2 id=\"因果\"><a href=\"#因果\" class=\"headerlink\" title=\"因果\"></a>因果</h2><ul>\n<li><em>～から和だから：表示因果。</em><br>[敬体／简体小句（原因）]＋から、……[敬体／简体小句]。<br>[句子]。ですから／だから 、……[句子（结果）]。<br>森さんは　お酒が　好きですから、 毎日　飲みます。<br>窓を　閉めます。 寒いですから。<br>キムさんは　野菜が　嫌いです。だから／ですから、あまり　食べません。<br>キムさんは　野菜が　嫌いですから、あまり　食べません。</li>\n</ul>\n<h2 id=\"否定\"><a href=\"#否定\" class=\"headerlink\" title=\"否定\"></a>否定</h2><ul>\n<li><em>まだ～：[否定] “尚未……，还没……”</em><br>まだ～ていません。<br>まだです。<br>小野さんは　もう　結婚して　いますか。<br>——いいえ、まだ　結婚して　いません。<br>——いいえ、まだです。<br>李さんは　来ましたか。<br>——いいえ、まだ　来て　いません。<br>——いいえ、まだです。</li>\n</ul>\n<h2 id=\"转折强调\"><a href=\"#转折强调\" class=\"headerlink\" title=\"转折强调\"></a>转折强调</h2><ul>\n<li><p><em>～けど、～：[转折][铺垫]</em>　多用于简体句<br>昨日の　試験、どうだった？<br>——ちょっと　難しかったけど、まあまあ　できたよ。<br>来週、送別会を　するけど、都合は　どうかな？</p>\n</li>\n<li><p><em>でも、～：但是……</em><br>そして、～：而且……<br>わたしの　部屋は　狭いです。でも、きれいです。<br>わたしの　部屋は　狭いです。そして、汚いです。</p>\n</li>\n<li><p><em>に／で／へ／から／まで／と＋は：助词叠加【格助词＋提示助词】</em><br>韓国へは　行きましたが、中国へは　行きませんでした。<br>森さんには　会いたく　ないです。</p>\n</li>\n<li><p><em>“を”→“は”：作为整个句子的话题或表示对比强调</em>　<br>コーヒーを　飲みません。     → コーヒーは　飲みません。<br>チケットを　買いましたか。 → チケットは　買いましたか。</p>\n</li>\n<li><p><em>～のです／～んです：对某前提事态的说明或解释。</em><br>~のですか／～んですか：寻求对某前提事态的说明或解释。<br>あ、雨が　降って　いるんですか。<br>何を　探して　いるんですか。<br>昨日　学校を　休みました。頭が　痛かったんです。<br>東京タワーへ　行きたいんですが、どうやって　行きますか。<br>接续：简体形小句＋のです／んです。名／二类形（だ→な）＋のです／んです</p>\n</li>\n<li><p><em>～から：起点 ～まで：终点</em><br>時間と空间<br>わたしは　９時から　午後５時まで　働きます。<br>東京から　広島まで　新幹線で　行きます。<br>試験は　９時から　１２時までです。</p>\n</li>\n<li><p><em>～くらい・ぐらい：前接数量词，表示大概的数量。</em><br>大阪まで　どのくらい／どれぐらい　かかりますか。<br>——２時間ぐらい　かかります。</p>\n</li>\n</ul>"},{"title":"2019","date":"2019-03-23T16:16:00.000Z","_content":"# 2019,新的开始\n<!--more-->\n## 前言\n&emsp;&emsp;今天终于把立了快半年flag的博客给搭建出来了，hexo方案还是很成熟的，比我之前从0开始写一个要优秀的多。\n想想一时冲动从物流转向前端，已经过去一年了。在去年的拼命的绝望，感慨命运的不公，到今年的满足和规划，点点滴滴，想要总结回顾在这里。\n## 从物流到前端\n&emsp;&emsp;**选择大于努力**，是在物流工作两年之后体会到真理。当我骄傲的顶着前十的校招成绩，完美的完成领导各项繁重的任务，绩效S和A拿不停的时候，我天真的以为真的能依靠自己的努力，换取升职加薪，收获属于自己的一份职场硕果的时候，绝望来的太快了。\n&emsp;&emsp;平均学历大专以下的低素质中层管理，带着浓浓痞子气，和你称兄道弟许你前途，转头就是捅你一刀。\n&emsp;&emsp;我看到连Excel都做不好的漂亮核算年度绩效轻松上S，办公室指导型的仓管和领导夜夜笙歌，快速升职加薪。我靠着拼命和服从，换取的一年升职为主管，人家半年请领导吃饭就可以了。\n&emsp;&emsp;当双十一的我，连续三四天通宵干活，住瓦板房，配送干完干仓管，换来的只是这波忙完后去下一波忙的地方的时候，我就知道，是时候和这个行业说拜拜了。\n我想我的博客并没有多少人去观看，但是如果物流专业的同学看到我这篇文章，奉劝你一句话，离开这个配不上你努力的行业，去提升效率更高的地方吧。\n## 2018年的曲折和绝望\n&emsp;&emsp;选择前端真的是一个偶然，毕竟一年前的这个时候我连Java和JavaScript的区别都分不清。\n&emsp;&emsp;小学时候记得是用微软的类似excel的工具去做过网页，当时还去市里面拿过奖。当时有个自媒体的同学说和我一起转行学习编程，告诉我前端好学。\n于是我就上网查询了前端的相关介绍，岗位信息，查询了一下前端的学习路径。当时记得知乎上面有一个千赞的前端学习书籍推荐，趁着双十二，我在当当上面买了\n200的书本，捧着《Head First》简单的学习了html和css，觉得很简单，编程原来如此好理解，就信心满满的决定转行前端了。\n&emsp;&emsp;个人感觉学习也其实没有那么难，对我来说卡住最多的就是刚开始长串的英文单词，JS部分难度是上去了，但是认真啃两遍高程，不懂得地方多去网上问问，JS也就过来了。\n&emsp;&emsp;一个人的学习很闷，不知道自己的真实水平，没有有工作经验的人给予评价，心里很虚。有时候遇到bug和问题，你甚至不知道怎么去网络上面搜索。女朋友还会时不时的和你\n闹个情绪，生个气。现在想想，不知道当时自己怎么熬下来的。当时那时确实是我这辈子学习最用功的时候。\n&emsp;&emsp;所幸坚持了下来，感谢那时候的自己，在打下比较坚实基础的同时，也掌握了编程的对应的学习方法，对现在的工作生活帮助很大。\n&emsp;&emsp;在学习了5个多月开始找工作的时候，家里出事了。我的父亲患了结肠癌，而且还是晚期。本来打算去杭州找工作的我悻悻回到家里，陪父亲的同时，写了个简单的自己网站\n&emsp;&emsp;开始去找工作，三线的城市，过了几个技术面，也因为没有工作经验的原因，被老板拒绝。当时的生活真的是绝望的，父亲病重，自己什么也做不了，工作也找不到，本来学的感觉还不错的自信也被撕扯的粉碎，每天只能紧紧抓着红皮的高程，一章一章拼了命的去反复看，感觉抓住了一点点的希望。\n&emsp;&emsp;想过自尽，但是想想父亲，坚持了下来。一星期左右的时候，找到了一份0福利，4000块钱的前端工作。\n&emsp;&emsp;现在想想，还是应该庆幸这份工作的。虽然公司的福利为0 ，一周6天班，工资少到令人发指，但是好歹愿意接受0经验的我参加实际项目，虽然公司的项目也很烂，但在这里，我完成了微信小程序的学习，完成了后台管理和官网的项目制作，有了项目经验，给今年找工作带来了极大的便利。\n&emsp;&emsp;在这里，我也见到了最底层的程序员的样子。除了公司项目迫不得已的学习之外，自驱力为0，项目草草写完，复制粘贴冗余代码，毫无逻辑可言。更别说书写代码的时候规范命名，解耦，融入设计模式思想。这些来自职技校或者三本的同学，把编程干出了物流的样子。\n## 生活也该向前看\n&emsp;&emsp;父亲动完手术恢复后，我也着手寻找我的新工作了。想在回想起来，我遇到的面试，都是怪上加怪。面试我http协议状态码的，面试我浏览器页面渲染优化的，我准备的css，JS面试题，愣是一题也没有用上。找工作的过程还算顺利，四份面试邀请，四份全中。最后选择去了阿里的外包工作。我原来公司的几个同事也纷纷跳槽，出来找工作，都反应工作不好找，但是我感觉，还是蛮轻松的，还是看你要求高低吧。月薪也顺利的翻了快3倍，先踏踏实实做个一年，积累工作经验，也把自己的工资线刷一些上去。\n## 2019的flag\n&emsp;&emsp;2019，生活似乎能好起来一些。立一些计划和flag吧。外包性质的工作最多干一年，明年想冲击一下15w的年薪，找一份自己平台的工作吧。\n&emsp;&emsp;今年的大体规划：\n1. 博文一周至少更新一篇，打算开三个系列，源码阅读，读书笔记，前端一些工作学习的总结。\n2. 慕课网上面的React源码和前端算法的课程刷刷完，下半年去攻克一下LeetCode，然后明年过年之后，就开始刷面试题了，争取能找到自己平台的工作。\n3. 今年重点学习一下设计模式，Canvas和SEO。","source":"_posts/others/2019.md","raw":"---\ntitle: 2019\ndate: 2019/3/24 0:16:00\ncategories:\n- [生活]\ntags:\n- 生活\n---\n# 2019,新的开始\n<!--more-->\n## 前言\n&emsp;&emsp;今天终于把立了快半年flag的博客给搭建出来了，hexo方案还是很成熟的，比我之前从0开始写一个要优秀的多。\n想想一时冲动从物流转向前端，已经过去一年了。在去年的拼命的绝望，感慨命运的不公，到今年的满足和规划，点点滴滴，想要总结回顾在这里。\n## 从物流到前端\n&emsp;&emsp;**选择大于努力**，是在物流工作两年之后体会到真理。当我骄傲的顶着前十的校招成绩，完美的完成领导各项繁重的任务，绩效S和A拿不停的时候，我天真的以为真的能依靠自己的努力，换取升职加薪，收获属于自己的一份职场硕果的时候，绝望来的太快了。\n&emsp;&emsp;平均学历大专以下的低素质中层管理，带着浓浓痞子气，和你称兄道弟许你前途，转头就是捅你一刀。\n&emsp;&emsp;我看到连Excel都做不好的漂亮核算年度绩效轻松上S，办公室指导型的仓管和领导夜夜笙歌，快速升职加薪。我靠着拼命和服从，换取的一年升职为主管，人家半年请领导吃饭就可以了。\n&emsp;&emsp;当双十一的我，连续三四天通宵干活，住瓦板房，配送干完干仓管，换来的只是这波忙完后去下一波忙的地方的时候，我就知道，是时候和这个行业说拜拜了。\n我想我的博客并没有多少人去观看，但是如果物流专业的同学看到我这篇文章，奉劝你一句话，离开这个配不上你努力的行业，去提升效率更高的地方吧。\n## 2018年的曲折和绝望\n&emsp;&emsp;选择前端真的是一个偶然，毕竟一年前的这个时候我连Java和JavaScript的区别都分不清。\n&emsp;&emsp;小学时候记得是用微软的类似excel的工具去做过网页，当时还去市里面拿过奖。当时有个自媒体的同学说和我一起转行学习编程，告诉我前端好学。\n于是我就上网查询了前端的相关介绍，岗位信息，查询了一下前端的学习路径。当时记得知乎上面有一个千赞的前端学习书籍推荐，趁着双十二，我在当当上面买了\n200的书本，捧着《Head First》简单的学习了html和css，觉得很简单，编程原来如此好理解，就信心满满的决定转行前端了。\n&emsp;&emsp;个人感觉学习也其实没有那么难，对我来说卡住最多的就是刚开始长串的英文单词，JS部分难度是上去了，但是认真啃两遍高程，不懂得地方多去网上问问，JS也就过来了。\n&emsp;&emsp;一个人的学习很闷，不知道自己的真实水平，没有有工作经验的人给予评价，心里很虚。有时候遇到bug和问题，你甚至不知道怎么去网络上面搜索。女朋友还会时不时的和你\n闹个情绪，生个气。现在想想，不知道当时自己怎么熬下来的。当时那时确实是我这辈子学习最用功的时候。\n&emsp;&emsp;所幸坚持了下来，感谢那时候的自己，在打下比较坚实基础的同时，也掌握了编程的对应的学习方法，对现在的工作生活帮助很大。\n&emsp;&emsp;在学习了5个多月开始找工作的时候，家里出事了。我的父亲患了结肠癌，而且还是晚期。本来打算去杭州找工作的我悻悻回到家里，陪父亲的同时，写了个简单的自己网站\n&emsp;&emsp;开始去找工作，三线的城市，过了几个技术面，也因为没有工作经验的原因，被老板拒绝。当时的生活真的是绝望的，父亲病重，自己什么也做不了，工作也找不到，本来学的感觉还不错的自信也被撕扯的粉碎，每天只能紧紧抓着红皮的高程，一章一章拼了命的去反复看，感觉抓住了一点点的希望。\n&emsp;&emsp;想过自尽，但是想想父亲，坚持了下来。一星期左右的时候，找到了一份0福利，4000块钱的前端工作。\n&emsp;&emsp;现在想想，还是应该庆幸这份工作的。虽然公司的福利为0 ，一周6天班，工资少到令人发指，但是好歹愿意接受0经验的我参加实际项目，虽然公司的项目也很烂，但在这里，我完成了微信小程序的学习，完成了后台管理和官网的项目制作，有了项目经验，给今年找工作带来了极大的便利。\n&emsp;&emsp;在这里，我也见到了最底层的程序员的样子。除了公司项目迫不得已的学习之外，自驱力为0，项目草草写完，复制粘贴冗余代码，毫无逻辑可言。更别说书写代码的时候规范命名，解耦，融入设计模式思想。这些来自职技校或者三本的同学，把编程干出了物流的样子。\n## 生活也该向前看\n&emsp;&emsp;父亲动完手术恢复后，我也着手寻找我的新工作了。想在回想起来，我遇到的面试，都是怪上加怪。面试我http协议状态码的，面试我浏览器页面渲染优化的，我准备的css，JS面试题，愣是一题也没有用上。找工作的过程还算顺利，四份面试邀请，四份全中。最后选择去了阿里的外包工作。我原来公司的几个同事也纷纷跳槽，出来找工作，都反应工作不好找，但是我感觉，还是蛮轻松的，还是看你要求高低吧。月薪也顺利的翻了快3倍，先踏踏实实做个一年，积累工作经验，也把自己的工资线刷一些上去。\n## 2019的flag\n&emsp;&emsp;2019，生活似乎能好起来一些。立一些计划和flag吧。外包性质的工作最多干一年，明年想冲击一下15w的年薪，找一份自己平台的工作吧。\n&emsp;&emsp;今年的大体规划：\n1. 博文一周至少更新一篇，打算开三个系列，源码阅读，读书笔记，前端一些工作学习的总结。\n2. 慕课网上面的React源码和前端算法的课程刷刷完，下半年去攻克一下LeetCode，然后明年过年之后，就开始刷面试题了，争取能找到自己平台的工作。\n3. 今年重点学习一下设计模式，Canvas和SEO。","slug":"others/2019","published":1,"updated":"2020-06-11T01:43:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxp00119r2vb0h58ii1","content":"<h1 id=\"2019-新的开始\"><a href=\"#2019-新的开始\" class=\"headerlink\" title=\"2019,新的开始\"></a>2019,新的开始</h1><a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;今天终于把立了快半年flag的博客给搭建出来了，hexo方案还是很成熟的，比我之前从0开始写一个要优秀的多。<br>想想一时冲动从物流转向前端，已经过去一年了。在去年的拼命的绝望，感慨命运的不公，到今年的满足和规划，点点滴滴，想要总结回顾在这里。</p>\n<h2 id=\"从物流到前端\"><a href=\"#从物流到前端\" class=\"headerlink\" title=\"从物流到前端\"></a>从物流到前端</h2><p>&emsp;&emsp;<strong>选择大于努力</strong>，是在物流工作两年之后体会到真理。当我骄傲的顶着前十的校招成绩，完美的完成领导各项繁重的任务，绩效S和A拿不停的时候，我天真的以为真的能依靠自己的努力，换取升职加薪，收获属于自己的一份职场硕果的时候，绝望来的太快了。<br>&emsp;&emsp;平均学历大专以下的低素质中层管理，带着浓浓痞子气，和你称兄道弟许你前途，转头就是捅你一刀。<br>&emsp;&emsp;我看到连Excel都做不好的漂亮核算年度绩效轻松上S，办公室指导型的仓管和领导夜夜笙歌，快速升职加薪。我靠着拼命和服从，换取的一年升职为主管，人家半年请领导吃饭就可以了。<br>&emsp;&emsp;当双十一的我，连续三四天通宵干活，住瓦板房，配送干完干仓管，换来的只是这波忙完后去下一波忙的地方的时候，我就知道，是时候和这个行业说拜拜了。<br>我想我的博客并没有多少人去观看，但是如果物流专业的同学看到我这篇文章，奉劝你一句话，离开这个配不上你努力的行业，去提升效率更高的地方吧。</p>\n<h2 id=\"2018年的曲折和绝望\"><a href=\"#2018年的曲折和绝望\" class=\"headerlink\" title=\"2018年的曲折和绝望\"></a>2018年的曲折和绝望</h2><p>&emsp;&emsp;选择前端真的是一个偶然，毕竟一年前的这个时候我连Java和JavaScript的区别都分不清。<br>&emsp;&emsp;小学时候记得是用微软的类似excel的工具去做过网页，当时还去市里面拿过奖。当时有个自媒体的同学说和我一起转行学习编程，告诉我前端好学。<br>于是我就上网查询了前端的相关介绍，岗位信息，查询了一下前端的学习路径。当时记得知乎上面有一个千赞的前端学习书籍推荐，趁着双十二，我在当当上面买了<br>200的书本，捧着《Head First》简单的学习了html和css，觉得很简单，编程原来如此好理解，就信心满满的决定转行前端了。<br>&emsp;&emsp;个人感觉学习也其实没有那么难，对我来说卡住最多的就是刚开始长串的英文单词，JS部分难度是上去了，但是认真啃两遍高程，不懂得地方多去网上问问，JS也就过来了。<br>&emsp;&emsp;一个人的学习很闷，不知道自己的真实水平，没有有工作经验的人给予评价，心里很虚。有时候遇到bug和问题，你甚至不知道怎么去网络上面搜索。女朋友还会时不时的和你<br>闹个情绪，生个气。现在想想，不知道当时自己怎么熬下来的。当时那时确实是我这辈子学习最用功的时候。<br>&emsp;&emsp;所幸坚持了下来，感谢那时候的自己，在打下比较坚实基础的同时，也掌握了编程的对应的学习方法，对现在的工作生活帮助很大。<br>&emsp;&emsp;在学习了5个多月开始找工作的时候，家里出事了。我的父亲患了结肠癌，而且还是晚期。本来打算去杭州找工作的我悻悻回到家里，陪父亲的同时，写了个简单的自己网站<br>&emsp;&emsp;开始去找工作，三线的城市，过了几个技术面，也因为没有工作经验的原因，被老板拒绝。当时的生活真的是绝望的，父亲病重，自己什么也做不了，工作也找不到，本来学的感觉还不错的自信也被撕扯的粉碎，每天只能紧紧抓着红皮的高程，一章一章拼了命的去反复看，感觉抓住了一点点的希望。<br>&emsp;&emsp;想过自尽，但是想想父亲，坚持了下来。一星期左右的时候，找到了一份0福利，4000块钱的前端工作。<br>&emsp;&emsp;现在想想，还是应该庆幸这份工作的。虽然公司的福利为0 ，一周6天班，工资少到令人发指，但是好歹愿意接受0经验的我参加实际项目，虽然公司的项目也很烂，但在这里，我完成了微信小程序的学习，完成了后台管理和官网的项目制作，有了项目经验，给今年找工作带来了极大的便利。<br>&emsp;&emsp;在这里，我也见到了最底层的程序员的样子。除了公司项目迫不得已的学习之外，自驱力为0，项目草草写完，复制粘贴冗余代码，毫无逻辑可言。更别说书写代码的时候规范命名，解耦，融入设计模式思想。这些来自职技校或者三本的同学，把编程干出了物流的样子。</p>\n<h2 id=\"生活也该向前看\"><a href=\"#生活也该向前看\" class=\"headerlink\" title=\"生活也该向前看\"></a>生活也该向前看</h2><p>&emsp;&emsp;父亲动完手术恢复后，我也着手寻找我的新工作了。想在回想起来，我遇到的面试，都是怪上加怪。面试我http协议状态码的，面试我浏览器页面渲染优化的，我准备的css，JS面试题，愣是一题也没有用上。找工作的过程还算顺利，四份面试邀请，四份全中。最后选择去了阿里的外包工作。我原来公司的几个同事也纷纷跳槽，出来找工作，都反应工作不好找，但是我感觉，还是蛮轻松的，还是看你要求高低吧。月薪也顺利的翻了快3倍，先踏踏实实做个一年，积累工作经验，也把自己的工资线刷一些上去。</p>\n<h2 id=\"2019的flag\"><a href=\"#2019的flag\" class=\"headerlink\" title=\"2019的flag\"></a>2019的flag</h2><p>&emsp;&emsp;2019，生活似乎能好起来一些。立一些计划和flag吧。外包性质的工作最多干一年，明年想冲击一下15w的年薪，找一份自己平台的工作吧。<br>&emsp;&emsp;今年的大体规划：</p>\n<ol>\n<li>博文一周至少更新一篇，打算开三个系列，源码阅读，读书笔记，前端一些工作学习的总结。</li>\n<li>慕课网上面的React源码和前端算法的课程刷刷完，下半年去攻克一下LeetCode，然后明年过年之后，就开始刷面试题了，争取能找到自己平台的工作。</li>\n<li>今年重点学习一下设计模式，Canvas和SEO。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"2019-新的开始\"><a href=\"#2019-新的开始\" class=\"headerlink\" title=\"2019,新的开始\"></a>2019,新的开始</h1>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>&emsp;&emsp;今天终于把立了快半年flag的博客给搭建出来了，hexo方案还是很成熟的，比我之前从0开始写一个要优秀的多。<br>想想一时冲动从物流转向前端，已经过去一年了。在去年的拼命的绝望，感慨命运的不公，到今年的满足和规划，点点滴滴，想要总结回顾在这里。</p>\n<h2 id=\"从物流到前端\"><a href=\"#从物流到前端\" class=\"headerlink\" title=\"从物流到前端\"></a>从物流到前端</h2><p>&emsp;&emsp;<strong>选择大于努力</strong>，是在物流工作两年之后体会到真理。当我骄傲的顶着前十的校招成绩，完美的完成领导各项繁重的任务，绩效S和A拿不停的时候，我天真的以为真的能依靠自己的努力，换取升职加薪，收获属于自己的一份职场硕果的时候，绝望来的太快了。<br>&emsp;&emsp;平均学历大专以下的低素质中层管理，带着浓浓痞子气，和你称兄道弟许你前途，转头就是捅你一刀。<br>&emsp;&emsp;我看到连Excel都做不好的漂亮核算年度绩效轻松上S，办公室指导型的仓管和领导夜夜笙歌，快速升职加薪。我靠着拼命和服从，换取的一年升职为主管，人家半年请领导吃饭就可以了。<br>&emsp;&emsp;当双十一的我，连续三四天通宵干活，住瓦板房，配送干完干仓管，换来的只是这波忙完后去下一波忙的地方的时候，我就知道，是时候和这个行业说拜拜了。<br>我想我的博客并没有多少人去观看，但是如果物流专业的同学看到我这篇文章，奉劝你一句话，离开这个配不上你努力的行业，去提升效率更高的地方吧。</p>\n<h2 id=\"2018年的曲折和绝望\"><a href=\"#2018年的曲折和绝望\" class=\"headerlink\" title=\"2018年的曲折和绝望\"></a>2018年的曲折和绝望</h2><p>&emsp;&emsp;选择前端真的是一个偶然，毕竟一年前的这个时候我连Java和JavaScript的区别都分不清。<br>&emsp;&emsp;小学时候记得是用微软的类似excel的工具去做过网页，当时还去市里面拿过奖。当时有个自媒体的同学说和我一起转行学习编程，告诉我前端好学。<br>于是我就上网查询了前端的相关介绍，岗位信息，查询了一下前端的学习路径。当时记得知乎上面有一个千赞的前端学习书籍推荐，趁着双十二，我在当当上面买了<br>200的书本，捧着《Head First》简单的学习了html和css，觉得很简单，编程原来如此好理解，就信心满满的决定转行前端了。<br>&emsp;&emsp;个人感觉学习也其实没有那么难，对我来说卡住最多的就是刚开始长串的英文单词，JS部分难度是上去了，但是认真啃两遍高程，不懂得地方多去网上问问，JS也就过来了。<br>&emsp;&emsp;一个人的学习很闷，不知道自己的真实水平，没有有工作经验的人给予评价，心里很虚。有时候遇到bug和问题，你甚至不知道怎么去网络上面搜索。女朋友还会时不时的和你<br>闹个情绪，生个气。现在想想，不知道当时自己怎么熬下来的。当时那时确实是我这辈子学习最用功的时候。<br>&emsp;&emsp;所幸坚持了下来，感谢那时候的自己，在打下比较坚实基础的同时，也掌握了编程的对应的学习方法，对现在的工作生活帮助很大。<br>&emsp;&emsp;在学习了5个多月开始找工作的时候，家里出事了。我的父亲患了结肠癌，而且还是晚期。本来打算去杭州找工作的我悻悻回到家里，陪父亲的同时，写了个简单的自己网站<br>&emsp;&emsp;开始去找工作，三线的城市，过了几个技术面，也因为没有工作经验的原因，被老板拒绝。当时的生活真的是绝望的，父亲病重，自己什么也做不了，工作也找不到，本来学的感觉还不错的自信也被撕扯的粉碎，每天只能紧紧抓着红皮的高程，一章一章拼了命的去反复看，感觉抓住了一点点的希望。<br>&emsp;&emsp;想过自尽，但是想想父亲，坚持了下来。一星期左右的时候，找到了一份0福利，4000块钱的前端工作。<br>&emsp;&emsp;现在想想，还是应该庆幸这份工作的。虽然公司的福利为0 ，一周6天班，工资少到令人发指，但是好歹愿意接受0经验的我参加实际项目，虽然公司的项目也很烂，但在这里，我完成了微信小程序的学习，完成了后台管理和官网的项目制作，有了项目经验，给今年找工作带来了极大的便利。<br>&emsp;&emsp;在这里，我也见到了最底层的程序员的样子。除了公司项目迫不得已的学习之外，自驱力为0，项目草草写完，复制粘贴冗余代码，毫无逻辑可言。更别说书写代码的时候规范命名，解耦，融入设计模式思想。这些来自职技校或者三本的同学，把编程干出了物流的样子。</p>\n<h2 id=\"生活也该向前看\"><a href=\"#生活也该向前看\" class=\"headerlink\" title=\"生活也该向前看\"></a>生活也该向前看</h2><p>&emsp;&emsp;父亲动完手术恢复后，我也着手寻找我的新工作了。想在回想起来，我遇到的面试，都是怪上加怪。面试我http协议状态码的，面试我浏览器页面渲染优化的，我准备的css，JS面试题，愣是一题也没有用上。找工作的过程还算顺利，四份面试邀请，四份全中。最后选择去了阿里的外包工作。我原来公司的几个同事也纷纷跳槽，出来找工作，都反应工作不好找，但是我感觉，还是蛮轻松的，还是看你要求高低吧。月薪也顺利的翻了快3倍，先踏踏实实做个一年，积累工作经验，也把自己的工资线刷一些上去。</p>\n<h2 id=\"2019的flag\"><a href=\"#2019的flag\" class=\"headerlink\" title=\"2019的flag\"></a>2019的flag</h2><p>&emsp;&emsp;2019，生活似乎能好起来一些。立一些计划和flag吧。外包性质的工作最多干一年，明年想冲击一下15w的年薪，找一份自己平台的工作吧。<br>&emsp;&emsp;今年的大体规划：</p>\n<ol>\n<li>博文一周至少更新一篇，打算开三个系列，源码阅读，读书笔记，前端一些工作学习的总结。</li>\n<li>慕课网上面的React源码和前端算法的课程刷刷完，下半年去攻克一下LeetCode，然后明年过年之后，就开始刷面试题了，争取能找到自己平台的工作。</li>\n<li>今年重点学习一下设计模式，Canvas和SEO。</li>\n</ol>"},{"title":"记一次服务器更换环境配置","date":"2019-11-05T11:00:00.000Z","_content":"&emsp;&emsp;双十一大促，老服务器到期。记一次服务器更换环境配置，用于节省以后的操作搜索时间。机器配置`1核 2GB内存 1Mbps带宽`，操作系统`Ubuntu18.0`。\n<!--more-->\n## 安装nodejs。\n&emsp;&emsp;nodejs是前端服务器生态配置的基础支持，首先安装nodejs & npm，用于服务器的访问运行。\n&emsp;&emsp;使用Ubuntu自带的生态安装工具apt install即可安装nodejs，不需要到官网curl压缩包解压再进行路径配置。\n```bash\nsudo apt update -y\nsudo apt install nodejs\nsudo apt install npm\nsudo npm install npm -g #更新npm\n```\n&emsp;&emsp;接着安装`n`。n是node的一个版本管理工具，可以方便的进行node的版本更新和控制。\n```bash\nsudo npm install n -g\nn 相关指令\nn                              显示已安装的Node版本\nn latest                       安装最新版本Node\nn stable                       安装最新稳定版Node\nn lts                          安装最新长期维护版(lts)Node\nn <version>                    根据提供的版本号安装Node</pre>\n```\n&emsp;&emsp;使用`sudo n`切换版本无效之后尝试修改node的path路径。\n\n```bash\nexport NODE_HOME=/usr/local\nexport PATH=$NODE_HOME/bin:$PATH\nexport NODE_PATH=$NODE_HOME/lib/node_modules:$PATH\n```\n\n## 配置git。\n&emsp;&emsp;配置git以便快速的部署新开发迭代的代码。毕竟平时是不大可能在服务器上面进行前端的开发的。\n&emsp;&emsp;配置git要注意，使用`sudo`加权生成的`ssh-key`所在的秘钥位置和不加生成的位置是不同的。在执行`git`相关命令访问的时候，关联的也不是一个`ssh-key`。\n```bash\nsudo apt-get install git  # 安装git\nssh-keygen -t rsa -C \"your github username\" # 非`sudo`生成配对的ssh秘钥 默认目录在 ~/.ssh/id_rsa.pub 下\nsudo git config ––global user.name \"your github username\"   # 配置全局的用户名\nsudo git config ––global user.email \"your github useremail\"   # 配置email\n```\n&emsp;&emsp;生成的秘钥进入github个人仓库setting到SSH and GPG keys，关联后进行正常的git操作。\n\n## 配置Nginx\n&emsp;&emsp;配置Nginx，完成反向代理。把默认非http网址代理为https访问，把80端口的访问代理为https的443端口访问。\n&emsp;&emsp;内部把443端口的访问代理到自己内部实现的服务器监听的端口上，在服务器端口放开上只需要放开常用的几个端口即可。\n&emsp;&emsp;安装Nginx。默认使用`sudo`安装的时候目录在`/etc/nginx`下。\n```bash\nsudo apt-get install nginx\nsudo nginx -t 测试\nsudo nginx -s reopen：重启Nginx\nsudo nginx -s reload：重新加载Nginx配置文件，然后以优雅的方式重启Nginx\nsudo nginx -s stop：强制停止Nginx服务\nsudo nginx -s quit：优雅地停止Nginx服务（即处理完所有请求后再停止服务）\n```\n相关配置\n```bash\nserver {\n    listen 80; #监听端口，非https默认为80\n    server_name www.tangdingblog.cn; # 访问名称\n    rewrite ^(.*) https://$host$1 permanent; #重定向到https\n    location / {\n       proxy_pass http://122.51.226.110:3000;\n       add_header Access-Control-Allow-Origin localhost;\n    }\n}\n```\n\n## 使用scp进行ssl证书传输配置\n```bash\nscp yourFilePath root@ip:copyedFilePath #传输\nscp root@ip:copyedFilePath yourFilePath #拷贝\n```\n\n\n## 配置pm2\n&emsp;&emsp;使用`npm`安装`pm2`使得mode的服务常驻，不在ssh访问断开连接后关闭。\n```bash\nsudo npm install pm2 -g #全局安装pm2\npm2 start app.js #启动服务\npm2 list # 展示当前启动的服务\npm2 kill # 杀掉进程\n```\n\n## 安装MongoDB\n&emsp;&emsp;数据库使用mongodb，安装完毕后会自动启动。[官方安装文档](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)。\n```bash\nsudo apt-get install mongodb\n```","source":"_posts/others/reinstall.md","raw":"---\ntitle: 记一次服务器更换环境配置\ndate: 2019/11/5 19:00:00\ncategories:\n- [Ubuntu]\ntags:\n- 环境配置\n---\n&emsp;&emsp;双十一大促，老服务器到期。记一次服务器更换环境配置，用于节省以后的操作搜索时间。机器配置`1核 2GB内存 1Mbps带宽`，操作系统`Ubuntu18.0`。\n<!--more-->\n## 安装nodejs。\n&emsp;&emsp;nodejs是前端服务器生态配置的基础支持，首先安装nodejs & npm，用于服务器的访问运行。\n&emsp;&emsp;使用Ubuntu自带的生态安装工具apt install即可安装nodejs，不需要到官网curl压缩包解压再进行路径配置。\n```bash\nsudo apt update -y\nsudo apt install nodejs\nsudo apt install npm\nsudo npm install npm -g #更新npm\n```\n&emsp;&emsp;接着安装`n`。n是node的一个版本管理工具，可以方便的进行node的版本更新和控制。\n```bash\nsudo npm install n -g\nn 相关指令\nn                              显示已安装的Node版本\nn latest                       安装最新版本Node\nn stable                       安装最新稳定版Node\nn lts                          安装最新长期维护版(lts)Node\nn <version>                    根据提供的版本号安装Node</pre>\n```\n&emsp;&emsp;使用`sudo n`切换版本无效之后尝试修改node的path路径。\n\n```bash\nexport NODE_HOME=/usr/local\nexport PATH=$NODE_HOME/bin:$PATH\nexport NODE_PATH=$NODE_HOME/lib/node_modules:$PATH\n```\n\n## 配置git。\n&emsp;&emsp;配置git以便快速的部署新开发迭代的代码。毕竟平时是不大可能在服务器上面进行前端的开发的。\n&emsp;&emsp;配置git要注意，使用`sudo`加权生成的`ssh-key`所在的秘钥位置和不加生成的位置是不同的。在执行`git`相关命令访问的时候，关联的也不是一个`ssh-key`。\n```bash\nsudo apt-get install git  # 安装git\nssh-keygen -t rsa -C \"your github username\" # 非`sudo`生成配对的ssh秘钥 默认目录在 ~/.ssh/id_rsa.pub 下\nsudo git config ––global user.name \"your github username\"   # 配置全局的用户名\nsudo git config ––global user.email \"your github useremail\"   # 配置email\n```\n&emsp;&emsp;生成的秘钥进入github个人仓库setting到SSH and GPG keys，关联后进行正常的git操作。\n\n## 配置Nginx\n&emsp;&emsp;配置Nginx，完成反向代理。把默认非http网址代理为https访问，把80端口的访问代理为https的443端口访问。\n&emsp;&emsp;内部把443端口的访问代理到自己内部实现的服务器监听的端口上，在服务器端口放开上只需要放开常用的几个端口即可。\n&emsp;&emsp;安装Nginx。默认使用`sudo`安装的时候目录在`/etc/nginx`下。\n```bash\nsudo apt-get install nginx\nsudo nginx -t 测试\nsudo nginx -s reopen：重启Nginx\nsudo nginx -s reload：重新加载Nginx配置文件，然后以优雅的方式重启Nginx\nsudo nginx -s stop：强制停止Nginx服务\nsudo nginx -s quit：优雅地停止Nginx服务（即处理完所有请求后再停止服务）\n```\n相关配置\n```bash\nserver {\n    listen 80; #监听端口，非https默认为80\n    server_name www.tangdingblog.cn; # 访问名称\n    rewrite ^(.*) https://$host$1 permanent; #重定向到https\n    location / {\n       proxy_pass http://122.51.226.110:3000;\n       add_header Access-Control-Allow-Origin localhost;\n    }\n}\n```\n\n## 使用scp进行ssl证书传输配置\n```bash\nscp yourFilePath root@ip:copyedFilePath #传输\nscp root@ip:copyedFilePath yourFilePath #拷贝\n```\n\n\n## 配置pm2\n&emsp;&emsp;使用`npm`安装`pm2`使得mode的服务常驻，不在ssh访问断开连接后关闭。\n```bash\nsudo npm install pm2 -g #全局安装pm2\npm2 start app.js #启动服务\npm2 list # 展示当前启动的服务\npm2 kill # 杀掉进程\n```\n\n## 安装MongoDB\n&emsp;&emsp;数据库使用mongodb，安装完毕后会自动启动。[官方安装文档](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)。\n```bash\nsudo apt-get install mongodb\n```","slug":"others/reinstall","published":1,"updated":"2020-06-11T01:43:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxq00169r2v883kniit","content":"<p>&emsp;&emsp;双十一大促，老服务器到期。记一次服务器更换环境配置，用于节省以后的操作搜索时间。机器配置<code>1核 2GB内存 1Mbps带宽</code>，操作系统<code>Ubuntu18.0</code>。<br><a id=\"more\"></a></p>\n<h2 id=\"安装nodejs。\"><a href=\"#安装nodejs。\" class=\"headerlink\" title=\"安装nodejs。\"></a>安装nodejs。</h2><p>&emsp;&emsp;nodejs是前端服务器生态配置的基础支持，首先安装nodejs &amp; npm，用于服务器的访问运行。<br>&emsp;&emsp;使用Ubuntu自带的生态安装工具apt install即可安装nodejs，不需要到官网curl压缩包解压再进行路径配置。<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update -y</span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm</span><br><span class=\"line\">sudo npm install npm -g <span class=\"hljs-comment\">#更新npm</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;接着安装<code>n</code>。n是node的一个版本管理工具，可以方便的进行node的版本更新和控制。<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install n -g</span><br><span class=\"line\">n 相关指令</span><br><span class=\"line\">n                              显示已安装的Node版本</span><br><span class=\"line\">n latest                       安装最新版本Node</span><br><span class=\"line\">n stable                       安装最新稳定版Node</span><br><span class=\"line\">n lts                          安装最新长期维护版(lts)Node</span><br><span class=\"line\">n &lt;version&gt;                    根据提供的版本号安装Node&lt;/pre&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;使用<code>sudo n</code>切换版本无效之后尝试修改node的path路径。</p>\n<figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">export</span> NODE_HOME=/usr/<span class=\"hljs-built_in\">local</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$NODE_HOME</span>/bin:<span class=\"hljs-variable\">$PATH</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">export</span> NODE_PATH=<span class=\"hljs-variable\">$NODE_HOME</span>/lib/node_modules:<span class=\"hljs-variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置git。\"><a href=\"#配置git。\" class=\"headerlink\" title=\"配置git。\"></a>配置git。</h2><p>&emsp;&emsp;配置git以便快速的部署新开发迭代的代码。毕竟平时是不大可能在服务器上面进行前端的开发的。<br>&emsp;&emsp;配置git要注意，使用<code>sudo</code>加权生成的<code>ssh-key</code>所在的秘钥位置和不加生成的位置是不同的。在执行<code>git</code>相关命令访问的时候，关联的也不是一个<code>ssh-key</code>。<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git  <span class=\"hljs-comment\"># 安装git</span></span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"hljs-string\">\"your github username\"</span> <span class=\"hljs-comment\"># 非`sudo`生成配对的ssh秘钥 默认目录在 ~/.ssh/id_rsa.pub 下</span></span><br><span class=\"line\">sudo git config ––global user.name <span class=\"hljs-string\">\"your github username\"</span>   <span class=\"hljs-comment\"># 配置全局的用户名</span></span><br><span class=\"line\">sudo git config ––global user.email <span class=\"hljs-string\">\"your github useremail\"</span>   <span class=\"hljs-comment\"># 配置email</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;生成的秘钥进入github个人仓库setting到SSH and GPG keys，关联后进行正常的git操作。</p>\n<h2 id=\"配置Nginx\"><a href=\"#配置Nginx\" class=\"headerlink\" title=\"配置Nginx\"></a>配置Nginx</h2><p>&emsp;&emsp;配置Nginx，完成反向代理。把默认非http网址代理为https访问，把80端口的访问代理为https的443端口访问。<br>&emsp;&emsp;内部把443端口的访问代理到自己内部实现的服务器监听的端口上，在服务器端口放开上只需要放开常用的几个端口即可。<br>&emsp;&emsp;安装Nginx。默认使用<code>sudo</code>安装的时候目录在<code>/etc/nginx</code>下。<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nginx</span><br><span class=\"line\">sudo nginx -t 测试</span><br><span class=\"line\">sudo nginx -s reopen：重启Nginx</span><br><span class=\"line\">sudo nginx -s reload：重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><span class=\"line\">sudo nginx -s stop：强制停止Nginx服务</span><br><span class=\"line\">sudo nginx -s quit：优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br></pre></td></tr></table></figure></p>\n<p>相关配置<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80; <span class=\"hljs-comment\">#监听端口，非https默认为80</span></span><br><span class=\"line\">    server_name www.tangdingblog.cn; <span class=\"hljs-comment\"># 访问名称</span></span><br><span class=\"line\">    rewrite ^(.*) https://<span class=\"hljs-variable\">$host</span><span class=\"hljs-variable\">$1</span> permanent; <span class=\"hljs-comment\">#重定向到https</span></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">       proxy_pass http://122.51.226.110:3000;</span><br><span class=\"line\">       add_header Access-Control-Allow-Origin localhost;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用scp进行ssl证书传输配置\"><a href=\"#使用scp进行ssl证书传输配置\" class=\"headerlink\" title=\"使用scp进行ssl证书传输配置\"></a>使用scp进行ssl证书传输配置</h2><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp yourFilePath root@ip:copyedFilePath <span class=\"hljs-comment\">#传输</span></span><br><span class=\"line\">scp root@ip:copyedFilePath yourFilePath <span class=\"hljs-comment\">#拷贝</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置pm2\"><a href=\"#配置pm2\" class=\"headerlink\" title=\"配置pm2\"></a>配置pm2</h2><p>&emsp;&emsp;使用<code>npm</code>安装<code>pm2</code>使得mode的服务常驻，不在ssh访问断开连接后关闭。<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install pm2 -g <span class=\"hljs-comment\">#全局安装pm2</span></span><br><span class=\"line\">pm2 start app.js <span class=\"hljs-comment\">#启动服务</span></span><br><span class=\"line\">pm2 list <span class=\"hljs-comment\"># 展示当前启动的服务</span></span><br><span class=\"line\">pm2 <span class=\"hljs-built_in\">kill</span> <span class=\"hljs-comment\"># 杀掉进程</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装MongoDB\"><a href=\"#安装MongoDB\" class=\"headerlink\" title=\"安装MongoDB\"></a>安装MongoDB</h2><p>&emsp;&emsp;数据库使用mongodb，安装完毕后会自动启动。<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\" target=\"_blank\" rel=\"noopener\">官方安装文档</a>。<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mongodb</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;双十一大促，老服务器到期。记一次服务器更换环境配置，用于节省以后的操作搜索时间。机器配置<code>1核 2GB内存 1Mbps带宽</code>，操作系统<code>Ubuntu18.0</code>。<br></p>","more":"</p>\n<h2 id=\"安装nodejs。\"><a href=\"#安装nodejs。\" class=\"headerlink\" title=\"安装nodejs。\"></a>安装nodejs。</h2><p>&emsp;&emsp;nodejs是前端服务器生态配置的基础支持，首先安装nodejs &amp; npm，用于服务器的访问运行。<br>&emsp;&emsp;使用Ubuntu自带的生态安装工具apt install即可安装nodejs，不需要到官网curl压缩包解压再进行路径配置。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update -y</span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm</span><br><span class=\"line\">sudo npm install npm -g <span class=\"comment\">#更新npm</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;接着安装<code>n</code>。n是node的一个版本管理工具，可以方便的进行node的版本更新和控制。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install n -g</span><br><span class=\"line\">n 相关指令</span><br><span class=\"line\">n                              显示已安装的Node版本</span><br><span class=\"line\">n latest                       安装最新版本Node</span><br><span class=\"line\">n stable                       安装最新稳定版Node</span><br><span class=\"line\">n lts                          安装最新长期维护版(lts)Node</span><br><span class=\"line\">n &lt;version&gt;                    根据提供的版本号安装Node&lt;/pre&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;使用<code>sudo n</code>切换版本无效之后尝试修改node的path路径。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NODE_HOME=/usr/<span class=\"built_in\">local</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$NODE_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> NODE_PATH=<span class=\"variable\">$NODE_HOME</span>/lib/node_modules:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置git。\"><a href=\"#配置git。\" class=\"headerlink\" title=\"配置git。\"></a>配置git。</h2><p>&emsp;&emsp;配置git以便快速的部署新开发迭代的代码。毕竟平时是不大可能在服务器上面进行前端的开发的。<br>&emsp;&emsp;配置git要注意，使用<code>sudo</code>加权生成的<code>ssh-key</code>所在的秘钥位置和不加生成的位置是不同的。在执行<code>git</code>相关命令访问的时候，关联的也不是一个<code>ssh-key</code>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git  <span class=\"comment\"># 安装git</span></span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"your github username\"</span> <span class=\"comment\"># 非`sudo`生成配对的ssh秘钥 默认目录在 ~/.ssh/id_rsa.pub 下</span></span><br><span class=\"line\">sudo git config ––global user.name <span class=\"string\">\"your github username\"</span>   <span class=\"comment\"># 配置全局的用户名</span></span><br><span class=\"line\">sudo git config ––global user.email <span class=\"string\">\"your github useremail\"</span>   <span class=\"comment\"># 配置email</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;生成的秘钥进入github个人仓库setting到SSH and GPG keys，关联后进行正常的git操作。</p>\n<h2 id=\"配置Nginx\"><a href=\"#配置Nginx\" class=\"headerlink\" title=\"配置Nginx\"></a>配置Nginx</h2><p>&emsp;&emsp;配置Nginx，完成反向代理。把默认非http网址代理为https访问，把80端口的访问代理为https的443端口访问。<br>&emsp;&emsp;内部把443端口的访问代理到自己内部实现的服务器监听的端口上，在服务器端口放开上只需要放开常用的几个端口即可。<br>&emsp;&emsp;安装Nginx。默认使用<code>sudo</code>安装的时候目录在<code>/etc/nginx</code>下。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nginx</span><br><span class=\"line\">sudo nginx -t 测试</span><br><span class=\"line\">sudo nginx -s reopen：重启Nginx</span><br><span class=\"line\">sudo nginx -s reload：重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><span class=\"line\">sudo nginx -s stop：强制停止Nginx服务</span><br><span class=\"line\">sudo nginx -s quit：优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br></pre></td></tr></table></figure></p>\n<p>相关配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80; <span class=\"comment\">#监听端口，非https默认为80</span></span><br><span class=\"line\">    server_name www.tangdingblog.cn; <span class=\"comment\"># 访问名称</span></span><br><span class=\"line\">    rewrite ^(.*) https://<span class=\"variable\">$host</span><span class=\"variable\">$1</span> permanent; <span class=\"comment\">#重定向到https</span></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">       proxy_pass http://122.51.226.110:3000;</span><br><span class=\"line\">       add_header Access-Control-Allow-Origin localhost;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用scp进行ssl证书传输配置\"><a href=\"#使用scp进行ssl证书传输配置\" class=\"headerlink\" title=\"使用scp进行ssl证书传输配置\"></a>使用scp进行ssl证书传输配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp yourFilePath root@ip:copyedFilePath <span class=\"comment\">#传输</span></span><br><span class=\"line\">scp root@ip:copyedFilePath yourFilePath <span class=\"comment\">#拷贝</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置pm2\"><a href=\"#配置pm2\" class=\"headerlink\" title=\"配置pm2\"></a>配置pm2</h2><p>&emsp;&emsp;使用<code>npm</code>安装<code>pm2</code>使得mode的服务常驻，不在ssh访问断开连接后关闭。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install pm2 -g <span class=\"comment\">#全局安装pm2</span></span><br><span class=\"line\">pm2 start app.js <span class=\"comment\">#启动服务</span></span><br><span class=\"line\">pm2 list <span class=\"comment\"># 展示当前启动的服务</span></span><br><span class=\"line\">pm2 <span class=\"built_in\">kill</span> <span class=\"comment\"># 杀掉进程</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装MongoDB\"><a href=\"#安装MongoDB\" class=\"headerlink\" title=\"安装MongoDB\"></a>安装MongoDB</h2><p>&emsp;&emsp;数据库使用mongodb，安装完毕后会自动启动。<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\" target=\"_blank\" rel=\"noopener\">官方安装文档</a>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mongodb</span><br></pre></td></tr></table></figure></p>"},{"title":"Hello Hexo","date":"2019-03-24T11:00:00.000Z","_content":"\n使用hexo搭建博客的测试文章，测试常用markdown，链接配置，注释一些默认的页面信息。\n<!--more-->\n\n# 标题测试h1\n## 标题测试h2\n### 标题测试h3\n---\n## 下面来一些列表测试\n无序列表\n- 无序1\n- 无序2\n有序列表\n1. 有序列表1\n2. 有序列表2\n---\n## 来个引用测试吧\n图片的引用也会居中显示\n![图片](/blog/public/imgs/1.png)\n[链接效果达到预期，返回主站](https://www.tangdingblog.cn)\n[来个锚点跳转，跳转底部](#bottom)\n> 事实上文字引用会居中，没有达到预期\n---\n## 接下来表格测试\n\nheader 1 | header 2\n---|---\nrow 1 col 1 | row 1 col 2\nrow 2 col 1 | row 2 col 2\n\n表格的效果比预期的要好很多\n\n---\n## code test\n``` javascript\nclass Test extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n}\n// 效果相当的好\n```\n\n---\n## 样式测试\n==mark==\n**加粗**\n*倾斜*\n++下划线++\n~~中划线~~\n- [ ] checkbox\n- [x] checkedbox\n\n\n<span id=\"bottom\">底部</span>","source":"_posts/others/hello-world.md","raw":"---\ntitle: Hello Hexo\ndate: 2019/3/24 19:00\ncategories:\n# - [前端, 源码阅读, JavaScript]\ntags:\n# - ps3\n---\n\n使用hexo搭建博客的测试文章，测试常用markdown，链接配置，注释一些默认的页面信息。\n<!--more-->\n\n# 标题测试h1\n## 标题测试h2\n### 标题测试h3\n---\n## 下面来一些列表测试\n无序列表\n- 无序1\n- 无序2\n有序列表\n1. 有序列表1\n2. 有序列表2\n---\n## 来个引用测试吧\n图片的引用也会居中显示\n![图片](/blog/public/imgs/1.png)\n[链接效果达到预期，返回主站](https://www.tangdingblog.cn)\n[来个锚点跳转，跳转底部](#bottom)\n> 事实上文字引用会居中，没有达到预期\n---\n## 接下来表格测试\n\nheader 1 | header 2\n---|---\nrow 1 col 1 | row 1 col 2\nrow 2 col 1 | row 2 col 2\n\n表格的效果比预期的要好很多\n\n---\n## code test\n``` javascript\nclass Test extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n}\n// 效果相当的好\n```\n\n---\n## 样式测试\n==mark==\n**加粗**\n*倾斜*\n++下划线++\n~~中划线~~\n- [ ] checkbox\n- [x] checkedbox\n\n\n<span id=\"bottom\">底部</span>","slug":"others/hello-world","published":1,"updated":"2020-06-11T01:43:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxr00199r2vw1kfbbz8","content":"<p>使用hexo搭建博客的测试文章，测试常用markdown，链接配置，注释一些默认的页面信息。<br><a id=\"more\"></a></p>\n<h1 id=\"标题测试h1\"><a href=\"#标题测试h1\" class=\"headerlink\" title=\"标题测试h1\"></a>标题测试h1</h1><h2 id=\"标题测试h2\"><a href=\"#标题测试h2\" class=\"headerlink\" title=\"标题测试h2\"></a>标题测试h2</h2><h3 id=\"标题测试h3\"><a href=\"#标题测试h3\" class=\"headerlink\" title=\"标题测试h3\"></a>标题测试h3</h3><hr>\n<h2 id=\"下面来一些列表测试\"><a href=\"#下面来一些列表测试\" class=\"headerlink\" title=\"下面来一些列表测试\"></a>下面来一些列表测试</h2><p>无序列表</p>\n<ul>\n<li>无序1</li>\n<li>无序2<br>有序列表</li>\n</ul>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<hr>\n<h2 id=\"来个引用测试吧\"><a href=\"#来个引用测试吧\" class=\"headerlink\" title=\"来个引用测试吧\"></a>来个引用测试吧</h2><p>图片的引用也会居中显示<br><img src=\"/blog/public/imgs/1.png\" alt=\"图片\"><br><a href=\"https://www.tangdingblog.cn\">链接效果达到预期，返回主站</a><br><a href=\"#bottom\">来个锚点跳转，跳转底部</a></p>\n<blockquote>\n<p>事实上文字引用会居中，没有达到预期</p>\n</blockquote>\n<hr>\n<h2 id=\"接下来表格测试\"><a href=\"#接下来表格测试\" class=\"headerlink\" title=\"接下来表格测试\"></a>接下来表格测试</h2><table>\n<thead>\n<tr>\n<th>header 1</th>\n<th>header 2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>row 1 col 1</td>\n<td>row 1 col 2</td>\n</tr>\n<tr>\n<td>row 2 col 1</td>\n<td>row 2 col 2</td>\n</tr>\n</tbody>\n</table>\n<p>表格的效果比预期的要好很多</p>\n<hr>\n<h2 id=\"code-test\"><a href=\"#code-test\" class=\"headerlink\" title=\"code test\"></a>code test</h2><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">super</span>(props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 效果相当的好</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"样式测试\"><a href=\"#样式测试\" class=\"headerlink\" title=\"样式测试\"></a>样式测试</h2><p>==mark==<br><strong>加粗</strong><br><em>倾斜</em><br>++下划线++<br><del>中划线</del></p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> checkbox</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> checkedbox</li>\n</ul>\n<p><span id=\"bottom\">底部</span></p>\n","site":{"data":{}},"excerpt":"<p>使用hexo搭建博客的测试文章，测试常用markdown，链接配置，注释一些默认的页面信息。<br></p>","more":"</p>\n<h1 id=\"标题测试h1\"><a href=\"#标题测试h1\" class=\"headerlink\" title=\"标题测试h1\"></a>标题测试h1</h1><h2 id=\"标题测试h2\"><a href=\"#标题测试h2\" class=\"headerlink\" title=\"标题测试h2\"></a>标题测试h2</h2><h3 id=\"标题测试h3\"><a href=\"#标题测试h3\" class=\"headerlink\" title=\"标题测试h3\"></a>标题测试h3</h3><hr>\n<h2 id=\"下面来一些列表测试\"><a href=\"#下面来一些列表测试\" class=\"headerlink\" title=\"下面来一些列表测试\"></a>下面来一些列表测试</h2><p>无序列表</p>\n<ul>\n<li>无序1</li>\n<li>无序2<br>有序列表</li>\n</ul>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n<hr>\n<h2 id=\"来个引用测试吧\"><a href=\"#来个引用测试吧\" class=\"headerlink\" title=\"来个引用测试吧\"></a>来个引用测试吧</h2><p>图片的引用也会居中显示<br><img src=\"/blog/public/imgs/1.png\" alt=\"图片\"><br><a href=\"https://www.tangdingblog.cn\">链接效果达到预期，返回主站</a><br><a href=\"#bottom\">来个锚点跳转，跳转底部</a></p>\n<blockquote>\n<p>事实上文字引用会居中，没有达到预期</p>\n</blockquote>\n<hr>\n<h2 id=\"接下来表格测试\"><a href=\"#接下来表格测试\" class=\"headerlink\" title=\"接下来表格测试\"></a>接下来表格测试</h2><table>\n<thead>\n<tr>\n<th>header 1</th>\n<th>header 2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>row 1 col 1</td>\n<td>row 1 col 2</td>\n</tr>\n<tr>\n<td>row 2 col 1</td>\n<td>row 2 col 2</td>\n</tr>\n</tbody>\n</table>\n<p>表格的效果比预期的要好很多</p>\n<hr>\n<h2 id=\"code-test\"><a href=\"#code-test\" class=\"headerlink\" title=\"code test\"></a>code test</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 效果相当的好</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"样式测试\"><a href=\"#样式测试\" class=\"headerlink\" title=\"样式测试\"></a>样式测试</h2><p>==mark==<br><strong>加粗</strong><br><em>倾斜</em><br>++下划线++<br><del>中划线</del></p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> checkbox</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> checkedbox</li>\n</ul>\n<p><span id=\"bottom\">底部</span></p>"},{"title":"Git实践整理","date":"2019-06-01T06:25:00.000Z","_content":"&emsp;&emsp;都2019-6-1了，不要再说你只会 add commit push 和 pull 了。\n<!--more-->\n# 前言\n&emsp;&emsp;Git是一个我们最常使用用代码管理工具，它的命令操作快速而又优雅，分支开发特性形成的独特git工作流模式也非常符合实际工作开发需求。这篇文章用于整理汇总我在实际工作过程中遇到的分支操作处理情况。\n\n&emsp;&emsp;整理前汇总几个概念：\n\n1. hash算法\n&emsp;&emsp;hash算法是一个开源的文件加密算法，它的特性在于不管多大文件的输入，文件在**没有变动**的情况下，总是得到相同的输出。而文件只要变动一点，它得出的hash值就完全不同。hash 算法具有不可逆性。Git 当中使用 hash 算法作为 git 的 文件变动commit成的快照的版本标识。\n\n2. git的**分支**和 **commit** 的操作实质上是对**文件快照(snapshot)**的处理\n&emsp;&emsp;我们在工作区的 add&commit 操作，本质上是保存了当前文件的一组快照。我们所做的分支切换改变工作区内容，本质上是移动本地的HEAD指针指向快照的位置，从而复现不同的工作区内容。\n![git三区交互](/blog/public/imgs/git-snapshot.png)\n\n3. 本地与远程 HEAD 和 origin\n&emsp;&emsp;前文提过，分支的本地移动，实质上是移动 git 文件当中的 HEAD 指针指向文件的快照。所以HEAD所代表的的就是本地的**当前操作的分支**。我们经常操作过程中提到的 origin 实际上是本地 git 文件**关联**的远程仓库的昵称。origin是你在关联远程仓库时候没有起名字时git默认的名称。因此再使用 git fetch origin/master 意思就是拉取 git 关联的名为 origin 远程仓库下面的master分支到本地。可以使用git remote来查看本地所关联的远程仓库别名。\n\n# 穿梭在 git 时空，reset 的妙用\n&emsp;&emsp;`git reset reset方式参数 log-hash值`，可以归置文件到对用的 commit 历史处。对应的 hash 值可以使用`git log`获得。\n`git reset` 拥有三个参数 `--hard --soft --mixed`，他们分别代表了reset的三种模式。\n- `--hard` 重置index和working tree\n- `--soft` 不会触碰working tree(工作区)和暂存区(index),（即不会改变文件内容），只是移动指针\n- `--mixed` 重置暂存区，不会触碰过工作区\n\n利用`--soft`不会改变当前工作区文件的特性，当你当前分支开发的 commit 太多想要删除一些commit的时候，可以使用soft重置到想要删除的commit之前，再使用 `git add & git commit` 来规整 commit 历史。\n&emsp;&emsp;比如这里我输入一下 git log，发现工作分支残留的 commit 太多：\n```bash\ncommit 7a3e18e3e4ac6a8b3f95fe8c073cf6cc0fcc9d1b\nAuthor: tangding12 <568783010@qq.com>\nDate:   Sun May 12 22:07:50 2019 +0800\n\n    change img\n\ncommit 31cef3d7f850c3f3cf21d3ae4357f1dee3d145bb\nAuthor: tangding12 <568783010@qq.com>\nDate:   Sun May 12 21:58:36 2019 +0800\n\n    add github url\n\ncommit da004222bddb1a99f9ed0e02c70b2173ad85149e\nAuthor: tangding12 <568783010@qq.com>\nDate:   Sun May 12 21:55:47 2019 +0800\n\n    start new chap of sicp\n\ncommit c6c29f8f825d24c4d1a9de0b72c56295022239ab\nAuthor: tangding12 <568783010@qq.com>\n```\n&emsp;&emsp;上面的commit中 `add github url change img` 这两个小的commit改动，我不想残留，我就直接 `git reset --soft c6c29f8f825d24c4d1a9de0b72c56295022239ab`跳转到 start new chap of sicp 这个 commit 上面，然后使用 `git add & git commit`。这样我就能在保留当前文件变化的同时删除掉不要的一些微小的commit，以便影响我后续的操作。\n\n\n# 重命名远程分支本质是删除远程分支再重新推送\n&emsp;&emsp;远程分支没有重命名操作，只有本地分支才能使用 `git branch -m oldBranchName newBranchName` 来重命名分支。远程分支重命名本质是使用 `git push origin :oldBranchName` 删除你需要重命名的分支，然后在使用 `git push --set-upstream` 推送一个新的分支名到远程仓库。\n\n# 优雅的合入分支，用 rebase 来代替 merge\n&emsp;&emsp;首先明确，分支的合入操作，永远是合入到当前所在的分支(HEAD)。因此再处理时候冲突时候，HEAD标识的永远是当前分支的内容，指定合入的分支永远是传入的内容。\n&emsp;&emsp;使用 `git merge` 操作的时候，git 会帮你当前所在分支自动创建一个快照文件并用以提交。\n\n![git merge iss53](/blog/public/imgs/git-merg.png)\n\n&emsp;&emsp;如图，当我在master分支的时候使用git merge iss53，git会帮我合入分支并自动自动创建一个到c2的文件快照。此时不难发现一个问题，那就是在iss53上面的提交commit 和 master 上面的log，就像两条平行线一样毫不相关。如果把iss53上面的所有git log能够同步到master分支上面，使得**合入分支的 git log **能够完整的记录和呈现，不是更全面更优雅吗？\n\n&emsp;&emsp;使用 `git rebase` 可以保证提交历史的整洁。——例如贡献代码时，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n&emsp;&emsp;简单来说 merge 和 rebase 最终的结果相同，唯一不同的就是分支合并的处理方式以及当前分支的 git log。温馨提示，git rebase完毕提交的时候，如果是你单人开发的场景，记得使用`git push -f`哦,千万不要照常在push前习惯性的 `git pull` 一下，这是我血与泪的教训。\n\n# 危险的pull，保险的fetch\n&emsp;&emsp;众所周知，`git pull = git fetch + git merge`，虽然git pull自动帮你合入当前分支的线上最新代码是一件非常畅快的事情，但是在实际开发过程当中是非常危险的。\n\n```bash\nmaster\ndevelop\n    |\n    ------ 你所在的分支\n    ------ 你的队友\n```\n&emsp;&emsp;实际开发过程当中，大多数是遵循git工作流的哲学(如上示意)。有一个维稳的 develope 分支来并行 master，而我们自己功能的开发分支均是基于 develope。经常你的队友完成一些**通用模块开发后**，会**先于你合入 develop 分支**。这种情况下你经常需要 merge 或者 rebase 一下最新的 develop 分支。此时如果你使用 git pull 操作去拉取最新的分支，很容易会让线上的分支代码与你新的通用模块产生一大堆冲突。最稳定的方法还是使用 `git fetch 分支` 的操作， 在浏览完代码没有问题之后再手动 merge/rebase 合入。","source":"_posts/others/git-1.md","raw":"---\ntitle: Git实践整理\ndate: 2019/6/1 14:25\ncategories:\n- [git]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;都2019-6-1了，不要再说你只会 add commit push 和 pull 了。\n<!--more-->\n# 前言\n&emsp;&emsp;Git是一个我们最常使用用代码管理工具，它的命令操作快速而又优雅，分支开发特性形成的独特git工作流模式也非常符合实际工作开发需求。这篇文章用于整理汇总我在实际工作过程中遇到的分支操作处理情况。\n\n&emsp;&emsp;整理前汇总几个概念：\n\n1. hash算法\n&emsp;&emsp;hash算法是一个开源的文件加密算法，它的特性在于不管多大文件的输入，文件在**没有变动**的情况下，总是得到相同的输出。而文件只要变动一点，它得出的hash值就完全不同。hash 算法具有不可逆性。Git 当中使用 hash 算法作为 git 的 文件变动commit成的快照的版本标识。\n\n2. git的**分支**和 **commit** 的操作实质上是对**文件快照(snapshot)**的处理\n&emsp;&emsp;我们在工作区的 add&commit 操作，本质上是保存了当前文件的一组快照。我们所做的分支切换改变工作区内容，本质上是移动本地的HEAD指针指向快照的位置，从而复现不同的工作区内容。\n![git三区交互](/blog/public/imgs/git-snapshot.png)\n\n3. 本地与远程 HEAD 和 origin\n&emsp;&emsp;前文提过，分支的本地移动，实质上是移动 git 文件当中的 HEAD 指针指向文件的快照。所以HEAD所代表的的就是本地的**当前操作的分支**。我们经常操作过程中提到的 origin 实际上是本地 git 文件**关联**的远程仓库的昵称。origin是你在关联远程仓库时候没有起名字时git默认的名称。因此再使用 git fetch origin/master 意思就是拉取 git 关联的名为 origin 远程仓库下面的master分支到本地。可以使用git remote来查看本地所关联的远程仓库别名。\n\n# 穿梭在 git 时空，reset 的妙用\n&emsp;&emsp;`git reset reset方式参数 log-hash值`，可以归置文件到对用的 commit 历史处。对应的 hash 值可以使用`git log`获得。\n`git reset` 拥有三个参数 `--hard --soft --mixed`，他们分别代表了reset的三种模式。\n- `--hard` 重置index和working tree\n- `--soft` 不会触碰working tree(工作区)和暂存区(index),（即不会改变文件内容），只是移动指针\n- `--mixed` 重置暂存区，不会触碰过工作区\n\n利用`--soft`不会改变当前工作区文件的特性，当你当前分支开发的 commit 太多想要删除一些commit的时候，可以使用soft重置到想要删除的commit之前，再使用 `git add & git commit` 来规整 commit 历史。\n&emsp;&emsp;比如这里我输入一下 git log，发现工作分支残留的 commit 太多：\n```bash\ncommit 7a3e18e3e4ac6a8b3f95fe8c073cf6cc0fcc9d1b\nAuthor: tangding12 <568783010@qq.com>\nDate:   Sun May 12 22:07:50 2019 +0800\n\n    change img\n\ncommit 31cef3d7f850c3f3cf21d3ae4357f1dee3d145bb\nAuthor: tangding12 <568783010@qq.com>\nDate:   Sun May 12 21:58:36 2019 +0800\n\n    add github url\n\ncommit da004222bddb1a99f9ed0e02c70b2173ad85149e\nAuthor: tangding12 <568783010@qq.com>\nDate:   Sun May 12 21:55:47 2019 +0800\n\n    start new chap of sicp\n\ncommit c6c29f8f825d24c4d1a9de0b72c56295022239ab\nAuthor: tangding12 <568783010@qq.com>\n```\n&emsp;&emsp;上面的commit中 `add github url change img` 这两个小的commit改动，我不想残留，我就直接 `git reset --soft c6c29f8f825d24c4d1a9de0b72c56295022239ab`跳转到 start new chap of sicp 这个 commit 上面，然后使用 `git add & git commit`。这样我就能在保留当前文件变化的同时删除掉不要的一些微小的commit，以便影响我后续的操作。\n\n\n# 重命名远程分支本质是删除远程分支再重新推送\n&emsp;&emsp;远程分支没有重命名操作，只有本地分支才能使用 `git branch -m oldBranchName newBranchName` 来重命名分支。远程分支重命名本质是使用 `git push origin :oldBranchName` 删除你需要重命名的分支，然后在使用 `git push --set-upstream` 推送一个新的分支名到远程仓库。\n\n# 优雅的合入分支，用 rebase 来代替 merge\n&emsp;&emsp;首先明确，分支的合入操作，永远是合入到当前所在的分支(HEAD)。因此再处理时候冲突时候，HEAD标识的永远是当前分支的内容，指定合入的分支永远是传入的内容。\n&emsp;&emsp;使用 `git merge` 操作的时候，git 会帮你当前所在分支自动创建一个快照文件并用以提交。\n\n![git merge iss53](/blog/public/imgs/git-merg.png)\n\n&emsp;&emsp;如图，当我在master分支的时候使用git merge iss53，git会帮我合入分支并自动自动创建一个到c2的文件快照。此时不难发现一个问题，那就是在iss53上面的提交commit 和 master 上面的log，就像两条平行线一样毫不相关。如果把iss53上面的所有git log能够同步到master分支上面，使得**合入分支的 git log **能够完整的记录和呈现，不是更全面更优雅吗？\n\n&emsp;&emsp;使用 `git rebase` 可以保证提交历史的整洁。——例如贡献代码时，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n&emsp;&emsp;简单来说 merge 和 rebase 最终的结果相同，唯一不同的就是分支合并的处理方式以及当前分支的 git log。温馨提示，git rebase完毕提交的时候，如果是你单人开发的场景，记得使用`git push -f`哦,千万不要照常在push前习惯性的 `git pull` 一下，这是我血与泪的教训。\n\n# 危险的pull，保险的fetch\n&emsp;&emsp;众所周知，`git pull = git fetch + git merge`，虽然git pull自动帮你合入当前分支的线上最新代码是一件非常畅快的事情，但是在实际开发过程当中是非常危险的。\n\n```bash\nmaster\ndevelop\n    |\n    ------ 你所在的分支\n    ------ 你的队友\n```\n&emsp;&emsp;实际开发过程当中，大多数是遵循git工作流的哲学(如上示意)。有一个维稳的 develope 分支来并行 master，而我们自己功能的开发分支均是基于 develope。经常你的队友完成一些**通用模块开发后**，会**先于你合入 develop 分支**。这种情况下你经常需要 merge 或者 rebase 一下最新的 develop 分支。此时如果你使用 git pull 操作去拉取最新的分支，很容易会让线上的分支代码与你新的通用模块产生一大堆冲突。最稳定的方法还是使用 `git fetch 分支` 的操作， 在浏览完代码没有问题之后再手动 merge/rebase 合入。","slug":"others/git-1","published":1,"updated":"2020-06-11T01:43:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxs001d9r2vf01ek3n9","content":"<p>&emsp;&emsp;都2019-6-1了，不要再说你只会 add commit push 和 pull 了。<br><a id=\"more\"></a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;Git是一个我们最常使用用代码管理工具，它的命令操作快速而又优雅，分支开发特性形成的独特git工作流模式也非常符合实际工作开发需求。这篇文章用于整理汇总我在实际工作过程中遇到的分支操作处理情况。</p>\n<p>&emsp;&emsp;整理前汇总几个概念：</p>\n<ol>\n<li><p>hash算法<br>&emsp;&emsp;hash算法是一个开源的文件加密算法，它的特性在于不管多大文件的输入，文件在<strong>没有变动</strong>的情况下，总是得到相同的输出。而文件只要变动一点，它得出的hash值就完全不同。hash 算法具有不可逆性。Git 当中使用 hash 算法作为 git 的 文件变动commit成的快照的版本标识。</p>\n</li>\n<li><p>git的<strong>分支</strong>和 <strong>commit</strong> 的操作实质上是对<strong>文件快照(snapshot)</strong>的处理<br>&emsp;&emsp;我们在工作区的 add&amp;commit 操作，本质上是保存了当前文件的一组快照。我们所做的分支切换改变工作区内容，本质上是移动本地的HEAD指针指向快照的位置，从而复现不同的工作区内容。<br><img src=\"/blog/public/imgs/git-snapshot.png\" alt=\"git三区交互\"></p>\n</li>\n<li><p>本地与远程 HEAD 和 origin<br>&emsp;&emsp;前文提过，分支的本地移动，实质上是移动 git 文件当中的 HEAD 指针指向文件的快照。所以HEAD所代表的的就是本地的<strong>当前操作的分支</strong>。我们经常操作过程中提到的 origin 实际上是本地 git 文件<strong>关联</strong>的远程仓库的昵称。origin是你在关联远程仓库时候没有起名字时git默认的名称。因此再使用 git fetch origin/master 意思就是拉取 git 关联的名为 origin 远程仓库下面的master分支到本地。可以使用git remote来查看本地所关联的远程仓库别名。</p>\n</li>\n</ol>\n<h1 id=\"穿梭在-git-时空，reset-的妙用\"><a href=\"#穿梭在-git-时空，reset-的妙用\" class=\"headerlink\" title=\"穿梭在 git 时空，reset 的妙用\"></a>穿梭在 git 时空，reset 的妙用</h1><p>&emsp;&emsp;<code>git reset reset方式参数 log-hash值</code>，可以归置文件到对用的 commit 历史处。对应的 hash 值可以使用<code>git log</code>获得。<br><code>git reset</code> 拥有三个参数 <code>--hard --soft --mixed</code>，他们分别代表了reset的三种模式。</p>\n<ul>\n<li><code>--hard</code> 重置index和working tree</li>\n<li><code>--soft</code> 不会触碰working tree(工作区)和暂存区(index),（即不会改变文件内容），只是移动指针</li>\n<li><code>--mixed</code> 重置暂存区，不会触碰过工作区</li>\n</ul>\n<p>利用<code>--soft</code>不会改变当前工作区文件的特性，当你当前分支开发的 commit 太多想要删除一些commit的时候，可以使用soft重置到想要删除的commit之前，再使用 <code>git add &amp; git commit</code> 来规整 commit 历史。<br>&emsp;&emsp;比如这里我输入一下 git log，发现工作分支残留的 commit 太多：<br><figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit 7a3e18e3e4ac6a8b3f95fe8c073cf6cc0fcc9d1b</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br><span class=\"line\">Date:   Sun May 12 22:07:50 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    change img</span><br><span class=\"line\"></span><br><span class=\"line\">commit 31cef3d7f850c3f3cf21d3ae4357f1dee3d145bb</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br><span class=\"line\">Date:   Sun May 12 21:58:36 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add github url</span><br><span class=\"line\"></span><br><span class=\"line\">commit da004222bddb1a99f9ed0e02c70b2173ad85149e</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br><span class=\"line\">Date:   Sun May 12 21:55:47 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    start new chap of sicp</span><br><span class=\"line\"></span><br><span class=\"line\">commit c6c29f8f825d24c4d1a9de0b72c56295022239ab</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;上面的commit中 <code>add github url change img</code> 这两个小的commit改动，我不想残留，我就直接 <code>git reset --soft c6c29f8f825d24c4d1a9de0b72c56295022239ab</code>跳转到 start new chap of sicp 这个 commit 上面，然后使用 <code>git add &amp; git commit</code>。这样我就能在保留当前文件变化的同时删除掉不要的一些微小的commit，以便影响我后续的操作。</p>\n<h1 id=\"重命名远程分支本质是删除远程分支再重新推送\"><a href=\"#重命名远程分支本质是删除远程分支再重新推送\" class=\"headerlink\" title=\"重命名远程分支本质是删除远程分支再重新推送\"></a>重命名远程分支本质是删除远程分支再重新推送</h1><p>&emsp;&emsp;远程分支没有重命名操作，只有本地分支才能使用 <code>git branch -m oldBranchName newBranchName</code> 来重命名分支。远程分支重命名本质是使用 <code>git push origin :oldBranchName</code> 删除你需要重命名的分支，然后在使用 <code>git push --set-upstream</code> 推送一个新的分支名到远程仓库。</p>\n<h1 id=\"优雅的合入分支，用-rebase-来代替-merge\"><a href=\"#优雅的合入分支，用-rebase-来代替-merge\" class=\"headerlink\" title=\"优雅的合入分支，用 rebase 来代替 merge\"></a>优雅的合入分支，用 rebase 来代替 merge</h1><p>&emsp;&emsp;首先明确，分支的合入操作，永远是合入到当前所在的分支(HEAD)。因此再处理时候冲突时候，HEAD标识的永远是当前分支的内容，指定合入的分支永远是传入的内容。<br>&emsp;&emsp;使用 <code>git merge</code> 操作的时候，git 会帮你当前所在分支自动创建一个快照文件并用以提交。</p>\n<p><img src=\"/blog/public/imgs/git-merg.png\" alt=\"git merge iss53\"></p>\n<p>&emsp;&emsp;如图，当我在master分支的时候使用git merge iss53，git会帮我合入分支并自动自动创建一个到c2的文件快照。此时不难发现一个问题，那就是在iss53上面的提交commit 和 master 上面的log，就像两条平行线一样毫不相关。如果把iss53上面的所有git log能够同步到master分支上面，使得<strong>合入分支的 git log </strong>能够完整的记录和呈现，不是更全面更优雅吗？</p>\n<p>&emsp;&emsp;使用 <code>git rebase</code> 可以保证提交历史的整洁。——例如贡献代码时，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>\n<p>&emsp;&emsp;简单来说 merge 和 rebase 最终的结果相同，唯一不同的就是分支合并的处理方式以及当前分支的 git log。温馨提示，git rebase完毕提交的时候，如果是你单人开发的场景，记得使用<code>git push -f</code>哦,千万不要照常在push前习惯性的 <code>git pull</code> 一下，这是我血与泪的教训。</p>\n<h1 id=\"危险的pull，保险的fetch\"><a href=\"#危险的pull，保险的fetch\" class=\"headerlink\" title=\"危险的pull，保险的fetch\"></a>危险的pull，保险的fetch</h1><p>&emsp;&emsp;众所周知，<code>git pull = git fetch + git merge</code>，虽然git pull自动帮你合入当前分支的线上最新代码是一件非常畅快的事情，但是在实际开发过程当中是非常危险的。</p>\n<figure class=\"highlight bash hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master</span><br><span class=\"line\">develop</span><br><span class=\"line\">    |</span><br><span class=\"line\">    ------ 你所在的分支</span><br><span class=\"line\">    ------ 你的队友</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;实际开发过程当中，大多数是遵循git工作流的哲学(如上示意)。有一个维稳的 develope 分支来并行 master，而我们自己功能的开发分支均是基于 develope。经常你的队友完成一些<strong>通用模块开发后</strong>，会<strong>先于你合入 develop 分支</strong>。这种情况下你经常需要 merge 或者 rebase 一下最新的 develop 分支。此时如果你使用 git pull 操作去拉取最新的分支，很容易会让线上的分支代码与你新的通用模块产生一大堆冲突。最稳定的方法还是使用 <code>git fetch 分支</code> 的操作， 在浏览完代码没有问题之后再手动 merge/rebase 合入。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;都2019-6-1了，不要再说你只会 add commit push 和 pull 了。<br></p>","more":"</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;Git是一个我们最常使用用代码管理工具，它的命令操作快速而又优雅，分支开发特性形成的独特git工作流模式也非常符合实际工作开发需求。这篇文章用于整理汇总我在实际工作过程中遇到的分支操作处理情况。</p>\n<p>&emsp;&emsp;整理前汇总几个概念：</p>\n<ol>\n<li><p>hash算法<br>&emsp;&emsp;hash算法是一个开源的文件加密算法，它的特性在于不管多大文件的输入，文件在<strong>没有变动</strong>的情况下，总是得到相同的输出。而文件只要变动一点，它得出的hash值就完全不同。hash 算法具有不可逆性。Git 当中使用 hash 算法作为 git 的 文件变动commit成的快照的版本标识。</p>\n</li>\n<li><p>git的<strong>分支</strong>和 <strong>commit</strong> 的操作实质上是对<strong>文件快照(snapshot)</strong>的处理<br>&emsp;&emsp;我们在工作区的 add&amp;commit 操作，本质上是保存了当前文件的一组快照。我们所做的分支切换改变工作区内容，本质上是移动本地的HEAD指针指向快照的位置，从而复现不同的工作区内容。<br><img src=\"/blog/public/imgs/git-snapshot.png\" alt=\"git三区交互\"></p>\n</li>\n<li><p>本地与远程 HEAD 和 origin<br>&emsp;&emsp;前文提过，分支的本地移动，实质上是移动 git 文件当中的 HEAD 指针指向文件的快照。所以HEAD所代表的的就是本地的<strong>当前操作的分支</strong>。我们经常操作过程中提到的 origin 实际上是本地 git 文件<strong>关联</strong>的远程仓库的昵称。origin是你在关联远程仓库时候没有起名字时git默认的名称。因此再使用 git fetch origin/master 意思就是拉取 git 关联的名为 origin 远程仓库下面的master分支到本地。可以使用git remote来查看本地所关联的远程仓库别名。</p>\n</li>\n</ol>\n<h1 id=\"穿梭在-git-时空，reset-的妙用\"><a href=\"#穿梭在-git-时空，reset-的妙用\" class=\"headerlink\" title=\"穿梭在 git 时空，reset 的妙用\"></a>穿梭在 git 时空，reset 的妙用</h1><p>&emsp;&emsp;<code>git reset reset方式参数 log-hash值</code>，可以归置文件到对用的 commit 历史处。对应的 hash 值可以使用<code>git log</code>获得。<br><code>git reset</code> 拥有三个参数 <code>--hard --soft --mixed</code>，他们分别代表了reset的三种模式。</p>\n<ul>\n<li><code>--hard</code> 重置index和working tree</li>\n<li><code>--soft</code> 不会触碰working tree(工作区)和暂存区(index),（即不会改变文件内容），只是移动指针</li>\n<li><code>--mixed</code> 重置暂存区，不会触碰过工作区</li>\n</ul>\n<p>利用<code>--soft</code>不会改变当前工作区文件的特性，当你当前分支开发的 commit 太多想要删除一些commit的时候，可以使用soft重置到想要删除的commit之前，再使用 <code>git add &amp; git commit</code> 来规整 commit 历史。<br>&emsp;&emsp;比如这里我输入一下 git log，发现工作分支残留的 commit 太多：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit 7a3e18e3e4ac6a8b3f95fe8c073cf6cc0fcc9d1b</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br><span class=\"line\">Date:   Sun May 12 22:07:50 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    change img</span><br><span class=\"line\"></span><br><span class=\"line\">commit 31cef3d7f850c3f3cf21d3ae4357f1dee3d145bb</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br><span class=\"line\">Date:   Sun May 12 21:58:36 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add github url</span><br><span class=\"line\"></span><br><span class=\"line\">commit da004222bddb1a99f9ed0e02c70b2173ad85149e</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br><span class=\"line\">Date:   Sun May 12 21:55:47 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    start new chap of sicp</span><br><span class=\"line\"></span><br><span class=\"line\">commit c6c29f8f825d24c4d1a9de0b72c56295022239ab</span><br><span class=\"line\">Author: tangding12 &lt;568783010@qq.com&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;上面的commit中 <code>add github url change img</code> 这两个小的commit改动，我不想残留，我就直接 <code>git reset --soft c6c29f8f825d24c4d1a9de0b72c56295022239ab</code>跳转到 start new chap of sicp 这个 commit 上面，然后使用 <code>git add &amp; git commit</code>。这样我就能在保留当前文件变化的同时删除掉不要的一些微小的commit，以便影响我后续的操作。</p>\n<h1 id=\"重命名远程分支本质是删除远程分支再重新推送\"><a href=\"#重命名远程分支本质是删除远程分支再重新推送\" class=\"headerlink\" title=\"重命名远程分支本质是删除远程分支再重新推送\"></a>重命名远程分支本质是删除远程分支再重新推送</h1><p>&emsp;&emsp;远程分支没有重命名操作，只有本地分支才能使用 <code>git branch -m oldBranchName newBranchName</code> 来重命名分支。远程分支重命名本质是使用 <code>git push origin :oldBranchName</code> 删除你需要重命名的分支，然后在使用 <code>git push --set-upstream</code> 推送一个新的分支名到远程仓库。</p>\n<h1 id=\"优雅的合入分支，用-rebase-来代替-merge\"><a href=\"#优雅的合入分支，用-rebase-来代替-merge\" class=\"headerlink\" title=\"优雅的合入分支，用 rebase 来代替 merge\"></a>优雅的合入分支，用 rebase 来代替 merge</h1><p>&emsp;&emsp;首先明确，分支的合入操作，永远是合入到当前所在的分支(HEAD)。因此再处理时候冲突时候，HEAD标识的永远是当前分支的内容，指定合入的分支永远是传入的内容。<br>&emsp;&emsp;使用 <code>git merge</code> 操作的时候，git 会帮你当前所在分支自动创建一个快照文件并用以提交。</p>\n<p><img src=\"/blog/public/imgs/git-merg.png\" alt=\"git merge iss53\"></p>\n<p>&emsp;&emsp;如图，当我在master分支的时候使用git merge iss53，git会帮我合入分支并自动自动创建一个到c2的文件快照。此时不难发现一个问题，那就是在iss53上面的提交commit 和 master 上面的log，就像两条平行线一样毫不相关。如果把iss53上面的所有git log能够同步到master分支上面，使得<strong>合入分支的 git log </strong>能够完整的记录和呈现，不是更全面更优雅吗？</p>\n<p>&emsp;&emsp;使用 <code>git rebase</code> 可以保证提交历史的整洁。——例如贡献代码时，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>\n<p>&emsp;&emsp;简单来说 merge 和 rebase 最终的结果相同，唯一不同的就是分支合并的处理方式以及当前分支的 git log。温馨提示，git rebase完毕提交的时候，如果是你单人开发的场景，记得使用<code>git push -f</code>哦,千万不要照常在push前习惯性的 <code>git pull</code> 一下，这是我血与泪的教训。</p>\n<h1 id=\"危险的pull，保险的fetch\"><a href=\"#危险的pull，保险的fetch\" class=\"headerlink\" title=\"危险的pull，保险的fetch\"></a>危险的pull，保险的fetch</h1><p>&emsp;&emsp;众所周知，<code>git pull = git fetch + git merge</code>，虽然git pull自动帮你合入当前分支的线上最新代码是一件非常畅快的事情，但是在实际开发过程当中是非常危险的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master</span><br><span class=\"line\">develop</span><br><span class=\"line\">    |</span><br><span class=\"line\">    ------ 你所在的分支</span><br><span class=\"line\">    ------ 你的队友</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;实际开发过程当中，大多数是遵循git工作流的哲学(如上示意)。有一个维稳的 develope 分支来并行 master，而我们自己功能的开发分支均是基于 develope。经常你的队友完成一些<strong>通用模块开发后</strong>，会<strong>先于你合入 develop 分支</strong>。这种情况下你经常需要 merge 或者 rebase 一下最新的 develop 分支。此时如果你使用 git pull 操作去拉取最新的分支，很容易会让线上的分支代码与你新的通用模块产生一大堆冲突。最稳定的方法还是使用 <code>git fetch 分支</code> 的操作， 在浏览完代码没有问题之后再手动 merge/rebase 合入。</p>"},{"title":"关于 react Hook 的一些思考","date":"2020-04-22T06:40:00.000Z","_content":"&emsp;&emsp;使用了将近一周的 react Hook，期间尝试将项目中原有的`class component`改造成`Hook`，比较`Hook`和`class`的区别，得出一些个人的思考与见解。\n\n<!--more-->\n## 什么是Hook\n&emsp;&emsp; react官网上面对 Hook 是这样描述的。\n> Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n### Hook提供了react中函数式组件操作state，响应state的能力。\n&emsp;&emsp;最简单的`todo`，一个函数式组件实现功能一个按钮点击增加计数，一个p标签来同步显示计数的更新。不用Hook的情况下我们需要依赖`class component`来进行外部props的更新。\n\n```javascript\nimport React, { Component } from 'react';\n\nfunction Demo({ num, addNum }) {\n  return (\n    <>\n      <p>{num}</p>\n      <button onClick={addNum}>点我增加</button>\n    </>\n  );\n};\n\nclass UseDemo extends Component {\n  state = { num: 0 };\n\n  addNum = () => {\n    this.setState({ num: this.state.num + 1 });\n  };\n\n  render() {\n    return <Demo num={this.state.num} addNum={this.addNum} />;\n  }\n}\n```\n&emsp;&emsp;使用Hook来进行对同样的todo来进行改造。\n\n```javascript\nimport React, { Component, useState } from 'react';\n\nfunction Demo() {\n  const [num, setNum] = useState(0);\n  return (\n    <>\n      <p>{num}</p>\n      <button onClick={() => setNum(num + 1)}>点我增加</button>\n    </>\n  );\n};\n```\n\n### Hook提供了函数式组件类似于生命周期的方法\n&emsp;&emsp;在Hook之前的设计中，函数式组件的更新由props变化决定，自行完成更新到视图。我们先来不用Hook写一个倒计时功能。\n\n```javascript\nimport React, { Component } from 'react';\n\nfunction Demo({ num }) {\n  return <p>{num === 0 ? '倒计时结束' : num}</p>;\n};\n\nclass UseDemo extends Component {\n  timer = null;\n\n  state = { num: 60 };\n\n  render() {\n    return <Demo num={this.state.num} />;\n  }\n\n  componentDidMount() {\n    this.timer = setInterval(() => {\n      if (this.state.num === 0) {\n        clearInterval(this.timer);\n        this.timer = null;\n      } else {\n        this.setState({ num: this.state.num - 1 });\n      }\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n  }\n\n}\n```\n&emsp;&emsp;我们完成了一个60秒倒计时的功能。在 UseDemo didMount 的时候生成一个60秒的计时器。为了防止用户在倒计时结束前退出当前组件渲染，在`componentWillUnmount`的时候，如果计时器还在计时，把它清空掉。\n\n&emsp;&emsp;我们使用Hook+函数组件来完成相同的功能。\n\n```javascript\nfunction useIntervalCountDown(countNum) {\n  const [num, setNum] = useState(countNum);\n  const [timer, setTimer] = useState(null);\n  useEffect(() => {\n    if (num === 0 && timer) {\n      clearInterval(timer);\n    }\n    if (!timer) {\n      let timeId = setInterval(() => {\n        setNum(num - 1);\n      }, 1000);\n      setTimer(timeId); 1000);\n    }\n    return () => {\n      if (timer) {\n        clearInterval(timer);\n        setTimer(null);\n      }\n    };\n  }, [num, timer]);\n  return num;\n}\n\nfunction Demo() {\n  const num = useIntervalCountDown(60);\n  return <p>{num === 0 ? '倒计时结束' : num}</p>;\n};\n```\n\n&emsp;&emsp;我们使用`useEffect`来完成`componentDidMount`和`componentWillUnmount`生命周期的模拟。`useEffect`接收两个参数，第一个参数为函数，第二参数是一个数组。数组中存在的变量变化时，`useEffect`会触发第一个入参的函数。第一个入参函数可以设置一个返回的函数值，这个函数将在组件取消挂载的前执行（近乎相当于`componentWillUnmount`）。\n\n&emsp;&emsp;Hook本质上就是给函数式组件提供各种类组件的能力。让你像写`class Component`一样来写`functional Component`。但是通过上面两个例子可以发现，Hook改造前后,代码量并没有减少多少，那么我们到底为什么需要react Hook。\n\n## Hook解决了什么问题\n\n### class component 逻辑复用不方便\n\n&emsp;&emsp;举一个最经常写的后台管理系统页面的例子。如下图：\n\n![常见的后台管理系统](/blog/public/imgs/admin.png)\n\n&emsp;&emsp;图中可以看到一个`table`呈现各个详情资料。然后最后一列是各种操作按钮。这种模式的页面一般会呈现在点击左侧菜单栏后出现，在一个后台管理系统会出现很多次。事实上，这些页面除了请求接口（url，入参）以及表格呈现（表格的标题，渲染逻辑）不同，其它有很多逻辑是相同的。比如：\n1. componentDidMount之后，请求表格的内容接口，设置到state。\n2. 翻页，改变页面尺寸，改变入参拉取请求列表。\n3. 请求列表前后，开启表格loading。\n\n&emsp;&emsp;在`class component`模式下，如果想要复用这部分的逻辑，操作到组件内部的`state`，只能使用继承的方式。\n\n```javascript\nimport React, { Component } from 'react';\n\n// 仅仅举例\nexport class BaseTableComponent extends Component {\n  // 拉取请求列表逻辑\n  fetchList = async () => {\n    const {\n      url,\n      params,\n    } = this.getRequestParams(); // 继承子类自己内部实现\n    const { list, total } = await fetch(url, params);\n    this.setState({ tableList: list, total });\n  };\n\n  // 翻页逻辑\n  handlePageChange = (current, size) => {\n    this.setState({ current, size }, () => {\n      this.fetchList();\n    });\n  };\n\n  // ... 省略其它组件复用的逻辑\n  componentDidMount() {\n    this.fetchList();\n  }\n}\n```\n\n&emsp;&emsp;在上面简单实现了一个抽象类`BaseTableComponent`，在这个类中实现了拉取接口部分逻辑的抽取，列表翻页逻辑的抽取。接下来写页面组件的时候，想要实现这部分逻辑都需要继承这个类。\n\n```javascript\nimport { BaseTableComponent } from './BaseTableComponent';\n\nexport default class UserPage extends BaseTableComponent {\n  getRequestParams = () => {\n    return {\n      url: '/demo/',\n      params: { page: 1, size: 10 },\n    };\n  };\n  render() {\n    const { list, total, current, size } = this.state;\n    return (\n      <Table\n        dataSource={list}\n        pagination={{\n          total,\n          current,\n          size,\n          onChange: this.handlePageChange,\n          pagination: this.handlePageChange,\n        }}\n      />\n    );\n  }\n}\n```\n\n&emsp;&emsp;这样子复用模式在实际项目中会带来比较多的两个问题：\n1. 复用逻辑组合复用不方便。\n比如我所有页面都用到了`input`搜索请求页面列表的逻辑，而单单页面A，B没有用到，我抽象出来的方法，在页面AB组件中就存在冗余。`extends class`的继承模式不能很好的解决这个问题。\n\n2. 复用逻辑必须一直关注**父类**用到的state。\n因为父类帮你抽象出来操作state的逻辑，因此，这部分占用的state(比如list，total)在所有子类的方法中，都不能再使用了。随着抽象的公用的逻辑越来越多，父类维护操作的state也会越来越多，需要关注不能使用的state也就越来越多。\n\n&emsp;&emsp;Hook能很好的解决这个问题。函数式的组件和`state`调用方法可以很方便的排列组合给需要的功能。\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nexport function useFetch({ url, params }) {\n  const [list, setList] = useState([]);\n  const [total, setTotal] = useTotal(0);\n  useEffect(() => {\n    fetch(url, params)\n      .then(({ total, list }) => {\n        setList(list);\n        setTotal(total);\n      })\n  }, [params]);\n  return { list, total };\n}\n\n// 这里为了举例简单不引入 useCallback 等渲染更新优化的逻辑\n// 页面组件使用抽象的组件逻辑\nexport default () => {\n  const [current, setCurrent] = useState(1);\n  const [size, setSize] = useState(10);\n  // 引入请求列表逻辑\n  const { list, total } = useFetch({ url, params: { current, size } });\n  return (\n    <Table\n      dataSource={list}\n      pagination={{\n        total,\n        current,\n        size,\n        onChange: (current, size) => {\n          setCurrent(current);\n          setSize(size);\n        },\n      }}\n    />\n  );\n};\n```\n\n&emsp;&emsp;Hook给予了函数组件操作state，以及使用类似于`class component`生命周期的能力。函数式组件本身高度灵活，可以拆卸复用各种小功能，而不会像`class`一样产生冗余。\n\n### Hook实现逻辑的高聚合\n\n&emsp;&emsp;回到开头第二个计时器的例子。在使用`class component`来实现计时器的时候，在`componentDidMount`和`componentWillUnmount`中分别进行了`setInterval`和`clearInterval`的操作。这就是`class component`的第二个缺点，有时候我们实现一个功能，需要把逻辑**分散在多个生命周期**当中。当外部的prop会和内部同步更新时我们还要带上`getDerivedStateFromProps`的生命周期方法。使得组件在后期的维护上存在很重的负担。接手代码的同学需要贯穿整个`react`数个生命周期方法才能明白你的一个数据处理逻辑。\n\n&emsp;&emsp;在计时器的例子中，我们抽取了`useIntervalCountDown`方法，把num, 和操作num的setNum逻辑放在一个函数里面，贯穿在一起。无论是读代码逻辑的连贯性，还是代码的聚合性都在一起，在维护度上的提升不是一星半点。\n\n### 最后一点\n&emsp;&emsp;其实Hook加入对react社区建设的意义也是非常积极的。Hook鼓励你对数据以及操作数据的逻辑进行提取.既然你在日常工作中已经提取了不少逻辑,何不发布到社区当中进行开源.实际上`react Hook`发布之后，react社区的其它核心组件包诸如`react-router`，`react-redux`都立即响应使用`React Hook`进行了包的更新编写。拥抱`Hook`的速度足以证明`react Hook`的积极意义。","source":"_posts/react/hooks.md","raw":"---\ntitle: 关于 react Hook 的一些思考\ndate: 2020/4/22 14:40\ncategories:\n- [前端, react]\ntags:\n- react\n---\n&emsp;&emsp;使用了将近一周的 react Hook，期间尝试将项目中原有的`class component`改造成`Hook`，比较`Hook`和`class`的区别，得出一些个人的思考与见解。\n\n<!--more-->\n## 什么是Hook\n&emsp;&emsp; react官网上面对 Hook 是这样描述的。\n> Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n### Hook提供了react中函数式组件操作state，响应state的能力。\n&emsp;&emsp;最简单的`todo`，一个函数式组件实现功能一个按钮点击增加计数，一个p标签来同步显示计数的更新。不用Hook的情况下我们需要依赖`class component`来进行外部props的更新。\n\n```javascript\nimport React, { Component } from 'react';\n\nfunction Demo({ num, addNum }) {\n  return (\n    <>\n      <p>{num}</p>\n      <button onClick={addNum}>点我增加</button>\n    </>\n  );\n};\n\nclass UseDemo extends Component {\n  state = { num: 0 };\n\n  addNum = () => {\n    this.setState({ num: this.state.num + 1 });\n  };\n\n  render() {\n    return <Demo num={this.state.num} addNum={this.addNum} />;\n  }\n}\n```\n&emsp;&emsp;使用Hook来进行对同样的todo来进行改造。\n\n```javascript\nimport React, { Component, useState } from 'react';\n\nfunction Demo() {\n  const [num, setNum] = useState(0);\n  return (\n    <>\n      <p>{num}</p>\n      <button onClick={() => setNum(num + 1)}>点我增加</button>\n    </>\n  );\n};\n```\n\n### Hook提供了函数式组件类似于生命周期的方法\n&emsp;&emsp;在Hook之前的设计中，函数式组件的更新由props变化决定，自行完成更新到视图。我们先来不用Hook写一个倒计时功能。\n\n```javascript\nimport React, { Component } from 'react';\n\nfunction Demo({ num }) {\n  return <p>{num === 0 ? '倒计时结束' : num}</p>;\n};\n\nclass UseDemo extends Component {\n  timer = null;\n\n  state = { num: 60 };\n\n  render() {\n    return <Demo num={this.state.num} />;\n  }\n\n  componentDidMount() {\n    this.timer = setInterval(() => {\n      if (this.state.num === 0) {\n        clearInterval(this.timer);\n        this.timer = null;\n      } else {\n        this.setState({ num: this.state.num - 1 });\n      }\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n  }\n\n}\n```\n&emsp;&emsp;我们完成了一个60秒倒计时的功能。在 UseDemo didMount 的时候生成一个60秒的计时器。为了防止用户在倒计时结束前退出当前组件渲染，在`componentWillUnmount`的时候，如果计时器还在计时，把它清空掉。\n\n&emsp;&emsp;我们使用Hook+函数组件来完成相同的功能。\n\n```javascript\nfunction useIntervalCountDown(countNum) {\n  const [num, setNum] = useState(countNum);\n  const [timer, setTimer] = useState(null);\n  useEffect(() => {\n    if (num === 0 && timer) {\n      clearInterval(timer);\n    }\n    if (!timer) {\n      let timeId = setInterval(() => {\n        setNum(num - 1);\n      }, 1000);\n      setTimer(timeId); 1000);\n    }\n    return () => {\n      if (timer) {\n        clearInterval(timer);\n        setTimer(null);\n      }\n    };\n  }, [num, timer]);\n  return num;\n}\n\nfunction Demo() {\n  const num = useIntervalCountDown(60);\n  return <p>{num === 0 ? '倒计时结束' : num}</p>;\n};\n```\n\n&emsp;&emsp;我们使用`useEffect`来完成`componentDidMount`和`componentWillUnmount`生命周期的模拟。`useEffect`接收两个参数，第一个参数为函数，第二参数是一个数组。数组中存在的变量变化时，`useEffect`会触发第一个入参的函数。第一个入参函数可以设置一个返回的函数值，这个函数将在组件取消挂载的前执行（近乎相当于`componentWillUnmount`）。\n\n&emsp;&emsp;Hook本质上就是给函数式组件提供各种类组件的能力。让你像写`class Component`一样来写`functional Component`。但是通过上面两个例子可以发现，Hook改造前后,代码量并没有减少多少，那么我们到底为什么需要react Hook。\n\n## Hook解决了什么问题\n\n### class component 逻辑复用不方便\n\n&emsp;&emsp;举一个最经常写的后台管理系统页面的例子。如下图：\n\n![常见的后台管理系统](/blog/public/imgs/admin.png)\n\n&emsp;&emsp;图中可以看到一个`table`呈现各个详情资料。然后最后一列是各种操作按钮。这种模式的页面一般会呈现在点击左侧菜单栏后出现，在一个后台管理系统会出现很多次。事实上，这些页面除了请求接口（url，入参）以及表格呈现（表格的标题，渲染逻辑）不同，其它有很多逻辑是相同的。比如：\n1. componentDidMount之后，请求表格的内容接口，设置到state。\n2. 翻页，改变页面尺寸，改变入参拉取请求列表。\n3. 请求列表前后，开启表格loading。\n\n&emsp;&emsp;在`class component`模式下，如果想要复用这部分的逻辑，操作到组件内部的`state`，只能使用继承的方式。\n\n```javascript\nimport React, { Component } from 'react';\n\n// 仅仅举例\nexport class BaseTableComponent extends Component {\n  // 拉取请求列表逻辑\n  fetchList = async () => {\n    const {\n      url,\n      params,\n    } = this.getRequestParams(); // 继承子类自己内部实现\n    const { list, total } = await fetch(url, params);\n    this.setState({ tableList: list, total });\n  };\n\n  // 翻页逻辑\n  handlePageChange = (current, size) => {\n    this.setState({ current, size }, () => {\n      this.fetchList();\n    });\n  };\n\n  // ... 省略其它组件复用的逻辑\n  componentDidMount() {\n    this.fetchList();\n  }\n}\n```\n\n&emsp;&emsp;在上面简单实现了一个抽象类`BaseTableComponent`，在这个类中实现了拉取接口部分逻辑的抽取，列表翻页逻辑的抽取。接下来写页面组件的时候，想要实现这部分逻辑都需要继承这个类。\n\n```javascript\nimport { BaseTableComponent } from './BaseTableComponent';\n\nexport default class UserPage extends BaseTableComponent {\n  getRequestParams = () => {\n    return {\n      url: '/demo/',\n      params: { page: 1, size: 10 },\n    };\n  };\n  render() {\n    const { list, total, current, size } = this.state;\n    return (\n      <Table\n        dataSource={list}\n        pagination={{\n          total,\n          current,\n          size,\n          onChange: this.handlePageChange,\n          pagination: this.handlePageChange,\n        }}\n      />\n    );\n  }\n}\n```\n\n&emsp;&emsp;这样子复用模式在实际项目中会带来比较多的两个问题：\n1. 复用逻辑组合复用不方便。\n比如我所有页面都用到了`input`搜索请求页面列表的逻辑，而单单页面A，B没有用到，我抽象出来的方法，在页面AB组件中就存在冗余。`extends class`的继承模式不能很好的解决这个问题。\n\n2. 复用逻辑必须一直关注**父类**用到的state。\n因为父类帮你抽象出来操作state的逻辑，因此，这部分占用的state(比如list，total)在所有子类的方法中，都不能再使用了。随着抽象的公用的逻辑越来越多，父类维护操作的state也会越来越多，需要关注不能使用的state也就越来越多。\n\n&emsp;&emsp;Hook能很好的解决这个问题。函数式的组件和`state`调用方法可以很方便的排列组合给需要的功能。\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nexport function useFetch({ url, params }) {\n  const [list, setList] = useState([]);\n  const [total, setTotal] = useTotal(0);\n  useEffect(() => {\n    fetch(url, params)\n      .then(({ total, list }) => {\n        setList(list);\n        setTotal(total);\n      })\n  }, [params]);\n  return { list, total };\n}\n\n// 这里为了举例简单不引入 useCallback 等渲染更新优化的逻辑\n// 页面组件使用抽象的组件逻辑\nexport default () => {\n  const [current, setCurrent] = useState(1);\n  const [size, setSize] = useState(10);\n  // 引入请求列表逻辑\n  const { list, total } = useFetch({ url, params: { current, size } });\n  return (\n    <Table\n      dataSource={list}\n      pagination={{\n        total,\n        current,\n        size,\n        onChange: (current, size) => {\n          setCurrent(current);\n          setSize(size);\n        },\n      }}\n    />\n  );\n};\n```\n\n&emsp;&emsp;Hook给予了函数组件操作state，以及使用类似于`class component`生命周期的能力。函数式组件本身高度灵活，可以拆卸复用各种小功能，而不会像`class`一样产生冗余。\n\n### Hook实现逻辑的高聚合\n\n&emsp;&emsp;回到开头第二个计时器的例子。在使用`class component`来实现计时器的时候，在`componentDidMount`和`componentWillUnmount`中分别进行了`setInterval`和`clearInterval`的操作。这就是`class component`的第二个缺点，有时候我们实现一个功能，需要把逻辑**分散在多个生命周期**当中。当外部的prop会和内部同步更新时我们还要带上`getDerivedStateFromProps`的生命周期方法。使得组件在后期的维护上存在很重的负担。接手代码的同学需要贯穿整个`react`数个生命周期方法才能明白你的一个数据处理逻辑。\n\n&emsp;&emsp;在计时器的例子中，我们抽取了`useIntervalCountDown`方法，把num, 和操作num的setNum逻辑放在一个函数里面，贯穿在一起。无论是读代码逻辑的连贯性，还是代码的聚合性都在一起，在维护度上的提升不是一星半点。\n\n### 最后一点\n&emsp;&emsp;其实Hook加入对react社区建设的意义也是非常积极的。Hook鼓励你对数据以及操作数据的逻辑进行提取.既然你在日常工作中已经提取了不少逻辑,何不发布到社区当中进行开源.实际上`react Hook`发布之后，react社区的其它核心组件包诸如`react-router`，`react-redux`都立即响应使用`React Hook`进行了包的更新编写。拥抱`Hook`的速度足以证明`react Hook`的积极意义。","slug":"react/hooks","published":1,"updated":"2020-06-11T01:43:32.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxt001g9r2vwvze12zw","content":"<p>&emsp;&emsp;使用了将近一周的 react Hook，期间尝试将项目中原有的<code>class component</code>改造成<code>Hook</code>，比较<code>Hook</code>和<code>class</code>的区别，得出一些个人的思考与见解。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是Hook\"><a href=\"#什么是Hook\" class=\"headerlink\" title=\"什么是Hook\"></a>什么是Hook</h2><p>&emsp;&emsp; react官网上面对 Hook 是这样描述的。</p>\n<blockquote>\n<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n</blockquote>\n<h3 id=\"Hook提供了react中函数式组件操作state，响应state的能力。\"><a href=\"#Hook提供了react中函数式组件操作state，响应state的能力。\" class=\"headerlink\" title=\"Hook提供了react中函数式组件操作state，响应state的能力。\"></a>Hook提供了react中函数式组件操作state，响应state的能力。</h3><p>&emsp;&emsp;最简单的<code>todo</code>，一个函数式组件实现功能一个按钮点击增加计数，一个p标签来同步显示计数的更新。不用Hook的情况下我们需要依赖<code>class component</code>来进行外部props的更新。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> React, &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Demo</span>(<span class=\"hljs-params\">&#123; num, addNum &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;num&#125;&lt;<span class=\"hljs-regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">      &lt;button onClick=&#123;addNum&#125;&gt;点我增加&lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"hljs-regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  );</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\"></span></span><br><span class=\"line\"><span class=\"hljs-regexp\">class UseDemo extends Component &#123;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  state = &#123; num: 0 &#125;;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\"></span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  addNum = () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">    this.setState(&#123; num: this.state.num + 1 &#125;);</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\"></span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">    return &lt;Demo num=&#123;this.state.num&#125; addNum=&#123;this.addNum&#125; /</span>&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用Hook来进行对同样的todo来进行改造。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> React, &#123; Component, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Demo</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;num&#125;&lt;<span class=\"hljs-regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">      &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt;点我增加&lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"hljs-regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  );</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Hook提供了函数式组件类似于生命周期的方法\"><a href=\"#Hook提供了函数式组件类似于生命周期的方法\" class=\"headerlink\" title=\"Hook提供了函数式组件类似于生命周期的方法\"></a>Hook提供了函数式组件类似于生命周期的方法</h3><p>&emsp;&emsp;在Hook之前的设计中，函数式组件的更新由props变化决定，自行完成更新到视图。我们先来不用Hook写一个倒计时功能。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> React, &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Demo</span>(<span class=\"hljs-params\">&#123; num &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;num === 0 ? '倒计时结束' : num&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UseDemo</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;</span><br><span class=\"line\">  timer = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123; <span class=\"hljs-attr\">num</span>: <span class=\"hljs-number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Demo</span> <span class=\"hljs-attr\">num</span>=<span class=\"hljs-string\">&#123;this.state.num&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.timer = setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.state.num === <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">        clearInterval(<span class=\"hljs-keyword\">this</span>.timer);</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.timer = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.setState(&#123; <span class=\"hljs-attr\">num</span>: <span class=\"hljs-keyword\">this</span>.state.num - <span class=\"hljs-number\">1</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"hljs-number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.timer) &#123;</span><br><span class=\"line\">      clearInterval(<span class=\"hljs-keyword\">this</span>.timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们完成了一个60秒倒计时的功能。在 UseDemo didMount 的时候生成一个60秒的计时器。为了防止用户在倒计时结束前退出当前组件渲染，在<code>componentWillUnmount</code>的时候，如果计时器还在计时，把它清空掉。</p>\n<p>&emsp;&emsp;我们使用Hook+函数组件来完成相同的功能。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useIntervalCountDown</span>(<span class=\"hljs-params\">countNum</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [num, setNum] = useState(countNum);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [timer, setTimer] = useState(<span class=\"hljs-literal\">null</span>);</span><br><span class=\"line\">  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (num === <span class=\"hljs-number\">0</span> &amp;&amp; timer) &#123;</span><br><span class=\"line\">      clearInterval(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">let</span> timeId = setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setNum(num - <span class=\"hljs-number\">1</span>);</span><br><span class=\"line\">      &#125;, <span class=\"hljs-number\">1000</span>);</span><br><span class=\"line\">      setTimer(timeId); <span class=\"hljs-number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        clearInterval(timer);</span><br><span class=\"line\">        setTimer(<span class=\"hljs-literal\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, [num, timer]);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Demo</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> num = useIntervalCountDown(<span class=\"hljs-number\">60</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;num === 0 ? '倒计时结束' : num&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们使用<code>useEffect</code>来完成<code>componentDidMount</code>和<code>componentWillUnmount</code>生命周期的模拟。<code>useEffect</code>接收两个参数，第一个参数为函数，第二参数是一个数组。数组中存在的变量变化时，<code>useEffect</code>会触发第一个入参的函数。第一个入参函数可以设置一个返回的函数值，这个函数将在组件取消挂载的前执行（近乎相当于<code>componentWillUnmount</code>）。</p>\n<p>&emsp;&emsp;Hook本质上就是给函数式组件提供各种类组件的能力。让你像写<code>class Component</code>一样来写<code>functional Component</code>。但是通过上面两个例子可以发现，Hook改造前后,代码量并没有减少多少，那么我们到底为什么需要react Hook。</p>\n<h2 id=\"Hook解决了什么问题\"><a href=\"#Hook解决了什么问题\" class=\"headerlink\" title=\"Hook解决了什么问题\"></a>Hook解决了什么问题</h2><h3 id=\"class-component-逻辑复用不方便\"><a href=\"#class-component-逻辑复用不方便\" class=\"headerlink\" title=\"class component 逻辑复用不方便\"></a>class component 逻辑复用不方便</h3><p>&emsp;&emsp;举一个最经常写的后台管理系统页面的例子。如下图：</p>\n<p><img src=\"/blog/public/imgs/admin.png\" alt=\"常见的后台管理系统\"></p>\n<p>&emsp;&emsp;图中可以看到一个<code>table</code>呈现各个详情资料。然后最后一列是各种操作按钮。这种模式的页面一般会呈现在点击左侧菜单栏后出现，在一个后台管理系统会出现很多次。事实上，这些页面除了请求接口（url，入参）以及表格呈现（表格的标题，渲染逻辑）不同，其它有很多逻辑是相同的。比如：</p>\n<ol>\n<li>componentDidMount之后，请求表格的内容接口，设置到state。</li>\n<li>翻页，改变页面尺寸，改变入参拉取请求列表。</li>\n<li>请求列表前后，开启表格loading。</li>\n</ol>\n<p>&emsp;&emsp;在<code>class component</code>模式下，如果想要复用这部分的逻辑，操作到组件内部的<code>state</code>，只能使用继承的方式。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> React, &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 仅仅举例</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseTableComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 拉取请求列表逻辑</span></span><br><span class=\"line\">  fetchList = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> &#123;</span><br><span class=\"line\">      url,</span><br><span class=\"line\">      params,</span><br><span class=\"line\">    &#125; = <span class=\"hljs-keyword\">this</span>.getRequestParams(); <span class=\"hljs-comment\">// 继承子类自己内部实现</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> &#123; list, total &#125; = <span class=\"hljs-keyword\">await</span> fetch(url, params);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.setState(&#123; <span class=\"hljs-attr\">tableList</span>: list, total &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 翻页逻辑</span></span><br><span class=\"line\">  handlePageChange = <span class=\"hljs-function\">(<span class=\"hljs-params\">current, size</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.setState(&#123; current, size &#125;, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.fetchList();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略其它组件复用的逻辑</span></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.fetchList();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在上面简单实现了一个抽象类<code>BaseTableComponent</code>，在这个类中实现了拉取接口部分逻辑的抽取，列表翻页逻辑的抽取。接下来写页面组件的时候，想要实现这部分逻辑都需要继承这个类。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; BaseTableComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseTableComponent'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseTableComponent</span> </span>&#123;</span><br><span class=\"line\">  getRequestParams = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"line\">      url: <span class=\"hljs-string\">'/demo/'</span>,</span><br><span class=\"line\">      params: &#123; <span class=\"hljs-attr\">page</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">size</span>: <span class=\"hljs-number\">10</span> &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> &#123; list, total, current, size &#125; = <span class=\"hljs-keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">      &lt;Table</span><br><span class=\"line\">        dataSource=&#123;list&#125;</span><br><span class=\"line\">        pagination=&#123;&#123;</span><br><span class=\"line\">          total,</span><br><span class=\"line\">          current,</span><br><span class=\"line\">          size,</span><br><span class=\"line\">          onChange: <span class=\"hljs-keyword\">this</span>.handlePageChange,</span><br><span class=\"line\">          pagination: <span class=\"hljs-keyword\">this</span>.handlePageChange,</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样子复用模式在实际项目中会带来比较多的两个问题：</p>\n<ol>\n<li><p>复用逻辑组合复用不方便。<br>比如我所有页面都用到了<code>input</code>搜索请求页面列表的逻辑，而单单页面A，B没有用到，我抽象出来的方法，在页面AB组件中就存在冗余。<code>extends class</code>的继承模式不能很好的解决这个问题。</p>\n</li>\n<li><p>复用逻辑必须一直关注<strong>父类</strong>用到的state。<br>因为父类帮你抽象出来操作state的逻辑，因此，这部分占用的state(比如list，total)在所有子类的方法中，都不能再使用了。随着抽象的公用的逻辑越来越多，父类维护操作的state也会越来越多，需要关注不能使用的state也就越来越多。</p>\n</li>\n</ol>\n<p>&emsp;&emsp;Hook能很好的解决这个问题。函数式的组件和<code>state</code>调用方法可以很方便的排列组合给需要的功能。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useFetch</span>(<span class=\"hljs-params\">&#123; url, params &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [list, setList] = useState([]);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [total, setTotal] = useTotal(<span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">  useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fetch(url, params)</span><br><span class=\"line\">      .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; total, list &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setList(list);</span><br><span class=\"line\">        setTotal(total);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;, [params]);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> &#123; list, total &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 这里为了举例简单不引入 useCallback 等渲染更新优化的逻辑</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 页面组件使用抽象的组件逻辑</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [current, setCurrent] = useState(<span class=\"hljs-number\">1</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [size, setSize] = useState(<span class=\"hljs-number\">10</span>);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 引入请求列表逻辑</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> &#123; list, total &#125; = useFetch(&#123; url, <span class=\"hljs-attr\">params</span>: &#123; current, size &#125; &#125;);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    &lt;Table</span><br><span class=\"line\">      dataSource=&#123;list&#125;</span><br><span class=\"line\">      pagination=&#123;&#123;</span><br><span class=\"line\">        total,</span><br><span class=\"line\">        current,</span><br><span class=\"line\">        size,</span><br><span class=\"line\">        onChange: <span class=\"hljs-function\">(<span class=\"hljs-params\">current, size</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          setCurrent(current);</span><br><span class=\"line\">          setSize(size);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;Hook给予了函数组件操作state，以及使用类似于<code>class component</code>生命周期的能力。函数式组件本身高度灵活，可以拆卸复用各种小功能，而不会像<code>class</code>一样产生冗余。</p>\n<h3 id=\"Hook实现逻辑的高聚合\"><a href=\"#Hook实现逻辑的高聚合\" class=\"headerlink\" title=\"Hook实现逻辑的高聚合\"></a>Hook实现逻辑的高聚合</h3><p>&emsp;&emsp;回到开头第二个计时器的例子。在使用<code>class component</code>来实现计时器的时候，在<code>componentDidMount</code>和<code>componentWillUnmount</code>中分别进行了<code>setInterval</code>和<code>clearInterval</code>的操作。这就是<code>class component</code>的第二个缺点，有时候我们实现一个功能，需要把逻辑<strong>分散在多个生命周期</strong>当中。当外部的prop会和内部同步更新时我们还要带上<code>getDerivedStateFromProps</code>的生命周期方法。使得组件在后期的维护上存在很重的负担。接手代码的同学需要贯穿整个<code>react</code>数个生命周期方法才能明白你的一个数据处理逻辑。</p>\n<p>&emsp;&emsp;在计时器的例子中，我们抽取了<code>useIntervalCountDown</code>方法，把num, 和操作num的setNum逻辑放在一个函数里面，贯穿在一起。无论是读代码逻辑的连贯性，还是代码的聚合性都在一起，在维护度上的提升不是一星半点。</p>\n<h3 id=\"最后一点\"><a href=\"#最后一点\" class=\"headerlink\" title=\"最后一点\"></a>最后一点</h3><p>&emsp;&emsp;其实Hook加入对react社区建设的意义也是非常积极的。Hook鼓励你对数据以及操作数据的逻辑进行提取.既然你在日常工作中已经提取了不少逻辑,何不发布到社区当中进行开源.实际上<code>react Hook</code>发布之后，react社区的其它核心组件包诸如<code>react-router</code>，<code>react-redux</code>都立即响应使用<code>React Hook</code>进行了包的更新编写。拥抱<code>Hook</code>的速度足以证明<code>react Hook</code>的积极意义。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;使用了将近一周的 react Hook，期间尝试将项目中原有的<code>class component</code>改造成<code>Hook</code>，比较<code>Hook</code>和<code>class</code>的区别，得出一些个人的思考与见解。</p>","more":"<h2 id=\"什么是Hook\"><a href=\"#什么是Hook\" class=\"headerlink\" title=\"什么是Hook\"></a>什么是Hook</h2><p>&emsp;&emsp; react官网上面对 Hook 是这样描述的。</p>\n<blockquote>\n<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n</blockquote>\n<h3 id=\"Hook提供了react中函数式组件操作state，响应state的能力。\"><a href=\"#Hook提供了react中函数式组件操作state，响应state的能力。\" class=\"headerlink\" title=\"Hook提供了react中函数式组件操作state，响应state的能力。\"></a>Hook提供了react中函数式组件操作state，响应state的能力。</h3><p>&emsp;&emsp;最简单的<code>todo</code>，一个函数式组件实现功能一个按钮点击增加计数，一个p标签来同步显示计数的更新。不用Hook的情况下我们需要依赖<code>class component</code>来进行外部props的更新。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\">&#123; num, addNum &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;num&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;addNum&#125;&gt;点我增加&lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class UseDemo extends Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  state = &#123; num: 0 &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  addNum = () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    this.setState(&#123; num: this.state.num + 1 &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &lt;Demo num=&#123;this.state.num&#125; addNum=&#123;this.addNum&#125; /</span>&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;使用Hook来进行对同样的todo来进行改造。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [num, setNum] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;num&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt;点我增加&lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Hook提供了函数式组件类似于生命周期的方法\"><a href=\"#Hook提供了函数式组件类似于生命周期的方法\" class=\"headerlink\" title=\"Hook提供了函数式组件类似于生命周期的方法\"></a>Hook提供了函数式组件类似于生命周期的方法</h3><p>&emsp;&emsp;在Hook之前的设计中，函数式组件的更新由props变化决定，自行完成更新到视图。我们先来不用Hook写一个倒计时功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\">&#123; num &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;num === 0 ? '倒计时结束' : num&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123; <span class=\"attr\">num</span>: <span class=\"number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Demo</span> <span class=\"attr\">num</span>=<span class=\"string\">&#123;this.state.num&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.timer = setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.num === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        clearInterval(<span class=\"keyword\">this</span>.timer);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">num</span>: <span class=\"keyword\">this</span>.state.num - <span class=\"number\">1</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.timer) &#123;</span><br><span class=\"line\">      clearInterval(<span class=\"keyword\">this</span>.timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们完成了一个60秒倒计时的功能。在 UseDemo didMount 的时候生成一个60秒的计时器。为了防止用户在倒计时结束前退出当前组件渲染，在<code>componentWillUnmount</code>的时候，如果计时器还在计时，把它清空掉。</p>\n<p>&emsp;&emsp;我们使用Hook+函数组件来完成相同的功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useIntervalCountDown</span>(<span class=\"params\">countNum</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [num, setNum] = useState(countNum);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [timer, setTimer] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num === <span class=\"number\">0</span> &amp;&amp; timer) &#123;</span><br><span class=\"line\">      clearInterval(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> timeId = setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setNum(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">      setTimer(timeId); <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        clearInterval(timer);</span><br><span class=\"line\">        setTimer(<span class=\"literal\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, [num, timer]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = useIntervalCountDown(<span class=\"number\">60</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;num === 0 ? '倒计时结束' : num&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们使用<code>useEffect</code>来完成<code>componentDidMount</code>和<code>componentWillUnmount</code>生命周期的模拟。<code>useEffect</code>接收两个参数，第一个参数为函数，第二参数是一个数组。数组中存在的变量变化时，<code>useEffect</code>会触发第一个入参的函数。第一个入参函数可以设置一个返回的函数值，这个函数将在组件取消挂载的前执行（近乎相当于<code>componentWillUnmount</code>）。</p>\n<p>&emsp;&emsp;Hook本质上就是给函数式组件提供各种类组件的能力。让你像写<code>class Component</code>一样来写<code>functional Component</code>。但是通过上面两个例子可以发现，Hook改造前后,代码量并没有减少多少，那么我们到底为什么需要react Hook。</p>\n<h2 id=\"Hook解决了什么问题\"><a href=\"#Hook解决了什么问题\" class=\"headerlink\" title=\"Hook解决了什么问题\"></a>Hook解决了什么问题</h2><h3 id=\"class-component-逻辑复用不方便\"><a href=\"#class-component-逻辑复用不方便\" class=\"headerlink\" title=\"class component 逻辑复用不方便\"></a>class component 逻辑复用不方便</h3><p>&emsp;&emsp;举一个最经常写的后台管理系统页面的例子。如下图：</p>\n<p><img src=\"/blog/public/imgs/admin.png\" alt=\"常见的后台管理系统\"></p>\n<p>&emsp;&emsp;图中可以看到一个<code>table</code>呈现各个详情资料。然后最后一列是各种操作按钮。这种模式的页面一般会呈现在点击左侧菜单栏后出现，在一个后台管理系统会出现很多次。事实上，这些页面除了请求接口（url，入参）以及表格呈现（表格的标题，渲染逻辑）不同，其它有很多逻辑是相同的。比如：</p>\n<ol>\n<li>componentDidMount之后，请求表格的内容接口，设置到state。</li>\n<li>翻页，改变页面尺寸，改变入参拉取请求列表。</li>\n<li>请求列表前后，开启表格loading。</li>\n</ol>\n<p>&emsp;&emsp;在<code>class component</code>模式下，如果想要复用这部分的逻辑，操作到组件内部的<code>state</code>，只能使用继承的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仅仅举例</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseTableComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 拉取请求列表逻辑</span></span><br><span class=\"line\">  fetchList = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">      url,</span><br><span class=\"line\">      params,</span><br><span class=\"line\">    &#125; = <span class=\"keyword\">this</span>.getRequestParams(); <span class=\"comment\">// 继承子类自己内部实现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; list, total &#125; = <span class=\"keyword\">await</span> fetch(url, params);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">tableList</span>: list, total &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 翻页逻辑</span></span><br><span class=\"line\">  handlePageChange = <span class=\"function\">(<span class=\"params\">current, size</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; current, size &#125;, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fetchList();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ... 省略其它组件复用的逻辑</span></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fetchList();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在上面简单实现了一个抽象类<code>BaseTableComponent</code>，在这个类中实现了拉取接口部分逻辑的抽取，列表翻页逻辑的抽取。接下来写页面组件的时候，想要实现这部分逻辑都需要继承这个类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; BaseTableComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./BaseTableComponent'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseTableComponent</span> </span>&#123;</span><br><span class=\"line\">  getRequestParams = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      url: <span class=\"string\">'/demo/'</span>,</span><br><span class=\"line\">      params: &#123; <span class=\"attr\">page</span>: <span class=\"number\">1</span>, <span class=\"attr\">size</span>: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; list, total, current, size &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Table</span><br><span class=\"line\">        dataSource=&#123;list&#125;</span><br><span class=\"line\">        pagination=&#123;&#123;</span><br><span class=\"line\">          total,</span><br><span class=\"line\">          current,</span><br><span class=\"line\">          size,</span><br><span class=\"line\">          onChange: <span class=\"keyword\">this</span>.handlePageChange,</span><br><span class=\"line\">          pagination: <span class=\"keyword\">this</span>.handlePageChange,</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样子复用模式在实际项目中会带来比较多的两个问题：</p>\n<ol>\n<li><p>复用逻辑组合复用不方便。<br>比如我所有页面都用到了<code>input</code>搜索请求页面列表的逻辑，而单单页面A，B没有用到，我抽象出来的方法，在页面AB组件中就存在冗余。<code>extends class</code>的继承模式不能很好的解决这个问题。</p>\n</li>\n<li><p>复用逻辑必须一直关注<strong>父类</strong>用到的state。<br>因为父类帮你抽象出来操作state的逻辑，因此，这部分占用的state(比如list，total)在所有子类的方法中，都不能再使用了。随着抽象的公用的逻辑越来越多，父类维护操作的state也会越来越多，需要关注不能使用的state也就越来越多。</p>\n</li>\n</ol>\n<p>&emsp;&emsp;Hook能很好的解决这个问题。函数式的组件和<code>state</code>调用方法可以很方便的排列组合给需要的功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFetch</span>(<span class=\"params\">&#123; url, params &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [list, setList] = useState([]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [total, setTotal] = useTotal(<span class=\"number\">0</span>);</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fetch(url, params)</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">&#123; total, list &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setList(list);</span><br><span class=\"line\">        setTotal(total);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;, [params]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; list, total &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里为了举例简单不引入 useCallback 等渲染更新优化的逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// 页面组件使用抽象的组件逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [current, setCurrent] = useState(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [size, setSize] = useState(<span class=\"number\">10</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 引入请求列表逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; list, total &#125; = useFetch(&#123; url, <span class=\"attr\">params</span>: &#123; current, size &#125; &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Table</span><br><span class=\"line\">      dataSource=&#123;list&#125;</span><br><span class=\"line\">      pagination=&#123;&#123;</span><br><span class=\"line\">        total,</span><br><span class=\"line\">        current,</span><br><span class=\"line\">        size,</span><br><span class=\"line\">        onChange: <span class=\"function\">(<span class=\"params\">current, size</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          setCurrent(current);</span><br><span class=\"line\">          setSize(size);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;Hook给予了函数组件操作state，以及使用类似于<code>class component</code>生命周期的能力。函数式组件本身高度灵活，可以拆卸复用各种小功能，而不会像<code>class</code>一样产生冗余。</p>\n<h3 id=\"Hook实现逻辑的高聚合\"><a href=\"#Hook实现逻辑的高聚合\" class=\"headerlink\" title=\"Hook实现逻辑的高聚合\"></a>Hook实现逻辑的高聚合</h3><p>&emsp;&emsp;回到开头第二个计时器的例子。在使用<code>class component</code>来实现计时器的时候，在<code>componentDidMount</code>和<code>componentWillUnmount</code>中分别进行了<code>setInterval</code>和<code>clearInterval</code>的操作。这就是<code>class component</code>的第二个缺点，有时候我们实现一个功能，需要把逻辑<strong>分散在多个生命周期</strong>当中。当外部的prop会和内部同步更新时我们还要带上<code>getDerivedStateFromProps</code>的生命周期方法。使得组件在后期的维护上存在很重的负担。接手代码的同学需要贯穿整个<code>react</code>数个生命周期方法才能明白你的一个数据处理逻辑。</p>\n<p>&emsp;&emsp;在计时器的例子中，我们抽取了<code>useIntervalCountDown</code>方法，把num, 和操作num的setNum逻辑放在一个函数里面，贯穿在一起。无论是读代码逻辑的连贯性，还是代码的聚合性都在一起，在维护度上的提升不是一星半点。</p>\n<h3 id=\"最后一点\"><a href=\"#最后一点\" class=\"headerlink\" title=\"最后一点\"></a>最后一点</h3><p>&emsp;&emsp;其实Hook加入对react社区建设的意义也是非常积极的。Hook鼓励你对数据以及操作数据的逻辑进行提取.既然你在日常工作中已经提取了不少逻辑,何不发布到社区当中进行开源.实际上<code>react Hook</code>发布之后，react社区的其它核心组件包诸如<code>react-router</code>，<code>react-redux</code>都立即响应使用<code>React Hook</code>进行了包的更新编写。拥抱<code>Hook</code>的速度足以证明<code>react Hook</code>的积极意义。</p>"},{"title":"react源码阅读2-react-domRender","date":"2020-03-22T09:00:00.000Z","_content":"&emsp;&emsp;react-dom入口函数以及基本数据类型。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n&emsp;&emsp;在<a href=\"../reactCode-react-1-2019-12-01/\" target=\"_blank\">第一章节</a>我们了解到，`react`包本质上是一个`数据结构`建立的抽象屏障，提供起来供react的其它包，诸如`react-dom`，`react-native`调用。在这一章中，进入`react-dom`的源码阅读。\n\n&emsp;&emsp;根据`package.json`的`main`字段入口，我们可以找到`react-dom`的入口文件为`src/client/ReactDOM.js`。我们发现该文件最后的代码`export default ReactDOM`仅仅对外暴露了一个对象模块。我们简单看一下这个对象模块。\n\n```javascript\n// 函数内部代码均先省略\nconst ReactDOM: Object = {\n  createPortal,\n  findDOMNode() {  },\n  hydrate() {},\n  render() {},\n  unstable_renderSubtreeIntoContainer() {},\n  unmountComponentAtNode() {},\n  unstable_createPortal() {},\n  unstable_interactiveUpdates() {},\n  unstable_discreteUpdates,\n  unstable_flushDiscreteUpdates,\n  flushSync,\n  unstable_createRoot,\n  unstable_createSyncRoot,\n  unstable_flushControlled,\n}\n```\n&emsp;&emsp;其实这里的对象模块就是对面暴露的`react-dom`提供的Api部分。我们可以看到包括最熟悉的`render`方法，用于服务端渲染的`hydrate`，还有`findDOMNode`，`createPortal`等。\n\n&emsp;&emsp;我们本章节就来查看下最常使用的`render`函数的源码大体逻辑结构。\n\n```javascript\n// 调用方式 ReactDOM.render(element, container[, callback])\nrender(\n    element: React$Element<any>,\n    container: DOMContainer,\n    callback: ?Function,\n  ) {\n    // 判断dom节点是否正确\n    invariant(\n      isValidContainer(container),\n      'Target container is not a DOM element.',\n    );\n    return legacyRenderSubtreeIntoContainer(\n      null,\n      element,\n      container,\n      false,\n      callback,\n    );\n  }\n```\n&emsp;&emsp;`react-dom`源码中使用了`flow`来定义数据类型，函数入参中如`element: React$Element<any>`这种写法就是`flow`的语法。近似于`typescript`。\n\n&emsp;&emsp;`render`函数在除去`DEV`调试部分逻辑后，剩余的代码非常简单，判断传入的`container`节点是否为`Dom`节点，是就进入`legacyRenderSubtreeIntoContainer`函数，我们来跟着代码接着看。\n\n```javascript\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: DOMContainer,\n  // 是否复用dom节点，服务端渲染调用\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // 从 container 中获得root节点\n  let root: _ReactSyncRoot = (container._reactRootContainer: any);\n  let fiberRoot;\n  if (!root) {\n    // 没有root，创建root节点， 移除所有子节点\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    fiberRoot = root._internalRoot;\n    // 有无callback\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n    // 有无callback 逻辑同上\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n```\n\n&emsp;&emsp;`legacyRenderSubtreeIntoContainer`首先取出`container`中的`root`节点，根据有无`root节`点来划分不同的创建更新逻辑。首次使用`render`函数的时候是不存在`root`节点的，此时通过`legacyCreateRootFromDOMContainer`创建一个`root`节点给`container._reactRootContainer`。然后如果存在`callback`就进行调用，最后进行了一个`unbatchedUpdates`。存在`root`节点的时候，就省去了创建`root`节点部分的代码，直接进行`callback`的判断和`updateContainer`。\n\n&emsp;&emsp;我们先来看创建`root`节点的`legacyCreateRootFromDOMContainer`部分的代码。\n\n```javascript\nfunction legacyCreateRootFromDOMContainer(\n  container: DOMContainer,\n  forceHydrate: boolean,\n): _ReactSyncRoot {\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  // 不需要进行 shouldHydrate 过程，即我们正常的render过程\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    // 当有子节点的时候，一直循环，删除完子节点\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n  // Legacy roots are not batched.\n  /**\n   * LegacyRoot 为一个常量标识符，具体细节如下\n   * export type RootTag = 0 | 1 | 2;\n   * export const LegacyRoot = 0;\n   * export const BatchedRoot = 1;\n   * export const ConcurrentRoot = 2;\n   */\n  return new ReactSyncRoot(container, LegacyRoot, shouldHydrate);\n}\n```\n&emsp;&emsp;前面提到过，`forceHydrate`这个布尔值是用于标识是否是服务端渲染的，在浏览器环境下是不触碰这部分的逻辑的，这个相关部分就先跳过。那么`legacyCreateRootFromDOMContainer`就做了两件事情：\n1. 删除`container`容器部分的所有子节点。这也就是为什么我们使用`ReactDom.render`渲染在目标节点之后，节点的子元素全部消失的原因。\n2. 返回了`ReactSyncRoot`类，实例化了一个`root`根节点的实例。\n\n&emsp;&emsp;接下来的`ReactSyncRoot`代码更简单：\n\n```javascript\nfunction ReactSyncRoot(\n  container: DOMContainer,\n  tag: RootTag,\n  hydrate: boolean,\n) {\n  // Tag is either LegacyRoot or Concurrent Root\n  const root = createContainer(container, tag, hydrate);\n  this._internalRoot = root;\n}\n```\n\n&emsp;&emsp;我们追寻`createContainer`函数，发现这个函数文件在`react-reconciler/src/ReactFiberReconciler`包中。我们跟着去查看一下：\n\n```javascript\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n): OpaqueRoot {\n  return createFiberRoot(containerInfo, tag, hydrate);\n}\n\n// 在 `react-reconciler/src/ReactFiberRoot`文件中\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n): FiberRoot {\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  const uninitializedFiber = createHostRootFiber(tag);\n  // 相互指\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  return root;\n}\n\n// fiber root 结构的真身\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  // root 节点对应的Fiber对象\n  this.current = null;\n  // dom 节点\n  this.containerInfo = containerInfo;\n  // 持久化更新会用到\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.firstBatch = null;\n  this.callbackNode = null;\n  this.callbackExpirationTime = NoWork;\n  this.firstPendingTime = NoWork;\n  this.lastPendingTime = NoWork;\n  this.pingTime = NoWork;\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n}\n```\n\n&emsp;&emsp;终于在`FiberRootNode`中发现了rootRoot的真身，就是一个带标识的对象。其中比较重要的一个为`containerInfo`，就是`reactElement`将要渲染上的容器节点信息。我们还能发现，很多标识赋值了`NoWork`，`NoWork`设计到后续我们更新会提及的`ExpirationTime`的概念，是`React`更新算法的基础。目前你可以就把`NoWork`理解为一个标识`0`的常量（`源码export const NoWork = 0;`）。\n\n&emsp;&emsp;我们最后来看`current`，在`createFiberRoot`中将其指向了`createHostRootFiber`创建的`uninitializedFiber`。这个`uninitializedFiber`就是`reactElement`对应的`fiber`节点，我们一起来看一下这部分逻辑。\n\n```javascript\n// 位于react-reconciler/src/ReactFiber.js\nfunction createHostRootFiber(tag: RootTag): Fiber {\n  let mode;\n  // 根据 tag 的不同，获得不同的mode模式\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode | BatchedMode | StrictMode;\n  } else if (tag === BatchedRoot) {\n    mode = BatchedMode | StrictMode;\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point–\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n  this.ref = null;\n  // pendingProps 将要更新\n  this.pendingProps = pendingProps;\n  // 之前的props\n  this.memoizedProps = null;\n  // update对象\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode;\n  // Effects，标记组件生命周期，以及组件是否需要更新\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n  this.firstEffect = null;\n  this.lastEffect = null;\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n}\n```\n&emsp;&emsp;这部分逻辑比较长，我们来拆成两部来看。`createHostRootFiber`总共做了两件事情，根据`tag`存在的标识，调整了`mode`字段。然后使用`mode`字段创建了`FiberNode`对象。\n\n&emsp;&emsp;这里我们稍微提一下使用`|`和`&`来进行一个打标的设计模式。比如我现在有三个属性的标识符`a/b/c`，我们用二进制来定义它们，保证每个模式`1`所在的位置不同。\n\n```javascript\nvar a = 0b001;\nvar b = 0b010;\nvar c = 0b100;\n```\n&emsp;&emsp;我们现在对一个`demo`变量进行属性的赋值，比如我想要这个`demo`变量拥有**属性a**和**属性c**。那我只需要`var demo = a | c`。在后续我对`demo`进行一个拥有属性判断的时候，我只需要使用`&`，如果得到的结果大于0，即转换为`true`，就说明`demo`拥有该属性。如我想要判断`demo`是否含有`a`属性，只需要`if (demo | a) { /* ... */ }`即可。如果我想要给`demo`添加一个属性，比如添加属性`b`，只需要将`demo |= b`即可，如果不是很了解一元操作符的同学，可以去`mdn`上面查一下相关的资料就能明白。\n\n&emsp;&emsp;我们前面在`legacyCreateRootFromDOMContainer`函数的注释中提到过，rootTag是通过`LegacyRoot | BatchedRoot | ConcurrentRoot`取得的三个模式的综合。所以`createHostRootFiber`这里我们走的是最后一个`else`分支，`mode=NoMode`。然后创建`Fiber`节点。\n\n&emsp;&emsp;`Fiber`节点就是对应每一个`ReactElement`的节点了，它上面记载了很多我们熟悉的属性，比如`ref`，比如`props`相关的`pendingProps`，`memoizedProps`。然后还需要关注一下的概念就是`expirationTime`。`expirationTime`前面`root`的时候也提到了，这是节点更新操作的依据，在后续的源码部分也会单独拆分一章节来阐述它。\n\n&emsp;&emsp;还需要提一下的是我注释了`Fiber`相关的几个属性`sibling，return，child`。`react`中的`Fiber`节点对应的是一个单向列表结构。比如我有这样的一个`jsx`结构：\n\n```javascript\nfunction Demo() {\n  return (\n    <ul>\n      <li></li>\n      <li></li>\n      <li></li>\n    </ul>\n  );\n}\n```\n&emsp;&emsp;那么这个结构在`Fiber`中会这样存在`ul.child -> li(1).sibling -> li(2).sibling -> li(3)`。每个节点的`return`则对应总的父节点`li(1).return -> ul`。\n\n&emsp;&emsp;这一章当中，我们简单看了一下`ReactDom.render`的总体函数逻辑和创建数据结构部分的源码。首次创建的时候，`render`会创建一个`FiberRootNode`对象，该对象作为整个**React应用**的根节点，同时给`RootNode`创建对应的`Fiber`对象。每一个`Fiber`对象对应一个`ReactElement`元素，它带有各种用于`React`调度的属性元素，`DOM`以单向链表的数据结存在于`React`应用当中。\n\n&emsp;&emsp;下一章我们会接着`render`函数的逻辑进入`unbatchedUpdates`部分代码，大体介绍一下`React-dom`在更新中的一些框架设计。","source":"_posts/react/reactCode-react-2.md","raw":"---\ntitle: react源码阅读2-react-domRender\ndate: 2020/3/22 17:00\ncategories:\n- [前端, react]\ntags:\n- react\n- 源码阅读\n---\n&emsp;&emsp;react-dom入口函数以及基本数据类型。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n&emsp;&emsp;在<a href=\"../reactCode-react-1-2019-12-01/\" target=\"_blank\">第一章节</a>我们了解到，`react`包本质上是一个`数据结构`建立的抽象屏障，提供起来供react的其它包，诸如`react-dom`，`react-native`调用。在这一章中，进入`react-dom`的源码阅读。\n\n&emsp;&emsp;根据`package.json`的`main`字段入口，我们可以找到`react-dom`的入口文件为`src/client/ReactDOM.js`。我们发现该文件最后的代码`export default ReactDOM`仅仅对外暴露了一个对象模块。我们简单看一下这个对象模块。\n\n```javascript\n// 函数内部代码均先省略\nconst ReactDOM: Object = {\n  createPortal,\n  findDOMNode() {  },\n  hydrate() {},\n  render() {},\n  unstable_renderSubtreeIntoContainer() {},\n  unmountComponentAtNode() {},\n  unstable_createPortal() {},\n  unstable_interactiveUpdates() {},\n  unstable_discreteUpdates,\n  unstable_flushDiscreteUpdates,\n  flushSync,\n  unstable_createRoot,\n  unstable_createSyncRoot,\n  unstable_flushControlled,\n}\n```\n&emsp;&emsp;其实这里的对象模块就是对面暴露的`react-dom`提供的Api部分。我们可以看到包括最熟悉的`render`方法，用于服务端渲染的`hydrate`，还有`findDOMNode`，`createPortal`等。\n\n&emsp;&emsp;我们本章节就来查看下最常使用的`render`函数的源码大体逻辑结构。\n\n```javascript\n// 调用方式 ReactDOM.render(element, container[, callback])\nrender(\n    element: React$Element<any>,\n    container: DOMContainer,\n    callback: ?Function,\n  ) {\n    // 判断dom节点是否正确\n    invariant(\n      isValidContainer(container),\n      'Target container is not a DOM element.',\n    );\n    return legacyRenderSubtreeIntoContainer(\n      null,\n      element,\n      container,\n      false,\n      callback,\n    );\n  }\n```\n&emsp;&emsp;`react-dom`源码中使用了`flow`来定义数据类型，函数入参中如`element: React$Element<any>`这种写法就是`flow`的语法。近似于`typescript`。\n\n&emsp;&emsp;`render`函数在除去`DEV`调试部分逻辑后，剩余的代码非常简单，判断传入的`container`节点是否为`Dom`节点，是就进入`legacyRenderSubtreeIntoContainer`函数，我们来跟着代码接着看。\n\n```javascript\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: DOMContainer,\n  // 是否复用dom节点，服务端渲染调用\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // 从 container 中获得root节点\n  let root: _ReactSyncRoot = (container._reactRootContainer: any);\n  let fiberRoot;\n  if (!root) {\n    // 没有root，创建root节点， 移除所有子节点\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    fiberRoot = root._internalRoot;\n    // 有无callback\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n    // 有无callback 逻辑同上\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n```\n\n&emsp;&emsp;`legacyRenderSubtreeIntoContainer`首先取出`container`中的`root`节点，根据有无`root节`点来划分不同的创建更新逻辑。首次使用`render`函数的时候是不存在`root`节点的，此时通过`legacyCreateRootFromDOMContainer`创建一个`root`节点给`container._reactRootContainer`。然后如果存在`callback`就进行调用，最后进行了一个`unbatchedUpdates`。存在`root`节点的时候，就省去了创建`root`节点部分的代码，直接进行`callback`的判断和`updateContainer`。\n\n&emsp;&emsp;我们先来看创建`root`节点的`legacyCreateRootFromDOMContainer`部分的代码。\n\n```javascript\nfunction legacyCreateRootFromDOMContainer(\n  container: DOMContainer,\n  forceHydrate: boolean,\n): _ReactSyncRoot {\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  // 不需要进行 shouldHydrate 过程，即我们正常的render过程\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    // 当有子节点的时候，一直循环，删除完子节点\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n  // Legacy roots are not batched.\n  /**\n   * LegacyRoot 为一个常量标识符，具体细节如下\n   * export type RootTag = 0 | 1 | 2;\n   * export const LegacyRoot = 0;\n   * export const BatchedRoot = 1;\n   * export const ConcurrentRoot = 2;\n   */\n  return new ReactSyncRoot(container, LegacyRoot, shouldHydrate);\n}\n```\n&emsp;&emsp;前面提到过，`forceHydrate`这个布尔值是用于标识是否是服务端渲染的，在浏览器环境下是不触碰这部分的逻辑的，这个相关部分就先跳过。那么`legacyCreateRootFromDOMContainer`就做了两件事情：\n1. 删除`container`容器部分的所有子节点。这也就是为什么我们使用`ReactDom.render`渲染在目标节点之后，节点的子元素全部消失的原因。\n2. 返回了`ReactSyncRoot`类，实例化了一个`root`根节点的实例。\n\n&emsp;&emsp;接下来的`ReactSyncRoot`代码更简单：\n\n```javascript\nfunction ReactSyncRoot(\n  container: DOMContainer,\n  tag: RootTag,\n  hydrate: boolean,\n) {\n  // Tag is either LegacyRoot or Concurrent Root\n  const root = createContainer(container, tag, hydrate);\n  this._internalRoot = root;\n}\n```\n\n&emsp;&emsp;我们追寻`createContainer`函数，发现这个函数文件在`react-reconciler/src/ReactFiberReconciler`包中。我们跟着去查看一下：\n\n```javascript\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n): OpaqueRoot {\n  return createFiberRoot(containerInfo, tag, hydrate);\n}\n\n// 在 `react-reconciler/src/ReactFiberRoot`文件中\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n): FiberRoot {\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  const uninitializedFiber = createHostRootFiber(tag);\n  // 相互指\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  return root;\n}\n\n// fiber root 结构的真身\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  // root 节点对应的Fiber对象\n  this.current = null;\n  // dom 节点\n  this.containerInfo = containerInfo;\n  // 持久化更新会用到\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.firstBatch = null;\n  this.callbackNode = null;\n  this.callbackExpirationTime = NoWork;\n  this.firstPendingTime = NoWork;\n  this.lastPendingTime = NoWork;\n  this.pingTime = NoWork;\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n}\n```\n\n&emsp;&emsp;终于在`FiberRootNode`中发现了rootRoot的真身，就是一个带标识的对象。其中比较重要的一个为`containerInfo`，就是`reactElement`将要渲染上的容器节点信息。我们还能发现，很多标识赋值了`NoWork`，`NoWork`设计到后续我们更新会提及的`ExpirationTime`的概念，是`React`更新算法的基础。目前你可以就把`NoWork`理解为一个标识`0`的常量（`源码export const NoWork = 0;`）。\n\n&emsp;&emsp;我们最后来看`current`，在`createFiberRoot`中将其指向了`createHostRootFiber`创建的`uninitializedFiber`。这个`uninitializedFiber`就是`reactElement`对应的`fiber`节点，我们一起来看一下这部分逻辑。\n\n```javascript\n// 位于react-reconciler/src/ReactFiber.js\nfunction createHostRootFiber(tag: RootTag): Fiber {\n  let mode;\n  // 根据 tag 的不同，获得不同的mode模式\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode | BatchedMode | StrictMode;\n  } else if (tag === BatchedRoot) {\n    mode = BatchedMode | StrictMode;\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point–\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n  this.ref = null;\n  // pendingProps 将要更新\n  this.pendingProps = pendingProps;\n  // 之前的props\n  this.memoizedProps = null;\n  // update对象\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode;\n  // Effects，标记组件生命周期，以及组件是否需要更新\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n  this.firstEffect = null;\n  this.lastEffect = null;\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n}\n```\n&emsp;&emsp;这部分逻辑比较长，我们来拆成两部来看。`createHostRootFiber`总共做了两件事情，根据`tag`存在的标识，调整了`mode`字段。然后使用`mode`字段创建了`FiberNode`对象。\n\n&emsp;&emsp;这里我们稍微提一下使用`|`和`&`来进行一个打标的设计模式。比如我现在有三个属性的标识符`a/b/c`，我们用二进制来定义它们，保证每个模式`1`所在的位置不同。\n\n```javascript\nvar a = 0b001;\nvar b = 0b010;\nvar c = 0b100;\n```\n&emsp;&emsp;我们现在对一个`demo`变量进行属性的赋值，比如我想要这个`demo`变量拥有**属性a**和**属性c**。那我只需要`var demo = a | c`。在后续我对`demo`进行一个拥有属性判断的时候，我只需要使用`&`，如果得到的结果大于0，即转换为`true`，就说明`demo`拥有该属性。如我想要判断`demo`是否含有`a`属性，只需要`if (demo | a) { /* ... */ }`即可。如果我想要给`demo`添加一个属性，比如添加属性`b`，只需要将`demo |= b`即可，如果不是很了解一元操作符的同学，可以去`mdn`上面查一下相关的资料就能明白。\n\n&emsp;&emsp;我们前面在`legacyCreateRootFromDOMContainer`函数的注释中提到过，rootTag是通过`LegacyRoot | BatchedRoot | ConcurrentRoot`取得的三个模式的综合。所以`createHostRootFiber`这里我们走的是最后一个`else`分支，`mode=NoMode`。然后创建`Fiber`节点。\n\n&emsp;&emsp;`Fiber`节点就是对应每一个`ReactElement`的节点了，它上面记载了很多我们熟悉的属性，比如`ref`，比如`props`相关的`pendingProps`，`memoizedProps`。然后还需要关注一下的概念就是`expirationTime`。`expirationTime`前面`root`的时候也提到了，这是节点更新操作的依据，在后续的源码部分也会单独拆分一章节来阐述它。\n\n&emsp;&emsp;还需要提一下的是我注释了`Fiber`相关的几个属性`sibling，return，child`。`react`中的`Fiber`节点对应的是一个单向列表结构。比如我有这样的一个`jsx`结构：\n\n```javascript\nfunction Demo() {\n  return (\n    <ul>\n      <li></li>\n      <li></li>\n      <li></li>\n    </ul>\n  );\n}\n```\n&emsp;&emsp;那么这个结构在`Fiber`中会这样存在`ul.child -> li(1).sibling -> li(2).sibling -> li(3)`。每个节点的`return`则对应总的父节点`li(1).return -> ul`。\n\n&emsp;&emsp;这一章当中，我们简单看了一下`ReactDom.render`的总体函数逻辑和创建数据结构部分的源码。首次创建的时候，`render`会创建一个`FiberRootNode`对象，该对象作为整个**React应用**的根节点，同时给`RootNode`创建对应的`Fiber`对象。每一个`Fiber`对象对应一个`ReactElement`元素，它带有各种用于`React`调度的属性元素，`DOM`以单向链表的数据结存在于`React`应用当中。\n\n&emsp;&emsp;下一章我们会接着`render`函数的逻辑进入`unbatchedUpdates`部分代码，大体介绍一下`React-dom`在更新中的一些框架设计。","slug":"react/reactCode-react-2","published":1,"updated":"2020-06-11T01:43:32.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxu001k9r2v1sdleikj","content":"<p>&emsp;&emsp;react-dom入口函数以及基本数据类型。阅读React包的源码版本为<strong>16.8.6</strong>。<br><a id=\"more\"></a><br>&emsp;&emsp;在<a href=\"../reactCode-react-1-2019-12-01/\" target=\"_blank\">第一章节</a>我们了解到，<code>react</code>包本质上是一个<code>数据结构</code>建立的抽象屏障，提供起来供react的其它包，诸如<code>react-dom</code>，<code>react-native</code>调用。在这一章中，进入<code>react-dom</code>的源码阅读。</p>\n<p>&emsp;&emsp;根据<code>package.json</code>的<code>main</code>字段入口，我们可以找到<code>react-dom</code>的入口文件为<code>src/client/ReactDOM.js</code>。我们发现该文件最后的代码<code>export default ReactDOM</code>仅仅对外暴露了一个对象模块。我们简单看一下这个对象模块。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 函数内部代码均先省略</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> ReactDOM: <span class=\"hljs-built_in\">Object</span> = &#123;</span><br><span class=\"line\">  createPortal,</span><br><span class=\"line\">  findDOMNode() &#123;  &#125;,</span><br><span class=\"line\">  hydrate() &#123;&#125;,</span><br><span class=\"line\">  render() &#123;&#125;,</span><br><span class=\"line\">  unstable_renderSubtreeIntoContainer() &#123;&#125;,</span><br><span class=\"line\">  unmountComponentAtNode() &#123;&#125;,</span><br><span class=\"line\">  unstable_createPortal() &#123;&#125;,</span><br><span class=\"line\">  unstable_interactiveUpdates() &#123;&#125;,</span><br><span class=\"line\">  unstable_discreteUpdates,</span><br><span class=\"line\">  unstable_flushDiscreteUpdates,</span><br><span class=\"line\">  flushSync,</span><br><span class=\"line\">  unstable_createRoot,</span><br><span class=\"line\">  unstable_createSyncRoot,</span><br><span class=\"line\">  unstable_flushControlled,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其实这里的对象模块就是对面暴露的<code>react-dom</code>提供的Api部分。我们可以看到包括最熟悉的<code>render</code>方法，用于服务端渲染的<code>hydrate</code>，还有<code>findDOMNode</code>，<code>createPortal</code>等。</p>\n<p>&emsp;&emsp;我们本章节就来查看下最常使用的<code>render</code>函数的源码大体逻辑结构。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 调用方式 ReactDOM.render(element, container[, callback])</span></span><br><span class=\"line\">render(</span><br><span class=\"line\">    element: React$Element&lt;any&gt;,</span><br><span class=\"line\">    container: DOMContainer,</span><br><span class=\"line\">    callback: ?<span class=\"hljs-built_in\">Function</span>,</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 判断dom节点是否正确</span></span><br><span class=\"line\">    invariant(</span><br><span class=\"line\">      isValidContainer(container),</span><br><span class=\"line\">      <span class=\"hljs-string\">'Target container is not a DOM element.'</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">      <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">      element,</span><br><span class=\"line\">      container,</span><br><span class=\"line\">      <span class=\"hljs-literal\">false</span>,</span><br><span class=\"line\">      callback,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>react-dom</code>源码中使用了<code>flow</code>来定义数据类型，函数入参中如<code>element: React$Element&lt;any&gt;</code>这种写法就是<code>flow</code>的语法。近似于<code>typescript</code>。</p>\n<p>&emsp;&emsp;<code>render</code>函数在除去<code>DEV</code>调试部分逻辑后，剩余的代码非常简单，判断传入的<code>container</code>节点是否为<code>Dom</code>节点，是就进入<code>legacyRenderSubtreeIntoContainer</code>函数，我们来跟着代码接着看。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">legacyRenderSubtreeIntoContainer</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  children: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  <span class=\"hljs-regexp\">//</span> 是否复用dom节点，服务端渲染调用</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  forceHydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 从 container 中获得root节点</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> root: _ReactSyncRoot = (container._reactRootContainer: any);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> fiberRoot;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 没有root，创建root节点， 移除所有子节点</span></span><br><span class=\"line\">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class=\"line\">      container,</span><br><span class=\"line\">      forceHydrate,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 有无callback</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callback === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Initial mount should not be batched.</span></span><br><span class=\"line\">    unbatchedUpdates(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 有无callback 逻辑同上</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callback === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Update</span></span><br><span class=\"line\">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>legacyRenderSubtreeIntoContainer</code>首先取出<code>container</code>中的<code>root</code>节点，根据有无<code>root节</code>点来划分不同的创建更新逻辑。首次使用<code>render</code>函数的时候是不存在<code>root</code>节点的，此时通过<code>legacyCreateRootFromDOMContainer</code>创建一个<code>root</code>节点给<code>container._reactRootContainer</code>。然后如果存在<code>callback</code>就进行调用，最后进行了一个<code>unbatchedUpdates</code>。存在<code>root</code>节点的时候，就省去了创建<code>root</code>节点部分的代码，直接进行<code>callback</code>的判断和<code>updateContainer</code>。</p>\n<p>&emsp;&emsp;我们先来看创建<code>root</code>节点的<code>legacyCreateRootFromDOMContainer</code>部分的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">legacyCreateRootFromDOMContainer</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  forceHydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">_ReactSyncRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> shouldHydrate =</span><br><span class=\"line\">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// First clear any existing content.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 不需要进行 shouldHydrate 过程，即我们正常的render过程</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!shouldHydrate) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> warned = <span class=\"hljs-literal\">false</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> rootSibling;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 当有子节点的时候，一直循环，删除完子节点</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class=\"line\">      container.removeChild(rootSibling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Legacy roots are not batched.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * LegacyRoot 为一个常量标识符，具体细节如下</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * export type RootTag = 0 | 1 | 2;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * export const LegacyRoot = 0;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * export const BatchedRoot = 1;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * export const ConcurrentRoot = 2;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ReactSyncRoot(container, LegacyRoot, shouldHydrate);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;前面提到过，<code>forceHydrate</code>这个布尔值是用于标识是否是服务端渲染的，在浏览器环境下是不触碰这部分的逻辑的，这个相关部分就先跳过。那么<code>legacyCreateRootFromDOMContainer</code>就做了两件事情：</p>\n<ol>\n<li>删除<code>container</code>容器部分的所有子节点。这也就是为什么我们使用<code>ReactDom.render</code>渲染在目标节点之后，节点的子元素全部消失的原因。</li>\n<li>返回了<code>ReactSyncRoot</code>类，实例化了一个<code>root</code>根节点的实例。</li>\n</ol>\n<p>&emsp;&emsp;接下来的<code>ReactSyncRoot</code>代码更简单：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ReactSyncRoot</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  hydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> root = createContainer(container, tag, hydrate);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>._internalRoot = root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们追寻<code>createContainer</code>函数，发现这个函数文件在<code>react-reconciler/src/ReactFiberReconciler</code>包中。我们跟着去查看一下：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createContainer</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  containerInfo: Container,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  hydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">OpaqueRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> createFiberRoot(containerInfo, tag, hydrate);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 在 `react-reconciler/src/ReactFiberRoot`文件中</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createFiberRoot</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  containerInfo: any,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  hydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">FiberRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> root: FiberRoot = (<span class=\"hljs-keyword\">new</span> FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// Cyclic construction. This cheats the type system right now because</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// stateNode is any.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 相互指</span></span><br><span class=\"line\">  root.current = uninitializedFiber;</span><br><span class=\"line\">  uninitializedFiber.stateNode = root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// fiber root 结构的真身</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">FiberRootNode</span>(<span class=\"hljs-params\">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// root 节点对应的Fiber对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.current = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// dom 节点</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.containerInfo = containerInfo;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 持久化更新会用到</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.pendingChildren = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.pingCache = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.finishedExpirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.finishedWork = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.timeoutHandle = noTimeout;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.context = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.pendingContext = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.hydrate = hydrate;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.firstBatch = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.callbackNode = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.callbackExpirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.firstPendingTime = NoWork;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.lastPendingTime = NoWork;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.pingTime = NoWork;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (enableSchedulerTracing) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.memoizedInteractions = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.pendingInteractionMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;终于在<code>FiberRootNode</code>中发现了rootRoot的真身，就是一个带标识的对象。其中比较重要的一个为<code>containerInfo</code>，就是<code>reactElement</code>将要渲染上的容器节点信息。我们还能发现，很多标识赋值了<code>NoWork</code>，<code>NoWork</code>设计到后续我们更新会提及的<code>ExpirationTime</code>的概念，是<code>React</code>更新算法的基础。目前你可以就把<code>NoWork</code>理解为一个标识<code>0</code>的常量（<code>源码export const NoWork = 0;</code>）。</p>\n<p>&emsp;&emsp;我们最后来看<code>current</code>，在<code>createFiberRoot</code>中将其指向了<code>createHostRootFiber</code>创建的<code>uninitializedFiber</code>。这个<code>uninitializedFiber</code>就是<code>reactElement</code>对应的<code>fiber</code>节点，我们一起来看一下这部分逻辑。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 位于react-reconciler/src/ReactFiber.js</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createHostRootFiber</span>(<span class=\"hljs-params\">tag: RootTag</span>): <span class=\"hljs-title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> mode;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 根据 tag 的不同，获得不同的mode模式</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class=\"line\">    mode = ConcurrentMode | BatchedMode | StrictMode;</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (tag === BatchedRoot) &#123;</span><br><span class=\"line\">    mode = BatchedMode | StrictMode;</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    mode = NoMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Always collect profile timings when DevTools are present.</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// This enables DevTools to start capturing timing at any point–</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// Without some nodes in the tree having empty base times.</span></span><br><span class=\"line\">    mode |= ProfileMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> createFiber(HostRoot, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, mode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> createFiber = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  key: null | string,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">FiberNode</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  key: null | string,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.elementType = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.stateNode = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.return = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.child = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.sibling = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.index = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.ref = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// pendingProps 将要更新</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.pendingProps = pendingProps;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 之前的props</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.memoizedProps = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// update对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.updateQueue = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.memoizedState = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.dependencies = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.mode = mode;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Effects，标记组件生命周期，以及组件是否需要更新</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.effectTag = NoEffect;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.nextEffect = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.firstEffect = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.lastEffect = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.expirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.childExpirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.alternate = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (enableProfilerTimer) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.actualDuration = <span class=\"hljs-built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.actualStartTime = <span class=\"hljs-built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.selfBaseDuration = <span class=\"hljs-built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.treeBaseDuration = <span class=\"hljs-built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// This won't trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.actualDuration = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.actualStartTime = <span class=\"hljs-number\">-1</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.selfBaseDuration = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.treeBaseDuration = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这部分逻辑比较长，我们来拆成两部来看。<code>createHostRootFiber</code>总共做了两件事情，根据<code>tag</code>存在的标识，调整了<code>mode</code>字段。然后使用<code>mode</code>字段创建了<code>FiberNode</code>对象。</p>\n<p>&emsp;&emsp;这里我们稍微提一下使用<code>|</code>和<code>&amp;</code>来进行一个打标的设计模式。比如我现在有三个属性的标识符<code>a/b/c</code>，我们用二进制来定义它们，保证每个模式<code>1</code>所在的位置不同。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0b001</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">0b010</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-number\">0b100</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在对一个<code>demo</code>变量进行属性的赋值，比如我想要这个<code>demo</code>变量拥有<strong>属性a</strong>和<strong>属性c</strong>。那我只需要<code>var demo = a | c</code>。在后续我对<code>demo</code>进行一个拥有属性判断的时候，我只需要使用<code>&amp;</code>，如果得到的结果大于0，即转换为<code>true</code>，就说明<code>demo</code>拥有该属性。如我想要判断<code>demo</code>是否含有<code>a</code>属性，只需要<code>if (demo | a) { /* ... */ }</code>即可。如果我想要给<code>demo</code>添加一个属性，比如添加属性<code>b</code>，只需要将<code>demo |= b</code>即可，如果不是很了解一元操作符的同学，可以去<code>mdn</code>上面查一下相关的资料就能明白。</p>\n<p>&emsp;&emsp;我们前面在<code>legacyCreateRootFromDOMContainer</code>函数的注释中提到过，rootTag是通过<code>LegacyRoot | BatchedRoot | ConcurrentRoot</code>取得的三个模式的综合。所以<code>createHostRootFiber</code>这里我们走的是最后一个<code>else</code>分支，<code>mode=NoMode</code>。然后创建<code>Fiber</code>节点。</p>\n<p>&emsp;&emsp;<code>Fiber</code>节点就是对应每一个<code>ReactElement</code>的节点了，它上面记载了很多我们熟悉的属性，比如<code>ref</code>，比如<code>props</code>相关的<code>pendingProps</code>，<code>memoizedProps</code>。然后还需要关注一下的概念就是<code>expirationTime</code>。<code>expirationTime</code>前面<code>root</code>的时候也提到了，这是节点更新操作的依据，在后续的源码部分也会单独拆分一章节来阐述它。</p>\n<p>&emsp;&emsp;还需要提一下的是我注释了<code>Fiber</code>相关的几个属性<code>sibling，return，child</code>。<code>react</code>中的<code>Fiber</code>节点对应的是一个单向列表结构。比如我有这样的一个<code>jsx</code>结构：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Demo</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;<span class=\"hljs-regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">      &lt;li&gt;&lt;/</span>li&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;<span class=\"hljs-regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">    &lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;那么这个结构在<code>Fiber</code>中会这样存在<code>ul.child -&gt; li(1).sibling -&gt; li(2).sibling -&gt; li(3)</code>。每个节点的<code>return</code>则对应总的父节点<code>li(1).return -&gt; ul</code>。</p>\n<p>&emsp;&emsp;这一章当中，我们简单看了一下<code>ReactDom.render</code>的总体函数逻辑和创建数据结构部分的源码。首次创建的时候，<code>render</code>会创建一个<code>FiberRootNode</code>对象，该对象作为整个<strong>React应用</strong>的根节点，同时给<code>RootNode</code>创建对应的<code>Fiber</code>对象。每一个<code>Fiber</code>对象对应一个<code>ReactElement</code>元素，它带有各种用于<code>React</code>调度的属性元素，<code>DOM</code>以单向链表的数据结存在于<code>React</code>应用当中。</p>\n<p>&emsp;&emsp;下一章我们会接着<code>render</code>函数的逻辑进入<code>unbatchedUpdates</code>部分代码，大体介绍一下<code>React-dom</code>在更新中的一些框架设计。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;react-dom入口函数以及基本数据类型。阅读React包的源码版本为<strong>16.8.6</strong>。<br></p>","more":"<br>&emsp;&emsp;在<a href=\"../reactCode-react-1-2019-12-01/\" target=\"_blank\">第一章节</a>我们了解到，<code>react</code>包本质上是一个<code>数据结构</code>建立的抽象屏障，提供起来供react的其它包，诸如<code>react-dom</code>，<code>react-native</code>调用。在这一章中，进入<code>react-dom</code>的源码阅读。</p>\n<p>&emsp;&emsp;根据<code>package.json</code>的<code>main</code>字段入口，我们可以找到<code>react-dom</code>的入口文件为<code>src/client/ReactDOM.js</code>。我们发现该文件最后的代码<code>export default ReactDOM</code>仅仅对外暴露了一个对象模块。我们简单看一下这个对象模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数内部代码均先省略</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ReactDOM: <span class=\"built_in\">Object</span> = &#123;</span><br><span class=\"line\">  createPortal,</span><br><span class=\"line\">  findDOMNode() &#123;  &#125;,</span><br><span class=\"line\">  hydrate() &#123;&#125;,</span><br><span class=\"line\">  render() &#123;&#125;,</span><br><span class=\"line\">  unstable_renderSubtreeIntoContainer() &#123;&#125;,</span><br><span class=\"line\">  unmountComponentAtNode() &#123;&#125;,</span><br><span class=\"line\">  unstable_createPortal() &#123;&#125;,</span><br><span class=\"line\">  unstable_interactiveUpdates() &#123;&#125;,</span><br><span class=\"line\">  unstable_discreteUpdates,</span><br><span class=\"line\">  unstable_flushDiscreteUpdates,</span><br><span class=\"line\">  flushSync,</span><br><span class=\"line\">  unstable_createRoot,</span><br><span class=\"line\">  unstable_createSyncRoot,</span><br><span class=\"line\">  unstable_flushControlled,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其实这里的对象模块就是对面暴露的<code>react-dom</code>提供的Api部分。我们可以看到包括最熟悉的<code>render</code>方法，用于服务端渲染的<code>hydrate</code>，还有<code>findDOMNode</code>，<code>createPortal</code>等。</p>\n<p>&emsp;&emsp;我们本章节就来查看下最常使用的<code>render</code>函数的源码大体逻辑结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用方式 ReactDOM.render(element, container[, callback])</span></span><br><span class=\"line\">render(</span><br><span class=\"line\">    element: React$Element&lt;any&gt;,</span><br><span class=\"line\">    container: DOMContainer,</span><br><span class=\"line\">    callback: ?<span class=\"built_in\">Function</span>,</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断dom节点是否正确</span></span><br><span class=\"line\">    invariant(</span><br><span class=\"line\">      isValidContainer(container),</span><br><span class=\"line\">      <span class=\"string\">'Target container is not a DOM element.'</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class=\"line\">      <span class=\"literal\">null</span>,</span><br><span class=\"line\">      element,</span><br><span class=\"line\">      container,</span><br><span class=\"line\">      <span class=\"literal\">false</span>,</span><br><span class=\"line\">      callback,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>react-dom</code>源码中使用了<code>flow</code>来定义数据类型，函数入参中如<code>element: React$Element&lt;any&gt;</code>这种写法就是<code>flow</code>的语法。近似于<code>typescript</code>。</p>\n<p>&emsp;&emsp;<code>render</code>函数在除去<code>DEV</code>调试部分逻辑后，剩余的代码非常简单，判断传入的<code>container</code>节点是否为<code>Dom</code>节点，是就进入<code>legacyRenderSubtreeIntoContainer</code>函数，我们来跟着代码接着看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyRenderSubtreeIntoContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  children: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span> 是否复用dom节点，服务端渲染调用</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  forceHydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从 container 中获得root节点</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> root: _ReactSyncRoot = (container._reactRootContainer: any);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fiberRoot;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没有root，创建root节点， 移除所有子节点</span></span><br><span class=\"line\">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class=\"line\">      container,</span><br><span class=\"line\">      forceHydrate,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"comment\">// 有无callback</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Initial mount should not be batched.</span></span><br><span class=\"line\">    unbatchedUpdates(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"comment\">// 有无callback 逻辑同上</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Update</span></span><br><span class=\"line\">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>legacyRenderSubtreeIntoContainer</code>首先取出<code>container</code>中的<code>root</code>节点，根据有无<code>root节</code>点来划分不同的创建更新逻辑。首次使用<code>render</code>函数的时候是不存在<code>root</code>节点的，此时通过<code>legacyCreateRootFromDOMContainer</code>创建一个<code>root</code>节点给<code>container._reactRootContainer</code>。然后如果存在<code>callback</code>就进行调用，最后进行了一个<code>unbatchedUpdates</code>。存在<code>root</code>节点的时候，就省去了创建<code>root</code>节点部分的代码，直接进行<code>callback</code>的判断和<code>updateContainer</code>。</p>\n<p>&emsp;&emsp;我们先来看创建<code>root</code>节点的<code>legacyCreateRootFromDOMContainer</code>部分的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyCreateRootFromDOMContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  forceHydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">_ReactSyncRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldHydrate =</span><br><span class=\"line\">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class=\"line\">  <span class=\"comment\">// First clear any existing content.</span></span><br><span class=\"line\">  <span class=\"comment\">// 不需要进行 shouldHydrate 过程，即我们正常的render过程</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!shouldHydrate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> warned = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rootSibling;</span><br><span class=\"line\">    <span class=\"comment\">// 当有子节点的时候，一直循环，删除完子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class=\"line\">      container.removeChild(rootSibling);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Legacy roots are not batched.</span></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * LegacyRoot 为一个常量标识符，具体细节如下</span></span><br><span class=\"line\"><span class=\"comment\">   * export type RootTag = 0 | 1 | 2;</span></span><br><span class=\"line\"><span class=\"comment\">   * export const LegacyRoot = 0;</span></span><br><span class=\"line\"><span class=\"comment\">   * export const BatchedRoot = 1;</span></span><br><span class=\"line\"><span class=\"comment\">   * export const ConcurrentRoot = 2;</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReactSyncRoot(container, LegacyRoot, shouldHydrate);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;前面提到过，<code>forceHydrate</code>这个布尔值是用于标识是否是服务端渲染的，在浏览器环境下是不触碰这部分的逻辑的，这个相关部分就先跳过。那么<code>legacyCreateRootFromDOMContainer</code>就做了两件事情：</p>\n<ol>\n<li>删除<code>container</code>容器部分的所有子节点。这也就是为什么我们使用<code>ReactDom.render</code>渲染在目标节点之后，节点的子元素全部消失的原因。</li>\n<li>返回了<code>ReactSyncRoot</code>类，实例化了一个<code>root</code>根节点的实例。</li>\n</ol>\n<p>&emsp;&emsp;接下来的<code>ReactSyncRoot</code>代码更简单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReactSyncRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Tag is either LegacyRoot or Concurrent Root</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> root = createContainer(container, tag, hydrate);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._internalRoot = root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们追寻<code>createContainer</code>函数，发现这个函数文件在<code>react-reconciler/src/ReactFiberReconciler</code>包中。我们跟着去查看一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  containerInfo: Container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">OpaqueRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createFiberRoot(containerInfo, tag, hydrate);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 `react-reconciler/src/ReactFiberRoot`文件中</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFiberRoot</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  containerInfo: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: RootTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  hydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">FiberRoot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> root: FiberRoot = (<span class=\"keyword\">new</span> FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cyclic construction. This cheats the type system right now because</span></span><br><span class=\"line\">  <span class=\"comment\">// stateNode is any.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> uninitializedFiber = createHostRootFiber(tag);</span><br><span class=\"line\">  <span class=\"comment\">// 相互指</span></span><br><span class=\"line\">  root.current = uninitializedFiber;</span><br><span class=\"line\">  uninitializedFiber.stateNode = root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fiber root 结构的真身</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FiberRootNode</span>(<span class=\"params\">containerInfo, tag, hydrate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"comment\">// root 节点对应的Fiber对象</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.current = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// dom 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.containerInfo = containerInfo;</span><br><span class=\"line\">  <span class=\"comment\">// 持久化更新会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingChildren = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pingCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.finishedExpirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.finishedWork = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeoutHandle = noTimeout;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.context = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingContext = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.hydrate = hydrate;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.firstBatch = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.callbackNode = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.callbackExpirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.firstPendingTime = NoWork;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.lastPendingTime = NoWork;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pingTime = NoWork;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableSchedulerTracing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.interactionThreadID = unstable_getThreadID();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.memoizedInteractions = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pendingInteractionMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;终于在<code>FiberRootNode</code>中发现了rootRoot的真身，就是一个带标识的对象。其中比较重要的一个为<code>containerInfo</code>，就是<code>reactElement</code>将要渲染上的容器节点信息。我们还能发现，很多标识赋值了<code>NoWork</code>，<code>NoWork</code>设计到后续我们更新会提及的<code>ExpirationTime</code>的概念，是<code>React</code>更新算法的基础。目前你可以就把<code>NoWork</code>理解为一个标识<code>0</code>的常量（<code>源码export const NoWork = 0;</code>）。</p>\n<p>&emsp;&emsp;我们最后来看<code>current</code>，在<code>createFiberRoot</code>中将其指向了<code>createHostRootFiber</code>创建的<code>uninitializedFiber</code>。这个<code>uninitializedFiber</code>就是<code>reactElement</code>对应的<code>fiber</code>节点，我们一起来看一下这部分逻辑。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位于react-reconciler/src/ReactFiber.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHostRootFiber</span>(<span class=\"params\">tag: RootTag</span>): <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mode;</span><br><span class=\"line\">  <span class=\"comment\">// 根据 tag 的不同，获得不同的mode模式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tag === ConcurrentRoot) &#123;</span><br><span class=\"line\">    mode = ConcurrentMode | BatchedMode | StrictMode;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag === BatchedRoot) &#123;</span><br><span class=\"line\">    mode = BatchedMode | StrictMode;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    mode = NoMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Always collect profile timings when DevTools are present.</span></span><br><span class=\"line\">    <span class=\"comment\">// This enables DevTools to start capturing timing at any point–</span></span><br><span class=\"line\">    <span class=\"comment\">// Without some nodes in the tree having empty base times.</span></span><br><span class=\"line\">    mode |= ProfileMode;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> createFiber(HostRoot, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, mode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createFiber = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: null | string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Fiber</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FiberNode</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  tag: WorkTag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  pendingProps: mixed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: null | string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  mode: TypeOfMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.tag = tag;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elementType = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.type = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.stateNode = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.return = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.child = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sibling = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.index = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.ref = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// pendingProps 将要更新</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.pendingProps = pendingProps;</span><br><span class=\"line\">  <span class=\"comment\">// 之前的props</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.memoizedProps = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// update对象</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.updateQueue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.memoizedState = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.dependencies = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.mode = mode;</span><br><span class=\"line\">  <span class=\"comment\">// Effects，标记组件生命周期，以及组件是否需要更新</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.effectTag = NoEffect;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.nextEffect = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.firstEffect = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.lastEffect = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.expirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.childExpirationTime = NoWork;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alternate = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enableProfilerTimer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualStartTime = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.selfBaseDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.treeBaseDuration = <span class=\"built_in\">Number</span>.NaN;</span><br><span class=\"line\">    <span class=\"comment\">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// This won't trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.actualStartTime = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.selfBaseDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.treeBaseDuration = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这部分逻辑比较长，我们来拆成两部来看。<code>createHostRootFiber</code>总共做了两件事情，根据<code>tag</code>存在的标识，调整了<code>mode</code>字段。然后使用<code>mode</code>字段创建了<code>FiberNode</code>对象。</p>\n<p>&emsp;&emsp;这里我们稍微提一下使用<code>|</code>和<code>&amp;</code>来进行一个打标的设计模式。比如我现在有三个属性的标识符<code>a/b/c</code>，我们用二进制来定义它们，保证每个模式<code>1</code>所在的位置不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0b001</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0b010</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">0b100</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在对一个<code>demo</code>变量进行属性的赋值，比如我想要这个<code>demo</code>变量拥有<strong>属性a</strong>和<strong>属性c</strong>。那我只需要<code>var demo = a | c</code>。在后续我对<code>demo</code>进行一个拥有属性判断的时候，我只需要使用<code>&amp;</code>，如果得到的结果大于0，即转换为<code>true</code>，就说明<code>demo</code>拥有该属性。如我想要判断<code>demo</code>是否含有<code>a</code>属性，只需要<code>if (demo | a) { /* ... */ }</code>即可。如果我想要给<code>demo</code>添加一个属性，比如添加属性<code>b</code>，只需要将<code>demo |= b</code>即可，如果不是很了解一元操作符的同学，可以去<code>mdn</code>上面查一下相关的资料就能明白。</p>\n<p>&emsp;&emsp;我们前面在<code>legacyCreateRootFromDOMContainer</code>函数的注释中提到过，rootTag是通过<code>LegacyRoot | BatchedRoot | ConcurrentRoot</code>取得的三个模式的综合。所以<code>createHostRootFiber</code>这里我们走的是最后一个<code>else</code>分支，<code>mode=NoMode</code>。然后创建<code>Fiber</code>节点。</p>\n<p>&emsp;&emsp;<code>Fiber</code>节点就是对应每一个<code>ReactElement</code>的节点了，它上面记载了很多我们熟悉的属性，比如<code>ref</code>，比如<code>props</code>相关的<code>pendingProps</code>，<code>memoizedProps</code>。然后还需要关注一下的概念就是<code>expirationTime</code>。<code>expirationTime</code>前面<code>root</code>的时候也提到了，这是节点更新操作的依据，在后续的源码部分也会单独拆分一章节来阐述它。</p>\n<p>&emsp;&emsp;还需要提一下的是我注释了<code>Fiber</code>相关的几个属性<code>sibling，return，child</code>。<code>react</code>中的<code>Fiber</code>节点对应的是一个单向列表结构。比如我有这样的一个<code>jsx</code>结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;li&gt;&lt;/</span>li&gt;</span><br><span class=\"line\">      &lt;li&gt;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;那么这个结构在<code>Fiber</code>中会这样存在<code>ul.child -&gt; li(1).sibling -&gt; li(2).sibling -&gt; li(3)</code>。每个节点的<code>return</code>则对应总的父节点<code>li(1).return -&gt; ul</code>。</p>\n<p>&emsp;&emsp;这一章当中，我们简单看了一下<code>ReactDom.render</code>的总体函数逻辑和创建数据结构部分的源码。首次创建的时候，<code>render</code>会创建一个<code>FiberRootNode</code>对象，该对象作为整个<strong>React应用</strong>的根节点，同时给<code>RootNode</code>创建对应的<code>Fiber</code>对象。每一个<code>Fiber</code>对象对应一个<code>ReactElement</code>元素，它带有各种用于<code>React</code>调度的属性元素，<code>DOM</code>以单向链表的数据结存在于<code>React</code>应用当中。</p>\n<p>&emsp;&emsp;下一章我们会接着<code>render</code>函数的逻辑进入<code>unbatchedUpdates</code>部分代码，大体介绍一下<code>React-dom</code>在更新中的一些框架设计。</p>"},{"title":"标日初级下册复习整理总结","date":"2019-09-21T06:30:00.000Z","_content":"&emsp;&emsp;初级下，自他动词，敬语，动词的意志形，被动型，命令形。\n<!--more-->\n\n## 1.名词的修饰\n动词：简体形式（基本形、た形、ない形、～なかった）\n形1：简体形式（赤いです→赤い、おもしろかったです→おもしろかった） \n- これは明日会議で使う資料です。（〇）   明日会議で使います（×）\n- あれは森さんが今夜泊まるホテルです。\n- あれはゆうべ泊まったホテルです。\n- 今、李さんと話している人はだれですか。\n- あの背が高い男性は森さんです。\n\n形2：词干＋な\n- 操作が簡単なパソコンが欲しいです。\n\n名词：名词1＋の＋名词2\n- 数学が専門の先生が今日休みました。\n\n## 2.自动词和他动词\n常见的两种（自、他动词的）词形对应关系：\n1. 自动词词尾为 aru，他动词词尾为 eru；\n- かかる<->かける\n- 始まる<->始める\n- 閉まる<->閉める\n- 止まる<->止める\n2. 自动词词尾为 eru、ru，他动词词尾为 su。\n- 壊れる<->壊す\n- 消える<->消す\n- 落ちる<->落とす\n\n- 李さんが部屋の電気を消した。→部屋の電気が消えている。\n- 田中さんがドアを開けた。→ドアが開いている。\n\n## 3.形容词的副词性用法\n形1：词尾“い”→“く”\n形2：词干＋に\n- 楽しく生きたい\n- 自由に生きたい\n\n## 4.形容词＋さ：形容词的名词化　\n形1：词尾“い”→“さ”\n形2：词干＋さ\n- この暑さはいつまで続くでしょう。\n- やっと仕事の楽しさが分かった。\n- やっと彼の良さが分かった。\n- 彼のまじめさには参りました。\n\n## 5.动词的命令形\n动1：把基本形的最后一个假名变成相应的“え”段假名；\n- 帰る→帰れ\n- 消す→消せ\n- 行く→行け\n- 待つ→待て\n- 死ぬ→死ね\n动2：把基本形的“る”变成“ろ”；\n- 見る→見ろ\n- 起きる→起きろ\n动3：把“来る（くる）”变成“来い（こい）”，把“する”变成“しろ”。\n- 電気を消せ！\n- 早く書類を提出しろ！\n- 早く来い！\n- 金を返せ！\n- 死ね！\n喊加油“頑張れ”时，女性可使用命令形，除此以外的场合，不宜使用命令形。\n\n## 6.动词的意志形\n动1：把基本形的最后一个假名变成相应的“お”段上的长音；\n- 帰る→帰ろう\n- 書く→書こう\n- 待つ→待とう\n动2：把基本形的“る”变成“よう”；\n- 食べる→食べよう\n- 見る→見よう\n- 寝る→寝よう\n动3：“来る”变成“来よう（こよう）”，“する”变成“しよう”。\n\n1. 表示自己当场形成的决心、意志（多用于自言自语）\n- もう11時だから、寝よう。\n- 明日はテストだ。今晩は勉強しよう。\n2. 表示向对方提议、劝诱（相当于“～ましょう”的简体形）\n- 仕事が終わったら、飲みに行こう。= 飲みに行きましょう。\n- 駅まで送ろう。 \n\n## 7.动词的ば形\n动词ば形：\n动1：把基本形最后一个音变成相应的“え”段上的音，再加“ば”；\n- 書く→書けば\n- 待つ→待てば\n- 読む→読めば\n- 飛ぶ→飛べば\n动2：把基本形的“る”变成“れば”；\n- 食べる→食べれば\n- 見る→見れば\n- 寝る→寝れば\n动3：“来る”变成“来れば（くれば）”，“する”变成“すれば”。\n\n形1ば形：\n一类形容词“ば形”：把词尾“い”变成“ければ”。\n- 楽しい→楽しければ\n- 広い→広ければ\n- 安い→安ければ\n- いい→よければ\n\n表示前项是后项的条件，“要怎么样，才会这样”。\n- どうすれば、東大に入ることができますか。\n——申請して、入学試験と面接に合格すれば、入ることができますよ。\n- 急がなければ、遅れますよ。\n- 旅行に行けば、彼のことが忘れられるでしょう。\n\n## 8.动词的可能形式\n动1：把基本形的最后一个音变成相应的“え”段上的音，再加“る”；\n- 書く→書ける\n- 話す→話せる\n- 乗る→乗れる\n- 飛ぶ→飛べる\n动2：把基本形的“る”变成“られる”；\n- 食べる→食べられる\n- 見る→見られる\n- 寝る→寝られる\n动3：“来る”变成“来られる（こられる）”，“する”变成“できる”。\n相当于“～ことができる”。\n1. 表示能力。\n- 李さんは日本語が話せます。＝李さんは日本語を話すことができます。\n- わたしは自転車に乗れません。\n\n2. 表示条件允许或可能性。\n- 日本では、女性は16歳、男性は18歳から結婚できます。\n- このキノコは食べられますか。\n\n在可能形式的前面，表示能力的对像，用助词“が”表示。\n\n## 9.动词被动形式\n动1：把“ない形”的“ない”变成“れる”；\n- 書く→書かれる\n- 読む→読まれる\n- 叱る→叱られる\n- 笑う→笑われる\n动2：把“ない形”的“ない”变成“られる”；\n- 食べる→食べられる\n- 見る→見られる\n- 褒める→褒められる\n动3：“来る”变成“来られる（こられる）”，“する”变成“される”。\n被动句的四种句型\n1. 直接被动句\n- 兄が弟を叱る。→弟が兄に叱られる。\n- 兄が弟に話しかける。→弟が兄に話しかけられる。\n2. 持有者被动句：\n- 今朝、電車の中で財布を盗まれた。　　（〇）わたしの財布が盗まれた。　　　　　　（×）\n- 李さんは昨日犬に手を噛まれました。　（〇）\n3. 受害被动句\n- 主动句：鳥が逃げました。→陳さんは鳥に逃げられました。\n- 張さんは昨日隣の人に夜遅くまで騒がれました。\n- 食事中、隣の人にタバコを吸われました。\n- 父に死なれて、大学を続けられなくなりました。\n4. 事物做主语的被动句\n- この歌は世界中で歌われています。\n- この本は世界中の子どもたちに読まれています。\n当动作主体是特定的人时，用“によって”表示动作主体。\n-『阿Q正伝』は魯迅によって書かれました。\n\n## 10.动词的使役形式  \n动1：把“ない形”的“ない”变成“せる”；\n- 書く→書かせる\n- 急ぐ→急がせる\n- 待つ→待たせる\n- 読む→読ませる\n- やる→やらせる\n动2：把“ない形”的“ない”变成“させる”；\n- 食べる→食べさせる\n- 見る→見させる\n动3：把“来る”变成“来させる（こさせる）”，把“する”变成“させる”。\n使役句的两种结构：\n1. 自动词的使役句\n- 部長は李さんを出張させます。\n- あの課長は部下を休ませません。\n2. 他动词的使役句\n- 部長は太田さんにレポートを書かせます。\n- 先生は生徒にこの本を読ませます。\n使役句的三种用法\n1. 强制，要求，指示（让~做……）\n- 部長は太田さんにレポートを書かせます。\n- 先生は生徒にこの本を読ませます。\n\n2. 许可、放任（让~做……，允许~做……）\n- あの課長は部下を休ませません。\n- 子供にできるだけ好きなことをさせたいです。\n\n3. 原因、导致（让……，使……）\n- 弟はよく両親を心配させます。\n- お待たせしました。\n\n## 11.动词的使役被动形式 \n动1：“ない形”的“ない”→“せられる”→“される”；\n动2：“ない形”的“ない”→“させられる” ；\n动3：“来る”变成“来させられる（こさせられる）”，“する”变成“させられる”。\n\n动1中，除以「す」结尾的动词外，可将使役被动形式中的「せら」约音为「さ」。\n结构：[被迫动作主体]は[要求做动作者]に～[使役被动]ます。\n- 選手は監督に走らされます。     \n- 生徒は先生にこの本を読ませられます／読まされます。\n- 小さいとき、母にピアノを習わされました。\n\n## 12.尊他语\n通过抬高话题中的动作主体，而对动作主体表示敬意。\n动词的尊他语的形式：\n1. ～（ら）れる\nI类动词：动词ない形（ない）＋れる  - 行く→行かれる\nII类动词：动词ない形（ない）＋られる  - 教える→教えられる\nIII类动词：来る→来られる、～する→～される\n- 周先生は明日日本へ行かれます。\n- 今朝何時に起きられましたか。\n\n2. お／ご～になる\nお＋I类动词／II类动词ます形去掉ます＋になる\nご＋III类动词的汉字部分+になる  \n- お客様はもうお帰りになりましたか。 \n- 明日の会議には、社長もご出席になるそうです。\n\n3. 特殊形式\n- 先生、何を召し上がりますか。\n\n## 13.自谦语\n通过贬低动作主体（自己或己方人员），从而相对地对动作接受者表示敬意\n动词的自谦语的形式：\n\n1. お／ご～する\nお＋I类动词／II类动词ます形去掉ます＋する　\nご＋III类动词的汉字部分+する  \n- 私は夕べ社長を車でお送りしました。\n- お荷物をお持ちしましょうか。\n- 明日の午後、ご連絡します。\n\n2. 特殊的自谦语动词\n- 先日、先生のお宅に伺いました。\n- 先生の論文を拝見しました。\n\n## 14.～間 ～間に\n～間：某动作或状态持续的期间\n～間に：某动作或事情发生或完成的期间范围。\n- 子どもが寝ている間、ずっと家事をしていました。\n- 子どもが寝ている間に、家事を済ませたいです。\n- 夏休みの間、ずっとアルバイトをしていました。\n- 夏休みの間に、レポートを書き終わりました。\n\n## 15. お・ご～します<自谦语>\n## 16. お・ご～になります<尊他语>　\n\n## 17.～終わります\n～はじめる・～だす・～つづける・～おわる\n[动(ます形去掉ます.]+始める：开始……\n[动(ます形去掉ます.]+出す：突然开始……\n[动(ます形去掉ます.]+続ける：表示持续做某事\n[动(ます形去掉ます.]+終わる：表示动作或事情结束\n\n- 雨が降り始めました。\n- 子どもが急に泣き出しました。\n- ３時間も待ち続けていたけど、彼は結局来てくれなかった。\n- この本はもう読み終わりましたか。\n降る＋つづく\n- 雨が１週間も降り続きました。\n\n## 18.（～が～）～は／が～　名词修饰句节\n经修饰的名词短语可以在句子中充当各种成分。\n名词修饰句节（定语从句）中的小主语要用“が”，而不用“は”。\n\n-（小野さんが作る）料理はおいしいです。\n-（森さんがくれた）本はこれです。\n-（操作が簡単な）パソコンが欲しいです。\n-（明るくて、頭がいい）男性が好きです。\n\n## 19.～かしら　和「かな」语义相近，前接简体形式，多为女性使用。\n1. 吐露内心疑问的自言自语。- 森さんたちは来ているかしら。\n2. 有听话人在场，向对方发问。\n\n## 20.～かもしれない\n表示说话人的推测，认为某事有可能发生，也有可能不发生。\n1. [动词]／[一类形容词小句简体形]+かもしれない\n2. [二类形容词]／[名词小句简体形去だ]+かもしれない\n\n- 小野さんは来ないかもしれません/かもしれない。\n～　　忙しい　　　～\n～　　暇　　　　　～\n～　　病気　　　　～\n\n## 21.～ことがある\n[动词基本形]／[ない形]＋ことがある：“有时……”。\n- 時々課長と一緒にゴルフをすることがあります。\n- 日曜日はいつも家で掃除をします。でも、たまに友達と買い物する\n　こともあります。\n- 彼はいつも返信が早いです。でも、たまに返信しないこともあります。\n\n## 22.～ことにします／～ことにしました：“我决定……”\n　～ことにします：当场下的决心\n- 明日から毎日運動することにします。\n- 今日からお酒を飲まないことにします。\n～ことにしました：已经下定的决心\n- 鈴木さんと結婚することにしました。\n\n## 23.～ことになりました：表示某事客观上定下来。\n- 来月から給料が上がることになりました。\n- 今週は会議を行わないことになりました。\n- ４月から大阪支社に転勤することになりました。\n\n## 24.[动]（さ）せていただきます\n用于礼貌地表达自己的动作。\n- 早速、資料を届けさせていただきます。\n- 明日、もう一度連絡させていただきます。\n\n## 25.[动]（さ）せてください\n请求对方允许自己做某事。\n- 疲れました。少し休ませてください。\n\n## 26.～し、～し　[叙述并列事项][罗列原因]\n- このレストランはおいしいし、雰囲気もいい。\n- このレストランはおいしいし、雰囲気もいいから、よく来ます。\n- もう遅いし、そろそろ失礼します。\n\n## 27.～しか～（否定）　表示“只，仅仅”\n- 教室には李さんしかいません。\n- 私が好きなのはあなたしかいない。\n- 私はワインしか飲みません。\n\n## 28.～過ぎます\n[动词(ます形去掉ます.]+過ぎます\n[一类形(去掉词尾い.]+過ぎます\n[二类形词干]+過ぎます\n表示超过了正常的量或程度。\n- ゆうべは飲み過ぎた。今日は頭が痛い。\n- この本は難しすぎて、読みにくいです。\n- この説明は複雑すぎます。\n\n## 29.～そうです　[传闻]  \n[小句(简体形.]そうです　①　[传闻]\n- 天気予報によると、明日は雨だそうです。\n- 田中さんの話によると、佐藤さんは来月会社を辞めるそうです。\n- あの店はおいしくないそうです。\n\n## 30.～そうです　②　[样态][推测]\n[动词ます形去掉ます]＋そうです\n[一类形容词去掉词尾い]＋そうです\n[二类形容词词干]＋そうです\n- このケーキはおいしそうです。\n- 李さんは仕事が大変そうですね。\n\n## 31.～だけ　只，仅仅\n- 教室には李さんだけいます。\n- 私が好きなのはあなただけです。\n- 在庫は３台だけです。\n\n## 32.～たところです\n～ところです：表示动作处于某种阶段\n1. ～る(基本形.＋ところです：即将进行\n2. ～ている＋ところです：正在进行\n3. ～たところです：刚刚结束\n- もしもし、今どこですか。\n——これから家を出るところです。\n- 論文はできましたか。\n——いいえ、まだです。今、資料を調べているところです。\n- すみません、お待たせして。\n——いいえ、わたしも今着いたところです。\n\n## 33.～たばかりです\n[动]たばかりです：表示动作或事情刚刚结束。\n～たばかりです：可用于动作结束后经过了较长一段时间的事态\n～たところです：一般用于动作结束后经过的时间极短的事态。\n- あの２人は去年結婚したばかりです。（〇） \nあの２人は去年結婚したところです。（×）\n- レポートはできましたか。\n——ええ、今できたところです。（〇） \n\n## 34.~ために、～　[目的]\n[小句1(基本形.]ために、[小句2]　　 \n[名]＋の＋ために、[小句] 　 　\n- 日本へ留学するために、お金を貯めています。\n- 留学のために、日本語を勉強しています。\n前项为意志性的动作；前后主语相同。\n\n## 35.～ために、～　[原因、理由]\n[小句1(简体形.]ために、[小句2]\n[名]＋の＋ために、[小句2]\n[二类形容词]＋な＋ために、[小句2] \n- 事故があったために、電車が遅れたんです。\n- 道路工事のために、道が込んでいます。\n- この村は交通が不便なために、住んでいる人が少ないです。\n小句1多为非意志性的事态或状态。多用于书面语或比较郑重的场合。\n\n## 36.～たら\n接续：将简体过去形式中的“た”变成“たら”。\n多用于一次性的、特定的事件。\n1. 表示假定条件，“假如，要是……的话，……”\n- もし宝くじに当たったら、どうしますか。\n2. 表示既定条件，即“……之后，……”。\n- 仕事が終わったら、飲みに行こう。\n- 空港に着いたら、電話してください。\n3. 表示意外发现。\n- カーテンを開けたら、富士山が見えました。\n\n## 37.～ちゃった\n“～てしまった”在口语中较随便的形式。\n- うっかり財布を電車の中に忘れちゃった。\n\n## 38.～続けます\n\n## 39.～つもりです\n接续：动词基本形／ない形＋つもりです\n用法：表示说话人的打算。\n- 今度の連休は旅行に行くつもりです。\n\n## 40.～て／～ないで\n即“～てください／～ないでください”，省略掉“ください”。\n表示祈使或轻微命令，用于关系亲密的人之间。\n- 私の話をちゃんと聞いてよ！\n- まこと、洗濯物入れてよ。\n- 遅れないでね。\n\n## 41.～て～／～ないで～　连接前后小句，表示伴随状态。\n- 眼鏡をかけて本を読みます。\n- 新しい洋服を着てパーティーに行きました。\n- 傘を持たないで出かけました。\n- 傘を持たずに出かけました。\n\n## 42.～て、～／～で、～　[理由、原因]\n[小句1(动／形1.]て、[小句2]  \n[小句1(名／形2.]で、[小句2]\n- 遅くなって、すみません。\n- 最近は忙しくて、彼女に会いたくても時間がありません。\n- 病気で、会社を休みました。\n- 暇で、朝からずっとテレビを見ていました。\n\n## 43.名词＋で　[原因、理由]\n- 昨日は仕事で森さんと会いました。\n- 主人は出張で大阪に行っています。\n\n## 44.で／へ／から／まで／と＋の\n- 東京での生活に慣れましたか。\n- 北京から東京までの便。\n- 見知らぬ女からの手紙。\n- 友達にあげるプレゼント。\n\n## 45.～てあげます\nAは／がBに[动~]てあげる。A为B做某事　B不能是“我”或“我方人员”\n- 森さんはお年寄りの荷物を持ってあげました。\n- きのう妹に新しい携帯を買ってあげました。\nAは／がBに[动~]てもらう。A从B处得到某项帮助／恩惠\n- 森さんは李さんに北京を案内してもらいました。\n- 私は日本人の友達におすしの作り方を教えてもらいました。\nAは／がBに[动~]てくれる。A为B提供某项帮助　B只能是“我”或“我方人员” \n- 友達が私におすしの作り方を教えてくれました。\n- 鈴木さんは傘を貸してくれました。\n\n## 46.～てあります\n[他动词]＋てある：表示某人有意做某事后动作结果的状态存续。\n[自动词]＋ている：表示状态。\n[动词]＋ておく：表示事先做准备。\n\n- 窓を開けておく。　　　[朱丽叶]\n- あの窓が開いている。　[路人]\n- 窓が開けてある。　　　[罗密欧]\n\n## 47.～である　是“～です”的书面语简体形式。 \n- 富士山は日本で最も高い山です。夏の晴れた朝には赤くなって、\n　とても美しいです。\n→富士山は日本で最も高い山である。夏の晴れた朝には赤くなり、\n　とても美しい。\n\n## 48.～ていきます／～てきます\n[空间方向性]\n～ていく：表示离说话人而去，由近及远；\n～てくる：表示向着说话人而来，由远及近。  \n- 飛行機は西から飛んできて、東へ消えていった。\n- 田中さんが校門から走ってきた。\n[时间持续的方向性]\n～てくる：由基准时间点之前向基准时间点推移、变化。\n～ていく：由基准时间点向基准时间点之后推移、变化。\n- 日本で学ぶ留学生の数が増えてきた。これからも増えていくだろう。\n\n## 49.～ていただきます\n是“～てもらいます”的自谦语形式。\n- 黄教授を紹介していただき、ありがとうございました。\n\n## 50.～ていただけますか／～ていただけませんか　[请求]\n用于礼貌的请求别人为自己做某事。\n- この服は小さいので、取り替えていただけますか。\n\n## 51.～ています　[反复][习惯]\n- 北京行きの飛行機は１時間に１便飛んでいます。\n- 祖母は毎朝公園で散歩しています。\n\n## 52.～ています　[结果状态]\n- 吉田さんは車を持っています。\n- 森さんを知っていますか。\n具有自他对应的自动词的“～ています”形式，都是表示结果状态的。\n- 部屋の電気は消えています。\n\n## 53.～ていらっしゃいます\nいらっしゃる：行く／来る／いる的尊他语。\nていらっしゃる：ていく／てくる／ている的尊他语。\n- 社長は会議室で待っていらっしゃいます。　　　　＝ています\n- 木村部長は先ほど戻っていらっしゃいましたよ。　＝てきました\n- 社長はもう東京に帰っていらっしゃいました。　　＝ていきました\n\n## 54.～ているところです\n\n## 55.～ておきます\n1. 为了某个目的而事先做某事；[准备]\n- お客さんが来る前に、部屋を掃除しておきます。\n- 日本へ行く前に、日本語を勉強しておいたほうがいいですよ。\n\n2. 为了某个目的而做某事，并使其结果或效果留存下来。[留存]\n- この辞書、片づけましょうか。\n——いいえ、まだ使いますから、そのままにしておいてください。\n\n## 56.～ております\n是“～ています”的郑重语。\n- 山田社長はいらっしゃいますか。\n——山田はただいま外出しております。\n\n## 57.～てきます／～てきました　[出现]\n- あっ、雨が降ってきた。\n\n## 58.～てくださいます　是“～てくれます”的尊他语。\n- 先生がわたしの論文を見てくださいました。\n- 社長が褒めてくださいました。\n\n## 59.～でございます　是“～です”的非常礼貌的说法。\n- はい、こちらはJC企画上海事務所でございます。\n\n## 60. 差し上げます　是“あげます”的自谦语。\n\n## 61.～てしまう\n1. 完成\n- さあ、最後まで飲んでしまいましょう。\n→さあ、最後まで飲んじゃおう！\n- この本はもう読んでしまったから、あげるよ。\n2. 发生某件结果不理想的事情\n- 大切な書類を電車の中に忘れてしまいました。\n- そんなに無理をすると、病気になってしまいますよ。\n→そんなに無理をすると、病気になっちゃうよ。\n\n## 62. ～でしょう　[推测]\n- 明日は雨になるでしょう。\n- 今はゴールデンウイークですから、どの行楽地も混んでいるでしょう。\n\n## 63. ～でしょう？　[确认]\n- 李さん、明日のパーティーに行くでしょう？　　　　　　（升调）\n- え、このケーキ、おいしいと思うの？まずいでしょう！　（降调）\n- お母さん、私の日記、見たでしょう！　　　　　　　　　（降调）\n\n## 64. ～でしょうか　礼貌的疑问方式。\n- 李さんは来ますか。→李さんは来るでしょうか。\n- コーヒー、いかがですか。→コーヒー、いかがでしょうか。\n\n## 65. ～ですもの／～だもん\n表示说话人认为某事具有正当性，带有不满、抗议、申辩的语气。\n一般为女性和儿童使用。\n- 今月から給料が上がったそうですね。\n——こんなにたくさん仕事しているんですもの。当然でしょう\n- 冷蔵庫の中のケーキを食べちゃったのは太郎でしょう？\n——だってお腹空いちゃったんだもん。\n\n## 66. ～ではありませんか\n用否定疑问句的形式礼貌地表达自己肯定的观点。\n\n## 67. ～てほしい　表达对他人的希望。\n- だれか、手伝ってほしい。\n- 子どもに元気で、自信がある子に育ってほしい。\n- 早く連休が来てほしい。\n\n## 68.～てみます　尝试做某事。\n- ケーキを作ってみました。食べてみてください。\n- 日本語で友達に手紙を書いてみました。\n\n## 69. ～ても、～　[转折]\n- 宝くじに当たっても、仕事を続けます。\n- 明日雨でも、彼女に会いに行きます。\n- いくら聞いても、彼は何も言わなかった。\n\n## 70. 名词＋でも　[提示极端例子]\n- この計算は難しくて、大人でもできません。\n- この森は夏でも涼しい。\n\n## 71. 名词＋でも　[示例]\n- コーヒーでも飲みませんか。\n- 仕事の後、映画でも見ませんか。\n\n## 72. ～てもらいます\n\n## 73. ～と、～\n“一……，就……”，表示恒定不变的真理，反复性状态，习惯等。\n- お酒を飲むと、必ず酔う。\n- 遅刻すると、彼女は必ず怒ります。\n- 兄は冬になると、スキーに行きます。\n后项不可以出现祈使、命令、意志的表达方式。\n还可表示意外的发现，此时后项要使用过去形式。\n- カーテンを開けると、富士山が見えました。\n\n## 74. ～と会います　\nに：用于单向性的动作对象\nと：用于双向性的动作对象\n- さっき駅前で佐藤さんに会いました。\n- さっき駅前で佐藤さんと会いました。\n\n## 75. ～という～　表示称谓，“叫做……”。\n- これはフジという花です。\n\n## 76. ～（よ）うと思います ～（よ）うと思っています\n[动(意志形.]＋と思います　把自己要做某事的意志告诉听话人。\n- 来年結婚しようと思います。\n- 将来、日本へ留学しようと思います。\n[动(意志形.]+ と思っています　表示某种意志持续了一段时间。\n- 今の仕事をやめようと思っています。\n- 将来、日本へ留学しようと思っています。\n- 張さんは将来、日本へ留学しようと思っています。\n\n## 77. ～とか～とか\n- パーティーで、戴さんとか楊さんとか、いろいろな人に会いました。\n- 海外旅行に行きたいとか、新しい車が欲しいとか、ぜいたくなことばかり\n　言っています。\n\n## 78. ～時、～\n- 子供の時、よく祖母と一緒に公園で散歩しました。\n- 映画を見る時、いつもいちばん後ろの席に座ります。\n- 忙しい時、いつもコンビニでお弁当を買って食べます。\n- 暇な時、よく一人で映画を見ます。\n\n## 79. ～ところです\n～る（基本形）+ところです。\n～ている＋ところです。\n～た＋ところです。\n\n## 80. 动词基本形＋な　[禁止]\n使用场合：1. 用于上对下，或有资格对对方发号施令的人；\n2. 特殊、紧急的场合。\n- 仕事をサボるな！\n- 笑うな！\n- 危ない！来るな！\n\n## 81. ～ないと／～ないといけません\n表示必须或义务，“不……不行，不得不……”。  \n- 時間がないから、そろそろ行かないと。\n- 明日までにレポートをまとめないといけません。\n\n## 82. ながら\n动词ます形去掉ます＋ながら， “一边……一边……” \n- テレビを見ながらご飯を食べます。\n- 歩きながら電話をします。\n- 食事をしながら話しましょうか。\n\n## 83. ～なければ／～なければなりません　“必须……，不得不……”\n\n## 84. なさい\n动词ます形去掉ます＋なさい，表示命令。 \n多用于长辈对晚辈、上级对下级、老师对学生等发号施令，语气比命令形柔和些。\n- 早く寝なさい。\n\n## 85. ～なら、～\n接续：简体形式＋なら（形2或名词去掉简体形式中的だ）\n根据对方的言谈或现场情况，陈述自己的意见或想法，以及向对方提出建议、\n忠告。\n- 天安門に行くなら、地下鉄が便利ですよ。\n- お寿司なら、駅前のあのお店がいいですよ。\n- 魚を買うなら、築地市場がいいですよ。\n- 飲んだら乗るな。乗るなら飲むな。\n\n## 86. ～に　[用途][基准]\n[名词]＋に\n[动词基本形]＋のに\n- この写真はパスポートの申請に使います。　　　　　　　　　　　[用途]\nこの写真はパスポートを申請するのに使います。　　　　　　　　[用途]\n- このマンションはスーパーから近くて、買い物に便利です。　　　[基准]\nこのマンションはスーパーから近くて、買い物するのに便利です。[基准]\n\n## 87. ～によると　表示传闻、消息的来源。\n- 天気予報によると、明日は雨だそうです。\n- 田中さんの話によると、佐藤さんは来月会社を辞めるそうです。\n\n## 88. ～によって \n～によって：表示变化的依据，“因……的不同而不同”\n- 飛行機のチケットは高かったり、安かったり、季節によって違います。\n以事物作主语的被动句中，当动作主体是特定的人时，要用によって来提示。\n-『阿Q正伝』は魯迅によって書かれました。\n- この車は日本の有名なデザイナーによって設計されました。\n\n## 89. ～のが～です\n- 自転車に二人で乗るのは危ないです。\n- 一人で映画を見るのが好きです。\n\n## 90. ～のが見えます／～のが聞こえます\n見える：自动词，某种景象映入眼帘。\n聞こえる：自动词，某种声音传入耳朵。\n- 隣の部屋で子どもたちが騒いでいるのが聞こえますか。\n- グラウンドで子どもたちが野球をしているのが見えます。\n\n## 91. ～のために　[目的] ～のために　[理由、原因]\n[动词][1形容词(简体.]+ために\n[名]+の＋ために\n\n## 92. ～ので、～　[理由、原因]\n接续：[动词／一类形容词简体]＋ので\n[名词／二类形容词简体(だ→な.]＋ので\n用法：用于客观叙述某事的原因、理由。\n- 家が遠いので、毎朝はやく起きなければなりません。\n- 目が疲れたので、少し休みます。\n- ここは静かなので、とても気に入っています。\n- もう終電の時間なので、帰ります。\n- 昨日は休みだったので、映画を見に行きました。\n\n## 93. ～のではないでしょうか　[婉转陈述意见]\n表达的是一种委婉的肯定， “不是……吗？”相当于“と思います”，\n语气更委婉。\n- 免税店では女性向けの商品がよく売れるのではないでしょうか。\n\n## 94. ～の時、～\n[名]+の＋時\n表示“……的时候”。\n\n## 95. ～のに　[用途][基准]\n[动词基本形]＋の＋に\n\n## 96. ～のに、～　[转折]\n表示在小句1的情况下发生小句2的情况不符合常识常理，“明明……却，\n可是，偏偏……”。\n- 目覚ましをかけておいたのに、今朝は起きられませんでした。\n- 森さんは家が近いのによく遅刻します。\n- 田中さんは作家なのに、読書が嫌いです。\n接续：[小句1(简体形.]のに、[小句2] \n[名词]／[二类形容词的现在肯定简体形式(だ→な.]＋のに、小句2\n\n## 97. ～のは～です。\n\n## 98. ～のまま、～\n[小句1(动词た形／ない形.]まま、小句2\n[名]＋の＋まま、小句\n- 眼鏡をかけたまま、寝てしまいました。\n- 馬さんは行き先を告げないまま、家を出てしまいました。\n- わたしたちは空腹のまま、出発しました。\n- 講堂に入る時、携帯の電源を切らなければなりませんか。\n　——いいえ、付けたままでいいですよ。\n\n## 99. ～のようです　[推测]\n说话人根据自己感知的情况，进行推测。\n[小句(简体形.]＋ようです  \n[名]＋の＋ようです\n[二类形词干]+な＋ようです\n- 玄関のところにだれかがいるようです。\n- 店の前には行列ができています。あの店の料理はおいしいようです。\n- 値段はほかの店の倍です。ここの料理はかなり豪華なようです。\n- 遠くから何か飛んできます。飛行機のようですね。\n\n## 100. ～のような味／においがします\n味・におい・声・音・感じ＋がする：表示有这种感觉。\n- この野菜、レモンのような味がします。\n- このせっけんは爽やかで、ランのようなにおいがします。\n- ここには昔来たことがあるような感じがします。\n寒気（さむけ）・吐き気（はきけ）・頭痛（ずつう）＋がする\n- 今朝から、ずっと寒気がしています。\n\n## 101. ～のを～\n- 手紙を出すのを忘れました。\n- 吉田さんが転勤するのを知っていますか。\n\n## 102. ～ば、～\n\n## 103. ～は～という～です　用于下定义或做解释。\n- 駐車禁止はここに車を止めるなという意味です。\n- そのマークはここでタバコを吸うなという意味です。\n\n## 110. ～ば～ほど　“越…越…”。\n接续：[动ば形]+[动(基本形.]＋ほど＋[小句]\n[一类形容词ば形]+[一类形容词(原形.]＋ほど＋[小句]\n[二类形容词(词干.]+なら＋[二类形容词(词干.]＋な＋ほど＋[小句]\n[二类形容词(词干.]+であれば＋[二类形容词(词干.]＋な＋ほど＋[小句]\n[二类形容词(词干.]+であれば＋あるほど＋[小句]\n\n- この本は読めば読むほど、おもしろいです。\n- 彼のことを知れば知るほど、好きになる。\n- 商品は安ければ安いほど売れるでしょう？\n\n- 子供は元気なら元気なほどいいです。\n　子供は元気であれば元気なほどいいです。\n\n## 111. ～ばかり～　～ばかりいます\n[名]＋ばかり＋[动]：表示所列举的事物全部相同；“光、净、只……”\n[动(て形.]＋ばかり＋います：表示总是发生同样的事情或总是进行同样的动作。\n　　　　　　　　　　　　　“老是，总是，光……，净……”[反复]\n- 林さんはカラオケで古い歌ばかり歌います。\n- うちの息子は毎日ゲームばかりしています。\n- 張さんは毎日お酒を飲んでばかりいます。\n- 遊んでばかりいないで、しっかり勉強しなさい。\n\n## 112. ～はじめる／～出す\n\n## 113. ～はずがありません\n～はずです\nはずです：表示个人根据某种理由，做好自身认为合情理的推断。\n- 会議は5 時までですから、もうすぐ終わるはずです。\n- 森さんは１時間ほど前に会社を出ましたから、もう家に着いているはずです。\n～はずがない：不可能……\n- 張さんは入院中ですから、旅行に行くはずがありません。\n- 7月のオーストラリアは冬ですから、暑いはずがありません。\n\n## 114. ～までに\n表示某事的截止时间点，即：在……之前，完成或发生某事。    \n- 来週の水曜日までにレポートを提出してください。\n- 今月の末までに、新しい家を見つけたいです。\n～まで：在……之前，持续做某事或某状态。\n- 彼に会うまで、ここで待つ。\n\n## 116. ～ようです／～みたいです　[推测][比喻]\n“ようです”语气正式，“みたいです”口语化。\n\n- 遠くから何か飛んできます。飛行機のようですね。　　　　[推测]\n遠くから何か飛んでくる。飛行機みたいだね。　　　　　　[推测]\n- これは柔らかくて、まるで本物の毛皮のようです。　　　　[比喻]\n- あの子は目が大きくてかわいいね。まるで人形みたいだ。　[比喻]\n- この野菜、レモンのような味がします。　　　　　　　　　[比喻]\n- 鳥のように空を飛んでみたいな。　　　　　　　　　　　　[比喻]\n- 田中さんのお宅はホテルのようにきれいです。　　　　　　[比喻]\n\n## 117. ～も　[超出预想]\n数量词+も+肯定：数量之多。\n- 参加者は50人も超えました。\n- 今日は3リットルも水を飲みました。\n\n## 118. ～やすい／～にくい\n[动词ます形去掉ます]＋やすい：构成形1，表示“易于……”\n[动词ます形去掉ます]＋にくい：构成形1，表示“难于……”\n- このペンは書きやすいです。\n- この本は漢字が多くて、読みにくいです。\n- 雨の日は事故が起こりやすいです。\n- 運動している人は太りにくいです。\n\n## 119. ～ように\n为了使前项成立，而做后项事情。前接非意志性动词，或意志性动词可能形式\n的基本形或ない形。\n- 留学生も分かるように、先生はゆっくり説明してくれました。\n- 子どもが触れないように、この薬は棚のいちばん上に置きましょう。\n\n## 120. ～ようにします\n“努力做到…… ”。前接意志性动词的基本形或ない形。\n- のどが痛いので、今日はあまり話さないようにします。\n- 明日の会議には、できるだけ出るようにします。\n～ようにしている：有意识地将某个习惯保留下来。\n- 陳さんは毎日、英字新聞を読むようにしています。\n- 健康のために、毎日30分ぐらいジョギングをするようにしています。\n\n## 121. ～ようになります\n表示能力、状况等的变化。前接非意志性动词，或意志性动词可能形式的\n基本形或ない形。\n- けがが治って、歩けるようになりました。\n- 赤ちゃんは1歳を過ぎると、言葉を話すようになります。\n\n## 122. [名词]＋らしい～　[典型性]\n- 食事らしい食事\n- 女らしい女\n- 学生なら、学生らしくしっかり勉強しなさい。\n\n## 123. ～らしいです　[推测][传闻]\n[小句(简体形.]＋らしいです\n- 田中さんは来月から大阪支社へ転勤するらしいですよ。　[传闻]\n- 電気が消えています。李さんは出かけたらしいですね。　[推测]\n- 火曜日なのに店が閉まっている。今日は休みらしいね。　[推测]\n\n## 124. ～られます　尊他语形式\n\n## 125. ～んじゃないですか　[婉转陈述意见的表达]\n与“～のではないでしょうか”一样，用否定疑问句的形式，婉转地表达\n自己肯定的意见，但礼貌程度比“～のではないでしょうか”稍低。\n- ここ、いいんじゃないですか。\n- さっきのはもっと広かったんじゃないですか。\n","source":"_posts/nihonngo/nihonngo-2.md","raw":"---\ntitle: 标日初级下册复习整理总结\ndate: 2019/9/21 14:30\ncategories:\n- [日语, 标日初级下册]\ntags:\n- 日语\n---\n&emsp;&emsp;初级下，自他动词，敬语，动词的意志形，被动型，命令形。\n<!--more-->\n\n## 1.名词的修饰\n动词：简体形式（基本形、た形、ない形、～なかった）\n形1：简体形式（赤いです→赤い、おもしろかったです→おもしろかった） \n- これは明日会議で使う資料です。（〇）   明日会議で使います（×）\n- あれは森さんが今夜泊まるホテルです。\n- あれはゆうべ泊まったホテルです。\n- 今、李さんと話している人はだれですか。\n- あの背が高い男性は森さんです。\n\n形2：词干＋な\n- 操作が簡単なパソコンが欲しいです。\n\n名词：名词1＋の＋名词2\n- 数学が専門の先生が今日休みました。\n\n## 2.自动词和他动词\n常见的两种（自、他动词的）词形对应关系：\n1. 自动词词尾为 aru，他动词词尾为 eru；\n- かかる<->かける\n- 始まる<->始める\n- 閉まる<->閉める\n- 止まる<->止める\n2. 自动词词尾为 eru、ru，他动词词尾为 su。\n- 壊れる<->壊す\n- 消える<->消す\n- 落ちる<->落とす\n\n- 李さんが部屋の電気を消した。→部屋の電気が消えている。\n- 田中さんがドアを開けた。→ドアが開いている。\n\n## 3.形容词的副词性用法\n形1：词尾“い”→“く”\n形2：词干＋に\n- 楽しく生きたい\n- 自由に生きたい\n\n## 4.形容词＋さ：形容词的名词化　\n形1：词尾“い”→“さ”\n形2：词干＋さ\n- この暑さはいつまで続くでしょう。\n- やっと仕事の楽しさが分かった。\n- やっと彼の良さが分かった。\n- 彼のまじめさには参りました。\n\n## 5.动词的命令形\n动1：把基本形的最后一个假名变成相应的“え”段假名；\n- 帰る→帰れ\n- 消す→消せ\n- 行く→行け\n- 待つ→待て\n- 死ぬ→死ね\n动2：把基本形的“る”变成“ろ”；\n- 見る→見ろ\n- 起きる→起きろ\n动3：把“来る（くる）”变成“来い（こい）”，把“する”变成“しろ”。\n- 電気を消せ！\n- 早く書類を提出しろ！\n- 早く来い！\n- 金を返せ！\n- 死ね！\n喊加油“頑張れ”时，女性可使用命令形，除此以外的场合，不宜使用命令形。\n\n## 6.动词的意志形\n动1：把基本形的最后一个假名变成相应的“お”段上的长音；\n- 帰る→帰ろう\n- 書く→書こう\n- 待つ→待とう\n动2：把基本形的“る”变成“よう”；\n- 食べる→食べよう\n- 見る→見よう\n- 寝る→寝よう\n动3：“来る”变成“来よう（こよう）”，“する”变成“しよう”。\n\n1. 表示自己当场形成的决心、意志（多用于自言自语）\n- もう11時だから、寝よう。\n- 明日はテストだ。今晩は勉強しよう。\n2. 表示向对方提议、劝诱（相当于“～ましょう”的简体形）\n- 仕事が終わったら、飲みに行こう。= 飲みに行きましょう。\n- 駅まで送ろう。 \n\n## 7.动词的ば形\n动词ば形：\n动1：把基本形最后一个音变成相应的“え”段上的音，再加“ば”；\n- 書く→書けば\n- 待つ→待てば\n- 読む→読めば\n- 飛ぶ→飛べば\n动2：把基本形的“る”变成“れば”；\n- 食べる→食べれば\n- 見る→見れば\n- 寝る→寝れば\n动3：“来る”变成“来れば（くれば）”，“する”变成“すれば”。\n\n形1ば形：\n一类形容词“ば形”：把词尾“い”变成“ければ”。\n- 楽しい→楽しければ\n- 広い→広ければ\n- 安い→安ければ\n- いい→よければ\n\n表示前项是后项的条件，“要怎么样，才会这样”。\n- どうすれば、東大に入ることができますか。\n——申請して、入学試験と面接に合格すれば、入ることができますよ。\n- 急がなければ、遅れますよ。\n- 旅行に行けば、彼のことが忘れられるでしょう。\n\n## 8.动词的可能形式\n动1：把基本形的最后一个音变成相应的“え”段上的音，再加“る”；\n- 書く→書ける\n- 話す→話せる\n- 乗る→乗れる\n- 飛ぶ→飛べる\n动2：把基本形的“る”变成“られる”；\n- 食べる→食べられる\n- 見る→見られる\n- 寝る→寝られる\n动3：“来る”变成“来られる（こられる）”，“する”变成“できる”。\n相当于“～ことができる”。\n1. 表示能力。\n- 李さんは日本語が話せます。＝李さんは日本語を話すことができます。\n- わたしは自転車に乗れません。\n\n2. 表示条件允许或可能性。\n- 日本では、女性は16歳、男性は18歳から結婚できます。\n- このキノコは食べられますか。\n\n在可能形式的前面，表示能力的对像，用助词“が”表示。\n\n## 9.动词被动形式\n动1：把“ない形”的“ない”变成“れる”；\n- 書く→書かれる\n- 読む→読まれる\n- 叱る→叱られる\n- 笑う→笑われる\n动2：把“ない形”的“ない”变成“られる”；\n- 食べる→食べられる\n- 見る→見られる\n- 褒める→褒められる\n动3：“来る”变成“来られる（こられる）”，“する”变成“される”。\n被动句的四种句型\n1. 直接被动句\n- 兄が弟を叱る。→弟が兄に叱られる。\n- 兄が弟に話しかける。→弟が兄に話しかけられる。\n2. 持有者被动句：\n- 今朝、電車の中で財布を盗まれた。　　（〇）わたしの財布が盗まれた。　　　　　　（×）\n- 李さんは昨日犬に手を噛まれました。　（〇）\n3. 受害被动句\n- 主动句：鳥が逃げました。→陳さんは鳥に逃げられました。\n- 張さんは昨日隣の人に夜遅くまで騒がれました。\n- 食事中、隣の人にタバコを吸われました。\n- 父に死なれて、大学を続けられなくなりました。\n4. 事物做主语的被动句\n- この歌は世界中で歌われています。\n- この本は世界中の子どもたちに読まれています。\n当动作主体是特定的人时，用“によって”表示动作主体。\n-『阿Q正伝』は魯迅によって書かれました。\n\n## 10.动词的使役形式  \n动1：把“ない形”的“ない”变成“せる”；\n- 書く→書かせる\n- 急ぐ→急がせる\n- 待つ→待たせる\n- 読む→読ませる\n- やる→やらせる\n动2：把“ない形”的“ない”变成“させる”；\n- 食べる→食べさせる\n- 見る→見させる\n动3：把“来る”变成“来させる（こさせる）”，把“する”变成“させる”。\n使役句的两种结构：\n1. 自动词的使役句\n- 部長は李さんを出張させます。\n- あの課長は部下を休ませません。\n2. 他动词的使役句\n- 部長は太田さんにレポートを書かせます。\n- 先生は生徒にこの本を読ませます。\n使役句的三种用法\n1. 强制，要求，指示（让~做……）\n- 部長は太田さんにレポートを書かせます。\n- 先生は生徒にこの本を読ませます。\n\n2. 许可、放任（让~做……，允许~做……）\n- あの課長は部下を休ませません。\n- 子供にできるだけ好きなことをさせたいです。\n\n3. 原因、导致（让……，使……）\n- 弟はよく両親を心配させます。\n- お待たせしました。\n\n## 11.动词的使役被动形式 \n动1：“ない形”的“ない”→“せられる”→“される”；\n动2：“ない形”的“ない”→“させられる” ；\n动3：“来る”变成“来させられる（こさせられる）”，“する”变成“させられる”。\n\n动1中，除以「す」结尾的动词外，可将使役被动形式中的「せら」约音为「さ」。\n结构：[被迫动作主体]は[要求做动作者]に～[使役被动]ます。\n- 選手は監督に走らされます。     \n- 生徒は先生にこの本を読ませられます／読まされます。\n- 小さいとき、母にピアノを習わされました。\n\n## 12.尊他语\n通过抬高话题中的动作主体，而对动作主体表示敬意。\n动词的尊他语的形式：\n1. ～（ら）れる\nI类动词：动词ない形（ない）＋れる  - 行く→行かれる\nII类动词：动词ない形（ない）＋られる  - 教える→教えられる\nIII类动词：来る→来られる、～する→～される\n- 周先生は明日日本へ行かれます。\n- 今朝何時に起きられましたか。\n\n2. お／ご～になる\nお＋I类动词／II类动词ます形去掉ます＋になる\nご＋III类动词的汉字部分+になる  \n- お客様はもうお帰りになりましたか。 \n- 明日の会議には、社長もご出席になるそうです。\n\n3. 特殊形式\n- 先生、何を召し上がりますか。\n\n## 13.自谦语\n通过贬低动作主体（自己或己方人员），从而相对地对动作接受者表示敬意\n动词的自谦语的形式：\n\n1. お／ご～する\nお＋I类动词／II类动词ます形去掉ます＋する　\nご＋III类动词的汉字部分+する  \n- 私は夕べ社長を車でお送りしました。\n- お荷物をお持ちしましょうか。\n- 明日の午後、ご連絡します。\n\n2. 特殊的自谦语动词\n- 先日、先生のお宅に伺いました。\n- 先生の論文を拝見しました。\n\n## 14.～間 ～間に\n～間：某动作或状态持续的期间\n～間に：某动作或事情发生或完成的期间范围。\n- 子どもが寝ている間、ずっと家事をしていました。\n- 子どもが寝ている間に、家事を済ませたいです。\n- 夏休みの間、ずっとアルバイトをしていました。\n- 夏休みの間に、レポートを書き終わりました。\n\n## 15. お・ご～します<自谦语>\n## 16. お・ご～になります<尊他语>　\n\n## 17.～終わります\n～はじめる・～だす・～つづける・～おわる\n[动(ます形去掉ます.]+始める：开始……\n[动(ます形去掉ます.]+出す：突然开始……\n[动(ます形去掉ます.]+続ける：表示持续做某事\n[动(ます形去掉ます.]+終わる：表示动作或事情结束\n\n- 雨が降り始めました。\n- 子どもが急に泣き出しました。\n- ３時間も待ち続けていたけど、彼は結局来てくれなかった。\n- この本はもう読み終わりましたか。\n降る＋つづく\n- 雨が１週間も降り続きました。\n\n## 18.（～が～）～は／が～　名词修饰句节\n经修饰的名词短语可以在句子中充当各种成分。\n名词修饰句节（定语从句）中的小主语要用“が”，而不用“は”。\n\n-（小野さんが作る）料理はおいしいです。\n-（森さんがくれた）本はこれです。\n-（操作が簡単な）パソコンが欲しいです。\n-（明るくて、頭がいい）男性が好きです。\n\n## 19.～かしら　和「かな」语义相近，前接简体形式，多为女性使用。\n1. 吐露内心疑问的自言自语。- 森さんたちは来ているかしら。\n2. 有听话人在场，向对方发问。\n\n## 20.～かもしれない\n表示说话人的推测，认为某事有可能发生，也有可能不发生。\n1. [动词]／[一类形容词小句简体形]+かもしれない\n2. [二类形容词]／[名词小句简体形去だ]+かもしれない\n\n- 小野さんは来ないかもしれません/かもしれない。\n～　　忙しい　　　～\n～　　暇　　　　　～\n～　　病気　　　　～\n\n## 21.～ことがある\n[动词基本形]／[ない形]＋ことがある：“有时……”。\n- 時々課長と一緒にゴルフをすることがあります。\n- 日曜日はいつも家で掃除をします。でも、たまに友達と買い物する\n　こともあります。\n- 彼はいつも返信が早いです。でも、たまに返信しないこともあります。\n\n## 22.～ことにします／～ことにしました：“我决定……”\n　～ことにします：当场下的决心\n- 明日から毎日運動することにします。\n- 今日からお酒を飲まないことにします。\n～ことにしました：已经下定的决心\n- 鈴木さんと結婚することにしました。\n\n## 23.～ことになりました：表示某事客观上定下来。\n- 来月から給料が上がることになりました。\n- 今週は会議を行わないことになりました。\n- ４月から大阪支社に転勤することになりました。\n\n## 24.[动]（さ）せていただきます\n用于礼貌地表达自己的动作。\n- 早速、資料を届けさせていただきます。\n- 明日、もう一度連絡させていただきます。\n\n## 25.[动]（さ）せてください\n请求对方允许自己做某事。\n- 疲れました。少し休ませてください。\n\n## 26.～し、～し　[叙述并列事项][罗列原因]\n- このレストランはおいしいし、雰囲気もいい。\n- このレストランはおいしいし、雰囲気もいいから、よく来ます。\n- もう遅いし、そろそろ失礼します。\n\n## 27.～しか～（否定）　表示“只，仅仅”\n- 教室には李さんしかいません。\n- 私が好きなのはあなたしかいない。\n- 私はワインしか飲みません。\n\n## 28.～過ぎます\n[动词(ます形去掉ます.]+過ぎます\n[一类形(去掉词尾い.]+過ぎます\n[二类形词干]+過ぎます\n表示超过了正常的量或程度。\n- ゆうべは飲み過ぎた。今日は頭が痛い。\n- この本は難しすぎて、読みにくいです。\n- この説明は複雑すぎます。\n\n## 29.～そうです　[传闻]  \n[小句(简体形.]そうです　①　[传闻]\n- 天気予報によると、明日は雨だそうです。\n- 田中さんの話によると、佐藤さんは来月会社を辞めるそうです。\n- あの店はおいしくないそうです。\n\n## 30.～そうです　②　[样态][推测]\n[动词ます形去掉ます]＋そうです\n[一类形容词去掉词尾い]＋そうです\n[二类形容词词干]＋そうです\n- このケーキはおいしそうです。\n- 李さんは仕事が大変そうですね。\n\n## 31.～だけ　只，仅仅\n- 教室には李さんだけいます。\n- 私が好きなのはあなただけです。\n- 在庫は３台だけです。\n\n## 32.～たところです\n～ところです：表示动作处于某种阶段\n1. ～る(基本形.＋ところです：即将进行\n2. ～ている＋ところです：正在进行\n3. ～たところです：刚刚结束\n- もしもし、今どこですか。\n——これから家を出るところです。\n- 論文はできましたか。\n——いいえ、まだです。今、資料を調べているところです。\n- すみません、お待たせして。\n——いいえ、わたしも今着いたところです。\n\n## 33.～たばかりです\n[动]たばかりです：表示动作或事情刚刚结束。\n～たばかりです：可用于动作结束后经过了较长一段时间的事态\n～たところです：一般用于动作结束后经过的时间极短的事态。\n- あの２人は去年結婚したばかりです。（〇） \nあの２人は去年結婚したところです。（×）\n- レポートはできましたか。\n——ええ、今できたところです。（〇） \n\n## 34.~ために、～　[目的]\n[小句1(基本形.]ために、[小句2]　　 \n[名]＋の＋ために、[小句] 　 　\n- 日本へ留学するために、お金を貯めています。\n- 留学のために、日本語を勉強しています。\n前项为意志性的动作；前后主语相同。\n\n## 35.～ために、～　[原因、理由]\n[小句1(简体形.]ために、[小句2]\n[名]＋の＋ために、[小句2]\n[二类形容词]＋な＋ために、[小句2] \n- 事故があったために、電車が遅れたんです。\n- 道路工事のために、道が込んでいます。\n- この村は交通が不便なために、住んでいる人が少ないです。\n小句1多为非意志性的事态或状态。多用于书面语或比较郑重的场合。\n\n## 36.～たら\n接续：将简体过去形式中的“た”变成“たら”。\n多用于一次性的、特定的事件。\n1. 表示假定条件，“假如，要是……的话，……”\n- もし宝くじに当たったら、どうしますか。\n2. 表示既定条件，即“……之后，……”。\n- 仕事が終わったら、飲みに行こう。\n- 空港に着いたら、電話してください。\n3. 表示意外发现。\n- カーテンを開けたら、富士山が見えました。\n\n## 37.～ちゃった\n“～てしまった”在口语中较随便的形式。\n- うっかり財布を電車の中に忘れちゃった。\n\n## 38.～続けます\n\n## 39.～つもりです\n接续：动词基本形／ない形＋つもりです\n用法：表示说话人的打算。\n- 今度の連休は旅行に行くつもりです。\n\n## 40.～て／～ないで\n即“～てください／～ないでください”，省略掉“ください”。\n表示祈使或轻微命令，用于关系亲密的人之间。\n- 私の話をちゃんと聞いてよ！\n- まこと、洗濯物入れてよ。\n- 遅れないでね。\n\n## 41.～て～／～ないで～　连接前后小句，表示伴随状态。\n- 眼鏡をかけて本を読みます。\n- 新しい洋服を着てパーティーに行きました。\n- 傘を持たないで出かけました。\n- 傘を持たずに出かけました。\n\n## 42.～て、～／～で、～　[理由、原因]\n[小句1(动／形1.]て、[小句2]  \n[小句1(名／形2.]で、[小句2]\n- 遅くなって、すみません。\n- 最近は忙しくて、彼女に会いたくても時間がありません。\n- 病気で、会社を休みました。\n- 暇で、朝からずっとテレビを見ていました。\n\n## 43.名词＋で　[原因、理由]\n- 昨日は仕事で森さんと会いました。\n- 主人は出張で大阪に行っています。\n\n## 44.で／へ／から／まで／と＋の\n- 東京での生活に慣れましたか。\n- 北京から東京までの便。\n- 見知らぬ女からの手紙。\n- 友達にあげるプレゼント。\n\n## 45.～てあげます\nAは／がBに[动~]てあげる。A为B做某事　B不能是“我”或“我方人员”\n- 森さんはお年寄りの荷物を持ってあげました。\n- きのう妹に新しい携帯を買ってあげました。\nAは／がBに[动~]てもらう。A从B处得到某项帮助／恩惠\n- 森さんは李さんに北京を案内してもらいました。\n- 私は日本人の友達におすしの作り方を教えてもらいました。\nAは／がBに[动~]てくれる。A为B提供某项帮助　B只能是“我”或“我方人员” \n- 友達が私におすしの作り方を教えてくれました。\n- 鈴木さんは傘を貸してくれました。\n\n## 46.～てあります\n[他动词]＋てある：表示某人有意做某事后动作结果的状态存续。\n[自动词]＋ている：表示状态。\n[动词]＋ておく：表示事先做准备。\n\n- 窓を開けておく。　　　[朱丽叶]\n- あの窓が開いている。　[路人]\n- 窓が開けてある。　　　[罗密欧]\n\n## 47.～である　是“～です”的书面语简体形式。 \n- 富士山は日本で最も高い山です。夏の晴れた朝には赤くなって、\n　とても美しいです。\n→富士山は日本で最も高い山である。夏の晴れた朝には赤くなり、\n　とても美しい。\n\n## 48.～ていきます／～てきます\n[空间方向性]\n～ていく：表示离说话人而去，由近及远；\n～てくる：表示向着说话人而来，由远及近。  \n- 飛行機は西から飛んできて、東へ消えていった。\n- 田中さんが校門から走ってきた。\n[时间持续的方向性]\n～てくる：由基准时间点之前向基准时间点推移、变化。\n～ていく：由基准时间点向基准时间点之后推移、变化。\n- 日本で学ぶ留学生の数が増えてきた。これからも増えていくだろう。\n\n## 49.～ていただきます\n是“～てもらいます”的自谦语形式。\n- 黄教授を紹介していただき、ありがとうございました。\n\n## 50.～ていただけますか／～ていただけませんか　[请求]\n用于礼貌的请求别人为自己做某事。\n- この服は小さいので、取り替えていただけますか。\n\n## 51.～ています　[反复][习惯]\n- 北京行きの飛行機は１時間に１便飛んでいます。\n- 祖母は毎朝公園で散歩しています。\n\n## 52.～ています　[结果状态]\n- 吉田さんは車を持っています。\n- 森さんを知っていますか。\n具有自他对应的自动词的“～ています”形式，都是表示结果状态的。\n- 部屋の電気は消えています。\n\n## 53.～ていらっしゃいます\nいらっしゃる：行く／来る／いる的尊他语。\nていらっしゃる：ていく／てくる／ている的尊他语。\n- 社長は会議室で待っていらっしゃいます。　　　　＝ています\n- 木村部長は先ほど戻っていらっしゃいましたよ。　＝てきました\n- 社長はもう東京に帰っていらっしゃいました。　　＝ていきました\n\n## 54.～ているところです\n\n## 55.～ておきます\n1. 为了某个目的而事先做某事；[准备]\n- お客さんが来る前に、部屋を掃除しておきます。\n- 日本へ行く前に、日本語を勉強しておいたほうがいいですよ。\n\n2. 为了某个目的而做某事，并使其结果或效果留存下来。[留存]\n- この辞書、片づけましょうか。\n——いいえ、まだ使いますから、そのままにしておいてください。\n\n## 56.～ております\n是“～ています”的郑重语。\n- 山田社長はいらっしゃいますか。\n——山田はただいま外出しております。\n\n## 57.～てきます／～てきました　[出现]\n- あっ、雨が降ってきた。\n\n## 58.～てくださいます　是“～てくれます”的尊他语。\n- 先生がわたしの論文を見てくださいました。\n- 社長が褒めてくださいました。\n\n## 59.～でございます　是“～です”的非常礼貌的说法。\n- はい、こちらはJC企画上海事務所でございます。\n\n## 60. 差し上げます　是“あげます”的自谦语。\n\n## 61.～てしまう\n1. 完成\n- さあ、最後まで飲んでしまいましょう。\n→さあ、最後まで飲んじゃおう！\n- この本はもう読んでしまったから、あげるよ。\n2. 发生某件结果不理想的事情\n- 大切な書類を電車の中に忘れてしまいました。\n- そんなに無理をすると、病気になってしまいますよ。\n→そんなに無理をすると、病気になっちゃうよ。\n\n## 62. ～でしょう　[推测]\n- 明日は雨になるでしょう。\n- 今はゴールデンウイークですから、どの行楽地も混んでいるでしょう。\n\n## 63. ～でしょう？　[确认]\n- 李さん、明日のパーティーに行くでしょう？　　　　　　（升调）\n- え、このケーキ、おいしいと思うの？まずいでしょう！　（降调）\n- お母さん、私の日記、見たでしょう！　　　　　　　　　（降调）\n\n## 64. ～でしょうか　礼貌的疑问方式。\n- 李さんは来ますか。→李さんは来るでしょうか。\n- コーヒー、いかがですか。→コーヒー、いかがでしょうか。\n\n## 65. ～ですもの／～だもん\n表示说话人认为某事具有正当性，带有不满、抗议、申辩的语气。\n一般为女性和儿童使用。\n- 今月から給料が上がったそうですね。\n——こんなにたくさん仕事しているんですもの。当然でしょう\n- 冷蔵庫の中のケーキを食べちゃったのは太郎でしょう？\n——だってお腹空いちゃったんだもん。\n\n## 66. ～ではありませんか\n用否定疑问句的形式礼貌地表达自己肯定的观点。\n\n## 67. ～てほしい　表达对他人的希望。\n- だれか、手伝ってほしい。\n- 子どもに元気で、自信がある子に育ってほしい。\n- 早く連休が来てほしい。\n\n## 68.～てみます　尝试做某事。\n- ケーキを作ってみました。食べてみてください。\n- 日本語で友達に手紙を書いてみました。\n\n## 69. ～ても、～　[转折]\n- 宝くじに当たっても、仕事を続けます。\n- 明日雨でも、彼女に会いに行きます。\n- いくら聞いても、彼は何も言わなかった。\n\n## 70. 名词＋でも　[提示极端例子]\n- この計算は難しくて、大人でもできません。\n- この森は夏でも涼しい。\n\n## 71. 名词＋でも　[示例]\n- コーヒーでも飲みませんか。\n- 仕事の後、映画でも見ませんか。\n\n## 72. ～てもらいます\n\n## 73. ～と、～\n“一……，就……”，表示恒定不变的真理，反复性状态，习惯等。\n- お酒を飲むと、必ず酔う。\n- 遅刻すると、彼女は必ず怒ります。\n- 兄は冬になると、スキーに行きます。\n后项不可以出现祈使、命令、意志的表达方式。\n还可表示意外的发现，此时后项要使用过去形式。\n- カーテンを開けると、富士山が見えました。\n\n## 74. ～と会います　\nに：用于单向性的动作对象\nと：用于双向性的动作对象\n- さっき駅前で佐藤さんに会いました。\n- さっき駅前で佐藤さんと会いました。\n\n## 75. ～という～　表示称谓，“叫做……”。\n- これはフジという花です。\n\n## 76. ～（よ）うと思います ～（よ）うと思っています\n[动(意志形.]＋と思います　把自己要做某事的意志告诉听话人。\n- 来年結婚しようと思います。\n- 将来、日本へ留学しようと思います。\n[动(意志形.]+ と思っています　表示某种意志持续了一段时间。\n- 今の仕事をやめようと思っています。\n- 将来、日本へ留学しようと思っています。\n- 張さんは将来、日本へ留学しようと思っています。\n\n## 77. ～とか～とか\n- パーティーで、戴さんとか楊さんとか、いろいろな人に会いました。\n- 海外旅行に行きたいとか、新しい車が欲しいとか、ぜいたくなことばかり\n　言っています。\n\n## 78. ～時、～\n- 子供の時、よく祖母と一緒に公園で散歩しました。\n- 映画を見る時、いつもいちばん後ろの席に座ります。\n- 忙しい時、いつもコンビニでお弁当を買って食べます。\n- 暇な時、よく一人で映画を見ます。\n\n## 79. ～ところです\n～る（基本形）+ところです。\n～ている＋ところです。\n～た＋ところです。\n\n## 80. 动词基本形＋な　[禁止]\n使用场合：1. 用于上对下，或有资格对对方发号施令的人；\n2. 特殊、紧急的场合。\n- 仕事をサボるな！\n- 笑うな！\n- 危ない！来るな！\n\n## 81. ～ないと／～ないといけません\n表示必须或义务，“不……不行，不得不……”。  \n- 時間がないから、そろそろ行かないと。\n- 明日までにレポートをまとめないといけません。\n\n## 82. ながら\n动词ます形去掉ます＋ながら， “一边……一边……” \n- テレビを見ながらご飯を食べます。\n- 歩きながら電話をします。\n- 食事をしながら話しましょうか。\n\n## 83. ～なければ／～なければなりません　“必须……，不得不……”\n\n## 84. なさい\n动词ます形去掉ます＋なさい，表示命令。 \n多用于长辈对晚辈、上级对下级、老师对学生等发号施令，语气比命令形柔和些。\n- 早く寝なさい。\n\n## 85. ～なら、～\n接续：简体形式＋なら（形2或名词去掉简体形式中的だ）\n根据对方的言谈或现场情况，陈述自己的意见或想法，以及向对方提出建议、\n忠告。\n- 天安門に行くなら、地下鉄が便利ですよ。\n- お寿司なら、駅前のあのお店がいいですよ。\n- 魚を買うなら、築地市場がいいですよ。\n- 飲んだら乗るな。乗るなら飲むな。\n\n## 86. ～に　[用途][基准]\n[名词]＋に\n[动词基本形]＋のに\n- この写真はパスポートの申請に使います。　　　　　　　　　　　[用途]\nこの写真はパスポートを申請するのに使います。　　　　　　　　[用途]\n- このマンションはスーパーから近くて、買い物に便利です。　　　[基准]\nこのマンションはスーパーから近くて、買い物するのに便利です。[基准]\n\n## 87. ～によると　表示传闻、消息的来源。\n- 天気予報によると、明日は雨だそうです。\n- 田中さんの話によると、佐藤さんは来月会社を辞めるそうです。\n\n## 88. ～によって \n～によって：表示变化的依据，“因……的不同而不同”\n- 飛行機のチケットは高かったり、安かったり、季節によって違います。\n以事物作主语的被动句中，当动作主体是特定的人时，要用によって来提示。\n-『阿Q正伝』は魯迅によって書かれました。\n- この車は日本の有名なデザイナーによって設計されました。\n\n## 89. ～のが～です\n- 自転車に二人で乗るのは危ないです。\n- 一人で映画を見るのが好きです。\n\n## 90. ～のが見えます／～のが聞こえます\n見える：自动词，某种景象映入眼帘。\n聞こえる：自动词，某种声音传入耳朵。\n- 隣の部屋で子どもたちが騒いでいるのが聞こえますか。\n- グラウンドで子どもたちが野球をしているのが見えます。\n\n## 91. ～のために　[目的] ～のために　[理由、原因]\n[动词][1形容词(简体.]+ために\n[名]+の＋ために\n\n## 92. ～ので、～　[理由、原因]\n接续：[动词／一类形容词简体]＋ので\n[名词／二类形容词简体(だ→な.]＋ので\n用法：用于客观叙述某事的原因、理由。\n- 家が遠いので、毎朝はやく起きなければなりません。\n- 目が疲れたので、少し休みます。\n- ここは静かなので、とても気に入っています。\n- もう終電の時間なので、帰ります。\n- 昨日は休みだったので、映画を見に行きました。\n\n## 93. ～のではないでしょうか　[婉转陈述意见]\n表达的是一种委婉的肯定， “不是……吗？”相当于“と思います”，\n语气更委婉。\n- 免税店では女性向けの商品がよく売れるのではないでしょうか。\n\n## 94. ～の時、～\n[名]+の＋時\n表示“……的时候”。\n\n## 95. ～のに　[用途][基准]\n[动词基本形]＋の＋に\n\n## 96. ～のに、～　[转折]\n表示在小句1的情况下发生小句2的情况不符合常识常理，“明明……却，\n可是，偏偏……”。\n- 目覚ましをかけておいたのに、今朝は起きられませんでした。\n- 森さんは家が近いのによく遅刻します。\n- 田中さんは作家なのに、読書が嫌いです。\n接续：[小句1(简体形.]のに、[小句2] \n[名词]／[二类形容词的现在肯定简体形式(だ→な.]＋のに、小句2\n\n## 97. ～のは～です。\n\n## 98. ～のまま、～\n[小句1(动词た形／ない形.]まま、小句2\n[名]＋の＋まま、小句\n- 眼鏡をかけたまま、寝てしまいました。\n- 馬さんは行き先を告げないまま、家を出てしまいました。\n- わたしたちは空腹のまま、出発しました。\n- 講堂に入る時、携帯の電源を切らなければなりませんか。\n　——いいえ、付けたままでいいですよ。\n\n## 99. ～のようです　[推测]\n说话人根据自己感知的情况，进行推测。\n[小句(简体形.]＋ようです  \n[名]＋の＋ようです\n[二类形词干]+な＋ようです\n- 玄関のところにだれかがいるようです。\n- 店の前には行列ができています。あの店の料理はおいしいようです。\n- 値段はほかの店の倍です。ここの料理はかなり豪華なようです。\n- 遠くから何か飛んできます。飛行機のようですね。\n\n## 100. ～のような味／においがします\n味・におい・声・音・感じ＋がする：表示有这种感觉。\n- この野菜、レモンのような味がします。\n- このせっけんは爽やかで、ランのようなにおいがします。\n- ここには昔来たことがあるような感じがします。\n寒気（さむけ）・吐き気（はきけ）・頭痛（ずつう）＋がする\n- 今朝から、ずっと寒気がしています。\n\n## 101. ～のを～\n- 手紙を出すのを忘れました。\n- 吉田さんが転勤するのを知っていますか。\n\n## 102. ～ば、～\n\n## 103. ～は～という～です　用于下定义或做解释。\n- 駐車禁止はここに車を止めるなという意味です。\n- そのマークはここでタバコを吸うなという意味です。\n\n## 110. ～ば～ほど　“越…越…”。\n接续：[动ば形]+[动(基本形.]＋ほど＋[小句]\n[一类形容词ば形]+[一类形容词(原形.]＋ほど＋[小句]\n[二类形容词(词干.]+なら＋[二类形容词(词干.]＋な＋ほど＋[小句]\n[二类形容词(词干.]+であれば＋[二类形容词(词干.]＋な＋ほど＋[小句]\n[二类形容词(词干.]+であれば＋あるほど＋[小句]\n\n- この本は読めば読むほど、おもしろいです。\n- 彼のことを知れば知るほど、好きになる。\n- 商品は安ければ安いほど売れるでしょう？\n\n- 子供は元気なら元気なほどいいです。\n　子供は元気であれば元気なほどいいです。\n\n## 111. ～ばかり～　～ばかりいます\n[名]＋ばかり＋[动]：表示所列举的事物全部相同；“光、净、只……”\n[动(て形.]＋ばかり＋います：表示总是发生同样的事情或总是进行同样的动作。\n　　　　　　　　　　　　　“老是，总是，光……，净……”[反复]\n- 林さんはカラオケで古い歌ばかり歌います。\n- うちの息子は毎日ゲームばかりしています。\n- 張さんは毎日お酒を飲んでばかりいます。\n- 遊んでばかりいないで、しっかり勉強しなさい。\n\n## 112. ～はじめる／～出す\n\n## 113. ～はずがありません\n～はずです\nはずです：表示个人根据某种理由，做好自身认为合情理的推断。\n- 会議は5 時までですから、もうすぐ終わるはずです。\n- 森さんは１時間ほど前に会社を出ましたから、もう家に着いているはずです。\n～はずがない：不可能……\n- 張さんは入院中ですから、旅行に行くはずがありません。\n- 7月のオーストラリアは冬ですから、暑いはずがありません。\n\n## 114. ～までに\n表示某事的截止时间点，即：在……之前，完成或发生某事。    \n- 来週の水曜日までにレポートを提出してください。\n- 今月の末までに、新しい家を見つけたいです。\n～まで：在……之前，持续做某事或某状态。\n- 彼に会うまで、ここで待つ。\n\n## 116. ～ようです／～みたいです　[推测][比喻]\n“ようです”语气正式，“みたいです”口语化。\n\n- 遠くから何か飛んできます。飛行機のようですね。　　　　[推测]\n遠くから何か飛んでくる。飛行機みたいだね。　　　　　　[推测]\n- これは柔らかくて、まるで本物の毛皮のようです。　　　　[比喻]\n- あの子は目が大きくてかわいいね。まるで人形みたいだ。　[比喻]\n- この野菜、レモンのような味がします。　　　　　　　　　[比喻]\n- 鳥のように空を飛んでみたいな。　　　　　　　　　　　　[比喻]\n- 田中さんのお宅はホテルのようにきれいです。　　　　　　[比喻]\n\n## 117. ～も　[超出预想]\n数量词+も+肯定：数量之多。\n- 参加者は50人も超えました。\n- 今日は3リットルも水を飲みました。\n\n## 118. ～やすい／～にくい\n[动词ます形去掉ます]＋やすい：构成形1，表示“易于……”\n[动词ます形去掉ます]＋にくい：构成形1，表示“难于……”\n- このペンは書きやすいです。\n- この本は漢字が多くて、読みにくいです。\n- 雨の日は事故が起こりやすいです。\n- 運動している人は太りにくいです。\n\n## 119. ～ように\n为了使前项成立，而做后项事情。前接非意志性动词，或意志性动词可能形式\n的基本形或ない形。\n- 留学生も分かるように、先生はゆっくり説明してくれました。\n- 子どもが触れないように、この薬は棚のいちばん上に置きましょう。\n\n## 120. ～ようにします\n“努力做到…… ”。前接意志性动词的基本形或ない形。\n- のどが痛いので、今日はあまり話さないようにします。\n- 明日の会議には、できるだけ出るようにします。\n～ようにしている：有意识地将某个习惯保留下来。\n- 陳さんは毎日、英字新聞を読むようにしています。\n- 健康のために、毎日30分ぐらいジョギングをするようにしています。\n\n## 121. ～ようになります\n表示能力、状况等的变化。前接非意志性动词，或意志性动词可能形式的\n基本形或ない形。\n- けがが治って、歩けるようになりました。\n- 赤ちゃんは1歳を過ぎると、言葉を話すようになります。\n\n## 122. [名词]＋らしい～　[典型性]\n- 食事らしい食事\n- 女らしい女\n- 学生なら、学生らしくしっかり勉強しなさい。\n\n## 123. ～らしいです　[推测][传闻]\n[小句(简体形.]＋らしいです\n- 田中さんは来月から大阪支社へ転勤するらしいですよ。　[传闻]\n- 電気が消えています。李さんは出かけたらしいですね。　[推测]\n- 火曜日なのに店が閉まっている。今日は休みらしいね。　[推测]\n\n## 124. ～られます　尊他语形式\n\n## 125. ～んじゃないですか　[婉转陈述意见的表达]\n与“～のではないでしょうか”一样，用否定疑问句的形式，婉转地表达\n自己肯定的意见，但礼貌程度比“～のではないでしょうか”稍低。\n- ここ、いいんじゃないですか。\n- さっきのはもっと広かったんじゃないですか。\n","slug":"nihonngo/nihonngo-2","published":1,"updated":"2020-06-11T01:43:32.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxw001n9r2vkax4eedv","content":"<p>&emsp;&emsp;初级下，自他动词，敬语，动词的意志形，被动型，命令形。<br><a id=\"more\"></a></p>\n<h2 id=\"1-名词的修饰\"><a href=\"#1-名词的修饰\" class=\"headerlink\" title=\"1.名词的修饰\"></a>1.名词的修饰</h2><p>动词：简体形式（基本形、た形、ない形、～なかった）<br>形1：简体形式（赤いです→赤い、おもしろかったです→おもしろかった） </p>\n<ul>\n<li>これは明日会議で使う資料です。（〇）   明日会議で使います（×）</li>\n<li>あれは森さんが今夜泊まるホテルです。</li>\n<li>あれはゆうべ泊まったホテルです。</li>\n<li>今、李さんと話している人はだれですか。</li>\n<li>あの背が高い男性は森さんです。</li>\n</ul>\n<p>形2：词干＋な</p>\n<ul>\n<li>操作が簡単なパソコンが欲しいです。</li>\n</ul>\n<p>名词：名词1＋の＋名词2</p>\n<ul>\n<li>数学が専門の先生が今日休みました。</li>\n</ul>\n<h2 id=\"2-自动词和他动词\"><a href=\"#2-自动词和他动词\" class=\"headerlink\" title=\"2.自动词和他动词\"></a>2.自动词和他动词</h2><p>常见的两种（自、他动词的）词形对应关系：</p>\n<ol>\n<li>自动词词尾为 aru，他动词词尾为 eru；</li>\n</ol>\n<ul>\n<li>かかる<->かける</-></li>\n<li>始まる<->始める</-></li>\n<li>閉まる<->閉める</-></li>\n<li>止まる<->止める</-></li>\n</ul>\n<ol start=\"2\">\n<li>自动词词尾为 eru、ru，他动词词尾为 su。</li>\n</ol>\n<ul>\n<li>壊れる<->壊す</-></li>\n<li>消える<->消す</-></li>\n<li><p>落ちる<->落とす</-></p>\n</li>\n<li><p>李さんが部屋の電気を消した。→部屋の電気が消えている。</p>\n</li>\n<li>田中さんがドアを開けた。→ドアが開いている。</li>\n</ul>\n<h2 id=\"3-形容词的副词性用法\"><a href=\"#3-形容词的副词性用法\" class=\"headerlink\" title=\"3.形容词的副词性用法\"></a>3.形容词的副词性用法</h2><p>形1：词尾“い”→“く”<br>形2：词干＋に</p>\n<ul>\n<li>楽しく生きたい</li>\n<li>自由に生きたい</li>\n</ul>\n<h2 id=\"4-形容词＋さ：形容词的名词化\"><a href=\"#4-形容词＋さ：形容词的名词化\" class=\"headerlink\" title=\"4.形容词＋さ：形容词的名词化　\"></a>4.形容词＋さ：形容词的名词化　</h2><p>形1：词尾“い”→“さ”<br>形2：词干＋さ</p>\n<ul>\n<li>この暑さはいつまで続くでしょう。</li>\n<li>やっと仕事の楽しさが分かった。</li>\n<li>やっと彼の良さが分かった。</li>\n<li>彼のまじめさには参りました。</li>\n</ul>\n<h2 id=\"5-动词的命令形\"><a href=\"#5-动词的命令形\" class=\"headerlink\" title=\"5.动词的命令形\"></a>5.动词的命令形</h2><p>动1：把基本形的最后一个假名变成相应的“え”段假名；</p>\n<ul>\n<li>帰る→帰れ</li>\n<li>消す→消せ</li>\n<li>行く→行け</li>\n<li>待つ→待て</li>\n<li>死ぬ→死ね<br>动2：把基本形的“る”变成“ろ”；</li>\n<li>見る→見ろ</li>\n<li>起きる→起きろ<br>动3：把“来る（くる）”变成“来い（こい）”，把“する”变成“しろ”。</li>\n<li>電気を消せ！</li>\n<li>早く書類を提出しろ！</li>\n<li>早く来い！</li>\n<li>金を返せ！</li>\n<li>死ね！<br>喊加油“頑張れ”时，女性可使用命令形，除此以外的场合，不宜使用命令形。</li>\n</ul>\n<h2 id=\"6-动词的意志形\"><a href=\"#6-动词的意志形\" class=\"headerlink\" title=\"6.动词的意志形\"></a>6.动词的意志形</h2><p>动1：把基本形的最后一个假名变成相应的“お”段上的长音；</p>\n<ul>\n<li>帰る→帰ろう</li>\n<li>書く→書こう</li>\n<li>待つ→待とう<br>动2：把基本形的“る”变成“よう”；</li>\n<li>食べる→食べよう</li>\n<li>見る→見よう</li>\n<li>寝る→寝よう<br>动3：“来る”变成“来よう（こよう）”，“する”变成“しよう”。</li>\n</ul>\n<ol>\n<li>表示自己当场形成的决心、意志（多用于自言自语）</li>\n</ol>\n<ul>\n<li>もう11時だから、寝よう。</li>\n<li>明日はテストだ。今晩は勉強しよう。</li>\n</ul>\n<ol start=\"2\">\n<li>表示向对方提议、劝诱（相当于“～ましょう”的简体形）</li>\n</ol>\n<ul>\n<li>仕事が終わったら、飲みに行こう。= 飲みに行きましょう。</li>\n<li>駅まで送ろう。 </li>\n</ul>\n<h2 id=\"7-动词的ば形\"><a href=\"#7-动词的ば形\" class=\"headerlink\" title=\"7.动词的ば形\"></a>7.动词的ば形</h2><p>动词ば形：<br>动1：把基本形最后一个音变成相应的“え”段上的音，再加“ば”；</p>\n<ul>\n<li>書く→書けば</li>\n<li>待つ→待てば</li>\n<li>読む→読めば</li>\n<li>飛ぶ→飛べば<br>动2：把基本形的“る”变成“れば”；</li>\n<li>食べる→食べれば</li>\n<li>見る→見れば</li>\n<li>寝る→寝れば<br>动3：“来る”变成“来れば（くれば）”，“する”变成“すれば”。</li>\n</ul>\n<p>形1ば形：<br>一类形容词“ば形”：把词尾“い”变成“ければ”。</p>\n<ul>\n<li>楽しい→楽しければ</li>\n<li>広い→広ければ</li>\n<li>安い→安ければ</li>\n<li>いい→よければ</li>\n</ul>\n<p>表示前项是后项的条件，“要怎么样，才会这样”。</p>\n<ul>\n<li>どうすれば、東大に入ることができますか。<br>——申請して、入学試験と面接に合格すれば、入ることができますよ。</li>\n<li>急がなければ、遅れますよ。</li>\n<li>旅行に行けば、彼のことが忘れられるでしょう。</li>\n</ul>\n<h2 id=\"8-动词的可能形式\"><a href=\"#8-动词的可能形式\" class=\"headerlink\" title=\"8.动词的可能形式\"></a>8.动词的可能形式</h2><p>动1：把基本形的最后一个音变成相应的“え”段上的音，再加“る”；</p>\n<ul>\n<li>書く→書ける</li>\n<li>話す→話せる</li>\n<li>乗る→乗れる</li>\n<li>飛ぶ→飛べる<br>动2：把基本形的“る”变成“られる”；</li>\n<li>食べる→食べられる</li>\n<li>見る→見られる</li>\n<li>寝る→寝られる<br>动3：“来る”变成“来られる（こられる）”，“する”变成“できる”。<br>相当于“～ことができる”。</li>\n</ul>\n<ol>\n<li>表示能力。</li>\n</ol>\n<ul>\n<li>李さんは日本語が話せます。＝李さんは日本語を話すことができます。</li>\n<li>わたしは自転車に乗れません。</li>\n</ul>\n<ol start=\"2\">\n<li>表示条件允许或可能性。</li>\n</ol>\n<ul>\n<li>日本では、女性は16歳、男性は18歳から結婚できます。</li>\n<li>このキノコは食べられますか。</li>\n</ul>\n<p>在可能形式的前面，表示能力的对像，用助词“が”表示。</p>\n<h2 id=\"9-动词被动形式\"><a href=\"#9-动词被动形式\" class=\"headerlink\" title=\"9.动词被动形式\"></a>9.动词被动形式</h2><p>动1：把“ない形”的“ない”变成“れる”；</p>\n<ul>\n<li>書く→書かれる</li>\n<li>読む→読まれる</li>\n<li>叱る→叱られる</li>\n<li>笑う→笑われる<br>动2：把“ない形”的“ない”变成“られる”；</li>\n<li>食べる→食べられる</li>\n<li>見る→見られる</li>\n<li>褒める→褒められる<br>动3：“来る”变成“来られる（こられる）”，“する”变成“される”。<br>被动句的四种句型</li>\n</ul>\n<ol>\n<li>直接被动句</li>\n</ol>\n<ul>\n<li>兄が弟を叱る。→弟が兄に叱られる。</li>\n<li>兄が弟に話しかける。→弟が兄に話しかけられる。</li>\n</ul>\n<ol start=\"2\">\n<li>持有者被动句：</li>\n</ol>\n<ul>\n<li>今朝、電車の中で財布を盗まれた。　　（〇）わたしの財布が盗まれた。　　　　　　（×）</li>\n<li>李さんは昨日犬に手を噛まれました。　（〇）</li>\n</ul>\n<ol start=\"3\">\n<li>受害被动句</li>\n</ol>\n<ul>\n<li>主动句：鳥が逃げました。→陳さんは鳥に逃げられました。</li>\n<li>張さんは昨日隣の人に夜遅くまで騒がれました。</li>\n<li>食事中、隣の人にタバコを吸われました。</li>\n<li>父に死なれて、大学を続けられなくなりました。</li>\n</ul>\n<ol start=\"4\">\n<li>事物做主语的被动句</li>\n</ol>\n<ul>\n<li>この歌は世界中で歌われています。</li>\n<li>この本は世界中の子どもたちに読まれています。<br>当动作主体是特定的人时，用“によって”表示动作主体。<br>-『阿Q正伝』は魯迅によって書かれました。</li>\n</ul>\n<h2 id=\"10-动词的使役形式\"><a href=\"#10-动词的使役形式\" class=\"headerlink\" title=\"10.动词的使役形式\"></a>10.动词的使役形式</h2><p>动1：把“ない形”的“ない”变成“せる”；</p>\n<ul>\n<li>書く→書かせる</li>\n<li>急ぐ→急がせる</li>\n<li>待つ→待たせる</li>\n<li>読む→読ませる</li>\n<li>やる→やらせる<br>动2：把“ない形”的“ない”变成“させる”；</li>\n<li>食べる→食べさせる</li>\n<li>見る→見させる<br>动3：把“来る”变成“来させる（こさせる）”，把“する”变成“させる”。<br>使役句的两种结构：</li>\n</ul>\n<ol>\n<li>自动词的使役句</li>\n</ol>\n<ul>\n<li>部長は李さんを出張させます。</li>\n<li>あの課長は部下を休ませません。</li>\n</ul>\n<ol start=\"2\">\n<li>他动词的使役句</li>\n</ol>\n<ul>\n<li>部長は太田さんにレポートを書かせます。</li>\n<li>先生は生徒にこの本を読ませます。<br>使役句的三种用法</li>\n</ul>\n<ol>\n<li>强制，要求，指示（让~做……）</li>\n</ol>\n<ul>\n<li>部長は太田さんにレポートを書かせます。</li>\n<li>先生は生徒にこの本を読ませます。</li>\n</ul>\n<ol start=\"2\">\n<li>许可、放任（让~做……，允许~做……）</li>\n</ol>\n<ul>\n<li>あの課長は部下を休ませません。</li>\n<li>子供にできるだけ好きなことをさせたいです。</li>\n</ul>\n<ol start=\"3\">\n<li>原因、导致（让……，使……）</li>\n</ol>\n<ul>\n<li>弟はよく両親を心配させます。</li>\n<li>お待たせしました。</li>\n</ul>\n<h2 id=\"11-动词的使役被动形式\"><a href=\"#11-动词的使役被动形式\" class=\"headerlink\" title=\"11.动词的使役被动形式\"></a>11.动词的使役被动形式</h2><p>动1：“ない形”的“ない”→“せられる”→“される”；<br>动2：“ない形”的“ない”→“させられる” ；<br>动3：“来る”变成“来させられる（こさせられる）”，“する”变成“させられる”。</p>\n<p>动1中，除以「す」结尾的动词外，可将使役被动形式中的「せら」约音为「さ」。<br>结构：[被迫动作主体]は[要求做动作者]に～[使役被动]ます。</p>\n<ul>\n<li>選手は監督に走らされます。     </li>\n<li>生徒は先生にこの本を読ませられます／読まされます。</li>\n<li>小さいとき、母にピアノを習わされました。</li>\n</ul>\n<h2 id=\"12-尊他语\"><a href=\"#12-尊他语\" class=\"headerlink\" title=\"12.尊他语\"></a>12.尊他语</h2><p>通过抬高话题中的动作主体，而对动作主体表示敬意。<br>动词的尊他语的形式：</p>\n<ol>\n<li>～（ら）れる<br>I类动词：动词ない形（ない）＋れる  - 行く→行かれる<br>II类动词：动词ない形（ない）＋られる  - 教える→教えられる<br>III类动词：来る→来られる、～する→～される</li>\n</ol>\n<ul>\n<li>周先生は明日日本へ行かれます。</li>\n<li>今朝何時に起きられましたか。</li>\n</ul>\n<ol start=\"2\">\n<li>お／ご～になる<br>お＋I类动词／II类动词ます形去掉ます＋になる<br>ご＋III类动词的汉字部分+になる  </li>\n</ol>\n<ul>\n<li>お客様はもうお帰りになりましたか。 </li>\n<li>明日の会議には、社長もご出席になるそうです。</li>\n</ul>\n<ol start=\"3\">\n<li>特殊形式</li>\n</ol>\n<ul>\n<li>先生、何を召し上がりますか。</li>\n</ul>\n<h2 id=\"13-自谦语\"><a href=\"#13-自谦语\" class=\"headerlink\" title=\"13.自谦语\"></a>13.自谦语</h2><p>通过贬低动作主体（自己或己方人员），从而相对地对动作接受者表示敬意<br>动词的自谦语的形式：</p>\n<ol>\n<li>お／ご～する<br>お＋I类动词／II类动词ます形去掉ます＋する　<br>ご＋III类动词的汉字部分+する  </li>\n</ol>\n<ul>\n<li>私は夕べ社長を車でお送りしました。</li>\n<li>お荷物をお持ちしましょうか。</li>\n<li>明日の午後、ご連絡します。</li>\n</ul>\n<ol start=\"2\">\n<li>特殊的自谦语动词</li>\n</ol>\n<ul>\n<li>先日、先生のお宅に伺いました。</li>\n<li>先生の論文を拝見しました。</li>\n</ul>\n<h2 id=\"14-～間-～間に\"><a href=\"#14-～間-～間に\" class=\"headerlink\" title=\"14.～間 ～間に\"></a>14.～間 ～間に</h2><p>～間：某动作或状态持续的期间<br>～間に：某动作或事情发生或完成的期间范围。</p>\n<ul>\n<li>子どもが寝ている間、ずっと家事をしていました。</li>\n<li>子どもが寝ている間に、家事を済ませたいです。</li>\n<li>夏休みの間、ずっとアルバイトをしていました。</li>\n<li>夏休みの間に、レポートを書き終わりました。</li>\n</ul>\n<h2 id=\"15-お・ご～します-lt-自谦语-gt\"><a href=\"#15-お・ご～します-lt-自谦语-gt\" class=\"headerlink\" title=\"15. お・ご～します&lt;自谦语&gt;\"></a>15. お・ご～します&lt;自谦语&gt;</h2><h2 id=\"16-お・ご～になります-lt-尊他语-gt\"><a href=\"#16-お・ご～になります-lt-尊他语-gt\" class=\"headerlink\" title=\"16. お・ご～になります&lt;尊他语&gt;　\"></a>16. お・ご～になります&lt;尊他语&gt;　</h2><h2 id=\"17-～終わります\"><a href=\"#17-～終わります\" class=\"headerlink\" title=\"17.～終わります\"></a>17.～終わります</h2><p>～はじめる・～だす・～つづける・～おわる<br>[动(ます形去掉ます.]+始める：开始……<br>[动(ます形去掉ます.]+出す：突然开始……<br>[动(ます形去掉ます.]+続ける：表示持续做某事<br>[动(ます形去掉ます.]+終わる：表示动作或事情结束</p>\n<ul>\n<li>雨が降り始めました。</li>\n<li>子どもが急に泣き出しました。</li>\n<li>３時間も待ち続けていたけど、彼は結局来てくれなかった。</li>\n<li>この本はもう読み終わりましたか。<br>降る＋つづく</li>\n<li>雨が１週間も降り続きました。</li>\n</ul>\n<h2 id=\"18-（～が～）～は／が～-名词修饰句节\"><a href=\"#18-（～が～）～は／が～-名词修饰句节\" class=\"headerlink\" title=\"18.（～が～）～は／が～　名词修饰句节\"></a>18.（～が～）～は／が～　名词修饰句节</h2><p>经修饰的名词短语可以在句子中充当各种成分。<br>名词修饰句节（定语从句）中的小主语要用“が”，而不用“は”。</p>\n<p>-（小野さんが作る）料理はおいしいです。<br>-（森さんがくれた）本はこれです。<br>-（操作が簡単な）パソコンが欲しいです。<br>-（明るくて、頭がいい）男性が好きです。</p>\n<h2 id=\"19-～かしら-和「かな」语义相近，前接简体形式，多为女性使用。\"><a href=\"#19-～かしら-和「かな」语义相近，前接简体形式，多为女性使用。\" class=\"headerlink\" title=\"19.～かしら　和「かな」语义相近，前接简体形式，多为女性使用。\"></a>19.～かしら　和「かな」语义相近，前接简体形式，多为女性使用。</h2><ol>\n<li>吐露内心疑问的自言自语。- 森さんたちは来ているかしら。</li>\n<li>有听话人在场，向对方发问。</li>\n</ol>\n<h2 id=\"20-～かもしれない\"><a href=\"#20-～かもしれない\" class=\"headerlink\" title=\"20.～かもしれない\"></a>20.～かもしれない</h2><p>表示说话人的推测，认为某事有可能发生，也有可能不发生。</p>\n<ol>\n<li>[动词]／[一类形容词小句简体形]+かもしれない</li>\n<li>[二类形容词]／[名词小句简体形去だ]+かもしれない</li>\n</ol>\n<ul>\n<li>小野さんは来ないかもしれません/かもしれない。<br>～　　忙しい　　　～<br>～　　暇　　　　　～<br>～　　病気　　　　～</li>\n</ul>\n<h2 id=\"21-～ことがある\"><a href=\"#21-～ことがある\" class=\"headerlink\" title=\"21.～ことがある\"></a>21.～ことがある</h2><p>[动词基本形]／[ない形]＋ことがある：“有时……”。</p>\n<ul>\n<li>時々課長と一緒にゴルフをすることがあります。</li>\n<li>日曜日はいつも家で掃除をします。でも、たまに友達と買い物する<br>　こともあります。</li>\n<li>彼はいつも返信が早いです。でも、たまに返信しないこともあります。</li>\n</ul>\n<h2 id=\"22-～ことにします／～ことにしました：“我决定……”\"><a href=\"#22-～ことにします／～ことにしました：“我决定……”\" class=\"headerlink\" title=\"22.～ことにします／～ことにしました：“我决定……”\"></a>22.～ことにします／～ことにしました：“我决定……”</h2><p>　～ことにします：当场下的决心</p>\n<ul>\n<li>明日から毎日運動することにします。</li>\n<li>今日からお酒を飲まないことにします。<br>～ことにしました：已经下定的决心</li>\n<li>鈴木さんと結婚することにしました。</li>\n</ul>\n<h2 id=\"23-～ことになりました：表示某事客观上定下来。\"><a href=\"#23-～ことになりました：表示某事客观上定下来。\" class=\"headerlink\" title=\"23.～ことになりました：表示某事客观上定下来。\"></a>23.～ことになりました：表示某事客观上定下来。</h2><ul>\n<li>来月から給料が上がることになりました。</li>\n<li>今週は会議を行わないことになりました。</li>\n<li>４月から大阪支社に転勤することになりました。</li>\n</ul>\n<h2 id=\"24-动-（さ）せていただきます\"><a href=\"#24-动-（さ）せていただきます\" class=\"headerlink\" title=\"24.[动]（さ）せていただきます\"></a>24.[动]（さ）せていただきます</h2><p>用于礼貌地表达自己的动作。</p>\n<ul>\n<li>早速、資料を届けさせていただきます。</li>\n<li>明日、もう一度連絡させていただきます。</li>\n</ul>\n<h2 id=\"25-动-（さ）せてください\"><a href=\"#25-动-（さ）せてください\" class=\"headerlink\" title=\"25.[动]（さ）せてください\"></a>25.[动]（さ）せてください</h2><p>请求对方允许自己做某事。</p>\n<ul>\n<li>疲れました。少し休ませてください。</li>\n</ul>\n<h2 id=\"26-～し、～し-叙述并列事项-罗列原因\"><a href=\"#26-～し、～し-叙述并列事项-罗列原因\" class=\"headerlink\" title=\"26.～し、～し　[叙述并列事项][罗列原因]\"></a>26.～し、～し　[叙述并列事项][罗列原因]</h2><ul>\n<li>このレストランはおいしいし、雰囲気もいい。</li>\n<li>このレストランはおいしいし、雰囲気もいいから、よく来ます。</li>\n<li>もう遅いし、そろそろ失礼します。</li>\n</ul>\n<h2 id=\"27-～しか～（否定）-表示“只，仅仅”\"><a href=\"#27-～しか～（否定）-表示“只，仅仅”\" class=\"headerlink\" title=\"27.～しか～（否定）　表示“只，仅仅”\"></a>27.～しか～（否定）　表示“只，仅仅”</h2><ul>\n<li>教室には李さんしかいません。</li>\n<li>私が好きなのはあなたしかいない。</li>\n<li>私はワインしか飲みません。</li>\n</ul>\n<h2 id=\"28-～過ぎます\"><a href=\"#28-～過ぎます\" class=\"headerlink\" title=\"28.～過ぎます\"></a>28.～過ぎます</h2><p>[动词(ます形去掉ます.]+過ぎます<br>[一类形(去掉词尾い.]+過ぎます<br>[二类形词干]+過ぎます<br>表示超过了正常的量或程度。</p>\n<ul>\n<li>ゆうべは飲み過ぎた。今日は頭が痛い。</li>\n<li>この本は難しすぎて、読みにくいです。</li>\n<li>この説明は複雑すぎます。</li>\n</ul>\n<h2 id=\"29-～そうです-传闻\"><a href=\"#29-～そうです-传闻\" class=\"headerlink\" title=\"29.～そうです　[传闻]\"></a>29.～そうです　[传闻]</h2><p>[小句(简体形.]そうです　①　[传闻]</p>\n<ul>\n<li>天気予報によると、明日は雨だそうです。</li>\n<li>田中さんの話によると、佐藤さんは来月会社を辞めるそうです。</li>\n<li>あの店はおいしくないそうです。</li>\n</ul>\n<h2 id=\"30-～そうです-②-样态-推测\"><a href=\"#30-～そうです-②-样态-推测\" class=\"headerlink\" title=\"30.～そうです　②　[样态][推测]\"></a>30.～そうです　②　[样态][推测]</h2><p>[动词ます形去掉ます]＋そうです<br>[一类形容词去掉词尾い]＋そうです<br>[二类形容词词干]＋そうです</p>\n<ul>\n<li>このケーキはおいしそうです。</li>\n<li>李さんは仕事が大変そうですね。</li>\n</ul>\n<h2 id=\"31-～だけ-只，仅仅\"><a href=\"#31-～だけ-只，仅仅\" class=\"headerlink\" title=\"31.～だけ　只，仅仅\"></a>31.～だけ　只，仅仅</h2><ul>\n<li>教室には李さんだけいます。</li>\n<li>私が好きなのはあなただけです。</li>\n<li>在庫は３台だけです。</li>\n</ul>\n<h2 id=\"32-～たところです\"><a href=\"#32-～たところです\" class=\"headerlink\" title=\"32.～たところです\"></a>32.～たところです</h2><p>～ところです：表示动作处于某种阶段</p>\n<ol>\n<li>～る(基本形.＋ところです：即将进行</li>\n<li>～ている＋ところです：正在进行</li>\n<li>～たところです：刚刚结束</li>\n</ol>\n<ul>\n<li>もしもし、今どこですか。<br>——これから家を出るところです。</li>\n<li>論文はできましたか。<br>——いいえ、まだです。今、資料を調べているところです。</li>\n<li>すみません、お待たせして。<br>——いいえ、わたしも今着いたところです。</li>\n</ul>\n<h2 id=\"33-～たばかりです\"><a href=\"#33-～たばかりです\" class=\"headerlink\" title=\"33.～たばかりです\"></a>33.～たばかりです</h2><p>[动]たばかりです：表示动作或事情刚刚结束。<br>～たばかりです：可用于动作结束后经过了较长一段时间的事态<br>～たところです：一般用于动作结束后经过的时间极短的事态。</p>\n<ul>\n<li>あの２人は去年結婚したばかりです。（〇）<br>あの２人は去年結婚したところです。（×）</li>\n<li>レポートはできましたか。<br>——ええ、今できたところです。（〇） </li>\n</ul>\n<h2 id=\"34-ために、～-目的\"><a href=\"#34-ために、～-目的\" class=\"headerlink\" title=\"34.~ために、～　[目的]\"></a>34.~ために、～　[目的]</h2><p>[小句1(基本形.]ために、[小句2]　　<br>[名]＋の＋ために、[小句] 　 　</p>\n<ul>\n<li>日本へ留学するために、お金を貯めています。</li>\n<li>留学のために、日本語を勉強しています。<br>前项为意志性的动作；前后主语相同。</li>\n</ul>\n<h2 id=\"35-～ために、～-原因、理由\"><a href=\"#35-～ために、～-原因、理由\" class=\"headerlink\" title=\"35.～ために、～　[原因、理由]\"></a>35.～ために、～　[原因、理由]</h2><p>[小句1(简体形.]ために、[小句2]<br>[名]＋の＋ために、[小句2]<br>[二类形容词]＋な＋ために、[小句2] </p>\n<ul>\n<li>事故があったために、電車が遅れたんです。</li>\n<li>道路工事のために、道が込んでいます。</li>\n<li>この村は交通が不便なために、住んでいる人が少ないです。<br>小句1多为非意志性的事态或状态。多用于书面语或比较郑重的场合。</li>\n</ul>\n<h2 id=\"36-～たら\"><a href=\"#36-～たら\" class=\"headerlink\" title=\"36.～たら\"></a>36.～たら</h2><p>接续：将简体过去形式中的“た”变成“たら”。<br>多用于一次性的、特定的事件。</p>\n<ol>\n<li>表示假定条件，“假如，要是……的话，……”</li>\n</ol>\n<ul>\n<li>もし宝くじに当たったら、どうしますか。</li>\n</ul>\n<ol start=\"2\">\n<li>表示既定条件，即“……之后，……”。</li>\n</ol>\n<ul>\n<li>仕事が終わったら、飲みに行こう。</li>\n<li>空港に着いたら、電話してください。</li>\n</ul>\n<ol start=\"3\">\n<li>表示意外发现。</li>\n</ol>\n<ul>\n<li>カーテンを開けたら、富士山が見えました。</li>\n</ul>\n<h2 id=\"37-～ちゃった\"><a href=\"#37-～ちゃった\" class=\"headerlink\" title=\"37.～ちゃった\"></a>37.～ちゃった</h2><p>“～てしまった”在口语中较随便的形式。</p>\n<ul>\n<li>うっかり財布を電車の中に忘れちゃった。</li>\n</ul>\n<h2 id=\"38-～続けます\"><a href=\"#38-～続けます\" class=\"headerlink\" title=\"38.～続けます\"></a>38.～続けます</h2><h2 id=\"39-～つもりです\"><a href=\"#39-～つもりです\" class=\"headerlink\" title=\"39.～つもりです\"></a>39.～つもりです</h2><p>接续：动词基本形／ない形＋つもりです<br>用法：表示说话人的打算。</p>\n<ul>\n<li>今度の連休は旅行に行くつもりです。</li>\n</ul>\n<h2 id=\"40-～て／～ないで\"><a href=\"#40-～て／～ないで\" class=\"headerlink\" title=\"40.～て／～ないで\"></a>40.～て／～ないで</h2><p>即“～てください／～ないでください”，省略掉“ください”。<br>表示祈使或轻微命令，用于关系亲密的人之间。</p>\n<ul>\n<li>私の話をちゃんと聞いてよ！</li>\n<li>まこと、洗濯物入れてよ。</li>\n<li>遅れないでね。</li>\n</ul>\n<h2 id=\"41-～て～／～ないで～-连接前后小句，表示伴随状态。\"><a href=\"#41-～て～／～ないで～-连接前后小句，表示伴随状态。\" class=\"headerlink\" title=\"41.～て～／～ないで～　连接前后小句，表示伴随状态。\"></a>41.～て～／～ないで～　连接前后小句，表示伴随状态。</h2><ul>\n<li>眼鏡をかけて本を読みます。</li>\n<li>新しい洋服を着てパーティーに行きました。</li>\n<li>傘を持たないで出かけました。</li>\n<li>傘を持たずに出かけました。</li>\n</ul>\n<h2 id=\"42-～て、～／～で、～-理由、原因\"><a href=\"#42-～て、～／～で、～-理由、原因\" class=\"headerlink\" title=\"42.～て、～／～で、～　[理由、原因]\"></a>42.～て、～／～で、～　[理由、原因]</h2><p>[小句1(动／形1.]て、[小句2]<br>[小句1(名／形2.]で、[小句2]</p>\n<ul>\n<li>遅くなって、すみません。</li>\n<li>最近は忙しくて、彼女に会いたくても時間がありません。</li>\n<li>病気で、会社を休みました。</li>\n<li>暇で、朝からずっとテレビを見ていました。</li>\n</ul>\n<h2 id=\"43-名词＋で-原因、理由\"><a href=\"#43-名词＋で-原因、理由\" class=\"headerlink\" title=\"43.名词＋で　[原因、理由]\"></a>43.名词＋で　[原因、理由]</h2><ul>\n<li>昨日は仕事で森さんと会いました。</li>\n<li>主人は出張で大阪に行っています。</li>\n</ul>\n<h2 id=\"44-で／へ／から／まで／と＋の\"><a href=\"#44-で／へ／から／まで／と＋の\" class=\"headerlink\" title=\"44.で／へ／から／まで／と＋の\"></a>44.で／へ／から／まで／と＋の</h2><ul>\n<li>東京での生活に慣れましたか。</li>\n<li>北京から東京までの便。</li>\n<li>見知らぬ女からの手紙。</li>\n<li>友達にあげるプレゼント。</li>\n</ul>\n<h2 id=\"45-～てあげます\"><a href=\"#45-～てあげます\" class=\"headerlink\" title=\"45.～てあげます\"></a>45.～てあげます</h2><p>Aは／がBに[动~]てあげる。A为B做某事　B不能是“我”或“我方人员”</p>\n<ul>\n<li>森さんはお年寄りの荷物を持ってあげました。</li>\n<li>きのう妹に新しい携帯を買ってあげました。<br>Aは／がBに[动~]てもらう。A从B处得到某项帮助／恩惠</li>\n<li>森さんは李さんに北京を案内してもらいました。</li>\n<li>私は日本人の友達におすしの作り方を教えてもらいました。<br>Aは／がBに[动~]てくれる。A为B提供某项帮助　B只能是“我”或“我方人员” </li>\n<li>友達が私におすしの作り方を教えてくれました。</li>\n<li>鈴木さんは傘を貸してくれました。</li>\n</ul>\n<h2 id=\"46-～てあります\"><a href=\"#46-～てあります\" class=\"headerlink\" title=\"46.～てあります\"></a>46.～てあります</h2><p>[他动词]＋てある：表示某人有意做某事后动作结果的状态存续。<br>[自动词]＋ている：表示状态。<br>[动词]＋ておく：表示事先做准备。</p>\n<ul>\n<li>窓を開けておく。　　　[朱丽叶]</li>\n<li>あの窓が開いている。　[路人]</li>\n<li>窓が開けてある。　　　[罗密欧]</li>\n</ul>\n<h2 id=\"47-～である-是“～です”的书面语简体形式。\"><a href=\"#47-～である-是“～です”的书面语简体形式。\" class=\"headerlink\" title=\"47.～である　是“～です”的书面语简体形式。\"></a>47.～である　是“～です”的书面语简体形式。</h2><ul>\n<li>富士山は日本で最も高い山です。夏の晴れた朝には赤くなって、<br>　とても美しいです。<br>→富士山は日本で最も高い山である。夏の晴れた朝には赤くなり、<br>　とても美しい。</li>\n</ul>\n<h2 id=\"48-～ていきます／～てきます\"><a href=\"#48-～ていきます／～てきます\" class=\"headerlink\" title=\"48.～ていきます／～てきます\"></a>48.～ていきます／～てきます</h2><p>[空间方向性]<br>～ていく：表示离说话人而去，由近及远；<br>～てくる：表示向着说话人而来，由远及近。  </p>\n<ul>\n<li>飛行機は西から飛んできて、東へ消えていった。</li>\n<li>田中さんが校門から走ってきた。<br>[时间持续的方向性]<br>～てくる：由基准时间点之前向基准时间点推移、变化。<br>～ていく：由基准时间点向基准时间点之后推移、变化。</li>\n<li>日本で学ぶ留学生の数が増えてきた。これからも増えていくだろう。</li>\n</ul>\n<h2 id=\"49-～ていただきます\"><a href=\"#49-～ていただきます\" class=\"headerlink\" title=\"49.～ていただきます\"></a>49.～ていただきます</h2><p>是“～てもらいます”的自谦语形式。</p>\n<ul>\n<li>黄教授を紹介していただき、ありがとうございました。</li>\n</ul>\n<h2 id=\"50-～ていただけますか／～ていただけませんか-请求\"><a href=\"#50-～ていただけますか／～ていただけませんか-请求\" class=\"headerlink\" title=\"50.～ていただけますか／～ていただけませんか　[请求]\"></a>50.～ていただけますか／～ていただけませんか　[请求]</h2><p>用于礼貌的请求别人为自己做某事。</p>\n<ul>\n<li>この服は小さいので、取り替えていただけますか。</li>\n</ul>\n<h2 id=\"51-～ています-反复-习惯\"><a href=\"#51-～ています-反复-习惯\" class=\"headerlink\" title=\"51.～ています　[反复][习惯]\"></a>51.～ています　[反复][习惯]</h2><ul>\n<li>北京行きの飛行機は１時間に１便飛んでいます。</li>\n<li>祖母は毎朝公園で散歩しています。</li>\n</ul>\n<h2 id=\"52-～ています-结果状态\"><a href=\"#52-～ています-结果状态\" class=\"headerlink\" title=\"52.～ています　[结果状态]\"></a>52.～ています　[结果状态]</h2><ul>\n<li>吉田さんは車を持っています。</li>\n<li>森さんを知っていますか。<br>具有自他对应的自动词的“～ています”形式，都是表示结果状态的。</li>\n<li>部屋の電気は消えています。</li>\n</ul>\n<h2 id=\"53-～ていらっしゃいます\"><a href=\"#53-～ていらっしゃいます\" class=\"headerlink\" title=\"53.～ていらっしゃいます\"></a>53.～ていらっしゃいます</h2><p>いらっしゃる：行く／来る／いる的尊他语。<br>ていらっしゃる：ていく／てくる／ている的尊他语。</p>\n<ul>\n<li>社長は会議室で待っていらっしゃいます。　　　　＝ています</li>\n<li>木村部長は先ほど戻っていらっしゃいましたよ。　＝てきました</li>\n<li>社長はもう東京に帰っていらっしゃいました。　　＝ていきました</li>\n</ul>\n<h2 id=\"54-～ているところです\"><a href=\"#54-～ているところです\" class=\"headerlink\" title=\"54.～ているところです\"></a>54.～ているところです</h2><h2 id=\"55-～ておきます\"><a href=\"#55-～ておきます\" class=\"headerlink\" title=\"55.～ておきます\"></a>55.～ておきます</h2><ol>\n<li>为了某个目的而事先做某事；[准备]</li>\n</ol>\n<ul>\n<li>お客さんが来る前に、部屋を掃除しておきます。</li>\n<li>日本へ行く前に、日本語を勉強しておいたほうがいいですよ。</li>\n</ul>\n<ol start=\"2\">\n<li>为了某个目的而做某事，并使其结果或效果留存下来。[留存]</li>\n</ol>\n<ul>\n<li>この辞書、片づけましょうか。<br>——いいえ、まだ使いますから、そのままにしておいてください。</li>\n</ul>\n<h2 id=\"56-～ております\"><a href=\"#56-～ております\" class=\"headerlink\" title=\"56.～ております\"></a>56.～ております</h2><p>是“～ています”的郑重语。</p>\n<ul>\n<li>山田社長はいらっしゃいますか。<br>——山田はただいま外出しております。</li>\n</ul>\n<h2 id=\"57-～てきます／～てきました-出现\"><a href=\"#57-～てきます／～てきました-出现\" class=\"headerlink\" title=\"57.～てきます／～てきました　[出现]\"></a>57.～てきます／～てきました　[出现]</h2><ul>\n<li>あっ、雨が降ってきた。</li>\n</ul>\n<h2 id=\"58-～てくださいます-是“～てくれます”的尊他语。\"><a href=\"#58-～てくださいます-是“～てくれます”的尊他语。\" class=\"headerlink\" title=\"58.～てくださいます　是“～てくれます”的尊他语。\"></a>58.～てくださいます　是“～てくれます”的尊他语。</h2><ul>\n<li>先生がわたしの論文を見てくださいました。</li>\n<li>社長が褒めてくださいました。</li>\n</ul>\n<h2 id=\"59-～でございます-是“～です”的非常礼貌的说法。\"><a href=\"#59-～でございます-是“～です”的非常礼貌的说法。\" class=\"headerlink\" title=\"59.～でございます　是“～です”的非常礼貌的说法。\"></a>59.～でございます　是“～です”的非常礼貌的说法。</h2><ul>\n<li>はい、こちらはJC企画上海事務所でございます。</li>\n</ul>\n<h2 id=\"60-差し上げます-是“あげます”的自谦语。\"><a href=\"#60-差し上げます-是“あげます”的自谦语。\" class=\"headerlink\" title=\"60. 差し上げます　是“あげます”的自谦语。\"></a>60. 差し上げます　是“あげます”的自谦语。</h2><h2 id=\"61-～てしまう\"><a href=\"#61-～てしまう\" class=\"headerlink\" title=\"61.～てしまう\"></a>61.～てしまう</h2><ol>\n<li>完成</li>\n</ol>\n<ul>\n<li>さあ、最後まで飲んでしまいましょう。<br>→さあ、最後まで飲んじゃおう！</li>\n<li>この本はもう読んでしまったから、あげるよ。</li>\n</ul>\n<ol start=\"2\">\n<li>发生某件结果不理想的事情</li>\n</ol>\n<ul>\n<li>大切な書類を電車の中に忘れてしまいました。</li>\n<li>そんなに無理をすると、病気になってしまいますよ。<br>→そんなに無理をすると、病気になっちゃうよ。</li>\n</ul>\n<h2 id=\"62-～でしょう-推测\"><a href=\"#62-～でしょう-推测\" class=\"headerlink\" title=\"62. ～でしょう　[推测]\"></a>62. ～でしょう　[推测]</h2><ul>\n<li>明日は雨になるでしょう。</li>\n<li>今はゴールデンウイークですから、どの行楽地も混んでいるでしょう。</li>\n</ul>\n<h2 id=\"63-～でしょう？-确认\"><a href=\"#63-～でしょう？-确认\" class=\"headerlink\" title=\"63. ～でしょう？　[确认]\"></a>63. ～でしょう？　[确认]</h2><ul>\n<li>李さん、明日のパーティーに行くでしょう？　　　　　　（升调）</li>\n<li>え、このケーキ、おいしいと思うの？まずいでしょう！　（降调）</li>\n<li>お母さん、私の日記、見たでしょう！　　　　　　　　　（降调）</li>\n</ul>\n<h2 id=\"64-～でしょうか-礼貌的疑问方式。\"><a href=\"#64-～でしょうか-礼貌的疑问方式。\" class=\"headerlink\" title=\"64. ～でしょうか　礼貌的疑问方式。\"></a>64. ～でしょうか　礼貌的疑问方式。</h2><ul>\n<li>李さんは来ますか。→李さんは来るでしょうか。</li>\n<li>コーヒー、いかがですか。→コーヒー、いかがでしょうか。</li>\n</ul>\n<h2 id=\"65-～ですもの／～だもん\"><a href=\"#65-～ですもの／～だもん\" class=\"headerlink\" title=\"65. ～ですもの／～だもん\"></a>65. ～ですもの／～だもん</h2><p>表示说话人认为某事具有正当性，带有不满、抗议、申辩的语气。<br>一般为女性和儿童使用。</p>\n<ul>\n<li>今月から給料が上がったそうですね。<br>——こんなにたくさん仕事しているんですもの。当然でしょう</li>\n<li>冷蔵庫の中のケーキを食べちゃったのは太郎でしょう？<br>——だってお腹空いちゃったんだもん。</li>\n</ul>\n<h2 id=\"66-～ではありませんか\"><a href=\"#66-～ではありませんか\" class=\"headerlink\" title=\"66. ～ではありませんか\"></a>66. ～ではありませんか</h2><p>用否定疑问句的形式礼貌地表达自己肯定的观点。</p>\n<h2 id=\"67-～てほしい-表达对他人的希望。\"><a href=\"#67-～てほしい-表达对他人的希望。\" class=\"headerlink\" title=\"67. ～てほしい　表达对他人的希望。\"></a>67. ～てほしい　表达对他人的希望。</h2><ul>\n<li>だれか、手伝ってほしい。</li>\n<li>子どもに元気で、自信がある子に育ってほしい。</li>\n<li>早く連休が来てほしい。</li>\n</ul>\n<h2 id=\"68-～てみます-尝试做某事。\"><a href=\"#68-～てみます-尝试做某事。\" class=\"headerlink\" title=\"68.～てみます　尝试做某事。\"></a>68.～てみます　尝试做某事。</h2><ul>\n<li>ケーキを作ってみました。食べてみてください。</li>\n<li>日本語で友達に手紙を書いてみました。</li>\n</ul>\n<h2 id=\"69-～ても、～-转折\"><a href=\"#69-～ても、～-转折\" class=\"headerlink\" title=\"69. ～ても、～　[转折]\"></a>69. ～ても、～　[转折]</h2><ul>\n<li>宝くじに当たっても、仕事を続けます。</li>\n<li>明日雨でも、彼女に会いに行きます。</li>\n<li>いくら聞いても、彼は何も言わなかった。</li>\n</ul>\n<h2 id=\"70-名词＋でも-提示极端例子\"><a href=\"#70-名词＋でも-提示极端例子\" class=\"headerlink\" title=\"70. 名词＋でも　[提示极端例子]\"></a>70. 名词＋でも　[提示极端例子]</h2><ul>\n<li>この計算は難しくて、大人でもできません。</li>\n<li>この森は夏でも涼しい。</li>\n</ul>\n<h2 id=\"71-名词＋でも-示例\"><a href=\"#71-名词＋でも-示例\" class=\"headerlink\" title=\"71. 名词＋でも　[示例]\"></a>71. 名词＋でも　[示例]</h2><ul>\n<li>コーヒーでも飲みませんか。</li>\n<li>仕事の後、映画でも見ませんか。</li>\n</ul>\n<h2 id=\"72-～てもらいます\"><a href=\"#72-～てもらいます\" class=\"headerlink\" title=\"72. ～てもらいます\"></a>72. ～てもらいます</h2><h2 id=\"73-～と、～\"><a href=\"#73-～と、～\" class=\"headerlink\" title=\"73. ～と、～\"></a>73. ～と、～</h2><p>“一……，就……”，表示恒定不变的真理，反复性状态，习惯等。</p>\n<ul>\n<li>お酒を飲むと、必ず酔う。</li>\n<li>遅刻すると、彼女は必ず怒ります。</li>\n<li>兄は冬になると、スキーに行きます。<br>后项不可以出现祈使、命令、意志的表达方式。<br>还可表示意外的发现，此时后项要使用过去形式。</li>\n<li>カーテンを開けると、富士山が見えました。</li>\n</ul>\n<h2 id=\"74-～と会います\"><a href=\"#74-～と会います\" class=\"headerlink\" title=\"74. ～と会います　\"></a>74. ～と会います　</h2><p>に：用于单向性的动作对象<br>と：用于双向性的动作对象</p>\n<ul>\n<li>さっき駅前で佐藤さんに会いました。</li>\n<li>さっき駅前で佐藤さんと会いました。</li>\n</ul>\n<h2 id=\"75-～という～-表示称谓，“叫做……”。\"><a href=\"#75-～という～-表示称谓，“叫做……”。\" class=\"headerlink\" title=\"75. ～という～　表示称谓，“叫做……”。\"></a>75. ～という～　表示称谓，“叫做……”。</h2><ul>\n<li>これはフジという花です。</li>\n</ul>\n<h2 id=\"76-～（よ）うと思います-～（よ）うと思っています\"><a href=\"#76-～（よ）うと思います-～（よ）うと思っています\" class=\"headerlink\" title=\"76. ～（よ）うと思います ～（よ）うと思っています\"></a>76. ～（よ）うと思います ～（よ）うと思っています</h2><p>[动(意志形.]＋と思います　把自己要做某事的意志告诉听话人。</p>\n<ul>\n<li>来年結婚しようと思います。</li>\n<li>将来、日本へ留学しようと思います。<br>[动(意志形.]+ と思っています　表示某种意志持续了一段时间。</li>\n<li>今の仕事をやめようと思っています。</li>\n<li>将来、日本へ留学しようと思っています。</li>\n<li>張さんは将来、日本へ留学しようと思っています。</li>\n</ul>\n<h2 id=\"77-～とか～とか\"><a href=\"#77-～とか～とか\" class=\"headerlink\" title=\"77. ～とか～とか\"></a>77. ～とか～とか</h2><ul>\n<li>パーティーで、戴さんとか楊さんとか、いろいろな人に会いました。</li>\n<li>海外旅行に行きたいとか、新しい車が欲しいとか、ぜいたくなことばかり<br>　言っています。</li>\n</ul>\n<h2 id=\"78-～時、～\"><a href=\"#78-～時、～\" class=\"headerlink\" title=\"78. ～時、～\"></a>78. ～時、～</h2><ul>\n<li>子供の時、よく祖母と一緒に公園で散歩しました。</li>\n<li>映画を見る時、いつもいちばん後ろの席に座ります。</li>\n<li>忙しい時、いつもコンビニでお弁当を買って食べます。</li>\n<li>暇な時、よく一人で映画を見ます。</li>\n</ul>\n<h2 id=\"79-～ところです\"><a href=\"#79-～ところです\" class=\"headerlink\" title=\"79. ～ところです\"></a>79. ～ところです</h2><p>～る（基本形）+ところです。<br>～ている＋ところです。<br>～た＋ところです。</p>\n<h2 id=\"80-动词基本形＋な-禁止\"><a href=\"#80-动词基本形＋な-禁止\" class=\"headerlink\" title=\"80. 动词基本形＋な　[禁止]\"></a>80. 动词基本形＋な　[禁止]</h2><p>使用场合：1. 用于上对下，或有资格对对方发号施令的人；</p>\n<ol start=\"2\">\n<li>特殊、紧急的场合。</li>\n</ol>\n<ul>\n<li>仕事をサボるな！</li>\n<li>笑うな！</li>\n<li>危ない！来るな！</li>\n</ul>\n<h2 id=\"81-～ないと／～ないといけません\"><a href=\"#81-～ないと／～ないといけません\" class=\"headerlink\" title=\"81. ～ないと／～ないといけません\"></a>81. ～ないと／～ないといけません</h2><p>表示必须或义务，“不……不行，不得不……”。  </p>\n<ul>\n<li>時間がないから、そろそろ行かないと。</li>\n<li>明日までにレポートをまとめないといけません。</li>\n</ul>\n<h2 id=\"82-ながら\"><a href=\"#82-ながら\" class=\"headerlink\" title=\"82. ながら\"></a>82. ながら</h2><p>动词ます形去掉ます＋ながら， “一边……一边……” </p>\n<ul>\n<li>テレビを見ながらご飯を食べます。</li>\n<li>歩きながら電話をします。</li>\n<li>食事をしながら話しましょうか。</li>\n</ul>\n<h2 id=\"83-～なければ／～なければなりません-“必须……，不得不……”\"><a href=\"#83-～なければ／～なければなりません-“必须……，不得不……”\" class=\"headerlink\" title=\"83. ～なければ／～なければなりません　“必须……，不得不……”\"></a>83. ～なければ／～なければなりません　“必须……，不得不……”</h2><h2 id=\"84-なさい\"><a href=\"#84-なさい\" class=\"headerlink\" title=\"84. なさい\"></a>84. なさい</h2><p>动词ます形去掉ます＋なさい，表示命令。<br>多用于长辈对晚辈、上级对下级、老师对学生等发号施令，语气比命令形柔和些。</p>\n<ul>\n<li>早く寝なさい。</li>\n</ul>\n<h2 id=\"85-～なら、～\"><a href=\"#85-～なら、～\" class=\"headerlink\" title=\"85. ～なら、～\"></a>85. ～なら、～</h2><p>接续：简体形式＋なら（形2或名词去掉简体形式中的だ）<br>根据对方的言谈或现场情况，陈述自己的意见或想法，以及向对方提出建议、<br>忠告。</p>\n<ul>\n<li>天安門に行くなら、地下鉄が便利ですよ。</li>\n<li>お寿司なら、駅前のあのお店がいいですよ。</li>\n<li>魚を買うなら、築地市場がいいですよ。</li>\n<li>飲んだら乗るな。乗るなら飲むな。</li>\n</ul>\n<h2 id=\"86-～に-用途-基准\"><a href=\"#86-～に-用途-基准\" class=\"headerlink\" title=\"86. ～に　[用途][基准]\"></a>86. ～に　[用途][基准]</h2><p>[名词]＋に<br>[动词基本形]＋のに</p>\n<ul>\n<li>この写真はパスポートの申請に使います。　　　　　　　　　　　[用途]<br>この写真はパスポートを申請するのに使います。　　　　　　　　[用途]</li>\n<li>このマンションはスーパーから近くて、買い物に便利です。　　　[基准]<br>このマンションはスーパーから近くて、買い物するのに便利です。[基准]</li>\n</ul>\n<h2 id=\"87-～によると-表示传闻、消息的来源。\"><a href=\"#87-～によると-表示传闻、消息的来源。\" class=\"headerlink\" title=\"87. ～によると　表示传闻、消息的来源。\"></a>87. ～によると　表示传闻、消息的来源。</h2><ul>\n<li>天気予報によると、明日は雨だそうです。</li>\n<li>田中さんの話によると、佐藤さんは来月会社を辞めるそうです。</li>\n</ul>\n<h2 id=\"88-～によって\"><a href=\"#88-～によって\" class=\"headerlink\" title=\"88. ～によって\"></a>88. ～によって</h2><p>～によって：表示变化的依据，“因……的不同而不同”</p>\n<ul>\n<li>飛行機のチケットは高かったり、安かったり、季節によって違います。<br>以事物作主语的被动句中，当动作主体是特定的人时，要用によって来提示。<br>-『阿Q正伝』は魯迅によって書かれました。</li>\n<li>この車は日本の有名なデザイナーによって設計されました。</li>\n</ul>\n<h2 id=\"89-～のが～です\"><a href=\"#89-～のが～です\" class=\"headerlink\" title=\"89. ～のが～です\"></a>89. ～のが～です</h2><ul>\n<li>自転車に二人で乗るのは危ないです。</li>\n<li>一人で映画を見るのが好きです。</li>\n</ul>\n<h2 id=\"90-～のが見えます／～のが聞こえます\"><a href=\"#90-～のが見えます／～のが聞こえます\" class=\"headerlink\" title=\"90. ～のが見えます／～のが聞こえます\"></a>90. ～のが見えます／～のが聞こえます</h2><p>見える：自动词，某种景象映入眼帘。<br>聞こえる：自动词，某种声音传入耳朵。</p>\n<ul>\n<li>隣の部屋で子どもたちが騒いでいるのが聞こえますか。</li>\n<li>グラウンドで子どもたちが野球をしているのが見えます。</li>\n</ul>\n<h2 id=\"91-～のために-目的-～のために-理由、原因\"><a href=\"#91-～のために-目的-～のために-理由、原因\" class=\"headerlink\" title=\"91. ～のために　[目的] ～のために　[理由、原因]\"></a>91. ～のために　[目的] ～のために　[理由、原因]</h2><p>[动词][1形容词(简体.]+ために<br>[名]+の＋ために</p>\n<h2 id=\"92-～ので、～-理由、原因\"><a href=\"#92-～ので、～-理由、原因\" class=\"headerlink\" title=\"92. ～ので、～　[理由、原因]\"></a>92. ～ので、～　[理由、原因]</h2><p>接续：[动词／一类形容词简体]＋ので<br>[名词／二类形容词简体(だ→な.]＋ので<br>用法：用于客观叙述某事的原因、理由。</p>\n<ul>\n<li>家が遠いので、毎朝はやく起きなければなりません。</li>\n<li>目が疲れたので、少し休みます。</li>\n<li>ここは静かなので、とても気に入っています。</li>\n<li>もう終電の時間なので、帰ります。</li>\n<li>昨日は休みだったので、映画を見に行きました。</li>\n</ul>\n<h2 id=\"93-～のではないでしょうか-婉转陈述意见\"><a href=\"#93-～のではないでしょうか-婉转陈述意见\" class=\"headerlink\" title=\"93. ～のではないでしょうか　[婉转陈述意见]\"></a>93. ～のではないでしょうか　[婉转陈述意见]</h2><p>表达的是一种委婉的肯定， “不是……吗？”相当于“と思います”，<br>语气更委婉。</p>\n<ul>\n<li>免税店では女性向けの商品がよく売れるのではないでしょうか。</li>\n</ul>\n<h2 id=\"94-～の時、～\"><a href=\"#94-～の時、～\" class=\"headerlink\" title=\"94. ～の時、～\"></a>94. ～の時、～</h2><p>[名]+の＋時<br>表示“……的时候”。</p>\n<h2 id=\"95-～のに-用途-基准\"><a href=\"#95-～のに-用途-基准\" class=\"headerlink\" title=\"95. ～のに　[用途][基准]\"></a>95. ～のに　[用途][基准]</h2><p>[动词基本形]＋の＋に</p>\n<h2 id=\"96-～のに、～-转折\"><a href=\"#96-～のに、～-转折\" class=\"headerlink\" title=\"96. ～のに、～　[转折]\"></a>96. ～のに、～　[转折]</h2><p>表示在小句1的情况下发生小句2的情况不符合常识常理，“明明……却，<br>可是，偏偏……”。</p>\n<ul>\n<li>目覚ましをかけておいたのに、今朝は起きられませんでした。</li>\n<li>森さんは家が近いのによく遅刻します。</li>\n<li>田中さんは作家なのに、読書が嫌いです。<br>接续：[小句1(简体形.]のに、[小句2]<br>[名词]／[二类形容词的现在肯定简体形式(だ→な.]＋のに、小句2</li>\n</ul>\n<h2 id=\"97-～のは～です。\"><a href=\"#97-～のは～です。\" class=\"headerlink\" title=\"97. ～のは～です。\"></a>97. ～のは～です。</h2><h2 id=\"98-～のまま、～\"><a href=\"#98-～のまま、～\" class=\"headerlink\" title=\"98. ～のまま、～\"></a>98. ～のまま、～</h2><p>[小句1(动词た形／ない形.]まま、小句2<br>[名]＋の＋まま、小句</p>\n<ul>\n<li>眼鏡をかけたまま、寝てしまいました。</li>\n<li>馬さんは行き先を告げないまま、家を出てしまいました。</li>\n<li>わたしたちは空腹のまま、出発しました。</li>\n<li>講堂に入る時、携帯の電源を切らなければなりませんか。<br>　——いいえ、付けたままでいいですよ。</li>\n</ul>\n<h2 id=\"99-～のようです-推测\"><a href=\"#99-～のようです-推测\" class=\"headerlink\" title=\"99. ～のようです　[推测]\"></a>99. ～のようです　[推测]</h2><p>说话人根据自己感知的情况，进行推测。<br>[小句(简体形.]＋ようです<br>[名]＋の＋ようです<br>[二类形词干]+な＋ようです</p>\n<ul>\n<li>玄関のところにだれかがいるようです。</li>\n<li>店の前には行列ができています。あの店の料理はおいしいようです。</li>\n<li>値段はほかの店の倍です。ここの料理はかなり豪華なようです。</li>\n<li>遠くから何か飛んできます。飛行機のようですね。</li>\n</ul>\n<h2 id=\"100-～のような味／においがします\"><a href=\"#100-～のような味／においがします\" class=\"headerlink\" title=\"100. ～のような味／においがします\"></a>100. ～のような味／においがします</h2><p>味・におい・声・音・感じ＋がする：表示有这种感觉。</p>\n<ul>\n<li>この野菜、レモンのような味がします。</li>\n<li>このせっけんは爽やかで、ランのようなにおいがします。</li>\n<li>ここには昔来たことがあるような感じがします。<br>寒気（さむけ）・吐き気（はきけ）・頭痛（ずつう）＋がする</li>\n<li>今朝から、ずっと寒気がしています。</li>\n</ul>\n<h2 id=\"101-～のを～\"><a href=\"#101-～のを～\" class=\"headerlink\" title=\"101. ～のを～\"></a>101. ～のを～</h2><ul>\n<li>手紙を出すのを忘れました。</li>\n<li>吉田さんが転勤するのを知っていますか。</li>\n</ul>\n<h2 id=\"102-～ば、～\"><a href=\"#102-～ば、～\" class=\"headerlink\" title=\"102. ～ば、～\"></a>102. ～ば、～</h2><h2 id=\"103-～は～という～です-用于下定义或做解释。\"><a href=\"#103-～は～という～です-用于下定义或做解释。\" class=\"headerlink\" title=\"103. ～は～という～です　用于下定义或做解释。\"></a>103. ～は～という～です　用于下定义或做解释。</h2><ul>\n<li>駐車禁止はここに車を止めるなという意味です。</li>\n<li>そのマークはここでタバコを吸うなという意味です。</li>\n</ul>\n<h2 id=\"110-～ば～ほど-“越…越…”。\"><a href=\"#110-～ば～ほど-“越…越…”。\" class=\"headerlink\" title=\"110. ～ば～ほど　“越…越…”。\"></a>110. ～ば～ほど　“越…越…”。</h2><p>接续：[动ば形]+[动(基本形.]＋ほど＋[小句]<br>[一类形容词ば形]+[一类形容词(原形.]＋ほど＋[小句]<br>[二类形容词(词干.]+なら＋[二类形容词(词干.]＋な＋ほど＋[小句]<br>[二类形容词(词干.]+であれば＋[二类形容词(词干.]＋な＋ほど＋[小句]<br>[二类形容词(词干.]+であれば＋あるほど＋[小句]</p>\n<ul>\n<li>この本は読めば読むほど、おもしろいです。</li>\n<li>彼のことを知れば知るほど、好きになる。</li>\n<li><p>商品は安ければ安いほど売れるでしょう？</p>\n</li>\n<li><p>子供は元気なら元気なほどいいです。<br>　子供は元気であれば元気なほどいいです。</p>\n</li>\n</ul>\n<h2 id=\"111-～ばかり～-～ばかりいます\"><a href=\"#111-～ばかり～-～ばかりいます\" class=\"headerlink\" title=\"111. ～ばかり～　～ばかりいます\"></a>111. ～ばかり～　～ばかりいます</h2><p>[名]＋ばかり＋[动]：表示所列举的事物全部相同；“光、净、只……”<br>[动(て形.]＋ばかり＋います：表示总是发生同样的事情或总是进行同样的动作。<br>　　　　　　　　　　　　　“老是，总是，光……，净……”[反复]</p>\n<ul>\n<li>林さんはカラオケで古い歌ばかり歌います。</li>\n<li>うちの息子は毎日ゲームばかりしています。</li>\n<li>張さんは毎日お酒を飲んでばかりいます。</li>\n<li>遊んでばかりいないで、しっかり勉強しなさい。</li>\n</ul>\n<h2 id=\"112-～はじめる／～出す\"><a href=\"#112-～はじめる／～出す\" class=\"headerlink\" title=\"112. ～はじめる／～出す\"></a>112. ～はじめる／～出す</h2><h2 id=\"113-～はずがありません\"><a href=\"#113-～はずがありません\" class=\"headerlink\" title=\"113. ～はずがありません\"></a>113. ～はずがありません</h2><p>～はずです<br>はずです：表示个人根据某种理由，做好自身认为合情理的推断。</p>\n<ul>\n<li>会議は5 時までですから、もうすぐ終わるはずです。</li>\n<li>森さんは１時間ほど前に会社を出ましたから、もう家に着いているはずです。<br>～はずがない：不可能……</li>\n<li>張さんは入院中ですから、旅行に行くはずがありません。</li>\n<li>7月のオーストラリアは冬ですから、暑いはずがありません。</li>\n</ul>\n<h2 id=\"114-～までに\"><a href=\"#114-～までに\" class=\"headerlink\" title=\"114. ～までに\"></a>114. ～までに</h2><p>表示某事的截止时间点，即：在……之前，完成或发生某事。    </p>\n<ul>\n<li>来週の水曜日までにレポートを提出してください。</li>\n<li>今月の末までに、新しい家を見つけたいです。<br>～まで：在……之前，持续做某事或某状态。</li>\n<li>彼に会うまで、ここで待つ。</li>\n</ul>\n<h2 id=\"116-～ようです／～みたいです-推测-比喻\"><a href=\"#116-～ようです／～みたいです-推测-比喻\" class=\"headerlink\" title=\"116. ～ようです／～みたいです　[推测][比喻]\"></a>116. ～ようです／～みたいです　[推测][比喻]</h2><p>“ようです”语气正式，“みたいです”口语化。</p>\n<ul>\n<li>遠くから何か飛んできます。飛行機のようですね。　　　　[推测]<br>遠くから何か飛んでくる。飛行機みたいだね。　　　　　　[推测]</li>\n<li>これは柔らかくて、まるで本物の毛皮のようです。　　　　[比喻]</li>\n<li>あの子は目が大きくてかわいいね。まるで人形みたいだ。　[比喻]</li>\n<li>この野菜、レモンのような味がします。　　　　　　　　　[比喻]</li>\n<li>鳥のように空を飛んでみたいな。　　　　　　　　　　　　[比喻]</li>\n<li>田中さんのお宅はホテルのようにきれいです。　　　　　　[比喻]</li>\n</ul>\n<h2 id=\"117-～も-超出预想\"><a href=\"#117-～も-超出预想\" class=\"headerlink\" title=\"117. ～も　[超出预想]\"></a>117. ～も　[超出预想]</h2><p>数量词+も+肯定：数量之多。</p>\n<ul>\n<li>参加者は50人も超えました。</li>\n<li>今日は3リットルも水を飲みました。</li>\n</ul>\n<h2 id=\"118-～やすい／～にくい\"><a href=\"#118-～やすい／～にくい\" class=\"headerlink\" title=\"118. ～やすい／～にくい\"></a>118. ～やすい／～にくい</h2><p>[动词ます形去掉ます]＋やすい：构成形1，表示“易于……”<br>[动词ます形去掉ます]＋にくい：构成形1，表示“难于……”</p>\n<ul>\n<li>このペンは書きやすいです。</li>\n<li>この本は漢字が多くて、読みにくいです。</li>\n<li>雨の日は事故が起こりやすいです。</li>\n<li>運動している人は太りにくいです。</li>\n</ul>\n<h2 id=\"119-～ように\"><a href=\"#119-～ように\" class=\"headerlink\" title=\"119. ～ように\"></a>119. ～ように</h2><p>为了使前项成立，而做后项事情。前接非意志性动词，或意志性动词可能形式<br>的基本形或ない形。</p>\n<ul>\n<li>留学生も分かるように、先生はゆっくり説明してくれました。</li>\n<li>子どもが触れないように、この薬は棚のいちばん上に置きましょう。</li>\n</ul>\n<h2 id=\"120-～ようにします\"><a href=\"#120-～ようにします\" class=\"headerlink\" title=\"120. ～ようにします\"></a>120. ～ようにします</h2><p>“努力做到…… ”。前接意志性动词的基本形或ない形。</p>\n<ul>\n<li>のどが痛いので、今日はあまり話さないようにします。</li>\n<li>明日の会議には、できるだけ出るようにします。<br>～ようにしている：有意识地将某个习惯保留下来。</li>\n<li>陳さんは毎日、英字新聞を読むようにしています。</li>\n<li>健康のために、毎日30分ぐらいジョギングをするようにしています。</li>\n</ul>\n<h2 id=\"121-～ようになります\"><a href=\"#121-～ようになります\" class=\"headerlink\" title=\"121. ～ようになります\"></a>121. ～ようになります</h2><p>表示能力、状况等的变化。前接非意志性动词，或意志性动词可能形式的<br>基本形或ない形。</p>\n<ul>\n<li>けがが治って、歩けるようになりました。</li>\n<li>赤ちゃんは1歳を過ぎると、言葉を話すようになります。</li>\n</ul>\n<h2 id=\"122-名词-＋らしい～-典型性\"><a href=\"#122-名词-＋らしい～-典型性\" class=\"headerlink\" title=\"122. [名词]＋らしい～　[典型性]\"></a>122. [名词]＋らしい～　[典型性]</h2><ul>\n<li>食事らしい食事</li>\n<li>女らしい女</li>\n<li>学生なら、学生らしくしっかり勉強しなさい。</li>\n</ul>\n<h2 id=\"123-～らしいです-推测-传闻\"><a href=\"#123-～らしいです-推测-传闻\" class=\"headerlink\" title=\"123. ～らしいです　[推测][传闻]\"></a>123. ～らしいです　[推测][传闻]</h2><p>[小句(简体形.]＋らしいです</p>\n<ul>\n<li>田中さんは来月から大阪支社へ転勤するらしいですよ。　[传闻]</li>\n<li>電気が消えています。李さんは出かけたらしいですね。　[推测]</li>\n<li>火曜日なのに店が閉まっている。今日は休みらしいね。　[推测]</li>\n</ul>\n<h2 id=\"124-～られます-尊他语形式\"><a href=\"#124-～られます-尊他语形式\" class=\"headerlink\" title=\"124. ～られます　尊他语形式\"></a>124. ～られます　尊他语形式</h2><h2 id=\"125-～んじゃないですか-婉转陈述意见的表达\"><a href=\"#125-～んじゃないですか-婉转陈述意见的表达\" class=\"headerlink\" title=\"125. ～んじゃないですか　[婉转陈述意见的表达]\"></a>125. ～んじゃないですか　[婉转陈述意见的表达]</h2><p>与“～のではないでしょうか”一样，用否定疑问句的形式，婉转地表达<br>自己肯定的意见，但礼貌程度比“～のではないでしょうか”稍低。</p>\n<ul>\n<li>ここ、いいんじゃないですか。</li>\n<li>さっきのはもっと広かったんじゃないですか。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;初级下，自他动词，敬语，动词的意志形，被动型，命令形。<br></p>","more":"</p>\n<h2 id=\"1-名词的修饰\"><a href=\"#1-名词的修饰\" class=\"headerlink\" title=\"1.名词的修饰\"></a>1.名词的修饰</h2><p>动词：简体形式（基本形、た形、ない形、～なかった）<br>形1：简体形式（赤いです→赤い、おもしろかったです→おもしろかった） </p>\n<ul>\n<li>これは明日会議で使う資料です。（〇）   明日会議で使います（×）</li>\n<li>あれは森さんが今夜泊まるホテルです。</li>\n<li>あれはゆうべ泊まったホテルです。</li>\n<li>今、李さんと話している人はだれですか。</li>\n<li>あの背が高い男性は森さんです。</li>\n</ul>\n<p>形2：词干＋な</p>\n<ul>\n<li>操作が簡単なパソコンが欲しいです。</li>\n</ul>\n<p>名词：名词1＋の＋名词2</p>\n<ul>\n<li>数学が専門の先生が今日休みました。</li>\n</ul>\n<h2 id=\"2-自动词和他动词\"><a href=\"#2-自动词和他动词\" class=\"headerlink\" title=\"2.自动词和他动词\"></a>2.自动词和他动词</h2><p>常见的两种（自、他动词的）词形对应关系：</p>\n<ol>\n<li>自动词词尾为 aru，他动词词尾为 eru；</li>\n</ol>\n<ul>\n<li>かかる<->かける</-></li>\n<li>始まる<->始める</-></li>\n<li>閉まる<->閉める</-></li>\n<li>止まる<->止める</-></li>\n</ul>\n<ol start=\"2\">\n<li>自动词词尾为 eru、ru，他动词词尾为 su。</li>\n</ol>\n<ul>\n<li>壊れる<->壊す</-></li>\n<li>消える<->消す</-></li>\n<li><p>落ちる<->落とす</-></p>\n</li>\n<li><p>李さんが部屋の電気を消した。→部屋の電気が消えている。</p>\n</li>\n<li>田中さんがドアを開けた。→ドアが開いている。</li>\n</ul>\n<h2 id=\"3-形容词的副词性用法\"><a href=\"#3-形容词的副词性用法\" class=\"headerlink\" title=\"3.形容词的副词性用法\"></a>3.形容词的副词性用法</h2><p>形1：词尾“い”→“く”<br>形2：词干＋に</p>\n<ul>\n<li>楽しく生きたい</li>\n<li>自由に生きたい</li>\n</ul>\n<h2 id=\"4-形容词＋さ：形容词的名词化\"><a href=\"#4-形容词＋さ：形容词的名词化\" class=\"headerlink\" title=\"4.形容词＋さ：形容词的名词化　\"></a>4.形容词＋さ：形容词的名词化　</h2><p>形1：词尾“い”→“さ”<br>形2：词干＋さ</p>\n<ul>\n<li>この暑さはいつまで続くでしょう。</li>\n<li>やっと仕事の楽しさが分かった。</li>\n<li>やっと彼の良さが分かった。</li>\n<li>彼のまじめさには参りました。</li>\n</ul>\n<h2 id=\"5-动词的命令形\"><a href=\"#5-动词的命令形\" class=\"headerlink\" title=\"5.动词的命令形\"></a>5.动词的命令形</h2><p>动1：把基本形的最后一个假名变成相应的“え”段假名；</p>\n<ul>\n<li>帰る→帰れ</li>\n<li>消す→消せ</li>\n<li>行く→行け</li>\n<li>待つ→待て</li>\n<li>死ぬ→死ね<br>动2：把基本形的“る”变成“ろ”；</li>\n<li>見る→見ろ</li>\n<li>起きる→起きろ<br>动3：把“来る（くる）”变成“来い（こい）”，把“する”变成“しろ”。</li>\n<li>電気を消せ！</li>\n<li>早く書類を提出しろ！</li>\n<li>早く来い！</li>\n<li>金を返せ！</li>\n<li>死ね！<br>喊加油“頑張れ”时，女性可使用命令形，除此以外的场合，不宜使用命令形。</li>\n</ul>\n<h2 id=\"6-动词的意志形\"><a href=\"#6-动词的意志形\" class=\"headerlink\" title=\"6.动词的意志形\"></a>6.动词的意志形</h2><p>动1：把基本形的最后一个假名变成相应的“お”段上的长音；</p>\n<ul>\n<li>帰る→帰ろう</li>\n<li>書く→書こう</li>\n<li>待つ→待とう<br>动2：把基本形的“る”变成“よう”；</li>\n<li>食べる→食べよう</li>\n<li>見る→見よう</li>\n<li>寝る→寝よう<br>动3：“来る”变成“来よう（こよう）”，“する”变成“しよう”。</li>\n</ul>\n<ol>\n<li>表示自己当场形成的决心、意志（多用于自言自语）</li>\n</ol>\n<ul>\n<li>もう11時だから、寝よう。</li>\n<li>明日はテストだ。今晩は勉強しよう。</li>\n</ul>\n<ol start=\"2\">\n<li>表示向对方提议、劝诱（相当于“～ましょう”的简体形）</li>\n</ol>\n<ul>\n<li>仕事が終わったら、飲みに行こう。= 飲みに行きましょう。</li>\n<li>駅まで送ろう。 </li>\n</ul>\n<h2 id=\"7-动词的ば形\"><a href=\"#7-动词的ば形\" class=\"headerlink\" title=\"7.动词的ば形\"></a>7.动词的ば形</h2><p>动词ば形：<br>动1：把基本形最后一个音变成相应的“え”段上的音，再加“ば”；</p>\n<ul>\n<li>書く→書けば</li>\n<li>待つ→待てば</li>\n<li>読む→読めば</li>\n<li>飛ぶ→飛べば<br>动2：把基本形的“る”变成“れば”；</li>\n<li>食べる→食べれば</li>\n<li>見る→見れば</li>\n<li>寝る→寝れば<br>动3：“来る”变成“来れば（くれば）”，“する”变成“すれば”。</li>\n</ul>\n<p>形1ば形：<br>一类形容词“ば形”：把词尾“い”变成“ければ”。</p>\n<ul>\n<li>楽しい→楽しければ</li>\n<li>広い→広ければ</li>\n<li>安い→安ければ</li>\n<li>いい→よければ</li>\n</ul>\n<p>表示前项是后项的条件，“要怎么样，才会这样”。</p>\n<ul>\n<li>どうすれば、東大に入ることができますか。<br>——申請して、入学試験と面接に合格すれば、入ることができますよ。</li>\n<li>急がなければ、遅れますよ。</li>\n<li>旅行に行けば、彼のことが忘れられるでしょう。</li>\n</ul>\n<h2 id=\"8-动词的可能形式\"><a href=\"#8-动词的可能形式\" class=\"headerlink\" title=\"8.动词的可能形式\"></a>8.动词的可能形式</h2><p>动1：把基本形的最后一个音变成相应的“え”段上的音，再加“る”；</p>\n<ul>\n<li>書く→書ける</li>\n<li>話す→話せる</li>\n<li>乗る→乗れる</li>\n<li>飛ぶ→飛べる<br>动2：把基本形的“る”变成“られる”；</li>\n<li>食べる→食べられる</li>\n<li>見る→見られる</li>\n<li>寝る→寝られる<br>动3：“来る”变成“来られる（こられる）”，“する”变成“できる”。<br>相当于“～ことができる”。</li>\n</ul>\n<ol>\n<li>表示能力。</li>\n</ol>\n<ul>\n<li>李さんは日本語が話せます。＝李さんは日本語を話すことができます。</li>\n<li>わたしは自転車に乗れません。</li>\n</ul>\n<ol start=\"2\">\n<li>表示条件允许或可能性。</li>\n</ol>\n<ul>\n<li>日本では、女性は16歳、男性は18歳から結婚できます。</li>\n<li>このキノコは食べられますか。</li>\n</ul>\n<p>在可能形式的前面，表示能力的对像，用助词“が”表示。</p>\n<h2 id=\"9-动词被动形式\"><a href=\"#9-动词被动形式\" class=\"headerlink\" title=\"9.动词被动形式\"></a>9.动词被动形式</h2><p>动1：把“ない形”的“ない”变成“れる”；</p>\n<ul>\n<li>書く→書かれる</li>\n<li>読む→読まれる</li>\n<li>叱る→叱られる</li>\n<li>笑う→笑われる<br>动2：把“ない形”的“ない”变成“られる”；</li>\n<li>食べる→食べられる</li>\n<li>見る→見られる</li>\n<li>褒める→褒められる<br>动3：“来る”变成“来られる（こられる）”，“する”变成“される”。<br>被动句的四种句型</li>\n</ul>\n<ol>\n<li>直接被动句</li>\n</ol>\n<ul>\n<li>兄が弟を叱る。→弟が兄に叱られる。</li>\n<li>兄が弟に話しかける。→弟が兄に話しかけられる。</li>\n</ul>\n<ol start=\"2\">\n<li>持有者被动句：</li>\n</ol>\n<ul>\n<li>今朝、電車の中で財布を盗まれた。　　（〇）わたしの財布が盗まれた。　　　　　　（×）</li>\n<li>李さんは昨日犬に手を噛まれました。　（〇）</li>\n</ul>\n<ol start=\"3\">\n<li>受害被动句</li>\n</ol>\n<ul>\n<li>主动句：鳥が逃げました。→陳さんは鳥に逃げられました。</li>\n<li>張さんは昨日隣の人に夜遅くまで騒がれました。</li>\n<li>食事中、隣の人にタバコを吸われました。</li>\n<li>父に死なれて、大学を続けられなくなりました。</li>\n</ul>\n<ol start=\"4\">\n<li>事物做主语的被动句</li>\n</ol>\n<ul>\n<li>この歌は世界中で歌われています。</li>\n<li>この本は世界中の子どもたちに読まれています。<br>当动作主体是特定的人时，用“によって”表示动作主体。<br>-『阿Q正伝』は魯迅によって書かれました。</li>\n</ul>\n<h2 id=\"10-动词的使役形式\"><a href=\"#10-动词的使役形式\" class=\"headerlink\" title=\"10.动词的使役形式\"></a>10.动词的使役形式</h2><p>动1：把“ない形”的“ない”变成“せる”；</p>\n<ul>\n<li>書く→書かせる</li>\n<li>急ぐ→急がせる</li>\n<li>待つ→待たせる</li>\n<li>読む→読ませる</li>\n<li>やる→やらせる<br>动2：把“ない形”的“ない”变成“させる”；</li>\n<li>食べる→食べさせる</li>\n<li>見る→見させる<br>动3：把“来る”变成“来させる（こさせる）”，把“する”变成“させる”。<br>使役句的两种结构：</li>\n</ul>\n<ol>\n<li>自动词的使役句</li>\n</ol>\n<ul>\n<li>部長は李さんを出張させます。</li>\n<li>あの課長は部下を休ませません。</li>\n</ul>\n<ol start=\"2\">\n<li>他动词的使役句</li>\n</ol>\n<ul>\n<li>部長は太田さんにレポートを書かせます。</li>\n<li>先生は生徒にこの本を読ませます。<br>使役句的三种用法</li>\n</ul>\n<ol>\n<li>强制，要求，指示（让~做……）</li>\n</ol>\n<ul>\n<li>部長は太田さんにレポートを書かせます。</li>\n<li>先生は生徒にこの本を読ませます。</li>\n</ul>\n<ol start=\"2\">\n<li>许可、放任（让~做……，允许~做……）</li>\n</ol>\n<ul>\n<li>あの課長は部下を休ませません。</li>\n<li>子供にできるだけ好きなことをさせたいです。</li>\n</ul>\n<ol start=\"3\">\n<li>原因、导致（让……，使……）</li>\n</ol>\n<ul>\n<li>弟はよく両親を心配させます。</li>\n<li>お待たせしました。</li>\n</ul>\n<h2 id=\"11-动词的使役被动形式\"><a href=\"#11-动词的使役被动形式\" class=\"headerlink\" title=\"11.动词的使役被动形式\"></a>11.动词的使役被动形式</h2><p>动1：“ない形”的“ない”→“せられる”→“される”；<br>动2：“ない形”的“ない”→“させられる” ；<br>动3：“来る”变成“来させられる（こさせられる）”，“する”变成“させられる”。</p>\n<p>动1中，除以「す」结尾的动词外，可将使役被动形式中的「せら」约音为「さ」。<br>结构：[被迫动作主体]は[要求做动作者]に～[使役被动]ます。</p>\n<ul>\n<li>選手は監督に走らされます。     </li>\n<li>生徒は先生にこの本を読ませられます／読まされます。</li>\n<li>小さいとき、母にピアノを習わされました。</li>\n</ul>\n<h2 id=\"12-尊他语\"><a href=\"#12-尊他语\" class=\"headerlink\" title=\"12.尊他语\"></a>12.尊他语</h2><p>通过抬高话题中的动作主体，而对动作主体表示敬意。<br>动词的尊他语的形式：</p>\n<ol>\n<li>～（ら）れる<br>I类动词：动词ない形（ない）＋れる  - 行く→行かれる<br>II类动词：动词ない形（ない）＋られる  - 教える→教えられる<br>III类动词：来る→来られる、～する→～される</li>\n</ol>\n<ul>\n<li>周先生は明日日本へ行かれます。</li>\n<li>今朝何時に起きられましたか。</li>\n</ul>\n<ol start=\"2\">\n<li>お／ご～になる<br>お＋I类动词／II类动词ます形去掉ます＋になる<br>ご＋III类动词的汉字部分+になる  </li>\n</ol>\n<ul>\n<li>お客様はもうお帰りになりましたか。 </li>\n<li>明日の会議には、社長もご出席になるそうです。</li>\n</ul>\n<ol start=\"3\">\n<li>特殊形式</li>\n</ol>\n<ul>\n<li>先生、何を召し上がりますか。</li>\n</ul>\n<h2 id=\"13-自谦语\"><a href=\"#13-自谦语\" class=\"headerlink\" title=\"13.自谦语\"></a>13.自谦语</h2><p>通过贬低动作主体（自己或己方人员），从而相对地对动作接受者表示敬意<br>动词的自谦语的形式：</p>\n<ol>\n<li>お／ご～する<br>お＋I类动词／II类动词ます形去掉ます＋する　<br>ご＋III类动词的汉字部分+する  </li>\n</ol>\n<ul>\n<li>私は夕べ社長を車でお送りしました。</li>\n<li>お荷物をお持ちしましょうか。</li>\n<li>明日の午後、ご連絡します。</li>\n</ul>\n<ol start=\"2\">\n<li>特殊的自谦语动词</li>\n</ol>\n<ul>\n<li>先日、先生のお宅に伺いました。</li>\n<li>先生の論文を拝見しました。</li>\n</ul>\n<h2 id=\"14-～間-～間に\"><a href=\"#14-～間-～間に\" class=\"headerlink\" title=\"14.～間 ～間に\"></a>14.～間 ～間に</h2><p>～間：某动作或状态持续的期间<br>～間に：某动作或事情发生或完成的期间范围。</p>\n<ul>\n<li>子どもが寝ている間、ずっと家事をしていました。</li>\n<li>子どもが寝ている間に、家事を済ませたいです。</li>\n<li>夏休みの間、ずっとアルバイトをしていました。</li>\n<li>夏休みの間に、レポートを書き終わりました。</li>\n</ul>\n<h2 id=\"15-お・ご～します-lt-自谦语-gt\"><a href=\"#15-お・ご～します-lt-自谦语-gt\" class=\"headerlink\" title=\"15. お・ご～します&lt;自谦语&gt;\"></a>15. お・ご～します&lt;自谦语&gt;</h2><h2 id=\"16-お・ご～になります-lt-尊他语-gt\"><a href=\"#16-お・ご～になります-lt-尊他语-gt\" class=\"headerlink\" title=\"16. お・ご～になります&lt;尊他语&gt;　\"></a>16. お・ご～になります&lt;尊他语&gt;　</h2><h2 id=\"17-～終わります\"><a href=\"#17-～終わります\" class=\"headerlink\" title=\"17.～終わります\"></a>17.～終わります</h2><p>～はじめる・～だす・～つづける・～おわる<br>[动(ます形去掉ます.]+始める：开始……<br>[动(ます形去掉ます.]+出す：突然开始……<br>[动(ます形去掉ます.]+続ける：表示持续做某事<br>[动(ます形去掉ます.]+終わる：表示动作或事情结束</p>\n<ul>\n<li>雨が降り始めました。</li>\n<li>子どもが急に泣き出しました。</li>\n<li>３時間も待ち続けていたけど、彼は結局来てくれなかった。</li>\n<li>この本はもう読み終わりましたか。<br>降る＋つづく</li>\n<li>雨が１週間も降り続きました。</li>\n</ul>\n<h2 id=\"18-（～が～）～は／が～-名词修饰句节\"><a href=\"#18-（～が～）～は／が～-名词修饰句节\" class=\"headerlink\" title=\"18.（～が～）～は／が～　名词修饰句节\"></a>18.（～が～）～は／が～　名词修饰句节</h2><p>经修饰的名词短语可以在句子中充当各种成分。<br>名词修饰句节（定语从句）中的小主语要用“が”，而不用“は”。</p>\n<p>-（小野さんが作る）料理はおいしいです。<br>-（森さんがくれた）本はこれです。<br>-（操作が簡単な）パソコンが欲しいです。<br>-（明るくて、頭がいい）男性が好きです。</p>\n<h2 id=\"19-～かしら-和「かな」语义相近，前接简体形式，多为女性使用。\"><a href=\"#19-～かしら-和「かな」语义相近，前接简体形式，多为女性使用。\" class=\"headerlink\" title=\"19.～かしら　和「かな」语义相近，前接简体形式，多为女性使用。\"></a>19.～かしら　和「かな」语义相近，前接简体形式，多为女性使用。</h2><ol>\n<li>吐露内心疑问的自言自语。- 森さんたちは来ているかしら。</li>\n<li>有听话人在场，向对方发问。</li>\n</ol>\n<h2 id=\"20-～かもしれない\"><a href=\"#20-～かもしれない\" class=\"headerlink\" title=\"20.～かもしれない\"></a>20.～かもしれない</h2><p>表示说话人的推测，认为某事有可能发生，也有可能不发生。</p>\n<ol>\n<li>[动词]／[一类形容词小句简体形]+かもしれない</li>\n<li>[二类形容词]／[名词小句简体形去だ]+かもしれない</li>\n</ol>\n<ul>\n<li>小野さんは来ないかもしれません/かもしれない。<br>～　　忙しい　　　～<br>～　　暇　　　　　～<br>～　　病気　　　　～</li>\n</ul>\n<h2 id=\"21-～ことがある\"><a href=\"#21-～ことがある\" class=\"headerlink\" title=\"21.～ことがある\"></a>21.～ことがある</h2><p>[动词基本形]／[ない形]＋ことがある：“有时……”。</p>\n<ul>\n<li>時々課長と一緒にゴルフをすることがあります。</li>\n<li>日曜日はいつも家で掃除をします。でも、たまに友達と買い物する<br>　こともあります。</li>\n<li>彼はいつも返信が早いです。でも、たまに返信しないこともあります。</li>\n</ul>\n<h2 id=\"22-～ことにします／～ことにしました：“我决定……”\"><a href=\"#22-～ことにします／～ことにしました：“我决定……”\" class=\"headerlink\" title=\"22.～ことにします／～ことにしました：“我决定……”\"></a>22.～ことにします／～ことにしました：“我决定……”</h2><p>　～ことにします：当场下的决心</p>\n<ul>\n<li>明日から毎日運動することにします。</li>\n<li>今日からお酒を飲まないことにします。<br>～ことにしました：已经下定的决心</li>\n<li>鈴木さんと結婚することにしました。</li>\n</ul>\n<h2 id=\"23-～ことになりました：表示某事客观上定下来。\"><a href=\"#23-～ことになりました：表示某事客观上定下来。\" class=\"headerlink\" title=\"23.～ことになりました：表示某事客观上定下来。\"></a>23.～ことになりました：表示某事客观上定下来。</h2><ul>\n<li>来月から給料が上がることになりました。</li>\n<li>今週は会議を行わないことになりました。</li>\n<li>４月から大阪支社に転勤することになりました。</li>\n</ul>\n<h2 id=\"24-动-（さ）せていただきます\"><a href=\"#24-动-（さ）せていただきます\" class=\"headerlink\" title=\"24.[动]（さ）せていただきます\"></a>24.[动]（さ）せていただきます</h2><p>用于礼貌地表达自己的动作。</p>\n<ul>\n<li>早速、資料を届けさせていただきます。</li>\n<li>明日、もう一度連絡させていただきます。</li>\n</ul>\n<h2 id=\"25-动-（さ）せてください\"><a href=\"#25-动-（さ）せてください\" class=\"headerlink\" title=\"25.[动]（さ）せてください\"></a>25.[动]（さ）せてください</h2><p>请求对方允许自己做某事。</p>\n<ul>\n<li>疲れました。少し休ませてください。</li>\n</ul>\n<h2 id=\"26-～し、～し-叙述并列事项-罗列原因\"><a href=\"#26-～し、～し-叙述并列事项-罗列原因\" class=\"headerlink\" title=\"26.～し、～し　[叙述并列事项][罗列原因]\"></a>26.～し、～し　[叙述并列事项][罗列原因]</h2><ul>\n<li>このレストランはおいしいし、雰囲気もいい。</li>\n<li>このレストランはおいしいし、雰囲気もいいから、よく来ます。</li>\n<li>もう遅いし、そろそろ失礼します。</li>\n</ul>\n<h2 id=\"27-～しか～（否定）-表示“只，仅仅”\"><a href=\"#27-～しか～（否定）-表示“只，仅仅”\" class=\"headerlink\" title=\"27.～しか～（否定）　表示“只，仅仅”\"></a>27.～しか～（否定）　表示“只，仅仅”</h2><ul>\n<li>教室には李さんしかいません。</li>\n<li>私が好きなのはあなたしかいない。</li>\n<li>私はワインしか飲みません。</li>\n</ul>\n<h2 id=\"28-～過ぎます\"><a href=\"#28-～過ぎます\" class=\"headerlink\" title=\"28.～過ぎます\"></a>28.～過ぎます</h2><p>[动词(ます形去掉ます.]+過ぎます<br>[一类形(去掉词尾い.]+過ぎます<br>[二类形词干]+過ぎます<br>表示超过了正常的量或程度。</p>\n<ul>\n<li>ゆうべは飲み過ぎた。今日は頭が痛い。</li>\n<li>この本は難しすぎて、読みにくいです。</li>\n<li>この説明は複雑すぎます。</li>\n</ul>\n<h2 id=\"29-～そうです-传闻\"><a href=\"#29-～そうです-传闻\" class=\"headerlink\" title=\"29.～そうです　[传闻]\"></a>29.～そうです　[传闻]</h2><p>[小句(简体形.]そうです　①　[传闻]</p>\n<ul>\n<li>天気予報によると、明日は雨だそうです。</li>\n<li>田中さんの話によると、佐藤さんは来月会社を辞めるそうです。</li>\n<li>あの店はおいしくないそうです。</li>\n</ul>\n<h2 id=\"30-～そうです-②-样态-推测\"><a href=\"#30-～そうです-②-样态-推测\" class=\"headerlink\" title=\"30.～そうです　②　[样态][推测]\"></a>30.～そうです　②　[样态][推测]</h2><p>[动词ます形去掉ます]＋そうです<br>[一类形容词去掉词尾い]＋そうです<br>[二类形容词词干]＋そうです</p>\n<ul>\n<li>このケーキはおいしそうです。</li>\n<li>李さんは仕事が大変そうですね。</li>\n</ul>\n<h2 id=\"31-～だけ-只，仅仅\"><a href=\"#31-～だけ-只，仅仅\" class=\"headerlink\" title=\"31.～だけ　只，仅仅\"></a>31.～だけ　只，仅仅</h2><ul>\n<li>教室には李さんだけいます。</li>\n<li>私が好きなのはあなただけです。</li>\n<li>在庫は３台だけです。</li>\n</ul>\n<h2 id=\"32-～たところです\"><a href=\"#32-～たところです\" class=\"headerlink\" title=\"32.～たところです\"></a>32.～たところです</h2><p>～ところです：表示动作处于某种阶段</p>\n<ol>\n<li>～る(基本形.＋ところです：即将进行</li>\n<li>～ている＋ところです：正在进行</li>\n<li>～たところです：刚刚结束</li>\n</ol>\n<ul>\n<li>もしもし、今どこですか。<br>——これから家を出るところです。</li>\n<li>論文はできましたか。<br>——いいえ、まだです。今、資料を調べているところです。</li>\n<li>すみません、お待たせして。<br>——いいえ、わたしも今着いたところです。</li>\n</ul>\n<h2 id=\"33-～たばかりです\"><a href=\"#33-～たばかりです\" class=\"headerlink\" title=\"33.～たばかりです\"></a>33.～たばかりです</h2><p>[动]たばかりです：表示动作或事情刚刚结束。<br>～たばかりです：可用于动作结束后经过了较长一段时间的事态<br>～たところです：一般用于动作结束后经过的时间极短的事态。</p>\n<ul>\n<li>あの２人は去年結婚したばかりです。（〇）<br>あの２人は去年結婚したところです。（×）</li>\n<li>レポートはできましたか。<br>——ええ、今できたところです。（〇） </li>\n</ul>\n<h2 id=\"34-ために、～-目的\"><a href=\"#34-ために、～-目的\" class=\"headerlink\" title=\"34.~ために、～　[目的]\"></a>34.~ために、～　[目的]</h2><p>[小句1(基本形.]ために、[小句2]　　<br>[名]＋の＋ために、[小句] 　 　</p>\n<ul>\n<li>日本へ留学するために、お金を貯めています。</li>\n<li>留学のために、日本語を勉強しています。<br>前项为意志性的动作；前后主语相同。</li>\n</ul>\n<h2 id=\"35-～ために、～-原因、理由\"><a href=\"#35-～ために、～-原因、理由\" class=\"headerlink\" title=\"35.～ために、～　[原因、理由]\"></a>35.～ために、～　[原因、理由]</h2><p>[小句1(简体形.]ために、[小句2]<br>[名]＋の＋ために、[小句2]<br>[二类形容词]＋な＋ために、[小句2] </p>\n<ul>\n<li>事故があったために、電車が遅れたんです。</li>\n<li>道路工事のために、道が込んでいます。</li>\n<li>この村は交通が不便なために、住んでいる人が少ないです。<br>小句1多为非意志性的事态或状态。多用于书面语或比较郑重的场合。</li>\n</ul>\n<h2 id=\"36-～たら\"><a href=\"#36-～たら\" class=\"headerlink\" title=\"36.～たら\"></a>36.～たら</h2><p>接续：将简体过去形式中的“た”变成“たら”。<br>多用于一次性的、特定的事件。</p>\n<ol>\n<li>表示假定条件，“假如，要是……的话，……”</li>\n</ol>\n<ul>\n<li>もし宝くじに当たったら、どうしますか。</li>\n</ul>\n<ol start=\"2\">\n<li>表示既定条件，即“……之后，……”。</li>\n</ol>\n<ul>\n<li>仕事が終わったら、飲みに行こう。</li>\n<li>空港に着いたら、電話してください。</li>\n</ul>\n<ol start=\"3\">\n<li>表示意外发现。</li>\n</ol>\n<ul>\n<li>カーテンを開けたら、富士山が見えました。</li>\n</ul>\n<h2 id=\"37-～ちゃった\"><a href=\"#37-～ちゃった\" class=\"headerlink\" title=\"37.～ちゃった\"></a>37.～ちゃった</h2><p>“～てしまった”在口语中较随便的形式。</p>\n<ul>\n<li>うっかり財布を電車の中に忘れちゃった。</li>\n</ul>\n<h2 id=\"38-～続けます\"><a href=\"#38-～続けます\" class=\"headerlink\" title=\"38.～続けます\"></a>38.～続けます</h2><h2 id=\"39-～つもりです\"><a href=\"#39-～つもりです\" class=\"headerlink\" title=\"39.～つもりです\"></a>39.～つもりです</h2><p>接续：动词基本形／ない形＋つもりです<br>用法：表示说话人的打算。</p>\n<ul>\n<li>今度の連休は旅行に行くつもりです。</li>\n</ul>\n<h2 id=\"40-～て／～ないで\"><a href=\"#40-～て／～ないで\" class=\"headerlink\" title=\"40.～て／～ないで\"></a>40.～て／～ないで</h2><p>即“～てください／～ないでください”，省略掉“ください”。<br>表示祈使或轻微命令，用于关系亲密的人之间。</p>\n<ul>\n<li>私の話をちゃんと聞いてよ！</li>\n<li>まこと、洗濯物入れてよ。</li>\n<li>遅れないでね。</li>\n</ul>\n<h2 id=\"41-～て～／～ないで～-连接前后小句，表示伴随状态。\"><a href=\"#41-～て～／～ないで～-连接前后小句，表示伴随状态。\" class=\"headerlink\" title=\"41.～て～／～ないで～　连接前后小句，表示伴随状态。\"></a>41.～て～／～ないで～　连接前后小句，表示伴随状态。</h2><ul>\n<li>眼鏡をかけて本を読みます。</li>\n<li>新しい洋服を着てパーティーに行きました。</li>\n<li>傘を持たないで出かけました。</li>\n<li>傘を持たずに出かけました。</li>\n</ul>\n<h2 id=\"42-～て、～／～で、～-理由、原因\"><a href=\"#42-～て、～／～で、～-理由、原因\" class=\"headerlink\" title=\"42.～て、～／～で、～　[理由、原因]\"></a>42.～て、～／～で、～　[理由、原因]</h2><p>[小句1(动／形1.]て、[小句2]<br>[小句1(名／形2.]で、[小句2]</p>\n<ul>\n<li>遅くなって、すみません。</li>\n<li>最近は忙しくて、彼女に会いたくても時間がありません。</li>\n<li>病気で、会社を休みました。</li>\n<li>暇で、朝からずっとテレビを見ていました。</li>\n</ul>\n<h2 id=\"43-名词＋で-原因、理由\"><a href=\"#43-名词＋で-原因、理由\" class=\"headerlink\" title=\"43.名词＋で　[原因、理由]\"></a>43.名词＋で　[原因、理由]</h2><ul>\n<li>昨日は仕事で森さんと会いました。</li>\n<li>主人は出張で大阪に行っています。</li>\n</ul>\n<h2 id=\"44-で／へ／から／まで／と＋の\"><a href=\"#44-で／へ／から／まで／と＋の\" class=\"headerlink\" title=\"44.で／へ／から／まで／と＋の\"></a>44.で／へ／から／まで／と＋の</h2><ul>\n<li>東京での生活に慣れましたか。</li>\n<li>北京から東京までの便。</li>\n<li>見知らぬ女からの手紙。</li>\n<li>友達にあげるプレゼント。</li>\n</ul>\n<h2 id=\"45-～てあげます\"><a href=\"#45-～てあげます\" class=\"headerlink\" title=\"45.～てあげます\"></a>45.～てあげます</h2><p>Aは／がBに[动~]てあげる。A为B做某事　B不能是“我”或“我方人员”</p>\n<ul>\n<li>森さんはお年寄りの荷物を持ってあげました。</li>\n<li>きのう妹に新しい携帯を買ってあげました。<br>Aは／がBに[动~]てもらう。A从B处得到某项帮助／恩惠</li>\n<li>森さんは李さんに北京を案内してもらいました。</li>\n<li>私は日本人の友達におすしの作り方を教えてもらいました。<br>Aは／がBに[动~]てくれる。A为B提供某项帮助　B只能是“我”或“我方人员” </li>\n<li>友達が私におすしの作り方を教えてくれました。</li>\n<li>鈴木さんは傘を貸してくれました。</li>\n</ul>\n<h2 id=\"46-～てあります\"><a href=\"#46-～てあります\" class=\"headerlink\" title=\"46.～てあります\"></a>46.～てあります</h2><p>[他动词]＋てある：表示某人有意做某事后动作结果的状态存续。<br>[自动词]＋ている：表示状态。<br>[动词]＋ておく：表示事先做准备。</p>\n<ul>\n<li>窓を開けておく。　　　[朱丽叶]</li>\n<li>あの窓が開いている。　[路人]</li>\n<li>窓が開けてある。　　　[罗密欧]</li>\n</ul>\n<h2 id=\"47-～である-是“～です”的书面语简体形式。\"><a href=\"#47-～である-是“～です”的书面语简体形式。\" class=\"headerlink\" title=\"47.～である　是“～です”的书面语简体形式。\"></a>47.～である　是“～です”的书面语简体形式。</h2><ul>\n<li>富士山は日本で最も高い山です。夏の晴れた朝には赤くなって、<br>　とても美しいです。<br>→富士山は日本で最も高い山である。夏の晴れた朝には赤くなり、<br>　とても美しい。</li>\n</ul>\n<h2 id=\"48-～ていきます／～てきます\"><a href=\"#48-～ていきます／～てきます\" class=\"headerlink\" title=\"48.～ていきます／～てきます\"></a>48.～ていきます／～てきます</h2><p>[空间方向性]<br>～ていく：表示离说话人而去，由近及远；<br>～てくる：表示向着说话人而来，由远及近。  </p>\n<ul>\n<li>飛行機は西から飛んできて、東へ消えていった。</li>\n<li>田中さんが校門から走ってきた。<br>[时间持续的方向性]<br>～てくる：由基准时间点之前向基准时间点推移、变化。<br>～ていく：由基准时间点向基准时间点之后推移、变化。</li>\n<li>日本で学ぶ留学生の数が増えてきた。これからも増えていくだろう。</li>\n</ul>\n<h2 id=\"49-～ていただきます\"><a href=\"#49-～ていただきます\" class=\"headerlink\" title=\"49.～ていただきます\"></a>49.～ていただきます</h2><p>是“～てもらいます”的自谦语形式。</p>\n<ul>\n<li>黄教授を紹介していただき、ありがとうございました。</li>\n</ul>\n<h2 id=\"50-～ていただけますか／～ていただけませんか-请求\"><a href=\"#50-～ていただけますか／～ていただけませんか-请求\" class=\"headerlink\" title=\"50.～ていただけますか／～ていただけませんか　[请求]\"></a>50.～ていただけますか／～ていただけませんか　[请求]</h2><p>用于礼貌的请求别人为自己做某事。</p>\n<ul>\n<li>この服は小さいので、取り替えていただけますか。</li>\n</ul>\n<h2 id=\"51-～ています-反复-习惯\"><a href=\"#51-～ています-反复-习惯\" class=\"headerlink\" title=\"51.～ています　[反复][习惯]\"></a>51.～ています　[反复][习惯]</h2><ul>\n<li>北京行きの飛行機は１時間に１便飛んでいます。</li>\n<li>祖母は毎朝公園で散歩しています。</li>\n</ul>\n<h2 id=\"52-～ています-结果状态\"><a href=\"#52-～ています-结果状态\" class=\"headerlink\" title=\"52.～ています　[结果状态]\"></a>52.～ています　[结果状态]</h2><ul>\n<li>吉田さんは車を持っています。</li>\n<li>森さんを知っていますか。<br>具有自他对应的自动词的“～ています”形式，都是表示结果状态的。</li>\n<li>部屋の電気は消えています。</li>\n</ul>\n<h2 id=\"53-～ていらっしゃいます\"><a href=\"#53-～ていらっしゃいます\" class=\"headerlink\" title=\"53.～ていらっしゃいます\"></a>53.～ていらっしゃいます</h2><p>いらっしゃる：行く／来る／いる的尊他语。<br>ていらっしゃる：ていく／てくる／ている的尊他语。</p>\n<ul>\n<li>社長は会議室で待っていらっしゃいます。　　　　＝ています</li>\n<li>木村部長は先ほど戻っていらっしゃいましたよ。　＝てきました</li>\n<li>社長はもう東京に帰っていらっしゃいました。　　＝ていきました</li>\n</ul>\n<h2 id=\"54-～ているところです\"><a href=\"#54-～ているところです\" class=\"headerlink\" title=\"54.～ているところです\"></a>54.～ているところです</h2><h2 id=\"55-～ておきます\"><a href=\"#55-～ておきます\" class=\"headerlink\" title=\"55.～ておきます\"></a>55.～ておきます</h2><ol>\n<li>为了某个目的而事先做某事；[准备]</li>\n</ol>\n<ul>\n<li>お客さんが来る前に、部屋を掃除しておきます。</li>\n<li>日本へ行く前に、日本語を勉強しておいたほうがいいですよ。</li>\n</ul>\n<ol start=\"2\">\n<li>为了某个目的而做某事，并使其结果或效果留存下来。[留存]</li>\n</ol>\n<ul>\n<li>この辞書、片づけましょうか。<br>——いいえ、まだ使いますから、そのままにしておいてください。</li>\n</ul>\n<h2 id=\"56-～ております\"><a href=\"#56-～ております\" class=\"headerlink\" title=\"56.～ております\"></a>56.～ております</h2><p>是“～ています”的郑重语。</p>\n<ul>\n<li>山田社長はいらっしゃいますか。<br>——山田はただいま外出しております。</li>\n</ul>\n<h2 id=\"57-～てきます／～てきました-出现\"><a href=\"#57-～てきます／～てきました-出现\" class=\"headerlink\" title=\"57.～てきます／～てきました　[出现]\"></a>57.～てきます／～てきました　[出现]</h2><ul>\n<li>あっ、雨が降ってきた。</li>\n</ul>\n<h2 id=\"58-～てくださいます-是“～てくれます”的尊他语。\"><a href=\"#58-～てくださいます-是“～てくれます”的尊他语。\" class=\"headerlink\" title=\"58.～てくださいます　是“～てくれます”的尊他语。\"></a>58.～てくださいます　是“～てくれます”的尊他语。</h2><ul>\n<li>先生がわたしの論文を見てくださいました。</li>\n<li>社長が褒めてくださいました。</li>\n</ul>\n<h2 id=\"59-～でございます-是“～です”的非常礼貌的说法。\"><a href=\"#59-～でございます-是“～です”的非常礼貌的说法。\" class=\"headerlink\" title=\"59.～でございます　是“～です”的非常礼貌的说法。\"></a>59.～でございます　是“～です”的非常礼貌的说法。</h2><ul>\n<li>はい、こちらはJC企画上海事務所でございます。</li>\n</ul>\n<h2 id=\"60-差し上げます-是“あげます”的自谦语。\"><a href=\"#60-差し上げます-是“あげます”的自谦语。\" class=\"headerlink\" title=\"60. 差し上げます　是“あげます”的自谦语。\"></a>60. 差し上げます　是“あげます”的自谦语。</h2><h2 id=\"61-～てしまう\"><a href=\"#61-～てしまう\" class=\"headerlink\" title=\"61.～てしまう\"></a>61.～てしまう</h2><ol>\n<li>完成</li>\n</ol>\n<ul>\n<li>さあ、最後まで飲んでしまいましょう。<br>→さあ、最後まで飲んじゃおう！</li>\n<li>この本はもう読んでしまったから、あげるよ。</li>\n</ul>\n<ol start=\"2\">\n<li>发生某件结果不理想的事情</li>\n</ol>\n<ul>\n<li>大切な書類を電車の中に忘れてしまいました。</li>\n<li>そんなに無理をすると、病気になってしまいますよ。<br>→そんなに無理をすると、病気になっちゃうよ。</li>\n</ul>\n<h2 id=\"62-～でしょう-推测\"><a href=\"#62-～でしょう-推测\" class=\"headerlink\" title=\"62. ～でしょう　[推测]\"></a>62. ～でしょう　[推测]</h2><ul>\n<li>明日は雨になるでしょう。</li>\n<li>今はゴールデンウイークですから、どの行楽地も混んでいるでしょう。</li>\n</ul>\n<h2 id=\"63-～でしょう？-确认\"><a href=\"#63-～でしょう？-确认\" class=\"headerlink\" title=\"63. ～でしょう？　[确认]\"></a>63. ～でしょう？　[确认]</h2><ul>\n<li>李さん、明日のパーティーに行くでしょう？　　　　　　（升调）</li>\n<li>え、このケーキ、おいしいと思うの？まずいでしょう！　（降调）</li>\n<li>お母さん、私の日記、見たでしょう！　　　　　　　　　（降调）</li>\n</ul>\n<h2 id=\"64-～でしょうか-礼貌的疑问方式。\"><a href=\"#64-～でしょうか-礼貌的疑问方式。\" class=\"headerlink\" title=\"64. ～でしょうか　礼貌的疑问方式。\"></a>64. ～でしょうか　礼貌的疑问方式。</h2><ul>\n<li>李さんは来ますか。→李さんは来るでしょうか。</li>\n<li>コーヒー、いかがですか。→コーヒー、いかがでしょうか。</li>\n</ul>\n<h2 id=\"65-～ですもの／～だもん\"><a href=\"#65-～ですもの／～だもん\" class=\"headerlink\" title=\"65. ～ですもの／～だもん\"></a>65. ～ですもの／～だもん</h2><p>表示说话人认为某事具有正当性，带有不满、抗议、申辩的语气。<br>一般为女性和儿童使用。</p>\n<ul>\n<li>今月から給料が上がったそうですね。<br>——こんなにたくさん仕事しているんですもの。当然でしょう</li>\n<li>冷蔵庫の中のケーキを食べちゃったのは太郎でしょう？<br>——だってお腹空いちゃったんだもん。</li>\n</ul>\n<h2 id=\"66-～ではありませんか\"><a href=\"#66-～ではありませんか\" class=\"headerlink\" title=\"66. ～ではありませんか\"></a>66. ～ではありませんか</h2><p>用否定疑问句的形式礼貌地表达自己肯定的观点。</p>\n<h2 id=\"67-～てほしい-表达对他人的希望。\"><a href=\"#67-～てほしい-表达对他人的希望。\" class=\"headerlink\" title=\"67. ～てほしい　表达对他人的希望。\"></a>67. ～てほしい　表达对他人的希望。</h2><ul>\n<li>だれか、手伝ってほしい。</li>\n<li>子どもに元気で、自信がある子に育ってほしい。</li>\n<li>早く連休が来てほしい。</li>\n</ul>\n<h2 id=\"68-～てみます-尝试做某事。\"><a href=\"#68-～てみます-尝试做某事。\" class=\"headerlink\" title=\"68.～てみます　尝试做某事。\"></a>68.～てみます　尝试做某事。</h2><ul>\n<li>ケーキを作ってみました。食べてみてください。</li>\n<li>日本語で友達に手紙を書いてみました。</li>\n</ul>\n<h2 id=\"69-～ても、～-转折\"><a href=\"#69-～ても、～-转折\" class=\"headerlink\" title=\"69. ～ても、～　[转折]\"></a>69. ～ても、～　[转折]</h2><ul>\n<li>宝くじに当たっても、仕事を続けます。</li>\n<li>明日雨でも、彼女に会いに行きます。</li>\n<li>いくら聞いても、彼は何も言わなかった。</li>\n</ul>\n<h2 id=\"70-名词＋でも-提示极端例子\"><a href=\"#70-名词＋でも-提示极端例子\" class=\"headerlink\" title=\"70. 名词＋でも　[提示极端例子]\"></a>70. 名词＋でも　[提示极端例子]</h2><ul>\n<li>この計算は難しくて、大人でもできません。</li>\n<li>この森は夏でも涼しい。</li>\n</ul>\n<h2 id=\"71-名词＋でも-示例\"><a href=\"#71-名词＋でも-示例\" class=\"headerlink\" title=\"71. 名词＋でも　[示例]\"></a>71. 名词＋でも　[示例]</h2><ul>\n<li>コーヒーでも飲みませんか。</li>\n<li>仕事の後、映画でも見ませんか。</li>\n</ul>\n<h2 id=\"72-～てもらいます\"><a href=\"#72-～てもらいます\" class=\"headerlink\" title=\"72. ～てもらいます\"></a>72. ～てもらいます</h2><h2 id=\"73-～と、～\"><a href=\"#73-～と、～\" class=\"headerlink\" title=\"73. ～と、～\"></a>73. ～と、～</h2><p>“一……，就……”，表示恒定不变的真理，反复性状态，习惯等。</p>\n<ul>\n<li>お酒を飲むと、必ず酔う。</li>\n<li>遅刻すると、彼女は必ず怒ります。</li>\n<li>兄は冬になると、スキーに行きます。<br>后项不可以出现祈使、命令、意志的表达方式。<br>还可表示意外的发现，此时后项要使用过去形式。</li>\n<li>カーテンを開けると、富士山が見えました。</li>\n</ul>\n<h2 id=\"74-～と会います\"><a href=\"#74-～と会います\" class=\"headerlink\" title=\"74. ～と会います　\"></a>74. ～と会います　</h2><p>に：用于单向性的动作对象<br>と：用于双向性的动作对象</p>\n<ul>\n<li>さっき駅前で佐藤さんに会いました。</li>\n<li>さっき駅前で佐藤さんと会いました。</li>\n</ul>\n<h2 id=\"75-～という～-表示称谓，“叫做……”。\"><a href=\"#75-～という～-表示称谓，“叫做……”。\" class=\"headerlink\" title=\"75. ～という～　表示称谓，“叫做……”。\"></a>75. ～という～　表示称谓，“叫做……”。</h2><ul>\n<li>これはフジという花です。</li>\n</ul>\n<h2 id=\"76-～（よ）うと思います-～（よ）うと思っています\"><a href=\"#76-～（よ）うと思います-～（よ）うと思っています\" class=\"headerlink\" title=\"76. ～（よ）うと思います ～（よ）うと思っています\"></a>76. ～（よ）うと思います ～（よ）うと思っています</h2><p>[动(意志形.]＋と思います　把自己要做某事的意志告诉听话人。</p>\n<ul>\n<li>来年結婚しようと思います。</li>\n<li>将来、日本へ留学しようと思います。<br>[动(意志形.]+ と思っています　表示某种意志持续了一段时间。</li>\n<li>今の仕事をやめようと思っています。</li>\n<li>将来、日本へ留学しようと思っています。</li>\n<li>張さんは将来、日本へ留学しようと思っています。</li>\n</ul>\n<h2 id=\"77-～とか～とか\"><a href=\"#77-～とか～とか\" class=\"headerlink\" title=\"77. ～とか～とか\"></a>77. ～とか～とか</h2><ul>\n<li>パーティーで、戴さんとか楊さんとか、いろいろな人に会いました。</li>\n<li>海外旅行に行きたいとか、新しい車が欲しいとか、ぜいたくなことばかり<br>　言っています。</li>\n</ul>\n<h2 id=\"78-～時、～\"><a href=\"#78-～時、～\" class=\"headerlink\" title=\"78. ～時、～\"></a>78. ～時、～</h2><ul>\n<li>子供の時、よく祖母と一緒に公園で散歩しました。</li>\n<li>映画を見る時、いつもいちばん後ろの席に座ります。</li>\n<li>忙しい時、いつもコンビニでお弁当を買って食べます。</li>\n<li>暇な時、よく一人で映画を見ます。</li>\n</ul>\n<h2 id=\"79-～ところです\"><a href=\"#79-～ところです\" class=\"headerlink\" title=\"79. ～ところです\"></a>79. ～ところです</h2><p>～る（基本形）+ところです。<br>～ている＋ところです。<br>～た＋ところです。</p>\n<h2 id=\"80-动词基本形＋な-禁止\"><a href=\"#80-动词基本形＋な-禁止\" class=\"headerlink\" title=\"80. 动词基本形＋な　[禁止]\"></a>80. 动词基本形＋な　[禁止]</h2><p>使用场合：1. 用于上对下，或有资格对对方发号施令的人；</p>\n<ol start=\"2\">\n<li>特殊、紧急的场合。</li>\n</ol>\n<ul>\n<li>仕事をサボるな！</li>\n<li>笑うな！</li>\n<li>危ない！来るな！</li>\n</ul>\n<h2 id=\"81-～ないと／～ないといけません\"><a href=\"#81-～ないと／～ないといけません\" class=\"headerlink\" title=\"81. ～ないと／～ないといけません\"></a>81. ～ないと／～ないといけません</h2><p>表示必须或义务，“不……不行，不得不……”。  </p>\n<ul>\n<li>時間がないから、そろそろ行かないと。</li>\n<li>明日までにレポートをまとめないといけません。</li>\n</ul>\n<h2 id=\"82-ながら\"><a href=\"#82-ながら\" class=\"headerlink\" title=\"82. ながら\"></a>82. ながら</h2><p>动词ます形去掉ます＋ながら， “一边……一边……” </p>\n<ul>\n<li>テレビを見ながらご飯を食べます。</li>\n<li>歩きながら電話をします。</li>\n<li>食事をしながら話しましょうか。</li>\n</ul>\n<h2 id=\"83-～なければ／～なければなりません-“必须……，不得不……”\"><a href=\"#83-～なければ／～なければなりません-“必须……，不得不……”\" class=\"headerlink\" title=\"83. ～なければ／～なければなりません　“必须……，不得不……”\"></a>83. ～なければ／～なければなりません　“必须……，不得不……”</h2><h2 id=\"84-なさい\"><a href=\"#84-なさい\" class=\"headerlink\" title=\"84. なさい\"></a>84. なさい</h2><p>动词ます形去掉ます＋なさい，表示命令。<br>多用于长辈对晚辈、上级对下级、老师对学生等发号施令，语气比命令形柔和些。</p>\n<ul>\n<li>早く寝なさい。</li>\n</ul>\n<h2 id=\"85-～なら、～\"><a href=\"#85-～なら、～\" class=\"headerlink\" title=\"85. ～なら、～\"></a>85. ～なら、～</h2><p>接续：简体形式＋なら（形2或名词去掉简体形式中的だ）<br>根据对方的言谈或现场情况，陈述自己的意见或想法，以及向对方提出建议、<br>忠告。</p>\n<ul>\n<li>天安門に行くなら、地下鉄が便利ですよ。</li>\n<li>お寿司なら、駅前のあのお店がいいですよ。</li>\n<li>魚を買うなら、築地市場がいいですよ。</li>\n<li>飲んだら乗るな。乗るなら飲むな。</li>\n</ul>\n<h2 id=\"86-～に-用途-基准\"><a href=\"#86-～に-用途-基准\" class=\"headerlink\" title=\"86. ～に　[用途][基准]\"></a>86. ～に　[用途][基准]</h2><p>[名词]＋に<br>[动词基本形]＋のに</p>\n<ul>\n<li>この写真はパスポートの申請に使います。　　　　　　　　　　　[用途]<br>この写真はパスポートを申請するのに使います。　　　　　　　　[用途]</li>\n<li>このマンションはスーパーから近くて、買い物に便利です。　　　[基准]<br>このマンションはスーパーから近くて、買い物するのに便利です。[基准]</li>\n</ul>\n<h2 id=\"87-～によると-表示传闻、消息的来源。\"><a href=\"#87-～によると-表示传闻、消息的来源。\" class=\"headerlink\" title=\"87. ～によると　表示传闻、消息的来源。\"></a>87. ～によると　表示传闻、消息的来源。</h2><ul>\n<li>天気予報によると、明日は雨だそうです。</li>\n<li>田中さんの話によると、佐藤さんは来月会社を辞めるそうです。</li>\n</ul>\n<h2 id=\"88-～によって\"><a href=\"#88-～によって\" class=\"headerlink\" title=\"88. ～によって\"></a>88. ～によって</h2><p>～によって：表示变化的依据，“因……的不同而不同”</p>\n<ul>\n<li>飛行機のチケットは高かったり、安かったり、季節によって違います。<br>以事物作主语的被动句中，当动作主体是特定的人时，要用によって来提示。<br>-『阿Q正伝』は魯迅によって書かれました。</li>\n<li>この車は日本の有名なデザイナーによって設計されました。</li>\n</ul>\n<h2 id=\"89-～のが～です\"><a href=\"#89-～のが～です\" class=\"headerlink\" title=\"89. ～のが～です\"></a>89. ～のが～です</h2><ul>\n<li>自転車に二人で乗るのは危ないです。</li>\n<li>一人で映画を見るのが好きです。</li>\n</ul>\n<h2 id=\"90-～のが見えます／～のが聞こえます\"><a href=\"#90-～のが見えます／～のが聞こえます\" class=\"headerlink\" title=\"90. ～のが見えます／～のが聞こえます\"></a>90. ～のが見えます／～のが聞こえます</h2><p>見える：自动词，某种景象映入眼帘。<br>聞こえる：自动词，某种声音传入耳朵。</p>\n<ul>\n<li>隣の部屋で子どもたちが騒いでいるのが聞こえますか。</li>\n<li>グラウンドで子どもたちが野球をしているのが見えます。</li>\n</ul>\n<h2 id=\"91-～のために-目的-～のために-理由、原因\"><a href=\"#91-～のために-目的-～のために-理由、原因\" class=\"headerlink\" title=\"91. ～のために　[目的] ～のために　[理由、原因]\"></a>91. ～のために　[目的] ～のために　[理由、原因]</h2><p>[动词][1形容词(简体.]+ために<br>[名]+の＋ために</p>\n<h2 id=\"92-～ので、～-理由、原因\"><a href=\"#92-～ので、～-理由、原因\" class=\"headerlink\" title=\"92. ～ので、～　[理由、原因]\"></a>92. ～ので、～　[理由、原因]</h2><p>接续：[动词／一类形容词简体]＋ので<br>[名词／二类形容词简体(だ→な.]＋ので<br>用法：用于客观叙述某事的原因、理由。</p>\n<ul>\n<li>家が遠いので、毎朝はやく起きなければなりません。</li>\n<li>目が疲れたので、少し休みます。</li>\n<li>ここは静かなので、とても気に入っています。</li>\n<li>もう終電の時間なので、帰ります。</li>\n<li>昨日は休みだったので、映画を見に行きました。</li>\n</ul>\n<h2 id=\"93-～のではないでしょうか-婉转陈述意见\"><a href=\"#93-～のではないでしょうか-婉转陈述意见\" class=\"headerlink\" title=\"93. ～のではないでしょうか　[婉转陈述意见]\"></a>93. ～のではないでしょうか　[婉转陈述意见]</h2><p>表达的是一种委婉的肯定， “不是……吗？”相当于“と思います”，<br>语气更委婉。</p>\n<ul>\n<li>免税店では女性向けの商品がよく売れるのではないでしょうか。</li>\n</ul>\n<h2 id=\"94-～の時、～\"><a href=\"#94-～の時、～\" class=\"headerlink\" title=\"94. ～の時、～\"></a>94. ～の時、～</h2><p>[名]+の＋時<br>表示“……的时候”。</p>\n<h2 id=\"95-～のに-用途-基准\"><a href=\"#95-～のに-用途-基准\" class=\"headerlink\" title=\"95. ～のに　[用途][基准]\"></a>95. ～のに　[用途][基准]</h2><p>[动词基本形]＋の＋に</p>\n<h2 id=\"96-～のに、～-转折\"><a href=\"#96-～のに、～-转折\" class=\"headerlink\" title=\"96. ～のに、～　[转折]\"></a>96. ～のに、～　[转折]</h2><p>表示在小句1的情况下发生小句2的情况不符合常识常理，“明明……却，<br>可是，偏偏……”。</p>\n<ul>\n<li>目覚ましをかけておいたのに、今朝は起きられませんでした。</li>\n<li>森さんは家が近いのによく遅刻します。</li>\n<li>田中さんは作家なのに、読書が嫌いです。<br>接续：[小句1(简体形.]のに、[小句2]<br>[名词]／[二类形容词的现在肯定简体形式(だ→な.]＋のに、小句2</li>\n</ul>\n<h2 id=\"97-～のは～です。\"><a href=\"#97-～のは～です。\" class=\"headerlink\" title=\"97. ～のは～です。\"></a>97. ～のは～です。</h2><h2 id=\"98-～のまま、～\"><a href=\"#98-～のまま、～\" class=\"headerlink\" title=\"98. ～のまま、～\"></a>98. ～のまま、～</h2><p>[小句1(动词た形／ない形.]まま、小句2<br>[名]＋の＋まま、小句</p>\n<ul>\n<li>眼鏡をかけたまま、寝てしまいました。</li>\n<li>馬さんは行き先を告げないまま、家を出てしまいました。</li>\n<li>わたしたちは空腹のまま、出発しました。</li>\n<li>講堂に入る時、携帯の電源を切らなければなりませんか。<br>　——いいえ、付けたままでいいですよ。</li>\n</ul>\n<h2 id=\"99-～のようです-推测\"><a href=\"#99-～のようです-推测\" class=\"headerlink\" title=\"99. ～のようです　[推测]\"></a>99. ～のようです　[推测]</h2><p>说话人根据自己感知的情况，进行推测。<br>[小句(简体形.]＋ようです<br>[名]＋の＋ようです<br>[二类形词干]+な＋ようです</p>\n<ul>\n<li>玄関のところにだれかがいるようです。</li>\n<li>店の前には行列ができています。あの店の料理はおいしいようです。</li>\n<li>値段はほかの店の倍です。ここの料理はかなり豪華なようです。</li>\n<li>遠くから何か飛んできます。飛行機のようですね。</li>\n</ul>\n<h2 id=\"100-～のような味／においがします\"><a href=\"#100-～のような味／においがします\" class=\"headerlink\" title=\"100. ～のような味／においがします\"></a>100. ～のような味／においがします</h2><p>味・におい・声・音・感じ＋がする：表示有这种感觉。</p>\n<ul>\n<li>この野菜、レモンのような味がします。</li>\n<li>このせっけんは爽やかで、ランのようなにおいがします。</li>\n<li>ここには昔来たことがあるような感じがします。<br>寒気（さむけ）・吐き気（はきけ）・頭痛（ずつう）＋がする</li>\n<li>今朝から、ずっと寒気がしています。</li>\n</ul>\n<h2 id=\"101-～のを～\"><a href=\"#101-～のを～\" class=\"headerlink\" title=\"101. ～のを～\"></a>101. ～のを～</h2><ul>\n<li>手紙を出すのを忘れました。</li>\n<li>吉田さんが転勤するのを知っていますか。</li>\n</ul>\n<h2 id=\"102-～ば、～\"><a href=\"#102-～ば、～\" class=\"headerlink\" title=\"102. ～ば、～\"></a>102. ～ば、～</h2><h2 id=\"103-～は～という～です-用于下定义或做解释。\"><a href=\"#103-～は～という～です-用于下定义或做解释。\" class=\"headerlink\" title=\"103. ～は～という～です　用于下定义或做解释。\"></a>103. ～は～という～です　用于下定义或做解释。</h2><ul>\n<li>駐車禁止はここに車を止めるなという意味です。</li>\n<li>そのマークはここでタバコを吸うなという意味です。</li>\n</ul>\n<h2 id=\"110-～ば～ほど-“越…越…”。\"><a href=\"#110-～ば～ほど-“越…越…”。\" class=\"headerlink\" title=\"110. ～ば～ほど　“越…越…”。\"></a>110. ～ば～ほど　“越…越…”。</h2><p>接续：[动ば形]+[动(基本形.]＋ほど＋[小句]<br>[一类形容词ば形]+[一类形容词(原形.]＋ほど＋[小句]<br>[二类形容词(词干.]+なら＋[二类形容词(词干.]＋な＋ほど＋[小句]<br>[二类形容词(词干.]+であれば＋[二类形容词(词干.]＋な＋ほど＋[小句]<br>[二类形容词(词干.]+であれば＋あるほど＋[小句]</p>\n<ul>\n<li>この本は読めば読むほど、おもしろいです。</li>\n<li>彼のことを知れば知るほど、好きになる。</li>\n<li><p>商品は安ければ安いほど売れるでしょう？</p>\n</li>\n<li><p>子供は元気なら元気なほどいいです。<br>　子供は元気であれば元気なほどいいです。</p>\n</li>\n</ul>\n<h2 id=\"111-～ばかり～-～ばかりいます\"><a href=\"#111-～ばかり～-～ばかりいます\" class=\"headerlink\" title=\"111. ～ばかり～　～ばかりいます\"></a>111. ～ばかり～　～ばかりいます</h2><p>[名]＋ばかり＋[动]：表示所列举的事物全部相同；“光、净、只……”<br>[动(て形.]＋ばかり＋います：表示总是发生同样的事情或总是进行同样的动作。<br>　　　　　　　　　　　　　“老是，总是，光……，净……”[反复]</p>\n<ul>\n<li>林さんはカラオケで古い歌ばかり歌います。</li>\n<li>うちの息子は毎日ゲームばかりしています。</li>\n<li>張さんは毎日お酒を飲んでばかりいます。</li>\n<li>遊んでばかりいないで、しっかり勉強しなさい。</li>\n</ul>\n<h2 id=\"112-～はじめる／～出す\"><a href=\"#112-～はじめる／～出す\" class=\"headerlink\" title=\"112. ～はじめる／～出す\"></a>112. ～はじめる／～出す</h2><h2 id=\"113-～はずがありません\"><a href=\"#113-～はずがありません\" class=\"headerlink\" title=\"113. ～はずがありません\"></a>113. ～はずがありません</h2><p>～はずです<br>はずです：表示个人根据某种理由，做好自身认为合情理的推断。</p>\n<ul>\n<li>会議は5 時までですから、もうすぐ終わるはずです。</li>\n<li>森さんは１時間ほど前に会社を出ましたから、もう家に着いているはずです。<br>～はずがない：不可能……</li>\n<li>張さんは入院中ですから、旅行に行くはずがありません。</li>\n<li>7月のオーストラリアは冬ですから、暑いはずがありません。</li>\n</ul>\n<h2 id=\"114-～までに\"><a href=\"#114-～までに\" class=\"headerlink\" title=\"114. ～までに\"></a>114. ～までに</h2><p>表示某事的截止时间点，即：在……之前，完成或发生某事。    </p>\n<ul>\n<li>来週の水曜日までにレポートを提出してください。</li>\n<li>今月の末までに、新しい家を見つけたいです。<br>～まで：在……之前，持续做某事或某状态。</li>\n<li>彼に会うまで、ここで待つ。</li>\n</ul>\n<h2 id=\"116-～ようです／～みたいです-推测-比喻\"><a href=\"#116-～ようです／～みたいです-推测-比喻\" class=\"headerlink\" title=\"116. ～ようです／～みたいです　[推测][比喻]\"></a>116. ～ようです／～みたいです　[推测][比喻]</h2><p>“ようです”语气正式，“みたいです”口语化。</p>\n<ul>\n<li>遠くから何か飛んできます。飛行機のようですね。　　　　[推测]<br>遠くから何か飛んでくる。飛行機みたいだね。　　　　　　[推测]</li>\n<li>これは柔らかくて、まるで本物の毛皮のようです。　　　　[比喻]</li>\n<li>あの子は目が大きくてかわいいね。まるで人形みたいだ。　[比喻]</li>\n<li>この野菜、レモンのような味がします。　　　　　　　　　[比喻]</li>\n<li>鳥のように空を飛んでみたいな。　　　　　　　　　　　　[比喻]</li>\n<li>田中さんのお宅はホテルのようにきれいです。　　　　　　[比喻]</li>\n</ul>\n<h2 id=\"117-～も-超出预想\"><a href=\"#117-～も-超出预想\" class=\"headerlink\" title=\"117. ～も　[超出预想]\"></a>117. ～も　[超出预想]</h2><p>数量词+も+肯定：数量之多。</p>\n<ul>\n<li>参加者は50人も超えました。</li>\n<li>今日は3リットルも水を飲みました。</li>\n</ul>\n<h2 id=\"118-～やすい／～にくい\"><a href=\"#118-～やすい／～にくい\" class=\"headerlink\" title=\"118. ～やすい／～にくい\"></a>118. ～やすい／～にくい</h2><p>[动词ます形去掉ます]＋やすい：构成形1，表示“易于……”<br>[动词ます形去掉ます]＋にくい：构成形1，表示“难于……”</p>\n<ul>\n<li>このペンは書きやすいです。</li>\n<li>この本は漢字が多くて、読みにくいです。</li>\n<li>雨の日は事故が起こりやすいです。</li>\n<li>運動している人は太りにくいです。</li>\n</ul>\n<h2 id=\"119-～ように\"><a href=\"#119-～ように\" class=\"headerlink\" title=\"119. ～ように\"></a>119. ～ように</h2><p>为了使前项成立，而做后项事情。前接非意志性动词，或意志性动词可能形式<br>的基本形或ない形。</p>\n<ul>\n<li>留学生も分かるように、先生はゆっくり説明してくれました。</li>\n<li>子どもが触れないように、この薬は棚のいちばん上に置きましょう。</li>\n</ul>\n<h2 id=\"120-～ようにします\"><a href=\"#120-～ようにします\" class=\"headerlink\" title=\"120. ～ようにします\"></a>120. ～ようにします</h2><p>“努力做到…… ”。前接意志性动词的基本形或ない形。</p>\n<ul>\n<li>のどが痛いので、今日はあまり話さないようにします。</li>\n<li>明日の会議には、できるだけ出るようにします。<br>～ようにしている：有意识地将某个习惯保留下来。</li>\n<li>陳さんは毎日、英字新聞を読むようにしています。</li>\n<li>健康のために、毎日30分ぐらいジョギングをするようにしています。</li>\n</ul>\n<h2 id=\"121-～ようになります\"><a href=\"#121-～ようになります\" class=\"headerlink\" title=\"121. ～ようになります\"></a>121. ～ようになります</h2><p>表示能力、状况等的变化。前接非意志性动词，或意志性动词可能形式的<br>基本形或ない形。</p>\n<ul>\n<li>けがが治って、歩けるようになりました。</li>\n<li>赤ちゃんは1歳を過ぎると、言葉を話すようになります。</li>\n</ul>\n<h2 id=\"122-名词-＋らしい～-典型性\"><a href=\"#122-名词-＋らしい～-典型性\" class=\"headerlink\" title=\"122. [名词]＋らしい～　[典型性]\"></a>122. [名词]＋らしい～　[典型性]</h2><ul>\n<li>食事らしい食事</li>\n<li>女らしい女</li>\n<li>学生なら、学生らしくしっかり勉強しなさい。</li>\n</ul>\n<h2 id=\"123-～らしいです-推测-传闻\"><a href=\"#123-～らしいです-推测-传闻\" class=\"headerlink\" title=\"123. ～らしいです　[推测][传闻]\"></a>123. ～らしいです　[推测][传闻]</h2><p>[小句(简体形.]＋らしいです</p>\n<ul>\n<li>田中さんは来月から大阪支社へ転勤するらしいですよ。　[传闻]</li>\n<li>電気が消えています。李さんは出かけたらしいですね。　[推测]</li>\n<li>火曜日なのに店が閉まっている。今日は休みらしいね。　[推测]</li>\n</ul>\n<h2 id=\"124-～られます-尊他语形式\"><a href=\"#124-～られます-尊他语形式\" class=\"headerlink\" title=\"124. ～られます　尊他语形式\"></a>124. ～られます　尊他语形式</h2><h2 id=\"125-～んじゃないですか-婉转陈述意见的表达\"><a href=\"#125-～んじゃないですか-婉转陈述意见的表达\" class=\"headerlink\" title=\"125. ～んじゃないですか　[婉转陈述意见的表达]\"></a>125. ～んじゃないですか　[婉转陈述意见的表达]</h2><p>与“～のではないでしょうか”一样，用否定疑问句的形式，婉转地表达<br>自己肯定的意见，但礼貌程度比“～のではないでしょうか”稍低。</p>\n<ul>\n<li>ここ、いいんじゃないですか。</li>\n<li>さっきのはもっと広かったんじゃないですか。</li>\n</ul>"},{"title":"react源码阅读4 ExpirationTime","date":"2020-05-31T06:00:00.000Z","_content":"react更新中优先级依赖的标识ExpirationTime。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n&emsp;&emsp;这一章节，让我们抛弃掉react代码中的联系，单纯的来看ExpirationTime以及一些计算方式。\n\n## ExpirationTime是什么。\n&emsp;&emsp;ExpirationTime是一个数字，你可以在`react-reconciler`包下的`ReactFiberExpirationTime.js`文件中找到它的定义。\n\n```javascript\nexport type ExpirationTime = number;\n```\n\n## ExpirationTime在React中有什么作用。\n&emsp;&emsp;既然ExpirationTime相关的定义出现在`react-reconciler`包之下，说明它的作用肯定是和React调用有关。我们从`ReactFiberExpirationTime`函数入手，该函数接收一个`ms`，返回一个`ExpirationTime`。\n\n\n```javascript\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\nconst MAX_SIGNED_31_BIT_INT = 1073741823\nexport const NoWork = 0;\nexport const Never = 1;\n// 1073741823 - 1\nexport const Sync = MAX_SIGNED_31_BIT_INT;\n// 1073741823 - 2\nexport const Batched = Sync - 1;\n\nconst UNIT_SIZE = 10;\n// // 1073741823 - 3\nconst MAGIC_NUMBER_OFFSET = Batched - 1;\n\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);\n}\n```\n\n&emsp;&emsp;我们先跳过首部的变量定义，直接看函数`msToExpirationTime`。`msToExpirationTime`接收一个`ms`，返回`ExpirationTime`。函数首先进行`((ms / UNIT_SIZE) | 0)`的计算，我们不来关注`ms`和`UNIT_SIZE`是多少，单纯来看这里的计算逻辑。在另一篇文章中提到过<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>，`A | 0`这个操作，在JS中是将`A`转换为`32位的带符号整数`，在这个公式里面，可以简单的理解为取整。那将`ms / UNIT_SIZE`之后取整意味着什么，我们可以简单将`ms`假设为100前后的数字，`UNIT_SIZE`假设为10来看一下。\n\n```javascript\n(95 / 10) | 0 = 9;\n(100 / 10) | 0 = 10;\n(105 / 10) | 0 = 10;\n(110 / 10) | 0 = 11;\n```\n\n&emsp;&emsp;`((ms / UNIT_SIZE) | 0)`这个操作，其实是抹平了`ms ~ (ms + UNIT_SIZE - 1)`这个范围的差值，让`ms ~ (ms + UNIT_SIZE - 1)`通过这个公式都能得到相同的数字。\n\n\n&emsp;&emsp;明白了调用的含义之后，我们顺着函数调用来看一下`ms`到底是什么。通过全局搜索`msToExpirationTime`，可以发现在`react-reconciler/ReactFiberWorkLoop.js`中存在`msToExpirationTime`的调用。\n\n```javascript\nexport function requestCurrentTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // ...省略无关逻辑\n}\n```\n\n&emsp;&emsp;这里的now方法忽略到调试等逻辑，可以简单的理解为Date.now，即获得当前的时间戳。到这里我们可以回头看一下`MAGIC_NUMBER_OFFSET`，`MAGIC_NUMBER_OFFSET`是**31最大整数**减去3的值，我们可以简单的把它理解为一个很大的常数整数。联系这些，我们可以大致的推断出`ExpirationTime`大体上是个什么值。\n\n&emsp;&emsp;`ExpirationTime`是根据当前时间戳，抹平了`10ms`与最大整数的一个差值。越在**后面**的执行，时间戳的值会**越大**，这就意味着与最大整数的差值会越小，`ExpirationTime`会越大。因此，只要存在`ExpirationTime a`大于`ExpirationTime b`，那么`a`肯定是先于`b`的存在。React会对应的先去处理它。\n\n&emsp;&emsp;实际上`ExpirationTime`与调度的优先级有一个相互对应的关系。\n\n```javascript\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\nexport function computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n\n// TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update\n// the names to reflect.\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\n\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n```\n\n&emsp;&emsp;翻看`ReactFiberExpirationTime.js`文件，我们可以看到申明了一些数字的常量，越是调度优先级靠后的，它的值会越大。高优先级调度常量，React又把这些叫做`interactive updates`，交互性的更新。可以看到React在内部对事件进行了一个高地优先级的排列优化。而不管高低优先级，都是调用了一个`computeExpirationBucket`方法来对`ExpirationTime`的值进行了调整。我们来看一下这个函数。\n\n```javascript\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n```\n&emsp;&emsp;这个`ceiling`函数很有意思，同样的，我们不关心传入值，单纯代入一些值看看结果。\n\n```javascript\n// 2\nceiling(10, 2); // 12\nceiling(11, 2); // 12\nceiling(12, 2); // 14\nceiling(13, 2); // 14\n\nceiling(100, 4); // 104\nceiling(101, 4); // 104\n```\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\n&emsp;&emsp;我们发现在`num`和`num + precision - 1`之间的值，都会被置到`num + precision`。比如`num`为100，`precision`为4，那么100~103的值都会被置为`104`，而104会被置为`108`。所以我们可以明白定义的常量的意义。第二个定义的带`BATCH`字样的差值，实际上是批量更新时允许的微秒差。如`HIGH_PRIORITY_BATCH_SIZE`，实际上就是在高优先调度级的批量更新中，`HIGH_PRIORITY_BATCH_SIZE / UNIT_SIZE = 100 / 10 = 10`，偏差在10ms的更新会被调整为同一个`expirationTime`时间，进行批量的相同更新。\n\n\n&emsp;&emsp;现在我们进入`computeExpirationBucket`来看一下。\n\n```javascript\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\ncomputeExpirationBucket(\n  currentTime,\n  HIGH_PRIORITY_EXPIRATION,\n  HIGH_PRIORITY_BATCH_SIZE,\n);\n\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, // (expirationInMs / UNIT_SIZE = 10)\n      bucketSizeMs / UNIT_SIZE, // 10\n    )\n  );\n}\n```\n\n&emsp;&emsp;上面分析`ceiling`实际上是对第一个参数做一个微量的区间调整，不考虑调整情况下，我们可以把函数简单的看为如下.\n\n```javascript\nMAGIC_NUMBER_OFFSET -\nceiling(\n  MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, // (expirationInMs / UNIT_SIZE = 10)\n  bucketSizeMs / UNIT_SIZE, // 10\n)\n// 简化\nMAGIC_NUMBER_OFFSET - (MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE)\n// 去括号\nMAGIC_NUMBER_OFFSET - MAGIC_NUMBER_OFFSET + currentTime - expirationInMs / UNIT_SIZE\n// 去掉 MAGIC_NUMBER_OFFSET\ncurrentTime - expirationInMs / UNIT_SIZE\n```\n\n&emsp;&emsp;可以看到，这个函数本质上就是求得了当前时间和定义毫秒的差值。当优先级调度越高，对应的`expirationInMs`的值会越小，其得到的值也就会越大。与上面计算`ExpirationTime`值越大优先级越高的逻辑上是相同的。我们全局来查询一下这两个函数，看看是在哪里被用到。\n\n```javascript\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  // ... 省略逻辑\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      expirationTime = Sync;\n      break;\n    case UserBlockingPriority:\n      // TODO: Rename this to computeUserBlockingExpiration\n      expirationTime = computeInteractiveExpiration(currentTime);\n      break;\n    case NormalPriority:\n    case LowPriority: // TODO: Handle LowPriority\n      // TODO: Rename this to... something better.\n      expirationTime = computeAsyncExpiration(currentTime);\n      break;\n    case IdlePriority:\n      expirationTime = Never;\n      break;\n    default:\n      invariant(false, 'Expected a valid priority level');\n  }\n  // 省略无关逻辑\n}\n```\n\n&emsp;&emsp;现在我们可以回到`computeExpirationForFiber`函数中来，明白了fiber节点上的`expirationTime`是怎样被更新上来的，做了哪一些调整。","source":"_posts/react/reactCode-react-4.md","raw":"---\ntitle: react源码阅读4 ExpirationTime\ndate: 2020/5/31 14:00\ncategories:\n- [前端, react]\ntags:\n- react\n- 源码阅读\n---\nreact更新中优先级依赖的标识ExpirationTime。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n&emsp;&emsp;这一章节，让我们抛弃掉react代码中的联系，单纯的来看ExpirationTime以及一些计算方式。\n\n## ExpirationTime是什么。\n&emsp;&emsp;ExpirationTime是一个数字，你可以在`react-reconciler`包下的`ReactFiberExpirationTime.js`文件中找到它的定义。\n\n```javascript\nexport type ExpirationTime = number;\n```\n\n## ExpirationTime在React中有什么作用。\n&emsp;&emsp;既然ExpirationTime相关的定义出现在`react-reconciler`包之下，说明它的作用肯定是和React调用有关。我们从`ReactFiberExpirationTime`函数入手，该函数接收一个`ms`，返回一个`ExpirationTime`。\n\n\n```javascript\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\nconst MAX_SIGNED_31_BIT_INT = 1073741823\nexport const NoWork = 0;\nexport const Never = 1;\n// 1073741823 - 1\nexport const Sync = MAX_SIGNED_31_BIT_INT;\n// 1073741823 - 2\nexport const Batched = Sync - 1;\n\nconst UNIT_SIZE = 10;\n// // 1073741823 - 3\nconst MAGIC_NUMBER_OFFSET = Batched - 1;\n\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);\n}\n```\n\n&emsp;&emsp;我们先跳过首部的变量定义，直接看函数`msToExpirationTime`。`msToExpirationTime`接收一个`ms`，返回`ExpirationTime`。函数首先进行`((ms / UNIT_SIZE) | 0)`的计算，我们不来关注`ms`和`UNIT_SIZE`是多少，单纯来看这里的计算逻辑。在另一篇文章中提到过<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>，`A | 0`这个操作，在JS中是将`A`转换为`32位的带符号整数`，在这个公式里面，可以简单的理解为取整。那将`ms / UNIT_SIZE`之后取整意味着什么，我们可以简单将`ms`假设为100前后的数字，`UNIT_SIZE`假设为10来看一下。\n\n```javascript\n(95 / 10) | 0 = 9;\n(100 / 10) | 0 = 10;\n(105 / 10) | 0 = 10;\n(110 / 10) | 0 = 11;\n```\n\n&emsp;&emsp;`((ms / UNIT_SIZE) | 0)`这个操作，其实是抹平了`ms ~ (ms + UNIT_SIZE - 1)`这个范围的差值，让`ms ~ (ms + UNIT_SIZE - 1)`通过这个公式都能得到相同的数字。\n\n\n&emsp;&emsp;明白了调用的含义之后，我们顺着函数调用来看一下`ms`到底是什么。通过全局搜索`msToExpirationTime`，可以发现在`react-reconciler/ReactFiberWorkLoop.js`中存在`msToExpirationTime`的调用。\n\n```javascript\nexport function requestCurrentTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // ...省略无关逻辑\n}\n```\n\n&emsp;&emsp;这里的now方法忽略到调试等逻辑，可以简单的理解为Date.now，即获得当前的时间戳。到这里我们可以回头看一下`MAGIC_NUMBER_OFFSET`，`MAGIC_NUMBER_OFFSET`是**31最大整数**减去3的值，我们可以简单的把它理解为一个很大的常数整数。联系这些，我们可以大致的推断出`ExpirationTime`大体上是个什么值。\n\n&emsp;&emsp;`ExpirationTime`是根据当前时间戳，抹平了`10ms`与最大整数的一个差值。越在**后面**的执行，时间戳的值会**越大**，这就意味着与最大整数的差值会越小，`ExpirationTime`会越大。因此，只要存在`ExpirationTime a`大于`ExpirationTime b`，那么`a`肯定是先于`b`的存在。React会对应的先去处理它。\n\n&emsp;&emsp;实际上`ExpirationTime`与调度的优先级有一个相互对应的关系。\n\n```javascript\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\nexport function computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n\n// TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update\n// the names to reflect.\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\n\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n```\n\n&emsp;&emsp;翻看`ReactFiberExpirationTime.js`文件，我们可以看到申明了一些数字的常量，越是调度优先级靠后的，它的值会越大。高优先级调度常量，React又把这些叫做`interactive updates`，交互性的更新。可以看到React在内部对事件进行了一个高地优先级的排列优化。而不管高低优先级，都是调用了一个`computeExpirationBucket`方法来对`ExpirationTime`的值进行了调整。我们来看一下这个函数。\n\n```javascript\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n```\n&emsp;&emsp;这个`ceiling`函数很有意思，同样的，我们不关心传入值，单纯代入一些值看看结果。\n\n```javascript\n// 2\nceiling(10, 2); // 12\nceiling(11, 2); // 12\nceiling(12, 2); // 14\nceiling(13, 2); // 14\n\nceiling(100, 4); // 104\nceiling(101, 4); // 104\n```\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\n&emsp;&emsp;我们发现在`num`和`num + precision - 1`之间的值，都会被置到`num + precision`。比如`num`为100，`precision`为4，那么100~103的值都会被置为`104`，而104会被置为`108`。所以我们可以明白定义的常量的意义。第二个定义的带`BATCH`字样的差值，实际上是批量更新时允许的微秒差。如`HIGH_PRIORITY_BATCH_SIZE`，实际上就是在高优先调度级的批量更新中，`HIGH_PRIORITY_BATCH_SIZE / UNIT_SIZE = 100 / 10 = 10`，偏差在10ms的更新会被调整为同一个`expirationTime`时间，进行批量的相同更新。\n\n\n&emsp;&emsp;现在我们进入`computeExpirationBucket`来看一下。\n\n```javascript\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\ncomputeExpirationBucket(\n  currentTime,\n  HIGH_PRIORITY_EXPIRATION,\n  HIGH_PRIORITY_BATCH_SIZE,\n);\n\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, // (expirationInMs / UNIT_SIZE = 10)\n      bucketSizeMs / UNIT_SIZE, // 10\n    )\n  );\n}\n```\n\n&emsp;&emsp;上面分析`ceiling`实际上是对第一个参数做一个微量的区间调整，不考虑调整情况下，我们可以把函数简单的看为如下.\n\n```javascript\nMAGIC_NUMBER_OFFSET -\nceiling(\n  MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, // (expirationInMs / UNIT_SIZE = 10)\n  bucketSizeMs / UNIT_SIZE, // 10\n)\n// 简化\nMAGIC_NUMBER_OFFSET - (MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE)\n// 去括号\nMAGIC_NUMBER_OFFSET - MAGIC_NUMBER_OFFSET + currentTime - expirationInMs / UNIT_SIZE\n// 去掉 MAGIC_NUMBER_OFFSET\ncurrentTime - expirationInMs / UNIT_SIZE\n```\n\n&emsp;&emsp;可以看到，这个函数本质上就是求得了当前时间和定义毫秒的差值。当优先级调度越高，对应的`expirationInMs`的值会越小，其得到的值也就会越大。与上面计算`ExpirationTime`值越大优先级越高的逻辑上是相同的。我们全局来查询一下这两个函数，看看是在哪里被用到。\n\n```javascript\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  // ... 省略逻辑\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      expirationTime = Sync;\n      break;\n    case UserBlockingPriority:\n      // TODO: Rename this to computeUserBlockingExpiration\n      expirationTime = computeInteractiveExpiration(currentTime);\n      break;\n    case NormalPriority:\n    case LowPriority: // TODO: Handle LowPriority\n      // TODO: Rename this to... something better.\n      expirationTime = computeAsyncExpiration(currentTime);\n      break;\n    case IdlePriority:\n      expirationTime = Never;\n      break;\n    default:\n      invariant(false, 'Expected a valid priority level');\n  }\n  // 省略无关逻辑\n}\n```\n\n&emsp;&emsp;现在我们可以回到`computeExpirationForFiber`函数中来，明白了fiber节点上的`expirationTime`是怎样被更新上来的，做了哪一些调整。","slug":"react/reactCode-react-4","published":1,"updated":"2020-06-11T01:43:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxx001q9r2v99ewemqu","content":"<p>react更新中优先级依赖的标识ExpirationTime。阅读React包的源码版本为<strong>16.8.6</strong>。<br><a id=\"more\"></a><br>&emsp;&emsp;这一章节，让我们抛弃掉react代码中的联系，单纯的来看ExpirationTime以及一些计算方式。</p>\n<h2 id=\"ExpirationTime是什么。\"><a href=\"#ExpirationTime是什么。\" class=\"headerlink\" title=\"ExpirationTime是什么。\"></a>ExpirationTime是什么。</h2><p>&emsp;&emsp;ExpirationTime是一个数字，你可以在<code>react-reconciler</code>包下的<code>ReactFiberExpirationTime.js</code>文件中找到它的定义。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> type ExpirationTime = number;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ExpirationTime在React中有什么作用。\"><a href=\"#ExpirationTime在React中有什么作用。\" class=\"headerlink\" title=\"ExpirationTime在React中有什么作用。\"></a>ExpirationTime在React中有什么作用。</h2><p>&emsp;&emsp;既然ExpirationTime相关的定义出现在<code>react-reconciler</code>包之下，说明它的作用肯定是和React调用有关。我们从<code>ReactFiberExpirationTime</code>函数入手，该函数接收一个<code>ms</code>，返回一个<code>ExpirationTime</code>。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// Math.pow(2, 30) - 1</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> MAX_SIGNED_31_BIT_INT = <span class=\"hljs-number\">1073741823</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> NoWork = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> Never = <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 1073741823 - 1</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> Sync = MAX_SIGNED_31_BIT_INT;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 1073741823 - 2</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> Batched = Sync - <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> UNIT_SIZE = <span class=\"hljs-number\">10</span>;</span><br><span class=\"line\"><span class=\"hljs-comment\">// // 1073741823 - 3</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> MAGIC_NUMBER_OFFSET = Batched - <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">msToExpirationTime</span>(<span class=\"hljs-params\">ms: number</span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Always add an offset so that we don't clash with the magic number for NoWork.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | <span class=\"hljs-number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们先跳过首部的变量定义，直接看函数<code>msToExpirationTime</code>。<code>msToExpirationTime</code>接收一个<code>ms</code>，返回<code>ExpirationTime</code>。函数首先进行<code>((ms / UNIT_SIZE) | 0)</code>的计算，我们不来关注<code>ms</code>和<code>UNIT_SIZE</code>是多少，单纯来看这里的计算逻辑。在另一篇文章中提到过<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>，<code>A | 0</code>这个操作，在JS中是将<code>A</code>转换为<code>32位的带符号整数</code>，在这个公式里面，可以简单的理解为取整。那将<code>ms / UNIT_SIZE</code>之后取整意味着什么，我们可以简单将<code>ms</code>假设为100前后的数字，<code>UNIT_SIZE</code>假设为10来看一下。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-number\">95</span> / <span class=\"hljs-number\">10</span>) | <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">9</span>;</span><br><span class=\"line\">(<span class=\"hljs-number\">100</span> / <span class=\"hljs-number\">10</span>) | <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">10</span>;</span><br><span class=\"line\">(<span class=\"hljs-number\">105</span> / <span class=\"hljs-number\">10</span>) | <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">10</span>;</span><br><span class=\"line\">(<span class=\"hljs-number\">110</span> / <span class=\"hljs-number\">10</span>) | <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">11</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>((ms / UNIT_SIZE) | 0)</code>这个操作，其实是抹平了<code>ms ~ (ms + UNIT_SIZE - 1)</code>这个范围的差值，让<code>ms ~ (ms + UNIT_SIZE - 1)</code>通过这个公式都能得到相同的数字。</p>\n<p>&emsp;&emsp;明白了调用的含义之后，我们顺着函数调用来看一下<code>ms</code>到底是什么。通过全局搜索<code>msToExpirationTime</code>，可以发现在<code>react-reconciler/ReactFiberWorkLoop.js</code>中存在<code>msToExpirationTime</code>的调用。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">requestCurrentTime</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// We're inside React, so it's fine to read the actual time.</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> msToExpirationTime(now());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...省略无关逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这里的now方法忽略到调试等逻辑，可以简单的理解为Date.now，即获得当前的时间戳。到这里我们可以回头看一下<code>MAGIC_NUMBER_OFFSET</code>，<code>MAGIC_NUMBER_OFFSET</code>是<strong>31最大整数</strong>减去3的值，我们可以简单的把它理解为一个很大的常数整数。联系这些，我们可以大致的推断出<code>ExpirationTime</code>大体上是个什么值。</p>\n<p>&emsp;&emsp;<code>ExpirationTime</code>是根据当前时间戳，抹平了<code>10ms</code>与最大整数的一个差值。越在<strong>后面</strong>的执行，时间戳的值会<strong>越大</strong>，这就意味着与最大整数的差值会越小，<code>ExpirationTime</code>会越大。因此，只要存在<code>ExpirationTime a</code>大于<code>ExpirationTime b</code>，那么<code>a</code>肯定是先于<code>b</code>的存在。React会对应的先去处理它。</p>\n<p>&emsp;&emsp;实际上<code>ExpirationTime</code>与调度的优先级有一个相互对应的关系。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// We intentionally set a higher expiration time for interactive updates in</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// dev than in production.</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> HIGH_PRIORITY_EXPIRATION = __DEV__ ? <span class=\"hljs-number\">500</span> : <span class=\"hljs-number\">150</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> HIGH_PRIORITY_BATCH_SIZE = <span class=\"hljs-number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeInteractiveExpiration</span>(<span class=\"hljs-params\">currentTime: ExpirationTime</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> computeExpirationBucket(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    HIGH_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    HIGH_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> This corresponds to Scheduler's NormalPriority, not LowPriority. Update</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// the names to reflect.</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> LOW_PRIORITY_EXPIRATION = <span class=\"hljs-number\">5000</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> LOW_PRIORITY_BATCH_SIZE = <span class=\"hljs-number\">250</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeAsyncExpiration</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  currentTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> computeExpirationBucket(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    LOW_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    LOW_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;翻看<code>ReactFiberExpirationTime.js</code>文件，我们可以看到申明了一些数字的常量，越是调度优先级靠后的，它的值会越大。高优先级调度常量，React又把这些叫做<code>interactive updates</code>，交互性的更新。可以看到React在内部对事件进行了一个高地优先级的排列优化。而不管高低优先级，都是调用了一个<code>computeExpirationBucket</code>方法来对<code>ExpirationTime</code>的值进行了调整。我们来看一下这个函数。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeExpirationBucket</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  currentTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  expirationInMs,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  bucketSizeMs,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    MAGIC_NUMBER_OFFSET -</span><br><span class=\"line\">    ceiling(</span><br><span class=\"line\">      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,</span><br><span class=\"line\">      bucketSizeMs / UNIT_SIZE,</span><br><span class=\"line\">    )</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ceiling</span>(<span class=\"hljs-params\">num: number, precision: number</span>): <span class=\"hljs-title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (((num / precision) | <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span>) * precision;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个<code>ceiling</code>函数很有意思，同样的，我们不关心传入值，单纯代入一些值看看结果。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 2</span></span><br><span class=\"line\">ceiling(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 12</span></span><br><span class=\"line\">ceiling(<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 12</span></span><br><span class=\"line\">ceiling(<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 14</span></span><br><span class=\"line\">ceiling(<span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 14</span></span><br><span class=\"line\"></span><br><span class=\"line\">ceiling(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 104</span></span><br><span class=\"line\">ceiling(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 104</span></span><br></pre></td></tr></table></figure>\n<p>export const HIGH_PRIORITY_EXPIRATION = <strong>DEV</strong> ? 500 : 150;<br>export const HIGH_PRIORITY_BATCH_SIZE = 100;</p>\n<p>&emsp;&emsp;我们发现在<code>num</code>和<code>num + precision - 1</code>之间的值，都会被置到<code>num + precision</code>。比如<code>num</code>为100，<code>precision</code>为4，那么100~103的值都会被置为<code>104</code>，而104会被置为<code>108</code>。所以我们可以明白定义的常量的意义。第二个定义的带<code>BATCH</code>字样的差值，实际上是批量更新时允许的微秒差。如<code>HIGH_PRIORITY_BATCH_SIZE</code>，实际上就是在高优先调度级的批量更新中，<code>HIGH_PRIORITY_BATCH_SIZE / UNIT_SIZE = 100 / 10 = 10</code>，偏差在10ms的更新会被调整为同一个<code>expirationTime</code>时间，进行批量的相同更新。</p>\n<p>&emsp;&emsp;现在我们进入<code>computeExpirationBucket</code>来看一下。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> HIGH_PRIORITY_EXPIRATION = __DEV__ ? <span class=\"hljs-number\">500</span> : <span class=\"hljs-number\">150</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> HIGH_PRIORITY_BATCH_SIZE = <span class=\"hljs-number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">computeExpirationBucket(</span><br><span class=\"line\">  currentTime,</span><br><span class=\"line\">  HIGH_PRIORITY_EXPIRATION,</span><br><span class=\"line\">  HIGH_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeExpirationBucket</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  currentTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  expirationInMs,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  bucketSizeMs,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    MAGIC_NUMBER_OFFSET -</span><br><span class=\"line\">    ceiling(</span><br><span class=\"line\">      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, <span class=\"hljs-comment\">// (expirationInMs / UNIT_SIZE = 10)</span></span><br><span class=\"line\">      bucketSizeMs / UNIT_SIZE, <span class=\"hljs-comment\">// 10</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面分析<code>ceiling</code>实际上是对第一个参数做一个微量的区间调整，不考虑调整情况下，我们可以把函数简单的看为如下.</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAGIC_NUMBER_OFFSET -</span><br><span class=\"line\">ceiling(</span><br><span class=\"line\">  MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, <span class=\"hljs-comment\">// (expirationInMs / UNIT_SIZE = 10)</span></span><br><span class=\"line\">  bucketSizeMs / UNIT_SIZE, <span class=\"hljs-comment\">// 10</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">// 简化</span></span><br><span class=\"line\">MAGIC_NUMBER_OFFSET - (MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE)</span><br><span class=\"line\"><span class=\"hljs-comment\">// 去括号</span></span><br><span class=\"line\">MAGIC_NUMBER_OFFSET - MAGIC_NUMBER_OFFSET + currentTime - expirationInMs / UNIT_SIZE</span><br><span class=\"line\"><span class=\"hljs-comment\">// 去掉 MAGIC_NUMBER_OFFSET</span></span><br><span class=\"line\">currentTime - expirationInMs / UNIT_SIZE</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;可以看到，这个函数本质上就是求得了当前时间和定义毫秒的差值。当优先级调度越高，对应的<code>expirationInMs</code>的值会越小，其得到的值也就会越大。与上面计算<code>ExpirationTime</code>值越大优先级越高的逻辑上是相同的。我们全局来查询一下这两个函数，看看是在哪里被用到。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeExpirationForFiber</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  currentTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  fiber: Fiber,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略逻辑</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">switch</span> (priorityLevel) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">case</span> ImmediatePriority:</span><br><span class=\"line\">      expirationTime = Sync;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">case</span> UserBlockingPriority:</span><br><span class=\"line\">      <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Rename this to computeUserBlockingExpiration</span></span><br><span class=\"line\">      expirationTime = computeInteractiveExpiration(currentTime);</span><br><span class=\"line\">      <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">case</span> NormalPriority:</span><br><span class=\"line\">    <span class=\"hljs-keyword\">case</span> LowPriority: <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Handle LowPriority</span></span><br><span class=\"line\">      <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Rename this to... something better.</span></span><br><span class=\"line\">      expirationTime = computeAsyncExpiration(currentTime);</span><br><span class=\"line\">      <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">case</span> IdlePriority:</span><br><span class=\"line\">      expirationTime = Never;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">default</span>:</span><br><span class=\"line\">      invariant(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">'Expected a valid priority level'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 省略无关逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们可以回到<code>computeExpirationForFiber</code>函数中来，明白了fiber节点上的<code>expirationTime</code>是怎样被更新上来的，做了哪一些调整。</p>\n","site":{"data":{}},"excerpt":"<p>react更新中优先级依赖的标识ExpirationTime。阅读React包的源码版本为<strong>16.8.6</strong>。<br></p>","more":"<br>&emsp;&emsp;这一章节，让我们抛弃掉react代码中的联系，单纯的来看ExpirationTime以及一些计算方式。</p>\n<h2 id=\"ExpirationTime是什么。\"><a href=\"#ExpirationTime是什么。\" class=\"headerlink\" title=\"ExpirationTime是什么。\"></a>ExpirationTime是什么。</h2><p>&emsp;&emsp;ExpirationTime是一个数字，你可以在<code>react-reconciler</code>包下的<code>ReactFiberExpirationTime.js</code>文件中找到它的定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> type ExpirationTime = number;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ExpirationTime在React中有什么作用。\"><a href=\"#ExpirationTime在React中有什么作用。\" class=\"headerlink\" title=\"ExpirationTime在React中有什么作用。\"></a>ExpirationTime在React中有什么作用。</h2><p>&emsp;&emsp;既然ExpirationTime相关的定义出现在<code>react-reconciler</code>包之下，说明它的作用肯定是和React调用有关。我们从<code>ReactFiberExpirationTime</code>函数入手，该函数接收一个<code>ms</code>，返回一个<code>ExpirationTime</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class=\"line\"><span class=\"comment\">// Math.pow(2, 30) - 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MAX_SIGNED_31_BIT_INT = <span class=\"number\">1073741823</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> NoWork = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Never = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 1073741823 - 1</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Sync = MAX_SIGNED_31_BIT_INT;</span><br><span class=\"line\"><span class=\"comment\">// 1073741823 - 2</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Batched = Sync - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UNIT_SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// // 1073741823 - 3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MAGIC_NUMBER_OFFSET = Batched - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">msToExpirationTime</span>(<span class=\"params\">ms: number</span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Always add an offset so that we don't clash with the magic number for NoWork.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们先跳过首部的变量定义，直接看函数<code>msToExpirationTime</code>。<code>msToExpirationTime</code>接收一个<code>ms</code>，返回<code>ExpirationTime</code>。函数首先进行<code>((ms / UNIT_SIZE) | 0)</code>的计算，我们不来关注<code>ms</code>和<code>UNIT_SIZE</code>是多少，单纯来看这里的计算逻辑。在另一篇文章中提到过<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>，<code>A | 0</code>这个操作，在JS中是将<code>A</code>转换为<code>32位的带符号整数</code>，在这个公式里面，可以简单的理解为取整。那将<code>ms / UNIT_SIZE</code>之后取整意味着什么，我们可以简单将<code>ms</code>假设为100前后的数字，<code>UNIT_SIZE</code>假设为10来看一下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">95</span> / <span class=\"number\">10</span>) | <span class=\"number\">0</span> = <span class=\"number\">9</span>;</span><br><span class=\"line\">(<span class=\"number\">100</span> / <span class=\"number\">10</span>) | <span class=\"number\">0</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">(<span class=\"number\">105</span> / <span class=\"number\">10</span>) | <span class=\"number\">0</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">(<span class=\"number\">110</span> / <span class=\"number\">10</span>) | <span class=\"number\">0</span> = <span class=\"number\">11</span>;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>((ms / UNIT_SIZE) | 0)</code>这个操作，其实是抹平了<code>ms ~ (ms + UNIT_SIZE - 1)</code>这个范围的差值，让<code>ms ~ (ms + UNIT_SIZE - 1)</code>通过这个公式都能得到相同的数字。</p>\n<p>&emsp;&emsp;明白了调用的含义之后，我们顺着函数调用来看一下<code>ms</code>到底是什么。通过全局搜索<code>msToExpirationTime</code>，可以发现在<code>react-reconciler/ReactFiberWorkLoop.js</code>中存在<code>msToExpirationTime</code>的调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requestCurrentTime</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// We're inside React, so it's fine to read the actual time.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> msToExpirationTime(now());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略无关逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这里的now方法忽略到调试等逻辑，可以简单的理解为Date.now，即获得当前的时间戳。到这里我们可以回头看一下<code>MAGIC_NUMBER_OFFSET</code>，<code>MAGIC_NUMBER_OFFSET</code>是<strong>31最大整数</strong>减去3的值，我们可以简单的把它理解为一个很大的常数整数。联系这些，我们可以大致的推断出<code>ExpirationTime</code>大体上是个什么值。</p>\n<p>&emsp;&emsp;<code>ExpirationTime</code>是根据当前时间戳，抹平了<code>10ms</code>与最大整数的一个差值。越在<strong>后面</strong>的执行，时间戳的值会<strong>越大</strong>，这就意味着与最大整数的差值会越小，<code>ExpirationTime</code>会越大。因此，只要存在<code>ExpirationTime a</code>大于<code>ExpirationTime b</code>，那么<code>a</code>肯定是先于<code>b</code>的存在。React会对应的先去处理它。</p>\n<p>&emsp;&emsp;实际上<code>ExpirationTime</code>与调度的优先级有一个相互对应的关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// We intentionally set a higher expiration time for interactive updates in</span></span><br><span class=\"line\"><span class=\"comment\">// dev than in production.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> HIGH_PRIORITY_EXPIRATION = __DEV__ ? <span class=\"number\">500</span> : <span class=\"number\">150</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> HIGH_PRIORITY_BATCH_SIZE = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeInteractiveExpiration</span>(<span class=\"params\">currentTime: ExpirationTime</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> computeExpirationBucket(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    HIGH_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    HIGH_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> This corresponds to Scheduler's NormalPriority, not LowPriority. Update</span></span><br><span class=\"line\"><span class=\"comment\">// the names to reflect.</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> LOW_PRIORITY_EXPIRATION = <span class=\"number\">5000</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> LOW_PRIORITY_BATCH_SIZE = <span class=\"number\">250</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeAsyncExpiration</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  currentTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> computeExpirationBucket(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    LOW_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    LOW_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;翻看<code>ReactFiberExpirationTime.js</code>文件，我们可以看到申明了一些数字的常量，越是调度优先级靠后的，它的值会越大。高优先级调度常量，React又把这些叫做<code>interactive updates</code>，交互性的更新。可以看到React在内部对事件进行了一个高地优先级的排列优化。而不管高低优先级，都是调用了一个<code>computeExpirationBucket</code>方法来对<code>ExpirationTime</code>的值进行了调整。我们来看一下这个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeExpirationBucket</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  currentTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  expirationInMs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  bucketSizeMs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    MAGIC_NUMBER_OFFSET -</span><br><span class=\"line\">    ceiling(</span><br><span class=\"line\">      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,</span><br><span class=\"line\">      bucketSizeMs / UNIT_SIZE,</span><br><span class=\"line\">    )</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ceiling</span>(<span class=\"params\">num: number, precision: number</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (((num / precision) | <span class=\"number\">0</span>) + <span class=\"number\">1</span>) * precision;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个<code>ceiling</code>函数很有意思，同样的，我们不关心传入值，单纯代入一些值看看结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">ceiling(<span class=\"number\">10</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 12</span></span><br><span class=\"line\">ceiling(<span class=\"number\">11</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 12</span></span><br><span class=\"line\">ceiling(<span class=\"number\">12</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 14</span></span><br><span class=\"line\">ceiling(<span class=\"number\">13</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 14</span></span><br><span class=\"line\"></span><br><span class=\"line\">ceiling(<span class=\"number\">100</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 104</span></span><br><span class=\"line\">ceiling(<span class=\"number\">101</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 104</span></span><br></pre></td></tr></table></figure>\n<p>export const HIGH_PRIORITY_EXPIRATION = <strong>DEV</strong> ? 500 : 150;<br>export const HIGH_PRIORITY_BATCH_SIZE = 100;</p>\n<p>&emsp;&emsp;我们发现在<code>num</code>和<code>num + precision - 1</code>之间的值，都会被置到<code>num + precision</code>。比如<code>num</code>为100，<code>precision</code>为4，那么100~103的值都会被置为<code>104</code>，而104会被置为<code>108</code>。所以我们可以明白定义的常量的意义。第二个定义的带<code>BATCH</code>字样的差值，实际上是批量更新时允许的微秒差。如<code>HIGH_PRIORITY_BATCH_SIZE</code>，实际上就是在高优先调度级的批量更新中，<code>HIGH_PRIORITY_BATCH_SIZE / UNIT_SIZE = 100 / 10 = 10</code>，偏差在10ms的更新会被调整为同一个<code>expirationTime</code>时间，进行批量的相同更新。</p>\n<p>&emsp;&emsp;现在我们进入<code>computeExpirationBucket</code>来看一下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> HIGH_PRIORITY_EXPIRATION = __DEV__ ? <span class=\"number\">500</span> : <span class=\"number\">150</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> HIGH_PRIORITY_BATCH_SIZE = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">computeExpirationBucket(</span><br><span class=\"line\">  currentTime,</span><br><span class=\"line\">  HIGH_PRIORITY_EXPIRATION,</span><br><span class=\"line\">  HIGH_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeExpirationBucket</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  currentTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  expirationInMs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  bucketSizeMs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    MAGIC_NUMBER_OFFSET -</span><br><span class=\"line\">    ceiling(</span><br><span class=\"line\">      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, <span class=\"comment\">// (expirationInMs / UNIT_SIZE = 10)</span></span><br><span class=\"line\">      bucketSizeMs / UNIT_SIZE, <span class=\"comment\">// 10</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面分析<code>ceiling</code>实际上是对第一个参数做一个微量的区间调整，不考虑调整情况下，我们可以把函数简单的看为如下.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAGIC_NUMBER_OFFSET -</span><br><span class=\"line\">ceiling(</span><br><span class=\"line\">  MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, <span class=\"comment\">// (expirationInMs / UNIT_SIZE = 10)</span></span><br><span class=\"line\">  bucketSizeMs / UNIT_SIZE, <span class=\"comment\">// 10</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 简化</span></span><br><span class=\"line\">MAGIC_NUMBER_OFFSET - (MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE)</span><br><span class=\"line\"><span class=\"comment\">// 去括号</span></span><br><span class=\"line\">MAGIC_NUMBER_OFFSET - MAGIC_NUMBER_OFFSET + currentTime - expirationInMs / UNIT_SIZE</span><br><span class=\"line\"><span class=\"comment\">// 去掉 MAGIC_NUMBER_OFFSET</span></span><br><span class=\"line\">currentTime - expirationInMs / UNIT_SIZE</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;可以看到，这个函数本质上就是求得了当前时间和定义毫秒的差值。当优先级调度越高，对应的<code>expirationInMs</code>的值会越小，其得到的值也就会越大。与上面计算<code>ExpirationTime</code>值越大优先级越高的逻辑上是相同的。我们全局来查询一下这两个函数，看看是在哪里被用到。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeExpirationForFiber</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  currentTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  fiber: Fiber,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (priorityLevel) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ImmediatePriority:</span><br><span class=\"line\">      expirationTime = Sync;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> UserBlockingPriority:</span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Rename this to computeUserBlockingExpiration</span></span><br><span class=\"line\">      expirationTime = computeInteractiveExpiration(currentTime);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> NormalPriority:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LowPriority: <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Handle LowPriority</span></span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Rename this to... something better.</span></span><br><span class=\"line\">      expirationTime = computeAsyncExpiration(currentTime);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> IdlePriority:</span><br><span class=\"line\">      expirationTime = Never;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      invariant(<span class=\"literal\">false</span>, <span class=\"string\">'Expected a valid priority level'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 省略无关逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们可以回到<code>computeExpirationForFiber</code>函数中来，明白了fiber节点上的<code>expirationTime</code>是怎样被更新上来的，做了哪一些调整。</p>"},{"title":"react源码阅读-react-基础","date":"2019-12-01T11:40:00.000Z","_content":"&emsp;&emsp;react包基础概念以及React包的两个核心api阅读。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n## 基础概念\n\n### react包\n&emsp;&emsp;react包的本质上是建立一个react相关数据类型的抽象屏障，它创建了一系列**符合react渲染调度**的数据结构，在各个react相关平台(dom,native,render)上进行渲染调度。\n\n&emsp;&emsp;在阅读源码前，我一度认为诸如`createElement`和`Component`相关包，会有一系列复杂诸如生命周期，组件更新，setState等复杂的逻辑，实际上react包在做的是生成符合规范的数据结构，对特定数据进行打标(标志数据类型)，react包当中最复杂的一个js文件就是`ReactChildren.js`文件，中途进行了对应的递归数组展开和到contextPour中拿取一系列数据。\n```javascript\n代码   |    react抽象层输出数据    |      多端适配渲染\n\n                               -> 服务端渲染     -> 服务端静态html文件\ncode  ->  react  ->  reactType -> react-dom    -> html\n                               -> react-native -> 移动端\n```\n### jsx与babel\n&emsp;&emsp;jsx是react框架的精髓，jsx允许以js的方式来书写html和css，使得react的dom更新熏染的方式真正活起来。jsx实质是createElement的语法糖，也是React当中使用最多的api。\n\n```javascript\nconst Box = <div id=\"box\" data-num=\"3\">123</div>;\nconst ContentBox = <Box />;\n\nvar Box = React.createElement(\"div\", {\n  id: \"box\",\n  \"data-num\": \"3\"\n}, \"123\");\nvar ContentBox = React.createElement(Box, null);\n```\n&emsp;&emsp;我们可以看到，在编译过程中，如果是html自身存在的元素，createElement的第一个参数将为一个html标签名的**字符串**，而如果是自带的组件，则为变量名。因此为了方便编译区分，自定义组件变量名规定为**大写**。\n\n<h2 id=\"react\">React入口与分层</h2>\n&emsp;&emsp;我们可以从package.json的main文件入口开始，来找寻React包的入口文件。\n\n```javascript\n// package.json\n\"main\": \"index.js\"\n\n// index.js\n'use strict';\n\nconst React = require('./src/React');\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nmodule.exports = React.default || React;\n```\n&emsp;&emsp;确定主文件入口为React.js后，来简单看一下react包的文件目录结构。\n![react包目录](/blog/public/imgs/reactCode/reactCode1-1.jpg)\n\n&emsp;&emsp;react包就是以各个api为js文件，然后React.js为主文件汇总的暴露的一个总分式文件结构。忽略掉引入文件以及dev模型的判断语句，React.js就是一个很简单的`对象-api`结构。\n```javascript\n// __DEV__ 为是否打开dev模式\nconst React = {\n  Children: {\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  createRef,\n  Component,\n  PureComponent,\n  createContext,\n  forwardRef,\n  lazy,\n  memo,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  Fragment: REACT_FRAGMENT_TYPE,\n  Profiler: REACT_PROFILER_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  Suspense: REACT_SUSPENSE_TYPE,\n  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,\n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,\n  isValidElement: isValidElement,\n  version: ReactVersion,\n  unstable_withSuspenseConfig: withSuspenseConfig,\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,\n};\n\nexport default React;\n```\n&emsp;&emsp;React当中所有存在的api，都存在于此React对象当中。\n\n## react-core-api\n\n&emsp;&emsp;上文刚刚分析过`jsx`的本质其实就是`React.createElement`的语法糖。因此react当中我们最常使用的api实质上是createElement和classComponent模式下去`extends`的React.Component。\n\n&emsp;&emsp;在我看源码之前，我本也以为这两个api的代码量会非常庞大，涉及到及其复杂的调度逻辑。其实这两个文件代码平均下来每个文件不过百来行。去掉注释和**dev**相关的一些异常输出处理，核心的逻辑不过50行。这两个api，实质上更多的是去创建定义一个`Reactly`的数据结构。这份数据结构，能够作为一个起点，来供`react-dom`以及`react-native`去在不同环境下拆分和使用。\n\n### ReactElement\n&emsp;&emsp;根据`React.js`的文件引用，我们可以很快找到`createElement`的api在同级目录的`ReactElement.js`下。我们来看一下去掉`dev`调试逻辑后，`createElement`部分的代码。\n\n```javascript\n/** \n * type 标签类型\n * config 标签属性对象\n * children 除了前两个之外剩下的都为 children，创建element的子节点\n*/\nfunction createElement(type, config, children) {\n  let propName;\n  // 1.处理config属性\n  const props = {};\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n  // 如果存在element的属性对象\n  if (config != null) {\n    // ref和key格式检查\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    // 从config上拷贝一份数据到props对象上面\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n  // 2. 处理 children， 小于1直接等于，否则复制到数组上\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n```\n\n&emsp;&emsp;`createElement`就做了很简单的两件事，我在注释中都有标注出来：\n1. 把config(标签属性定义)数据，移植到prop对象上。在这过程中对`key/ref/defualtProps`等一些特殊属性做了一个合法以及赋值的处理。\n2. 处理了一下children，把入参的children转换成数组，赋值到props上。最后调用了`ReactElement`函数。\n\n&emsp;&emsp;`ReactElement`函数就更简单了，它直接返回一个打了标的`react`对象。其中`self/source`的概念都是用于`dev`状态下的调试。无需去关心。\n\n```javascript\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n  return element;\n}\n```\n\n&emsp;&emsp;我们可以看到，我们写的`jsx`代码，最终就是转换为这样一份对象数据。这份对象数据作为一个起点，作用在react各个渲染平台上`dom/native/server`，去实现各自的渲染逻辑。\n\n### React.Component\n&emsp;&emsp;`Component`代码逻辑在`React.js`同目录下的`ReactBaseClasses.js`文件中。`Component`的代码更简单，就是初始化了一个`Component`实例，在原型上绑定了常用的一些方法。\n\n```javascript\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\nComponent.prototype.setState = function(partialState, callback) {\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\nComponent.prototype.forceUpdate = function(callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n```\n\n&emsp;&emsp;我们最关心的`setState`方法，其实什么也没做，只是调用了一个`updater.enqueueSetState`方法。而这个方法具体实现，是在React各个包中实现，这个方法的使用，将在后续`react-dom`包中进行讲述，","source":"_posts/react/reactCode-react-1.md","raw":"---\ntitle: react源码阅读-react-基础\ndate: 2019/12/1 19:40\ncategories:\n- [前端, react]\ntags:\n- react\n- 源码阅读\n---\n&emsp;&emsp;react包基础概念以及React包的两个核心api阅读。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n## 基础概念\n\n### react包\n&emsp;&emsp;react包的本质上是建立一个react相关数据类型的抽象屏障，它创建了一系列**符合react渲染调度**的数据结构，在各个react相关平台(dom,native,render)上进行渲染调度。\n\n&emsp;&emsp;在阅读源码前，我一度认为诸如`createElement`和`Component`相关包，会有一系列复杂诸如生命周期，组件更新，setState等复杂的逻辑，实际上react包在做的是生成符合规范的数据结构，对特定数据进行打标(标志数据类型)，react包当中最复杂的一个js文件就是`ReactChildren.js`文件，中途进行了对应的递归数组展开和到contextPour中拿取一系列数据。\n```javascript\n代码   |    react抽象层输出数据    |      多端适配渲染\n\n                               -> 服务端渲染     -> 服务端静态html文件\ncode  ->  react  ->  reactType -> react-dom    -> html\n                               -> react-native -> 移动端\n```\n### jsx与babel\n&emsp;&emsp;jsx是react框架的精髓，jsx允许以js的方式来书写html和css，使得react的dom更新熏染的方式真正活起来。jsx实质是createElement的语法糖，也是React当中使用最多的api。\n\n```javascript\nconst Box = <div id=\"box\" data-num=\"3\">123</div>;\nconst ContentBox = <Box />;\n\nvar Box = React.createElement(\"div\", {\n  id: \"box\",\n  \"data-num\": \"3\"\n}, \"123\");\nvar ContentBox = React.createElement(Box, null);\n```\n&emsp;&emsp;我们可以看到，在编译过程中，如果是html自身存在的元素，createElement的第一个参数将为一个html标签名的**字符串**，而如果是自带的组件，则为变量名。因此为了方便编译区分，自定义组件变量名规定为**大写**。\n\n<h2 id=\"react\">React入口与分层</h2>\n&emsp;&emsp;我们可以从package.json的main文件入口开始，来找寻React包的入口文件。\n\n```javascript\n// package.json\n\"main\": \"index.js\"\n\n// index.js\n'use strict';\n\nconst React = require('./src/React');\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nmodule.exports = React.default || React;\n```\n&emsp;&emsp;确定主文件入口为React.js后，来简单看一下react包的文件目录结构。\n![react包目录](/blog/public/imgs/reactCode/reactCode1-1.jpg)\n\n&emsp;&emsp;react包就是以各个api为js文件，然后React.js为主文件汇总的暴露的一个总分式文件结构。忽略掉引入文件以及dev模型的判断语句，React.js就是一个很简单的`对象-api`结构。\n```javascript\n// __DEV__ 为是否打开dev模式\nconst React = {\n  Children: {\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  createRef,\n  Component,\n  PureComponent,\n  createContext,\n  forwardRef,\n  lazy,\n  memo,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  Fragment: REACT_FRAGMENT_TYPE,\n  Profiler: REACT_PROFILER_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  Suspense: REACT_SUSPENSE_TYPE,\n  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,\n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,\n  isValidElement: isValidElement,\n  version: ReactVersion,\n  unstable_withSuspenseConfig: withSuspenseConfig,\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,\n};\n\nexport default React;\n```\n&emsp;&emsp;React当中所有存在的api，都存在于此React对象当中。\n\n## react-core-api\n\n&emsp;&emsp;上文刚刚分析过`jsx`的本质其实就是`React.createElement`的语法糖。因此react当中我们最常使用的api实质上是createElement和classComponent模式下去`extends`的React.Component。\n\n&emsp;&emsp;在我看源码之前，我本也以为这两个api的代码量会非常庞大，涉及到及其复杂的调度逻辑。其实这两个文件代码平均下来每个文件不过百来行。去掉注释和**dev**相关的一些异常输出处理，核心的逻辑不过50行。这两个api，实质上更多的是去创建定义一个`Reactly`的数据结构。这份数据结构，能够作为一个起点，来供`react-dom`以及`react-native`去在不同环境下拆分和使用。\n\n### ReactElement\n&emsp;&emsp;根据`React.js`的文件引用，我们可以很快找到`createElement`的api在同级目录的`ReactElement.js`下。我们来看一下去掉`dev`调试逻辑后，`createElement`部分的代码。\n\n```javascript\n/** \n * type 标签类型\n * config 标签属性对象\n * children 除了前两个之外剩下的都为 children，创建element的子节点\n*/\nfunction createElement(type, config, children) {\n  let propName;\n  // 1.处理config属性\n  const props = {};\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n  // 如果存在element的属性对象\n  if (config != null) {\n    // ref和key格式检查\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    // 从config上拷贝一份数据到props对象上面\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n  // 2. 处理 children， 小于1直接等于，否则复制到数组上\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n```\n\n&emsp;&emsp;`createElement`就做了很简单的两件事，我在注释中都有标注出来：\n1. 把config(标签属性定义)数据，移植到prop对象上。在这过程中对`key/ref/defualtProps`等一些特殊属性做了一个合法以及赋值的处理。\n2. 处理了一下children，把入参的children转换成数组，赋值到props上。最后调用了`ReactElement`函数。\n\n&emsp;&emsp;`ReactElement`函数就更简单了，它直接返回一个打了标的`react`对象。其中`self/source`的概念都是用于`dev`状态下的调试。无需去关心。\n\n```javascript\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n  return element;\n}\n```\n\n&emsp;&emsp;我们可以看到，我们写的`jsx`代码，最终就是转换为这样一份对象数据。这份对象数据作为一个起点，作用在react各个渲染平台上`dom/native/server`，去实现各自的渲染逻辑。\n\n### React.Component\n&emsp;&emsp;`Component`代码逻辑在`React.js`同目录下的`ReactBaseClasses.js`文件中。`Component`的代码更简单，就是初始化了一个`Component`实例，在原型上绑定了常用的一些方法。\n\n```javascript\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\nComponent.prototype.setState = function(partialState, callback) {\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\nComponent.prototype.forceUpdate = function(callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n```\n\n&emsp;&emsp;我们最关心的`setState`方法，其实什么也没做，只是调用了一个`updater.enqueueSetState`方法。而这个方法具体实现，是在React各个包中实现，这个方法的使用，将在后续`react-dom`包中进行讲述，","slug":"react/reactCode-react-1","published":1,"updated":"2020-06-11T01:43:32.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhxz001t9r2vxz1ynyjz","content":"<p>&emsp;&emsp;react包基础概念以及React包的两个核心api阅读。阅读React包的源码版本为<strong>16.8.6</strong>。<br><a id=\"more\"></a></p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"react包\"><a href=\"#react包\" class=\"headerlink\" title=\"react包\"></a>react包</h3><p>&emsp;&emsp;react包的本质上是建立一个react相关数据类型的抽象屏障，它创建了一系列<strong>符合react渲染调度</strong>的数据结构，在各个react相关平台(dom,native,render)上进行渲染调度。</p>\n<p>&emsp;&emsp;在阅读源码前，我一度认为诸如<code>createElement</code>和<code>Component</code>相关包，会有一系列复杂诸如生命周期，组件更新，setState等复杂的逻辑，实际上react包在做的是生成符合规范的数据结构，对特定数据进行打标(标志数据类型)，react包当中最复杂的一个js文件就是<code>ReactChildren.js</code>文件，中途进行了对应的递归数组展开和到contextPour中拿取一系列数据。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码   |    react抽象层输出数据    |      多端适配渲染</span><br><span class=\"line\"></span><br><span class=\"line\">                               -&gt; 服务端渲染     -&gt; 服务端静态html文件</span><br><span class=\"line\">code  -&gt;  react  -&gt;  reactType -&gt; react-dom    -&gt; html</span><br><span class=\"line\">                               -&gt; react-native -&gt; 移动端</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"jsx与babel\"><a href=\"#jsx与babel\" class=\"headerlink\" title=\"jsx与babel\"></a>jsx与babel</h3><p>&emsp;&emsp;jsx是react框架的精髓，jsx允许以js的方式来书写html和css，使得react的dom更新熏染的方式真正活起来。jsx实质是createElement的语法糖，也是React当中使用最多的api。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> Box = <span class=\"hljs-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"box\"</span> <span class=\"hljs-attr\">data-num</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>123<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> ContentBox = <span class=\"hljs-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Box</span> /&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> Box = React.createElement(<span class=\"hljs-string\">\"div\"</span>, &#123;</span><br><span class=\"line\">  id: <span class=\"hljs-string\">\"box\"</span>,</span><br><span class=\"line\">  <span class=\"hljs-string\">\"data-num\"</span>: <span class=\"hljs-string\">\"3\"</span></span><br><span class=\"line\">&#125;, <span class=\"hljs-string\">\"123\"</span>);</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> ContentBox = React.createElement(Box, <span class=\"hljs-literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，在编译过程中，如果是html自身存在的元素，createElement的第一个参数将为一个html标签名的<strong>字符串</strong>，而如果是自带的组件，则为变量名。因此为了方便编译区分，自定义组件变量名规定为<strong>大写</strong>。</p>\n<p></p><h2 id=\"react\">React入口与分层</h2><br>&emsp;&emsp;我们可以从package.json的main文件入口开始，来找寻React包的入口文件。<p></p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// package.json</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// index.js</span></span><br><span class=\"line\"><span class=\"hljs-meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> React = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./src/React'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> decide on the top-level export form.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// This is hacky but makes it work with both Rollup and Jest.</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">module</span>.exports = React.default || React;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;确定主文件入口为React.js后，来简单看一下react包的文件目录结构。<br><img src=\"/blog/public/imgs/reactCode/reactCode1-1.jpg\" alt=\"react包目录\"></p>\n<p>&emsp;&emsp;react包就是以各个api为js文件，然后React.js为主文件汇总的暴露的一个总分式文件结构。忽略掉引入文件以及dev模型的判断语句，React.js就是一个很简单的<code>对象-api</code>结构。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// __DEV__ 为是否打开dev模式</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> React = &#123;</span><br><span class=\"line\">  Children: &#123;</span><br><span class=\"line\">    map,</span><br><span class=\"line\">    forEach,</span><br><span class=\"line\">    count,</span><br><span class=\"line\">    toArray,</span><br><span class=\"line\">    only,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  createRef,</span><br><span class=\"line\">  Component,</span><br><span class=\"line\">  PureComponent,</span><br><span class=\"line\">  createContext,</span><br><span class=\"line\">  forwardRef,</span><br><span class=\"line\">  lazy,</span><br><span class=\"line\">  memo,</span><br><span class=\"line\">  useCallback,</span><br><span class=\"line\">  useContext,</span><br><span class=\"line\">  useEffect,</span><br><span class=\"line\">  useImperativeHandle,</span><br><span class=\"line\">  useDebugValue,</span><br><span class=\"line\">  useLayoutEffect,</span><br><span class=\"line\">  useMemo,</span><br><span class=\"line\">  useReducer,</span><br><span class=\"line\">  useRef,</span><br><span class=\"line\">  useState,</span><br><span class=\"line\">  Fragment: REACT_FRAGMENT_TYPE,</span><br><span class=\"line\">  Profiler: REACT_PROFILER_TYPE,</span><br><span class=\"line\">  StrictMode: REACT_STRICT_MODE_TYPE,</span><br><span class=\"line\">  Suspense: REACT_SUSPENSE_TYPE,</span><br><span class=\"line\">  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,</span><br><span class=\"line\">  createElement: __DEV__ ? createElementWithValidation : createElement,</span><br><span class=\"line\">  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class=\"line\">  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class=\"line\">  isValidElement: isValidElement,</span><br><span class=\"line\">  version: ReactVersion,</span><br><span class=\"line\">  unstable_withSuspenseConfig: withSuspenseConfig,</span><br><span class=\"line\">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> React;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;React当中所有存在的api，都存在于此React对象当中。</p>\n<h2 id=\"react-core-api\"><a href=\"#react-core-api\" class=\"headerlink\" title=\"react-core-api\"></a>react-core-api</h2><p>&emsp;&emsp;上文刚刚分析过<code>jsx</code>的本质其实就是<code>React.createElement</code>的语法糖。因此react当中我们最常使用的api实质上是createElement和classComponent模式下去<code>extends</code>的React.Component。</p>\n<p>&emsp;&emsp;在我看源码之前，我本也以为这两个api的代码量会非常庞大，涉及到及其复杂的调度逻辑。其实这两个文件代码平均下来每个文件不过百来行。去掉注释和<strong>dev</strong>相关的一些异常输出处理，核心的逻辑不过50行。这两个api，实质上更多的是去创建定义一个<code>Reactly</code>的数据结构。这份数据结构，能够作为一个起点，来供<code>react-dom</code>以及<code>react-native</code>去在不同环境下拆分和使用。</p>\n<h3 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h3><p>&emsp;&emsp;根据<code>React.js</code>的文件引用，我们可以很快找到<code>createElement</code>的api在同级目录的<code>ReactElement.js</code>下。我们来看一下去掉<code>dev</code>调试逻辑后，<code>createElement</code>部分的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** </span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * type 标签类型</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * config 标签属性对象</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * children 除了前两个之外剩下的都为 children，创建element的子节点</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>(<span class=\"hljs-params\">type, config, children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> propName;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 1.处理config属性</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> props = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> key = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> ref = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> self = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> source = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 如果存在element的属性对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (config != <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// ref和key格式检查</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"hljs-string\">''</span> + config.key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    self = config.__self === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-literal\">null</span> : config.__self;</span><br><span class=\"line\">    source = config.__source === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-literal\">null</span> : config.__source;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Remaining properties are added to a new props object</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// 从config上拷贝一份数据到props对象上面</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">for</span> (propName <span class=\"hljs-keyword\">in</span> config) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (</span><br><span class=\"line\">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class=\"line\">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        props[propName] = config[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 2. 处理 children， 小于1直接等于，否则复制到数组上</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> childrenLength = <span class=\"hljs-built_in\">arguments</span>.length - <span class=\"hljs-number\">2</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (childrenLength === <span class=\"hljs-number\">1</span>) &#123;</span><br><span class=\"line\">    props.children = children;</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (childrenLength &gt; <span class=\"hljs-number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> childArray = <span class=\"hljs-built_in\">Array</span>(childrenLength);</span><br><span class=\"line\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class=\"line\">      childArray[i] = <span class=\"hljs-built_in\">arguments</span>[i + <span class=\"hljs-number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.children = childArray;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// Resolve default props</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">for</span> (propName <span class=\"hljs-keyword\">in</span> defaultProps) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (props[propName] === <span class=\"hljs-literal\">undefined</span>) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> ReactElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    key,</span><br><span class=\"line\">    ref,</span><br><span class=\"line\">    self,</span><br><span class=\"line\">    source,</span><br><span class=\"line\">    ReactCurrentOwner.current,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>createElement</code>就做了很简单的两件事，我在注释中都有标注出来：</p>\n<ol>\n<li>把config(标签属性定义)数据，移植到prop对象上。在这过程中对<code>key/ref/defualtProps</code>等一些特殊属性做了一个合法以及赋值的处理。</li>\n<li>处理了一下children，把入参的children转换成数组，赋值到props上。最后调用了<code>ReactElement</code>函数。</li>\n</ol>\n<p>&emsp;&emsp;<code>ReactElement</code>函数就更简单了，它直接返回一个打了标的<code>react</code>对象。其中<code>self/source</code>的概念都是用于<code>dev</code>状态下的调试。无需去关心。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> ReactElement = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> element = &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class=\"line\">    $$<span class=\"hljs-keyword\">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// Built-in properties that belong on the element</span></span><br><span class=\"line\">    type: type,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// Record the component responsible for creating this element.</span></span><br><span class=\"line\">    _owner: owner,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，我们写的<code>jsx</code>代码，最终就是转换为这样一份对象数据。这份对象数据作为一个起点，作用在react各个渲染平台上<code>dom/native/server</code>，去实现各自的渲染逻辑。</p>\n<h3 id=\"React-Component\"><a href=\"#React-Component\" class=\"headerlink\" title=\"React.Component\"></a>React.Component</h3><p>&emsp;&emsp;<code>Component</code>代码逻辑在<code>React.js</code>同目录下的<code>ReactBaseClasses.js</code>文件中。<code>Component</code>的代码更简单，就是初始化了一个<code>Component</code>实例，在原型上绑定了常用的一些方法。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Component</span>(<span class=\"hljs-params\">props, context, updater</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.props = props;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.context = context;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// If a component has string refs, we will assign a different object later.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.refs = emptyObject;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// We initialize the default updater but the real one gets injected by the</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// renderer.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.setState = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">partialState, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.updater.enqueueSetState(<span class=\"hljs-keyword\">this</span>, partialState, callback, <span class=\"hljs-string\">'setState'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">this</span>.updater.enqueueForceUpdate(<span class=\"hljs-keyword\">this</span>, callback, <span class=\"hljs-string\">'forceUpdate'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们最关心的<code>setState</code>方法，其实什么也没做，只是调用了一个<code>updater.enqueueSetState</code>方法。而这个方法具体实现，是在React各个包中实现，这个方法的使用，将在后续<code>react-dom</code>包中进行讲述，</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;react包基础概念以及React包的两个核心api阅读。阅读React包的源码版本为<strong>16.8.6</strong>。<br></p>","more":"</p>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><h3 id=\"react包\"><a href=\"#react包\" class=\"headerlink\" title=\"react包\"></a>react包</h3><p>&emsp;&emsp;react包的本质上是建立一个react相关数据类型的抽象屏障，它创建了一系列<strong>符合react渲染调度</strong>的数据结构，在各个react相关平台(dom,native,render)上进行渲染调度。</p>\n<p>&emsp;&emsp;在阅读源码前，我一度认为诸如<code>createElement</code>和<code>Component</code>相关包，会有一系列复杂诸如生命周期，组件更新，setState等复杂的逻辑，实际上react包在做的是生成符合规范的数据结构，对特定数据进行打标(标志数据类型)，react包当中最复杂的一个js文件就是<code>ReactChildren.js</code>文件，中途进行了对应的递归数组展开和到contextPour中拿取一系列数据。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码   |    react抽象层输出数据    |      多端适配渲染</span><br><span class=\"line\"></span><br><span class=\"line\">                               -&gt; 服务端渲染     -&gt; 服务端静态html文件</span><br><span class=\"line\">code  -&gt;  react  -&gt;  reactType -&gt; react-dom    -&gt; html</span><br><span class=\"line\">                               -&gt; react-native -&gt; 移动端</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"jsx与babel\"><a href=\"#jsx与babel\" class=\"headerlink\" title=\"jsx与babel\"></a>jsx与babel</h3><p>&emsp;&emsp;jsx是react框架的精髓，jsx允许以js的方式来书写html和css，使得react的dom更新熏染的方式真正活起来。jsx实质是createElement的语法糖，也是React当中使用最多的api。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Box = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"box\"</span> <span class=\"attr\">data-num</span>=<span class=\"string\">\"3\"</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ContentBox = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Box</span> /&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Box = React.createElement(<span class=\"string\">\"div\"</span>, &#123;</span><br><span class=\"line\">  id: <span class=\"string\">\"box\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"data-num\"</span>: <span class=\"string\">\"3\"</span></span><br><span class=\"line\">&#125;, <span class=\"string\">\"123\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ContentBox = React.createElement(Box, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，在编译过程中，如果是html自身存在的元素，createElement的第一个参数将为一个html标签名的<strong>字符串</strong>，而如果是自带的组件，则为变量名。因此为了方便编译区分，自定义组件变量名规定为<strong>大写</strong>。</p>\n<p></p><h2 id=\"react\">React入口与分层</h2><br>&emsp;&emsp;我们可以从package.json的main文件入口开始，来找寻React包的入口文件。<p></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\"><span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'./src/React'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> decide on the top-level export form.</span></span><br><span class=\"line\"><span class=\"comment\">// This is hacky but makes it work with both Rollup and Jest.</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = React.default || React;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;确定主文件入口为React.js后，来简单看一下react包的文件目录结构。<br><img src=\"/blog/public/imgs/reactCode/reactCode1-1.jpg\" alt=\"react包目录\"></p>\n<p>&emsp;&emsp;react包就是以各个api为js文件，然后React.js为主文件汇总的暴露的一个总分式文件结构。忽略掉引入文件以及dev模型的判断语句，React.js就是一个很简单的<code>对象-api</code>结构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// __DEV__ 为是否打开dev模式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> React = &#123;</span><br><span class=\"line\">  Children: &#123;</span><br><span class=\"line\">    map,</span><br><span class=\"line\">    forEach,</span><br><span class=\"line\">    count,</span><br><span class=\"line\">    toArray,</span><br><span class=\"line\">    only,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  createRef,</span><br><span class=\"line\">  Component,</span><br><span class=\"line\">  PureComponent,</span><br><span class=\"line\">  createContext,</span><br><span class=\"line\">  forwardRef,</span><br><span class=\"line\">  lazy,</span><br><span class=\"line\">  memo,</span><br><span class=\"line\">  useCallback,</span><br><span class=\"line\">  useContext,</span><br><span class=\"line\">  useEffect,</span><br><span class=\"line\">  useImperativeHandle,</span><br><span class=\"line\">  useDebugValue,</span><br><span class=\"line\">  useLayoutEffect,</span><br><span class=\"line\">  useMemo,</span><br><span class=\"line\">  useReducer,</span><br><span class=\"line\">  useRef,</span><br><span class=\"line\">  useState,</span><br><span class=\"line\">  Fragment: REACT_FRAGMENT_TYPE,</span><br><span class=\"line\">  Profiler: REACT_PROFILER_TYPE,</span><br><span class=\"line\">  StrictMode: REACT_STRICT_MODE_TYPE,</span><br><span class=\"line\">  Suspense: REACT_SUSPENSE_TYPE,</span><br><span class=\"line\">  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,</span><br><span class=\"line\">  createElement: __DEV__ ? createElementWithValidation : createElement,</span><br><span class=\"line\">  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class=\"line\">  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class=\"line\">  isValidElement: isValidElement,</span><br><span class=\"line\">  version: ReactVersion,</span><br><span class=\"line\">  unstable_withSuspenseConfig: withSuspenseConfig,</span><br><span class=\"line\">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> React;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;React当中所有存在的api，都存在于此React对象当中。</p>\n<h2 id=\"react-core-api\"><a href=\"#react-core-api\" class=\"headerlink\" title=\"react-core-api\"></a>react-core-api</h2><p>&emsp;&emsp;上文刚刚分析过<code>jsx</code>的本质其实就是<code>React.createElement</code>的语法糖。因此react当中我们最常使用的api实质上是createElement和classComponent模式下去<code>extends</code>的React.Component。</p>\n<p>&emsp;&emsp;在我看源码之前，我本也以为这两个api的代码量会非常庞大，涉及到及其复杂的调度逻辑。其实这两个文件代码平均下来每个文件不过百来行。去掉注释和<strong>dev</strong>相关的一些异常输出处理，核心的逻辑不过50行。这两个api，实质上更多的是去创建定义一个<code>Reactly</code>的数据结构。这份数据结构，能够作为一个起点，来供<code>react-dom</code>以及<code>react-native</code>去在不同环境下拆分和使用。</p>\n<h3 id=\"ReactElement\"><a href=\"#ReactElement\" class=\"headerlink\" title=\"ReactElement\"></a>ReactElement</h3><p>&emsp;&emsp;根据<code>React.js</code>的文件引用，我们可以很快找到<code>createElement</code>的api在同级目录的<code>ReactElement.js</code>下。我们来看一下去掉<code>dev</code>调试逻辑后，<code>createElement</code>部分的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * type 标签类型</span></span><br><span class=\"line\"><span class=\"comment\"> * config 标签属性对象</span></span><br><span class=\"line\"><span class=\"comment\"> * children 除了前两个之外剩下的都为 children，创建element的子节点</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">type, config, children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> propName;</span><br><span class=\"line\">  <span class=\"comment\">// 1.处理config属性</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> props = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> key = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ref = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> self = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> source = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 如果存在element的属性对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ref和key格式检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidRef(config)) &#123;</span><br><span class=\"line\">      ref = config.ref;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasValidKey(config)) &#123;</span><br><span class=\"line\">      key = <span class=\"string\">''</span> + config.key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    self = config.__self === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : config.__self;</span><br><span class=\"line\">    source = config.__source === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : config.__source;</span><br><span class=\"line\">    <span class=\"comment\">// Remaining properties are added to a new props object</span></span><br><span class=\"line\">    <span class=\"comment\">// 从config上拷贝一份数据到props对象上面</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> config) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class=\"line\">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        props[propName] = config[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 2. 处理 children， 小于1直接等于，否则复制到数组上</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> childrenLength = <span class=\"built_in\">arguments</span>.length - <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childrenLength === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    props.children = children;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenLength &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> childArray = <span class=\"built_in\">Array</span>(childrenLength);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class=\"line\">      childArray[i] = <span class=\"built_in\">arguments</span>[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.children = childArray;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Resolve default props</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> defaultProps = type.defaultProps;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (propName <span class=\"keyword\">in</span> defaultProps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (props[propName] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        props[propName] = defaultProps[propName];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> ReactElement(</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    key,</span><br><span class=\"line\">    ref,</span><br><span class=\"line\">    self,</span><br><span class=\"line\">    source,</span><br><span class=\"line\">    ReactCurrentOwner.current,</span><br><span class=\"line\">    props,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>createElement</code>就做了很简单的两件事，我在注释中都有标注出来：</p>\n<ol>\n<li>把config(标签属性定义)数据，移植到prop对象上。在这过程中对<code>key/ref/defualtProps</code>等一些特殊属性做了一个合法以及赋值的处理。</li>\n<li>处理了一下children，把入参的children转换成数组，赋值到props上。最后调用了<code>ReactElement</code>函数。</li>\n</ol>\n<p>&emsp;&emsp;<code>ReactElement</code>函数就更简单了，它直接返回一个打了标的<code>react</code>对象。其中<code>self/source</code>的概念都是用于<code>dev</code>状态下的调试。无需去关心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ReactElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class=\"line\">    $$<span class=\"keyword\">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Built-in properties that belong on the element</span></span><br><span class=\"line\">    type: type,</span><br><span class=\"line\">    key: key,</span><br><span class=\"line\">    ref: ref,</span><br><span class=\"line\">    props: props,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Record the component responsible for creating this element.</span></span><br><span class=\"line\">    _owner: owner,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以看到，我们写的<code>jsx</code>代码，最终就是转换为这样一份对象数据。这份对象数据作为一个起点，作用在react各个渲染平台上<code>dom/native/server</code>，去实现各自的渲染逻辑。</p>\n<h3 id=\"React-Component\"><a href=\"#React-Component\" class=\"headerlink\" title=\"React.Component\"></a>React.Component</h3><p>&emsp;&emsp;<code>Component</code>代码逻辑在<code>React.js</code>同目录下的<code>ReactBaseClasses.js</code>文件中。<code>Component</code>的代码更简单，就是初始化了一个<code>Component</code>实例，在原型上绑定了常用的一些方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Component</span>(<span class=\"params\">props, context, updater</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.props = props;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.context = context;</span><br><span class=\"line\">  <span class=\"comment\">// If a component has string refs, we will assign a different object later.</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.refs = emptyObject;</span><br><span class=\"line\">  <span class=\"comment\">// We initialize the default updater but the real one gets injected by the</span></span><br><span class=\"line\">  <span class=\"comment\">// renderer.</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">partialState, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.updater.enqueueSetState(<span class=\"keyword\">this</span>, partialState, callback, <span class=\"string\">'setState'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.updater.enqueueForceUpdate(<span class=\"keyword\">this</span>, callback, <span class=\"string\">'forceUpdate'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们最关心的<code>setState</code>方法，其实什么也没做，只是调用了一个<code>updater.enqueueSetState</code>方法。而这个方法具体实现，是在React各个包中实现，这个方法的使用，将在后续<code>react-dom</code>包中进行讲述，</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-2.1","date":"2019-07-04T11:40:00.000Z","_content":"## 第二章第一节 数据抽象引导\n&emsp;&emsp;现在到了数学抽象中最关键的一步，让我们忘记这些符号所表示的对象，不应该在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表什么东西。\n<!--more-->\n&emsp;&emsp;程序本质是对现实的模拟，在遇到复杂的现实情况时，**简单的数据类型**将不能再满足我们对程序实现的需要。我们需要复杂的**复合数据**来满足各种各样的程序设计。\n\n&emsp;&emsp;来举一个简单的例子，现在需要定义一个过程，接受`a,b,x,y`四个参数，返回`ax + by`的值。根据过程我们能够很轻松的定义出来函数。`linear-combination`。\n```scheme\n(define (linear-combination a b x y)\n    (+ (* a b) (* b y))\n)\n```\n&emsp;&emsp;此时存在问题，`linear-combination`函数只能适配正常简单数字数据结构的入参，当入参为有理数，复数，甚至多项式的时候，这个函数就不能运行了。我们需要做的，就是在命令式的`+`和`*`上面做一层**函数抽象**，能够让`linear-combination`函数适配各种复杂的数据结构，达到`ax + by`的目的。函数修改如下：\n```scheme\n(define (linear-combination a b x y)\n    (add (mul a b) (mul b y))\n)\n```\n&emsp;&emsp;此时的`add`和`mul`不是简单的`+`和`*`，而是针对不同的数据结构进行不同的抽象的操作，这就是这一章的核心思想，如何在复杂的数据结构之中建立适当的**抽象屏障**，来设计出合健壮的程序。\n\n&emsp;&emsp;在第一节数据抽象导引中，将用有理数作为例子，通过实现一系列的有理数的操作，来学习如何在程序中建立合适的**抽象屏障**。\n## 2.1数据抽象导引\n&emsp;&emsp;数据抽象的基本思想就是构造出一段程序，在使用时就像你在**操作**这复合数据一样。\n\n&emsp;&emsp;我们来看有理数的例子。我们需要定义一个变量来存放有理数，再定义一个`make-rat`的函数能够生成一个有理数，之后通过`numer`来获取有理数的分子，`denom`来获取有理数的分母。就像这样：\n```scheme\n;; 定义 1/2\n(define rational (make-rat 1 2))\n;; 拿出分子1\n(numer rational)\n;; 拿出分母2\n(denom rational)\n```\n&emsp;&emsp;实际上在`scheme`中，程序自带一种名为`序对`的数据结构，能够像**粘合**一样，把两个数绑定在一起。使用`(cons a b)`来把a和b粘合到一起，`car`和`cdr`来取出第一项和第二项。\n```scheme\n(define x (cons 1 2))\n(display x) ;; (1 . 2)\n(car x) ;; 1\n(cdr x) ;; 2\n```\n&emsp;&emsp;利用序对我们可以非常简单的写出来`make-rat`，`numer`和`denom`。我们还能定义一个打印有理数的方法`display-rat`。\n```scheme\n(define (make-rat a b)\n    (cons a b)\n)\n(define (numer rational) (car rational))\n(define (denom rational) (cdr rational))\n(define (display-rat rational)\n  (newline)\n  (display (numer rational))\n  (display \"/\")\n  (display (denom rational))\n)\n```\n&emsp;&emsp;现在我们可以的结合有理数的例子简单领悟一下抽象屏障的概念。\n```\n-  使用有理数的程序 -\n-  操作有理数的方法(如display-rat) - \n-  有理数本身的数据结构(make-rat) -\n-  作为序对的有理数(cons car cdr) - \n```\n&emsp;&emsp;作为有理数程序的使用者，我们无需关心有理数的数据组织结构，只需要使用生成有理数的`make-rat`，以及相应提供的操作有理数的方法，来去实现我们程序所需要的。就像JS当中的数组和对象，我们使用字面量或者构造函数生成数组对象，再使用数组对象prototype上面的各种方法来操作这些数据结构来实现我们的程序，而不用去关心这些底层的内容。\n&emsp;&emsp;现在我们来关心一下底层`cons`方法以及对应的`car,cdr`的实现。\n```scheme\n(define (cons x y)\n    (define (dispatch m)\n        (cond ((= m 0) x)\n              ((= m 1) y)\n              (else (error \"Argument not 0 or 1 -- cons\"))\n        )\n    )\n    dispatch\n)\n```\n&emsp;&emsp;这里我们定义`cons`函数，它返回一个名为`dispatch`的函数过程。`dispatch`接受一个参数，当参数为0时返回x，参数为1时返回y。现在我们就可以轻松的定义出来`car`和`cdr`。\n```scheme\n;; cons函数返回的为dispatch，即这里cons-num就是dispatch\n;; 我们只需要在取数内部取出即可\n(define (car cons-num) (cons-num 0))\n(define (cdr cons-num) (cons-num 1))\n```\n&emsp;&emsp;按照这个逻辑思路，你可以定义出关联三个数的`cons-three`，关联四个数的`cons-four`。正如这章开头所说的，**复杂数据**本质是**过程**的高级抽象。\n&emsp;&emsp;最后来看课后的习题2.4来组合一下思路，使用代还模型证明一种新的`cons`方法可用，并根据`car`实现`cdr`。\n```scheme\n(define (cons x y)\n    (lambda (m) (m x y))\n)\n(define (car z)\n    (z (lambda (p q) p))\n)\n```\n&emsp;&emsp;这里的`cons`方法同样返回一个`lambda`过程，这个`lambda`接受一个函数，接受后直接传入xy参数并执行。那么我们来代换一下`car`。\n```scheme\n;; z其实就是cons返回的lambda\n(car (lambda (m) (m x y)))\n```\n&emsp;&emsp;那么car中执行执行这个函数，并传入了新的一个`lambda`方法`(lambda (p q) p)`。即直接把m代换为`(lambda (p q) p)`。\n```scheme\n;; m为(lambda (p q) p)\n(lambda (x y) x)\n```\n&emsp;&emsp;所以根据这个逻辑cdr的实现很简单。\n```scheme\n(define (car z)\n    (z (lambda (p q) q))\n)\n```\n&emsp;&emsp;课后还有一小节区间算数的内容就是同样的思路换了一种数据结构。这里就不再赘述了。可去[我的github](https://github.com/tangdingga1)上面简单看一下我选择性写的几道习题。\n\n&emsp;&emsp;这本书习题真的是多到和正文内容一样多了，工作又忙，读起来的速度是真的非常慢。但是总的来说还是有所值的。本章节阐述了核心思想，**符合数据结构**本质上都是**一段程序过程**。我们在做**复合数据结构**设计的时候，要有**抽象屏障**的概念，提供**制造复合数据**的方法以及各种**使用复合数据**的方法让调用的人不用去关心底层的内容，","source":"_posts/scip/scip(chap2-1).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-2.1\ndate: 2019/7/4 19:40:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第二章第一节 数据抽象引导\n&emsp;&emsp;现在到了数学抽象中最关键的一步，让我们忘记这些符号所表示的对象，不应该在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表什么东西。\n<!--more-->\n&emsp;&emsp;程序本质是对现实的模拟，在遇到复杂的现实情况时，**简单的数据类型**将不能再满足我们对程序实现的需要。我们需要复杂的**复合数据**来满足各种各样的程序设计。\n\n&emsp;&emsp;来举一个简单的例子，现在需要定义一个过程，接受`a,b,x,y`四个参数，返回`ax + by`的值。根据过程我们能够很轻松的定义出来函数。`linear-combination`。\n```scheme\n(define (linear-combination a b x y)\n    (+ (* a b) (* b y))\n)\n```\n&emsp;&emsp;此时存在问题，`linear-combination`函数只能适配正常简单数字数据结构的入参，当入参为有理数，复数，甚至多项式的时候，这个函数就不能运行了。我们需要做的，就是在命令式的`+`和`*`上面做一层**函数抽象**，能够让`linear-combination`函数适配各种复杂的数据结构，达到`ax + by`的目的。函数修改如下：\n```scheme\n(define (linear-combination a b x y)\n    (add (mul a b) (mul b y))\n)\n```\n&emsp;&emsp;此时的`add`和`mul`不是简单的`+`和`*`，而是针对不同的数据结构进行不同的抽象的操作，这就是这一章的核心思想，如何在复杂的数据结构之中建立适当的**抽象屏障**，来设计出合健壮的程序。\n\n&emsp;&emsp;在第一节数据抽象导引中，将用有理数作为例子，通过实现一系列的有理数的操作，来学习如何在程序中建立合适的**抽象屏障**。\n## 2.1数据抽象导引\n&emsp;&emsp;数据抽象的基本思想就是构造出一段程序，在使用时就像你在**操作**这复合数据一样。\n\n&emsp;&emsp;我们来看有理数的例子。我们需要定义一个变量来存放有理数，再定义一个`make-rat`的函数能够生成一个有理数，之后通过`numer`来获取有理数的分子，`denom`来获取有理数的分母。就像这样：\n```scheme\n;; 定义 1/2\n(define rational (make-rat 1 2))\n;; 拿出分子1\n(numer rational)\n;; 拿出分母2\n(denom rational)\n```\n&emsp;&emsp;实际上在`scheme`中，程序自带一种名为`序对`的数据结构，能够像**粘合**一样，把两个数绑定在一起。使用`(cons a b)`来把a和b粘合到一起，`car`和`cdr`来取出第一项和第二项。\n```scheme\n(define x (cons 1 2))\n(display x) ;; (1 . 2)\n(car x) ;; 1\n(cdr x) ;; 2\n```\n&emsp;&emsp;利用序对我们可以非常简单的写出来`make-rat`，`numer`和`denom`。我们还能定义一个打印有理数的方法`display-rat`。\n```scheme\n(define (make-rat a b)\n    (cons a b)\n)\n(define (numer rational) (car rational))\n(define (denom rational) (cdr rational))\n(define (display-rat rational)\n  (newline)\n  (display (numer rational))\n  (display \"/\")\n  (display (denom rational))\n)\n```\n&emsp;&emsp;现在我们可以的结合有理数的例子简单领悟一下抽象屏障的概念。\n```\n-  使用有理数的程序 -\n-  操作有理数的方法(如display-rat) - \n-  有理数本身的数据结构(make-rat) -\n-  作为序对的有理数(cons car cdr) - \n```\n&emsp;&emsp;作为有理数程序的使用者，我们无需关心有理数的数据组织结构，只需要使用生成有理数的`make-rat`，以及相应提供的操作有理数的方法，来去实现我们程序所需要的。就像JS当中的数组和对象，我们使用字面量或者构造函数生成数组对象，再使用数组对象prototype上面的各种方法来操作这些数据结构来实现我们的程序，而不用去关心这些底层的内容。\n&emsp;&emsp;现在我们来关心一下底层`cons`方法以及对应的`car,cdr`的实现。\n```scheme\n(define (cons x y)\n    (define (dispatch m)\n        (cond ((= m 0) x)\n              ((= m 1) y)\n              (else (error \"Argument not 0 or 1 -- cons\"))\n        )\n    )\n    dispatch\n)\n```\n&emsp;&emsp;这里我们定义`cons`函数，它返回一个名为`dispatch`的函数过程。`dispatch`接受一个参数，当参数为0时返回x，参数为1时返回y。现在我们就可以轻松的定义出来`car`和`cdr`。\n```scheme\n;; cons函数返回的为dispatch，即这里cons-num就是dispatch\n;; 我们只需要在取数内部取出即可\n(define (car cons-num) (cons-num 0))\n(define (cdr cons-num) (cons-num 1))\n```\n&emsp;&emsp;按照这个逻辑思路，你可以定义出关联三个数的`cons-three`，关联四个数的`cons-four`。正如这章开头所说的，**复杂数据**本质是**过程**的高级抽象。\n&emsp;&emsp;最后来看课后的习题2.4来组合一下思路，使用代还模型证明一种新的`cons`方法可用，并根据`car`实现`cdr`。\n```scheme\n(define (cons x y)\n    (lambda (m) (m x y))\n)\n(define (car z)\n    (z (lambda (p q) p))\n)\n```\n&emsp;&emsp;这里的`cons`方法同样返回一个`lambda`过程，这个`lambda`接受一个函数，接受后直接传入xy参数并执行。那么我们来代换一下`car`。\n```scheme\n;; z其实就是cons返回的lambda\n(car (lambda (m) (m x y)))\n```\n&emsp;&emsp;那么car中执行执行这个函数，并传入了新的一个`lambda`方法`(lambda (p q) p)`。即直接把m代换为`(lambda (p q) p)`。\n```scheme\n;; m为(lambda (p q) p)\n(lambda (x y) x)\n```\n&emsp;&emsp;所以根据这个逻辑cdr的实现很简单。\n```scheme\n(define (car z)\n    (z (lambda (p q) q))\n)\n```\n&emsp;&emsp;课后还有一小节区间算数的内容就是同样的思路换了一种数据结构。这里就不再赘述了。可去[我的github](https://github.com/tangdingga1)上面简单看一下我选择性写的几道习题。\n\n&emsp;&emsp;这本书习题真的是多到和正文内容一样多了，工作又忙，读起来的速度是真的非常慢。但是总的来说还是有所值的。本章节阐述了核心思想，**符合数据结构**本质上都是**一段程序过程**。我们在做**复合数据结构**设计的时候，要有**抽象屏障**的概念，提供**制造复合数据**的方法以及各种**使用复合数据**的方法让调用的人不用去关心底层的内容，","slug":"scip/scip(chap2-1)","published":1,"updated":"2020-06-11T01:43:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy0001w9r2v9umpja3m","content":"<h2 id=\"第二章第一节-数据抽象引导\"><a href=\"#第二章第一节-数据抽象引导\" class=\"headerlink\" title=\"第二章第一节 数据抽象引导\"></a>第二章第一节 数据抽象引导</h2><p>&emsp;&emsp;现在到了数学抽象中最关键的一步，让我们忘记这些符号所表示的对象，不应该在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表什么东西。<br><a id=\"more\"></a><br>&emsp;&emsp;程序本质是对现实的模拟，在遇到复杂的现实情况时，<strong>简单的数据类型</strong>将不能再满足我们对程序实现的需要。我们需要复杂的<strong>复合数据</strong>来满足各种各样的程序设计。</p>\n<p>&emsp;&emsp;来举一个简单的例子，现在需要定义一个过程，接受<code>a,b,x,y</code>四个参数，返回<code>ax + by</code>的值。根据过程我们能够很轻松的定义出来函数。<code>linear-combination</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">linear-combination</span> a b x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> a b) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> b y))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时存在问题，<code>linear-combination</code>函数只能适配正常简单数字数据结构的入参，当入参为有理数，复数，甚至多项式的时候，这个函数就不能运行了。我们需要做的，就是在命令式的<code>+</code>和<code>*</code>上面做一层<strong>函数抽象</strong>，能够让<code>linear-combination</code>函数适配各种复杂的数据结构，达到<code>ax + by</code>的目的。函数修改如下：<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">linear-combination</span> a b x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\">add</span> (<span class=\"hljs-name\">mul</span> a b) (<span class=\"hljs-name\">mul</span> b y))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时的<code>add</code>和<code>mul</code>不是简单的<code>+</code>和<code>*</code>，而是针对不同的数据结构进行不同的抽象的操作，这就是这一章的核心思想，如何在复杂的数据结构之中建立适当的<strong>抽象屏障</strong>，来设计出合健壮的程序。</p>\n<p>&emsp;&emsp;在第一节数据抽象导引中，将用有理数作为例子，通过实现一系列的有理数的操作，来学习如何在程序中建立合适的<strong>抽象屏障</strong>。</p>\n<h2 id=\"2-1数据抽象导引\"><a href=\"#2-1数据抽象导引\" class=\"headerlink\" title=\"2.1数据抽象导引\"></a>2.1数据抽象导引</h2><p>&emsp;&emsp;数据抽象的基本思想就是构造出一段程序，在使用时就像你在<strong>操作</strong>这复合数据一样。</p>\n<p>&emsp;&emsp;我们来看有理数的例子。我们需要定义一个变量来存放有理数，再定义一个<code>make-rat</code>的函数能够生成一个有理数，之后通过<code>numer</code>来获取有理数的分子，<code>denom</code>来获取有理数的分母。就像这样：<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 定义 1/2</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> rational (<span class=\"hljs-name\">make-rat</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 拿出分子1</span></span><br><span class=\"line\">(<span class=\"hljs-name\">numer</span> rational)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 拿出分母2</span></span><br><span class=\"line\">(<span class=\"hljs-name\">denom</span> rational)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上在<code>scheme</code>中，程序自带一种名为<code>序对</code>的数据结构，能够像<strong>粘合</strong>一样，把两个数绑定在一起。使用<code>(cons a b)</code>来把a和b粘合到一起，<code>car</code>和<code>cdr</code>来取出第一项和第二项。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> x) <span class=\"hljs-comment\">;; (1 . 2)</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> x) <span class=\"hljs-comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> x) <span class=\"hljs-comment\">;; 2</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;利用序对我们可以非常简单的写出来<code>make-rat</code>，<code>numer</code>和<code>denom</code>。我们还能定义一个打印有理数的方法<code>display-rat</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-rat</span> a b)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> a b)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">numer</span> rational) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> rational))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">denom</span> rational) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> rational))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">display-rat</span> rational)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">newline</span></span>)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> (<span class=\"hljs-name\">numer</span> rational))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\"/\"</span>)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> (<span class=\"hljs-name\">denom</span> rational))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们可以的结合有理数的例子简单领悟一下抽象屏障的概念。<br><figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  使用有理数的程序 -</span><br><span class=\"line\">-  操作有理数的方法(如display-rat) - </span><br><span class=\"line\">-  有理数本身的数据结构(make-rat) -</span><br><span class=\"line\">-  作为序对的有理数(cons car cdr) -</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;作为有理数程序的使用者，我们无需关心有理数的数据组织结构，只需要使用生成有理数的<code>make-rat</code>，以及相应提供的操作有理数的方法，来去实现我们程序所需要的。就像JS当中的数组和对象，我们使用字面量或者构造函数生成数组对象，再使用数组对象prototype上面的各种方法来操作这些数据结构来实现我们的程序，而不用去关心这些底层的内容。<br>&emsp;&emsp;现在我们来关心一下底层<code>cons</code>方法以及对应的<code>car,cdr</code>的实现。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">dispatch</span> m)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> m <span class=\"hljs-number\">0</span>) x)</span><br><span class=\"line\">              ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> m <span class=\"hljs-number\">1</span>) y)</span><br><span class=\"line\">              (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Argument not 0 or 1 -- cons\"</span>))</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">    dispatch</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里我们定义<code>cons</code>函数，它返回一个名为<code>dispatch</code>的函数过程。<code>dispatch</code>接受一个参数，当参数为0时返回x，参数为1时返回y。现在我们就可以轻松的定义出来<code>car</code>和<code>cdr</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; cons函数返回的为dispatch，即这里cons-num就是dispatch</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 我们只需要在取数内部取出即可</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> cons-num) (<span class=\"hljs-name\">cons-num</span> <span class=\"hljs-number\">0</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> cons-num) (<span class=\"hljs-name\">cons-num</span> <span class=\"hljs-number\">1</span>))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;按照这个逻辑思路，你可以定义出关联三个数的<code>cons-three</code>，关联四个数的<code>cons-four</code>。正如这章开头所说的，<strong>复杂数据</strong>本质是<strong>过程</strong>的高级抽象。<br>&emsp;&emsp;最后来看课后的习题2.4来组合一下思路，使用代还模型证明一种新的<code>cons</code>方法可用，并根据<code>car</code>实现<code>cdr</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (m) (<span class=\"hljs-name\">m</span> x y))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> z)</span><br><span class=\"line\">    (<span class=\"hljs-name\">z</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (p q) p))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里的<code>cons</code>方法同样返回一个<code>lambda</code>过程，这个<code>lambda</code>接受一个函数，接受后直接传入xy参数并执行。那么我们来代换一下<code>car</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; z其实就是cons返回的lambda</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (m) (<span class=\"hljs-name\">m</span> x y)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;那么car中执行执行这个函数，并传入了新的一个<code>lambda</code>方法<code>(lambda (p q) p)</code>。即直接把m代换为<code>(lambda (p q) p)</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; m为(lambda (p q) p)</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) x)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;所以根据这个逻辑cdr的实现很简单。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> z)</span><br><span class=\"line\">    (<span class=\"hljs-name\">z</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (p q) q))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;课后还有一小节区间算数的内容就是同样的思路换了一种数据结构。这里就不再赘述了。可去<a href=\"https://github.com/tangdingga1\" target=\"_blank\" rel=\"noopener\">我的github</a>上面简单看一下我选择性写的几道习题。</p>\n<p>&emsp;&emsp;这本书习题真的是多到和正文内容一样多了，工作又忙，读起来的速度是真的非常慢。但是总的来说还是有所值的。本章节阐述了核心思想，<strong>符合数据结构</strong>本质上都是<strong>一段程序过程</strong>。我们在做<strong>复合数据结构</strong>设计的时候，要有<strong>抽象屏障</strong>的概念，提供<strong>制造复合数据</strong>的方法以及各种<strong>使用复合数据</strong>的方法让调用的人不用去关心底层的内容，</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第二章第一节-数据抽象引导\"><a href=\"#第二章第一节-数据抽象引导\" class=\"headerlink\" title=\"第二章第一节 数据抽象引导\"></a>第二章第一节 数据抽象引导</h2><p>&emsp;&emsp;现在到了数学抽象中最关键的一步，让我们忘记这些符号所表示的对象，不应该在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表什么东西。<br></p>","more":"<br>&emsp;&emsp;程序本质是对现实的模拟，在遇到复杂的现实情况时，<strong>简单的数据类型</strong>将不能再满足我们对程序实现的需要。我们需要复杂的<strong>复合数据</strong>来满足各种各样的程序设计。</p>\n<p>&emsp;&emsp;来举一个简单的例子，现在需要定义一个过程，接受<code>a,b,x,y</code>四个参数，返回<code>ax + by</code>的值。根据过程我们能够很轻松的定义出来函数。<code>linear-combination</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">linear-combination</span> a b x y)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> a b) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> b y))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时存在问题，<code>linear-combination</code>函数只能适配正常简单数字数据结构的入参，当入参为有理数，复数，甚至多项式的时候，这个函数就不能运行了。我们需要做的，就是在命令式的<code>+</code>和<code>*</code>上面做一层<strong>函数抽象</strong>，能够让<code>linear-combination</code>函数适配各种复杂的数据结构，达到<code>ax + by</code>的目的。函数修改如下：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">linear-combination</span> a b x y)</span><br><span class=\"line\">    (<span class=\"name\">add</span> (<span class=\"name\">mul</span> a b) (<span class=\"name\">mul</span> b y))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时的<code>add</code>和<code>mul</code>不是简单的<code>+</code>和<code>*</code>，而是针对不同的数据结构进行不同的抽象的操作，这就是这一章的核心思想，如何在复杂的数据结构之中建立适当的<strong>抽象屏障</strong>，来设计出合健壮的程序。</p>\n<p>&emsp;&emsp;在第一节数据抽象导引中，将用有理数作为例子，通过实现一系列的有理数的操作，来学习如何在程序中建立合适的<strong>抽象屏障</strong>。</p>\n<h2 id=\"2-1数据抽象导引\"><a href=\"#2-1数据抽象导引\" class=\"headerlink\" title=\"2.1数据抽象导引\"></a>2.1数据抽象导引</h2><p>&emsp;&emsp;数据抽象的基本思想就是构造出一段程序，在使用时就像你在<strong>操作</strong>这复合数据一样。</p>\n<p>&emsp;&emsp;我们来看有理数的例子。我们需要定义一个变量来存放有理数，再定义一个<code>make-rat</code>的函数能够生成一个有理数，之后通过<code>numer</code>来获取有理数的分子，<code>denom</code>来获取有理数的分母。就像这样：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 定义 1/2</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> rational (<span class=\"name\">make-rat</span> <span class=\"number\">1</span> <span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"comment\">;; 拿出分子1</span></span><br><span class=\"line\">(<span class=\"name\">numer</span> rational)</span><br><span class=\"line\"><span class=\"comment\">;; 拿出分母2</span></span><br><span class=\"line\">(<span class=\"name\">denom</span> rational)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上在<code>scheme</code>中，程序自带一种名为<code>序对</code>的数据结构，能够像<strong>粘合</strong>一样，把两个数绑定在一起。使用<code>(cons a b)</code>来把a和b粘合到一起，<code>car</code>和<code>cdr</code>来取出第一项和第二项。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> x (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">display</span></span> x) <span class=\"comment\">;; (1 . 2)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> x) <span class=\"comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x) <span class=\"comment\">;; 2</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;利用序对我们可以非常简单的写出来<code>make-rat</code>，<code>numer</code>和<code>denom</code>。我们还能定义一个打印有理数的方法<code>display-rat</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-rat</span> a b)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> a b)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">numer</span> rational) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> rational))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">denom</span> rational) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> rational))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">display-rat</span> rational)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">newline</span></span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">display</span></span> (<span class=\"name\">numer</span> rational))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">display</span></span> (<span class=\"name\">denom</span> rational))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们可以的结合有理数的例子简单领悟一下抽象屏障的概念。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  使用有理数的程序 -</span><br><span class=\"line\">-  操作有理数的方法(如display-rat) - </span><br><span class=\"line\">-  有理数本身的数据结构(make-rat) -</span><br><span class=\"line\">-  作为序对的有理数(cons car cdr) -</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;作为有理数程序的使用者，我们无需关心有理数的数据组织结构，只需要使用生成有理数的<code>make-rat</code>，以及相应提供的操作有理数的方法，来去实现我们程序所需要的。就像JS当中的数组和对象，我们使用字面量或者构造函数生成数组对象，再使用数组对象prototype上面的各种方法来操作这些数据结构来实现我们的程序，而不用去关心这些底层的内容。<br>&emsp;&emsp;现在我们来关心一下底层<code>cons</code>方法以及对应的<code>car,cdr</code>的实现。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x y)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dispatch</span> m)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> m <span class=\"number\">0</span>) x)</span><br><span class=\"line\">              ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> m <span class=\"number\">1</span>) y)</span><br><span class=\"line\">              (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Argument not 0 or 1 -- cons\"</span>))</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">    dispatch</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里我们定义<code>cons</code>函数，它返回一个名为<code>dispatch</code>的函数过程。<code>dispatch</code>接受一个参数，当参数为0时返回x，参数为1时返回y。现在我们就可以轻松的定义出来<code>car</code>和<code>cdr</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; cons函数返回的为dispatch，即这里cons-num就是dispatch</span></span><br><span class=\"line\"><span class=\"comment\">;; 我们只需要在取数内部取出即可</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> cons-num) (<span class=\"name\">cons-num</span> <span class=\"number\">0</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> cons-num) (<span class=\"name\">cons-num</span> <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;按照这个逻辑思路，你可以定义出关联三个数的<code>cons-three</code>，关联四个数的<code>cons-four</code>。正如这章开头所说的，<strong>复杂数据</strong>本质是<strong>过程</strong>的高级抽象。<br>&emsp;&emsp;最后来看课后的习题2.4来组合一下思路，使用代还模型证明一种新的<code>cons</code>方法可用，并根据<code>car</code>实现<code>cdr</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x y)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (m) (<span class=\"name\">m</span> x y))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z)</span><br><span class=\"line\">    (<span class=\"name\">z</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (p q) p))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里的<code>cons</code>方法同样返回一个<code>lambda</code>过程，这个<code>lambda</code>接受一个函数，接受后直接传入xy参数并执行。那么我们来代换一下<code>car</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; z其实就是cons返回的lambda</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (m) (<span class=\"name\">m</span> x y)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;那么car中执行执行这个函数，并传入了新的一个<code>lambda</code>方法<code>(lambda (p q) p)</code>。即直接把m代换为<code>(lambda (p q) p)</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; m为(lambda (p q) p)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) x)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;所以根据这个逻辑cdr的实现很简单。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z)</span><br><span class=\"line\">    (<span class=\"name\">z</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (p q) q))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;课后还有一小节区间算数的内容就是同样的思路换了一种数据结构。这里就不再赘述了。可去<a href=\"https://github.com/tangdingga1\" target=\"_blank\" rel=\"noopener\">我的github</a>上面简单看一下我选择性写的几道习题。</p>\n<p>&emsp;&emsp;这本书习题真的是多到和正文内容一样多了，工作又忙，读起来的速度是真的非常慢。但是总的来说还是有所值的。本章节阐述了核心思想，<strong>符合数据结构</strong>本质上都是<strong>一段程序过程</strong>。我们在做<strong>复合数据结构</strong>设计的时候，要有<strong>抽象屏障</strong>的概念，提供<strong>制造复合数据</strong>的方法以及各种<strong>使用复合数据</strong>的方法让调用的人不用去关心底层的内容，</p>"},{"title":"react源码阅读3 update与updateQueue","date":"2020-04-01T06:00:00.000Z","_content":"react-dom后续updateContainer部分。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n&emsp;&emsp;在<a href=\"../reactCode-react-2-2020-03-22/\" target=\"_blank\">上一章节中</a>我们看到了`react-dom`中`render`函数的逻辑是给传入的React组件创建了一个`fiberRoot`对象，用于标识它是整个应用的起点，上面拥有很多应用更新相关的表示符。然后创建对应的`fiber`给`fiberRoot`节点，`fiber`对象是每一个`ReactElement`都拥有的节点，它标识了更新时间的一些信息，props和state的一些信息，以及相关联的节点信息。`ReactElement`彼此是通过一个单向链表的数据结构联系在一起的。\n\n&emsp;&emsp;这一章我们接着`legacyRenderSubtreeIntoContainer`函数创建完`fiber`相关对象的部分，查看接下来`updateContainer`相关的逻辑。我们先回顾一下这部分的代码。\n\n```javascript\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: DOMContainer,\n  // 是否复用dom节点，服务端渲染调用\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // ...省略创建fiber节点相关部分逻辑\n  // 初次使用render不存在root节点\n  if (!root) {\n    // ...省略创建fiber节点相关部分逻辑\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n    // 有无callback 逻辑同上\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n```\n\n&emsp;&emsp;我们先看`callback`部分的处理，在`render`函数中`callback`是传入的第三个参数，根据`react文档`，该回调将在组件被渲染或更新之后被执行，并且在非箭头函数的情况下，该回调的this指向`render`渲染的那个组件。我们先来回顾下这个入参的使用方式。\n\n```javascript\nconst instance = render(\n  <Hello text=\"123\" />,\n  document.getElementById(\"page\"),\n  function () { console.log(this) }\n);\n\nconsole.log(instance);\n\n/*\nthis === instance === Hello\nHello {\n  isMounted: (...)\n  replaceState: (...)\n  props: {text: \"123\"}\n  context: {}\n  refs: {}\n  updater: {isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ}\n  _reactInternalFiber: FiberNode {tag: 1, key: null, stateNode: Hello, elementType: ƒ, type: ƒ, …}\n  _reactInternalInstance: {_processChildContext: ƒ}\n  state: null\n  __proto__: Component\n}\n*/\n```\n\n&emsp;&emsp;在上述代码中使用`render`函数时，传入了一个匿名函数作为`render`的第三个入参，并打印了`this`，然后将`render`函数的返回值赋予了`instance`变量并打印出来。我们可以看到，输出的是一个对象信息，其实使用过`react`测试相关诸如`react-test-renderer`等框架的，应该对这个`instance`比较熟悉。它标志了一个由`fiberRoot`开始的完整的组件信息。\n\n&emsp;&emsp;现在回到源码，我们可以看到我们在调用`render`时候，`callback`的this和`render`返回的组件`instance`信息都是由`getPublicRootInstance`创建的。`react`将我们传入的`callback`赋值给了变量`originalCallback`，然后声明一个新的`callback`，新的`callback`创建了一个`instance`，然后用`call`让`originalCallback`的this指向它，把它传入到了`updateContainer`的`callback`参数中。\n\n&emsp;&emsp;至于`getPublicRootInstance`如何创建一个`Instance`的细节代码与主流程牵扯不大，这边就跳过。只要知道该函数根据`fiberRoot`提供了一个`Instance`信息对象即可。接着我们可以看到，无论是否是初次使用`render`函数（初次调用render函数不存在root节点），`legacyRenderSubtreeIntoContainer`都调用了`updateContainer`方法，区别就是初次使用`render`的时候，`updateContainer`是在`unbatchedUpdates`方法回调中使用的。`unbatchedUpdates`做的事情实际就是在`render`初次调用的时候，不用去批量更新`updateContainer`，这个函数做的事情仅仅是改变了几个标志符，然后立即更新了`CallbackQueue`，我们也略过这部分逻辑，重点来看一下`updateContainer`相关的部分。\n\n```javascript\nfunction updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot, // root\n  parentComponent: ?React$Component<any, any>, // 根节点是null\n  callback: ?Function,\n): ExpirationTime {\n  // fiberRoot的current为fiberRoot的fiber对象\n  const current = container.current;\n  // 获得当前时间到js加载完时间的时间差值\n  const currentTime = requestCurrentTime();\n  // 得到当前update的配置\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  // @todo 及时更新，计算出了一个expirationTime\n  const expirationTime = computeExpirationForFiber(\n    currentTime,\n    current,\n    suspenseConfig,\n  );\n  return updateContainerAtExpirationTime(\n    element, // 更新的element\n    container, // root\n    parentComponent, // 根节点null\n    expirationTime,\n    suspenseConfig,\n    callback,\n  );\n}\n```\n\n&emsp;&emsp;`updateContainer`函数中，采用的全是语义化的函数，整个代码逻辑看上去非常的清晰。先是拿到`container`上的`current`对象，即`rootFiber`上的`Fiber`对象。然后根据`requestCurrentTime`取得一个`currentTime`,计算出一个`suspenseConfig`用于标识的配置，计算`computeExpirationForFiber`然后使用`computeExpirationForFiber`更新`container`。其实我们不用太深究细节的`currentTime`和`suspenseConfig`是什么，而把重点放在`ExpirationTime`上面。我们来简单看下`requestCurrentSuspenseConfig`和`requestCurrentSuspenseConfig`做了什么。这边把涉及到变量相关的内容都摘抄出来汇总在一起。\n\n```javascript\n// in react-reconciler/src/ReactFiberExpirationTime.js\nexport const NoWork = 0;\n\nconst NoContext = /*                    */ 0b000000;\nconst BatchedContext = /*               */ 0b000001;\nconst EventContext = /*                 */ 0b000010;\nconst DiscreteEventContext = /*         */ 0b000100;\nconst LegacyUnbatchedContext = /*       */ 0b001000;\nconst RenderContext = /*                */ 0b010000;\nconst CommitContext = /*                */ 0b100000;\n\n// Describes where we are in the React execution stack\nlet executionContext: number = NoContext;\nlet currentEventTime: number = NoWork;\n\n// 主函数\nfunction requestCurrentTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\n```\n&emsp;&emsp;`requestCurrentTime`其实做的事情很简单，就是根据当前标识的几个状态，返回对应的时间，这里涉及**位操作来标识状态**的一种设计模式，不了解具体原理可以查看我的<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>的文章。\n\n&emsp;&emsp;`requestCurrentTime`三个`if`分支情况分别对应：在*React调度中*，在*浏览器事件调度中*，以及*初次更新*。这里面的now方法可以理解为就相当于`Date.now()`。在非*浏览器事件*情况下，就是通过当前的时间戳计算出了一个`currentEventTime`并返回。`msToExpirationTime`具体做了什么，`expirationTime`是什么，我们卖个关子，到下个专门讲`expirationTime`章节的时候一起来看。\n\n&emsp;&emsp;我们继续来看`requestCurrentSuspenseConfig`的代码。\n\n```javascript\n// shared/ReactSharedInternals.js\nimport React from 'react';\n\nconst ReactSharedInternals =\n  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n// Prevent newer renderers from RTE when used with older react package versions.\n// Current owner and dispatcher used to share the same ref,\n// but PR #14548 split them out to better support the react-debug-tools package.\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n  ReactSharedInternals.ReactCurrentDispatcher = {\n    current: null,\n  };\n}\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n  ReactSharedInternals.ReactCurrentBatchConfig = {\n    suspense: null,\n  };\n}\n\nexport default ReactSharedInternals;\n\n// react-reconciler/src/ReactFiberSuspenseConfig.js\nconst {ReactCurrentBatchConfig} = ReactSharedInternals;\n\nexport function requestCurrentSuspenseConfig(): null | SuspenseConfig {\n  return ReactCurrentBatchConfig.suspense;\n}\n```\n\n&emsp;&emsp;Suspense是React新加入的特性，能够让你的组件等待某些操作完成之后，再进行渲染。`requestCurrentSuspenseConfig`就是设置一个对应的标识符以便进行后续的操作。\n\n&emsp;&emsp;我们继续看函数`updateContainer`的逻辑剩下的两个函数`computeExpirationForFiber`和`updateContainerAtExpirationTime`。`computeExpirationForFiber`代码其实也都是根据标识符来进行计算不同的`ExpirationTime`，其中涉及到的几种不同的计算`expirationTime`的方式我们统一放到下一章专门讲`expirationTime`的部分来解释。\n\n```javascript\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    return Sync;\n  }\n  /*\n    得到一个调度的优先级\n    几种优先级方式\n    ImmediatePriority 99\n    UserBlockingPriority 98\n    NormalPriority 97\n    LowPriority 96\n    IdlePriority 95\n  */\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Never;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\n```\n&emsp;&emsp;计算出了`ExpirationTime`之后接着就使用`ExpirationTime`来更新`container`了。调用`updateContainerAtExpirationTime`的部分。\n\n```javascript\nexport function updateContainerAtExpirationTime(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n  callback: ?Function,\n) {\n  // TODO: If this is a nested container, this won't be the root.\n  const current = container.current;\n  // 省略掉context相关的逻辑...\n  return scheduleRootUpdate(\n    current,\n    element,\n    expirationTime,\n    suspenseConfig,\n    callback,\n  );\n}\n\nfunction scheduleRootUpdate(\n  current: Fiber, // 当前的Fiber节点\n  element: ReactNodeList,\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n  callback: ?Function,\n) {\n  // @todo 标记节点哪些地方需要更新，创建update对象\n  const update = createUpdate(expirationTime, suspenseConfig);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n  // 创建或者更新enqueue的过程\n  enqueueUpdate(current, update);\n  // 开始进行任务调度\n  scheduleWork(current, expirationTime);\n\n  return expirationTime;\n}\n```\n\n&emsp;&emsp;省略掉`updateContainerAtExpirationTime`函数中关于`context`以及`DEV`相关的逻辑后，剩下的便是直接调用`scheduleRootUpdate`，调度root的更新。`scheduleRootUpdate`中首先创建了一个`update`对象，然后把`element`赋值给这个对象的payload属性。接着针对callback做一个处理，如果callback存在，赋值给`update`对象。使用enqueueUpdate对`update`对象进行创建。最后开始任务调度。这一章的代码就看到`scheduleWork`，如何进行调度工作为止。调度流程是一个很庞大的工作流程，到后面会拆分几个章节来讲这部分的代码。目前只需要知道`scheduleWork`是对当前标识的`update`对象进行更新调度到dom上面的流程就可以了。我们接下来来看一下这个`update`对象到底是什么。\n\n```javascript\nfunction createUpdate(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): Update<*> {\n  return {\n    expirationTime,\n    suspenseConfig,\n    /*\n      tag对应\n      export const UpdateState = 0;\n      export const ReplaceState = 1;\n      export const ForceUpdate = 2;\n      // 渲染的错误\n      export const CaptureUpdate = 3;\n    */\n    tag: UpdateState,\n    // 渲染更新的功能，比如element(render初始化的时候)，setState对应的就是第一个参数\n    payload: null,\n    callback: null,\n    // 指向下一个更新\n    next: null,\n    nextEffect: null,\n  };\n}\n```\n\n&emsp;&emsp;`update`对象其实和`fiber`对象一样，就是一个带着标识符的对象。它是用来标识`react`当前需要更新的内容。有多少个`update`，就表示`react`接下来需要更新多少内容。比如`render`函数调用，或者`setState`调用的时候，都会创建`update`更新对象。`update`对象彼此通过next相互连接，形成一个单向链表的数据结构。了解了`update`，我们再来看一下`enqueueUpdate`做了什么。\n\n&emsp;&emsp;`enqueueUpdate`其实就是把`update`放入`updateQueue`的过程。而`updateQueue`其实就是用于保存记录`update`的一个队列。我调整了函数的顺序，把`createUpdateQueue`放在最前面，先来看一下创建的`updateQueue`内容。\n\n```javascript\nfunction createUpdateQueue<State>(baseState: State): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    // 每次更新完的state\n    baseState,\n    // 单向链表记录最后第一项\n    firstUpdate: null,\n    lastUpdate: null,\n    // 错误捕获产生的update\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n```\n&emsp;&emsp;`UpdateQueue`也是一个标识符的对象，它维护着所有需要进行更新的`update`。`firstUpdate`和`lastUpdate`分别指向第一个和最后一个`update`。`firstCapturedUpdate`和`lastCapturedUpdate`用来指向抓取的错误更新的`update`，是为新增加的`componentDidCatch`来服务的。了解了`UpdateQueue`是什么了之后，我们来看下`enqueueUpdate`做了什么。\n\n```javascript\nfunction enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {\n  // Update queues are created lazily.\n  // current(fiber对象)到workInProcess的对象\n  const alternate = fiber.alternate;\n  let queue1;\n  let queue2;\n  // react dom render第一次的情况\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState,\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  // 第一次渲染时queue2为null\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list — we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n}\n\nfunction appendUpdateToQueue<State>(\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\n// 除 baseState/firstUpdate/lastUpdate之外的属性全部置为null\nfunction cloneUpdateQueue<State>(\n  currentQueue: UpdateQueue<State>,\n): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n```\n\n&emsp;&emsp;`enqueueUpdate`根据`fiber.alternate`的情况，来获得`queue1`和`queue2`，添加到`UpdateQueue`的`firstUpdate`和`lastUpdate`上面去。`alternate`用来标识`current(fiber对象)到workInProcess的对象`关系，后续讲到`scheduleWork`部分的时候会提及到。\n\n&emsp;&emsp;本章节讲述了`updateContainer`部分的逻辑，提及到了一个`ExpirationTime`的概念，它是`react`进行任务调度的依据，根据不同的调度等级获得不同的`ExpirationTime`。然后根据`ExpirationTime`和`Fiber`对象，创建`update`对象和维护`update`对象的`UpdateQueue`队列，它们是`react`应用更新的依据和基础。完成之后就可以使用`scheduleWork`函数进行调度工作了。\n\n&emsp;&emsp;本章挖下的两个大坑，一个`ExpirationTime`，它到底代表什么，是如何计算的，将在下章阐述。阐述完毕`ExpirationTime`后，会带一下`setState`的内容，你会发现`setState`的代码逻辑和`render`代码逻辑结构是非常接近的。完成后，将会进入`scheduleWork`，`react`整个调度的章节源码阅读。","source":"_posts/react/reactCode-react-3.md","raw":"---\ntitle: react源码阅读3 update与updateQueue\ndate: 2020/4/1 14:00\ncategories:\n- [前端, react]\ntags:\n- react\n- 源码阅读\n---\nreact-dom后续updateContainer部分。阅读React包的源码版本为**16.8.6**。\n<!--more-->\n&emsp;&emsp;在<a href=\"../reactCode-react-2-2020-03-22/\" target=\"_blank\">上一章节中</a>我们看到了`react-dom`中`render`函数的逻辑是给传入的React组件创建了一个`fiberRoot`对象，用于标识它是整个应用的起点，上面拥有很多应用更新相关的表示符。然后创建对应的`fiber`给`fiberRoot`节点，`fiber`对象是每一个`ReactElement`都拥有的节点，它标识了更新时间的一些信息，props和state的一些信息，以及相关联的节点信息。`ReactElement`彼此是通过一个单向链表的数据结构联系在一起的。\n\n&emsp;&emsp;这一章我们接着`legacyRenderSubtreeIntoContainer`函数创建完`fiber`相关对象的部分，查看接下来`updateContainer`相关的逻辑。我们先回顾一下这部分的代码。\n\n```javascript\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: DOMContainer,\n  // 是否复用dom节点，服务端渲染调用\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // ...省略创建fiber节点相关部分逻辑\n  // 初次使用render不存在root节点\n  if (!root) {\n    // ...省略创建fiber节点相关部分逻辑\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n    // 有无callback 逻辑同上\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n```\n\n&emsp;&emsp;我们先看`callback`部分的处理，在`render`函数中`callback`是传入的第三个参数，根据`react文档`，该回调将在组件被渲染或更新之后被执行，并且在非箭头函数的情况下，该回调的this指向`render`渲染的那个组件。我们先来回顾下这个入参的使用方式。\n\n```javascript\nconst instance = render(\n  <Hello text=\"123\" />,\n  document.getElementById(\"page\"),\n  function () { console.log(this) }\n);\n\nconsole.log(instance);\n\n/*\nthis === instance === Hello\nHello {\n  isMounted: (...)\n  replaceState: (...)\n  props: {text: \"123\"}\n  context: {}\n  refs: {}\n  updater: {isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ}\n  _reactInternalFiber: FiberNode {tag: 1, key: null, stateNode: Hello, elementType: ƒ, type: ƒ, …}\n  _reactInternalInstance: {_processChildContext: ƒ}\n  state: null\n  __proto__: Component\n}\n*/\n```\n\n&emsp;&emsp;在上述代码中使用`render`函数时，传入了一个匿名函数作为`render`的第三个入参，并打印了`this`，然后将`render`函数的返回值赋予了`instance`变量并打印出来。我们可以看到，输出的是一个对象信息，其实使用过`react`测试相关诸如`react-test-renderer`等框架的，应该对这个`instance`比较熟悉。它标志了一个由`fiberRoot`开始的完整的组件信息。\n\n&emsp;&emsp;现在回到源码，我们可以看到我们在调用`render`时候，`callback`的this和`render`返回的组件`instance`信息都是由`getPublicRootInstance`创建的。`react`将我们传入的`callback`赋值给了变量`originalCallback`，然后声明一个新的`callback`，新的`callback`创建了一个`instance`，然后用`call`让`originalCallback`的this指向它，把它传入到了`updateContainer`的`callback`参数中。\n\n&emsp;&emsp;至于`getPublicRootInstance`如何创建一个`Instance`的细节代码与主流程牵扯不大，这边就跳过。只要知道该函数根据`fiberRoot`提供了一个`Instance`信息对象即可。接着我们可以看到，无论是否是初次使用`render`函数（初次调用render函数不存在root节点），`legacyRenderSubtreeIntoContainer`都调用了`updateContainer`方法，区别就是初次使用`render`的时候，`updateContainer`是在`unbatchedUpdates`方法回调中使用的。`unbatchedUpdates`做的事情实际就是在`render`初次调用的时候，不用去批量更新`updateContainer`，这个函数做的事情仅仅是改变了几个标志符，然后立即更新了`CallbackQueue`，我们也略过这部分逻辑，重点来看一下`updateContainer`相关的部分。\n\n```javascript\nfunction updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot, // root\n  parentComponent: ?React$Component<any, any>, // 根节点是null\n  callback: ?Function,\n): ExpirationTime {\n  // fiberRoot的current为fiberRoot的fiber对象\n  const current = container.current;\n  // 获得当前时间到js加载完时间的时间差值\n  const currentTime = requestCurrentTime();\n  // 得到当前update的配置\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  // @todo 及时更新，计算出了一个expirationTime\n  const expirationTime = computeExpirationForFiber(\n    currentTime,\n    current,\n    suspenseConfig,\n  );\n  return updateContainerAtExpirationTime(\n    element, // 更新的element\n    container, // root\n    parentComponent, // 根节点null\n    expirationTime,\n    suspenseConfig,\n    callback,\n  );\n}\n```\n\n&emsp;&emsp;`updateContainer`函数中，采用的全是语义化的函数，整个代码逻辑看上去非常的清晰。先是拿到`container`上的`current`对象，即`rootFiber`上的`Fiber`对象。然后根据`requestCurrentTime`取得一个`currentTime`,计算出一个`suspenseConfig`用于标识的配置，计算`computeExpirationForFiber`然后使用`computeExpirationForFiber`更新`container`。其实我们不用太深究细节的`currentTime`和`suspenseConfig`是什么，而把重点放在`ExpirationTime`上面。我们来简单看下`requestCurrentSuspenseConfig`和`requestCurrentSuspenseConfig`做了什么。这边把涉及到变量相关的内容都摘抄出来汇总在一起。\n\n```javascript\n// in react-reconciler/src/ReactFiberExpirationTime.js\nexport const NoWork = 0;\n\nconst NoContext = /*                    */ 0b000000;\nconst BatchedContext = /*               */ 0b000001;\nconst EventContext = /*                 */ 0b000010;\nconst DiscreteEventContext = /*         */ 0b000100;\nconst LegacyUnbatchedContext = /*       */ 0b001000;\nconst RenderContext = /*                */ 0b010000;\nconst CommitContext = /*                */ 0b100000;\n\n// Describes where we are in the React execution stack\nlet executionContext: number = NoContext;\nlet currentEventTime: number = NoWork;\n\n// 主函数\nfunction requestCurrentTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\n```\n&emsp;&emsp;`requestCurrentTime`其实做的事情很简单，就是根据当前标识的几个状态，返回对应的时间，这里涉及**位操作来标识状态**的一种设计模式，不了解具体原理可以查看我的<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>的文章。\n\n&emsp;&emsp;`requestCurrentTime`三个`if`分支情况分别对应：在*React调度中*，在*浏览器事件调度中*，以及*初次更新*。这里面的now方法可以理解为就相当于`Date.now()`。在非*浏览器事件*情况下，就是通过当前的时间戳计算出了一个`currentEventTime`并返回。`msToExpirationTime`具体做了什么，`expirationTime`是什么，我们卖个关子，到下个专门讲`expirationTime`章节的时候一起来看。\n\n&emsp;&emsp;我们继续来看`requestCurrentSuspenseConfig`的代码。\n\n```javascript\n// shared/ReactSharedInternals.js\nimport React from 'react';\n\nconst ReactSharedInternals =\n  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n// Prevent newer renderers from RTE when used with older react package versions.\n// Current owner and dispatcher used to share the same ref,\n// but PR #14548 split them out to better support the react-debug-tools package.\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n  ReactSharedInternals.ReactCurrentDispatcher = {\n    current: null,\n  };\n}\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n  ReactSharedInternals.ReactCurrentBatchConfig = {\n    suspense: null,\n  };\n}\n\nexport default ReactSharedInternals;\n\n// react-reconciler/src/ReactFiberSuspenseConfig.js\nconst {ReactCurrentBatchConfig} = ReactSharedInternals;\n\nexport function requestCurrentSuspenseConfig(): null | SuspenseConfig {\n  return ReactCurrentBatchConfig.suspense;\n}\n```\n\n&emsp;&emsp;Suspense是React新加入的特性，能够让你的组件等待某些操作完成之后，再进行渲染。`requestCurrentSuspenseConfig`就是设置一个对应的标识符以便进行后续的操作。\n\n&emsp;&emsp;我们继续看函数`updateContainer`的逻辑剩下的两个函数`computeExpirationForFiber`和`updateContainerAtExpirationTime`。`computeExpirationForFiber`代码其实也都是根据标识符来进行计算不同的`ExpirationTime`，其中涉及到的几种不同的计算`expirationTime`的方式我们统一放到下一章专门讲`expirationTime`的部分来解释。\n\n```javascript\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    return Sync;\n  }\n  /*\n    得到一个调度的优先级\n    几种优先级方式\n    ImmediatePriority 99\n    UserBlockingPriority 98\n    NormalPriority 97\n    LowPriority 96\n    IdlePriority 95\n  */\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Never;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\n```\n&emsp;&emsp;计算出了`ExpirationTime`之后接着就使用`ExpirationTime`来更新`container`了。调用`updateContainerAtExpirationTime`的部分。\n\n```javascript\nexport function updateContainerAtExpirationTime(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n  callback: ?Function,\n) {\n  // TODO: If this is a nested container, this won't be the root.\n  const current = container.current;\n  // 省略掉context相关的逻辑...\n  return scheduleRootUpdate(\n    current,\n    element,\n    expirationTime,\n    suspenseConfig,\n    callback,\n  );\n}\n\nfunction scheduleRootUpdate(\n  current: Fiber, // 当前的Fiber节点\n  element: ReactNodeList,\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n  callback: ?Function,\n) {\n  // @todo 标记节点哪些地方需要更新，创建update对象\n  const update = createUpdate(expirationTime, suspenseConfig);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n  // 创建或者更新enqueue的过程\n  enqueueUpdate(current, update);\n  // 开始进行任务调度\n  scheduleWork(current, expirationTime);\n\n  return expirationTime;\n}\n```\n\n&emsp;&emsp;省略掉`updateContainerAtExpirationTime`函数中关于`context`以及`DEV`相关的逻辑后，剩下的便是直接调用`scheduleRootUpdate`，调度root的更新。`scheduleRootUpdate`中首先创建了一个`update`对象，然后把`element`赋值给这个对象的payload属性。接着针对callback做一个处理，如果callback存在，赋值给`update`对象。使用enqueueUpdate对`update`对象进行创建。最后开始任务调度。这一章的代码就看到`scheduleWork`，如何进行调度工作为止。调度流程是一个很庞大的工作流程，到后面会拆分几个章节来讲这部分的代码。目前只需要知道`scheduleWork`是对当前标识的`update`对象进行更新调度到dom上面的流程就可以了。我们接下来来看一下这个`update`对象到底是什么。\n\n```javascript\nfunction createUpdate(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): Update<*> {\n  return {\n    expirationTime,\n    suspenseConfig,\n    /*\n      tag对应\n      export const UpdateState = 0;\n      export const ReplaceState = 1;\n      export const ForceUpdate = 2;\n      // 渲染的错误\n      export const CaptureUpdate = 3;\n    */\n    tag: UpdateState,\n    // 渲染更新的功能，比如element(render初始化的时候)，setState对应的就是第一个参数\n    payload: null,\n    callback: null,\n    // 指向下一个更新\n    next: null,\n    nextEffect: null,\n  };\n}\n```\n\n&emsp;&emsp;`update`对象其实和`fiber`对象一样，就是一个带着标识符的对象。它是用来标识`react`当前需要更新的内容。有多少个`update`，就表示`react`接下来需要更新多少内容。比如`render`函数调用，或者`setState`调用的时候，都会创建`update`更新对象。`update`对象彼此通过next相互连接，形成一个单向链表的数据结构。了解了`update`，我们再来看一下`enqueueUpdate`做了什么。\n\n&emsp;&emsp;`enqueueUpdate`其实就是把`update`放入`updateQueue`的过程。而`updateQueue`其实就是用于保存记录`update`的一个队列。我调整了函数的顺序，把`createUpdateQueue`放在最前面，先来看一下创建的`updateQueue`内容。\n\n```javascript\nfunction createUpdateQueue<State>(baseState: State): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    // 每次更新完的state\n    baseState,\n    // 单向链表记录最后第一项\n    firstUpdate: null,\n    lastUpdate: null,\n    // 错误捕获产生的update\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n```\n&emsp;&emsp;`UpdateQueue`也是一个标识符的对象，它维护着所有需要进行更新的`update`。`firstUpdate`和`lastUpdate`分别指向第一个和最后一个`update`。`firstCapturedUpdate`和`lastCapturedUpdate`用来指向抓取的错误更新的`update`，是为新增加的`componentDidCatch`来服务的。了解了`UpdateQueue`是什么了之后，我们来看下`enqueueUpdate`做了什么。\n\n```javascript\nfunction enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {\n  // Update queues are created lazily.\n  // current(fiber对象)到workInProcess的对象\n  const alternate = fiber.alternate;\n  let queue1;\n  let queue2;\n  // react dom render第一次的情况\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState,\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  // 第一次渲染时queue2为null\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list — we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n}\n\nfunction appendUpdateToQueue<State>(\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\n// 除 baseState/firstUpdate/lastUpdate之外的属性全部置为null\nfunction cloneUpdateQueue<State>(\n  currentQueue: UpdateQueue<State>,\n): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n```\n\n&emsp;&emsp;`enqueueUpdate`根据`fiber.alternate`的情况，来获得`queue1`和`queue2`，添加到`UpdateQueue`的`firstUpdate`和`lastUpdate`上面去。`alternate`用来标识`current(fiber对象)到workInProcess的对象`关系，后续讲到`scheduleWork`部分的时候会提及到。\n\n&emsp;&emsp;本章节讲述了`updateContainer`部分的逻辑，提及到了一个`ExpirationTime`的概念，它是`react`进行任务调度的依据，根据不同的调度等级获得不同的`ExpirationTime`。然后根据`ExpirationTime`和`Fiber`对象，创建`update`对象和维护`update`对象的`UpdateQueue`队列，它们是`react`应用更新的依据和基础。完成之后就可以使用`scheduleWork`函数进行调度工作了。\n\n&emsp;&emsp;本章挖下的两个大坑，一个`ExpirationTime`，它到底代表什么，是如何计算的，将在下章阐述。阐述完毕`ExpirationTime`后，会带一下`setState`的内容，你会发现`setState`的代码逻辑和`render`代码逻辑结构是非常接近的。完成后，将会进入`scheduleWork`，`react`整个调度的章节源码阅读。","slug":"react/reactCode-react-3","published":1,"updated":"2020-06-11T01:43:32.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy1001y9r2v7zexjasy","content":"<p>react-dom后续updateContainer部分。阅读React包的源码版本为<strong>16.8.6</strong>。<br><a id=\"more\"></a><br>&emsp;&emsp;在<a href=\"../reactCode-react-2-2020-03-22/\" target=\"_blank\">上一章节中</a>我们看到了<code>react-dom</code>中<code>render</code>函数的逻辑是给传入的React组件创建了一个<code>fiberRoot</code>对象，用于标识它是整个应用的起点，上面拥有很多应用更新相关的表示符。然后创建对应的<code>fiber</code>给<code>fiberRoot</code>节点，<code>fiber</code>对象是每一个<code>ReactElement</code>都拥有的节点，它标识了更新时间的一些信息，props和state的一些信息，以及相关联的节点信息。<code>ReactElement</code>彼此是通过一个单向链表的数据结构联系在一起的。</p>\n<p>&emsp;&emsp;这一章我们接着<code>legacyRenderSubtreeIntoContainer</code>函数创建完<code>fiber</code>相关对象的部分，查看接下来<code>updateContainer</code>相关的逻辑。我们先回顾一下这部分的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">legacyRenderSubtreeIntoContainer</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  children: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  <span class=\"hljs-regexp\">//</span> 是否复用dom节点，服务端渲染调用</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  forceHydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...省略创建fiber节点相关部分逻辑</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 初次使用render不存在root节点</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// ...省略创建fiber节点相关部分逻辑</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callback === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Initial mount should not be batched.</span></span><br><span class=\"line\">    unbatchedUpdates(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 有无callback 逻辑同上</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> callback === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Update</span></span><br><span class=\"line\">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们先看<code>callback</code>部分的处理，在<code>render</code>函数中<code>callback</code>是传入的第三个参数，根据<code>react文档</code>，该回调将在组件被渲染或更新之后被执行，并且在非箭头函数的情况下，该回调的this指向<code>render</code>渲染的那个组件。我们先来回顾下这个入参的使用方式。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> instance = render(</span><br><span class=\"line\">  &lt;Hello text=<span class=\"hljs-string\">\"123\"</span> /&gt;,</span><br><span class=\"line\">  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"page\"</span>),</span><br><span class=\"line\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>) &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-built_in\">console</span>.log(instance);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">this === instance === Hello</span></span><br><span class=\"line\"><span class=\"hljs-comment\">Hello &#123;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  isMounted: (...)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  replaceState: (...)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  props: &#123;text: \"123\"&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  context: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  refs: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  updater: &#123;isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  _reactInternalFiber: FiberNode &#123;tag: 1, key: null, stateNode: Hello, elementType: ƒ, type: ƒ, …&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  _reactInternalInstance: &#123;_processChildContext: ƒ&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  state: null</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  __proto__: Component</span></span><br><span class=\"line\"><span class=\"hljs-comment\">&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在上述代码中使用<code>render</code>函数时，传入了一个匿名函数作为<code>render</code>的第三个入参，并打印了<code>this</code>，然后将<code>render</code>函数的返回值赋予了<code>instance</code>变量并打印出来。我们可以看到，输出的是一个对象信息，其实使用过<code>react</code>测试相关诸如<code>react-test-renderer</code>等框架的，应该对这个<code>instance</code>比较熟悉。它标志了一个由<code>fiberRoot</code>开始的完整的组件信息。</p>\n<p>&emsp;&emsp;现在回到源码，我们可以看到我们在调用<code>render</code>时候，<code>callback</code>的this和<code>render</code>返回的组件<code>instance</code>信息都是由<code>getPublicRootInstance</code>创建的。<code>react</code>将我们传入的<code>callback</code>赋值给了变量<code>originalCallback</code>，然后声明一个新的<code>callback</code>，新的<code>callback</code>创建了一个<code>instance</code>，然后用<code>call</code>让<code>originalCallback</code>的this指向它，把它传入到了<code>updateContainer</code>的<code>callback</code>参数中。</p>\n<p>&emsp;&emsp;至于<code>getPublicRootInstance</code>如何创建一个<code>Instance</code>的细节代码与主流程牵扯不大，这边就跳过。只要知道该函数根据<code>fiberRoot</code>提供了一个<code>Instance</code>信息对象即可。接着我们可以看到，无论是否是初次使用<code>render</code>函数（初次调用render函数不存在root节点），<code>legacyRenderSubtreeIntoContainer</code>都调用了<code>updateContainer</code>方法，区别就是初次使用<code>render</code>的时候，<code>updateContainer</code>是在<code>unbatchedUpdates</code>方法回调中使用的。<code>unbatchedUpdates</code>做的事情实际就是在<code>render</code>初次调用的时候，不用去批量更新<code>updateContainer</code>，这个函数做的事情仅仅是改变了几个标志符，然后立即更新了<code>CallbackQueue</code>，我们也略过这部分逻辑，重点来看一下<code>updateContainer</code>相关的部分。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateContainer</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  element: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  container: OpaqueRoot, <span class=\"hljs-regexp\">//</span> root</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  parentComponent: ?React$Component&lt;any, any&gt;, <span class=\"hljs-regexp\">//</span> 根节点是null</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// fiberRoot的current为fiberRoot的fiber对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> current = container.current;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 获得当前时间到js加载完时间的时间差值</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> currentTime = requestCurrentTime();</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 得到当前update的配置</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class=\"line\">  <span class=\"hljs-comment\">// @todo 及时更新，计算出了一个expirationTime</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> expirationTime = computeExpirationForFiber(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    current,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> updateContainerAtExpirationTime(</span><br><span class=\"line\">    element, <span class=\"hljs-comment\">// 更新的element</span></span><br><span class=\"line\">    container, <span class=\"hljs-comment\">// root</span></span><br><span class=\"line\">    parentComponent, <span class=\"hljs-comment\">// 根节点null</span></span><br><span class=\"line\">    expirationTime,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>updateContainer</code>函数中，采用的全是语义化的函数，整个代码逻辑看上去非常的清晰。先是拿到<code>container</code>上的<code>current</code>对象，即<code>rootFiber</code>上的<code>Fiber</code>对象。然后根据<code>requestCurrentTime</code>取得一个<code>currentTime</code>,计算出一个<code>suspenseConfig</code>用于标识的配置，计算<code>computeExpirationForFiber</code>然后使用<code>computeExpirationForFiber</code>更新<code>container</code>。其实我们不用太深究细节的<code>currentTime</code>和<code>suspenseConfig</code>是什么，而把重点放在<code>ExpirationTime</code>上面。我们来简单看下<code>requestCurrentSuspenseConfig</code>和<code>requestCurrentSuspenseConfig</code>做了什么。这边把涉及到变量相关的内容都摘抄出来汇总在一起。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// in react-reconciler/src/ReactFiberExpirationTime.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> NoWork = <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> NoContext = <span class=\"hljs-comment\">/*                    */</span> <span class=\"hljs-number\">0b000000</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> BatchedContext = <span class=\"hljs-comment\">/*               */</span> <span class=\"hljs-number\">0b000001</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> EventContext = <span class=\"hljs-comment\">/*                 */</span> <span class=\"hljs-number\">0b000010</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> DiscreteEventContext = <span class=\"hljs-comment\">/*         */</span> <span class=\"hljs-number\">0b000100</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> LegacyUnbatchedContext = <span class=\"hljs-comment\">/*       */</span> <span class=\"hljs-number\">0b001000</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> RenderContext = <span class=\"hljs-comment\">/*                */</span> <span class=\"hljs-number\">0b010000</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> CommitContext = <span class=\"hljs-comment\">/*                */</span> <span class=\"hljs-number\">0b100000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// Describes where we are in the React execution stack</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> executionContext: number = NoContext;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> currentEventTime: number = NoWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 主函数</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">requestCurrentTime</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// We're inside React, so it's fine to read the actual time.</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> msToExpirationTime(now());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// We're not inside React, so we may be in the middle of a browser event.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (currentEventTime !== NoWork) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Use the same start time for all updates until we enter React again.</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> currentEventTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// This is the first update since React yielded. Compute a new start time.</span></span><br><span class=\"line\">  currentEventTime = msToExpirationTime(now());</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> currentEventTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>requestCurrentTime</code>其实做的事情很简单，就是根据当前标识的几个状态，返回对应的时间，这里涉及<strong>位操作来标识状态</strong>的一种设计模式，不了解具体原理可以查看我的<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>的文章。</p>\n<p>&emsp;&emsp;<code>requestCurrentTime</code>三个<code>if</code>分支情况分别对应：在<em>React调度中</em>，在<em>浏览器事件调度中</em>，以及<em>初次更新</em>。这里面的now方法可以理解为就相当于<code>Date.now()</code>。在非<em>浏览器事件</em>情况下，就是通过当前的时间戳计算出了一个<code>currentEventTime</code>并返回。<code>msToExpirationTime</code>具体做了什么，<code>expirationTime</code>是什么，我们卖个关子，到下个专门讲<code>expirationTime</code>章节的时候一起来看。</p>\n<p>&emsp;&emsp;我们继续来看<code>requestCurrentSuspenseConfig</code>的代码。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// shared/ReactSharedInternals.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> ReactSharedInternals =</span><br><span class=\"line\">  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// Prevent newer renderers from RTE when used with older react package versions.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// Current owner and dispatcher used to share the same ref,</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// but PR #14548 split them out to better support the react-debug-tools package.</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (!ReactSharedInternals.hasOwnProperty(<span class=\"hljs-string\">'ReactCurrentDispatcher'</span>)) &#123;</span><br><span class=\"line\">  ReactSharedInternals.ReactCurrentDispatcher = &#123;</span><br><span class=\"line\">    current: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (!ReactSharedInternals.hasOwnProperty(<span class=\"hljs-string\">'ReactCurrentBatchConfig'</span>)) &#123;</span><br><span class=\"line\">  ReactSharedInternals.ReactCurrentBatchConfig = &#123;</span><br><span class=\"line\">    suspense: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> ReactSharedInternals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// react-reconciler/src/ReactFiberSuspenseConfig.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> &#123;ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">requestCurrentSuspenseConfig</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">null</span> | <span class=\"hljs-title\">SuspenseConfig</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> ReactCurrentBatchConfig.suspense;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;Suspense是React新加入的特性，能够让你的组件等待某些操作完成之后，再进行渲染。<code>requestCurrentSuspenseConfig</code>就是设置一个对应的标识符以便进行后续的操作。</p>\n<p>&emsp;&emsp;我们继续看函数<code>updateContainer</code>的逻辑剩下的两个函数<code>computeExpirationForFiber</code>和<code>updateContainerAtExpirationTime</code>。<code>computeExpirationForFiber</code>代码其实也都是根据标识符来进行计算不同的<code>ExpirationTime</code>，其中涉及到的几种不同的计算<code>expirationTime</code>的方式我们统一放到下一章专门讲<code>expirationTime</code>的部分来解释。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computeExpirationForFiber</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  currentTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  fiber: Fiber,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> mode = fiber.mode;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((mode &amp; BatchedMode) === NoMode) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> Sync;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    得到一个调度的优先级</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    几种优先级方式</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    ImmediatePriority 99</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    UserBlockingPriority 98</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    NormalPriority 97</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    LowPriority 96</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    IdlePriority 95</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> priorityLevel = getCurrentPriorityLevel();</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> priorityLevel === ImmediatePriority ? Sync : Batched;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((executionContext &amp; RenderContext) !== NoContext) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Use whatever time we're already rendering</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> renderExpirationTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> expirationTime;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (suspenseConfig !== <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Compute an expiration time based on the Suspense timeout.</span></span><br><span class=\"line\">    expirationTime = computeSuspenseExpiration(</span><br><span class=\"line\">      currentTime,</span><br><span class=\"line\">      suspenseConfig.timeoutMs | <span class=\"hljs-number\">0</span> || LOW_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Compute an expiration time based on the Scheduler priority.</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">switch</span> (priorityLevel) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">case</span> ImmediatePriority:</span><br><span class=\"line\">        expirationTime = Sync;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">case</span> UserBlockingPriority:</span><br><span class=\"line\">        <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Rename this to computeUserBlockingExpiration</span></span><br><span class=\"line\">        expirationTime = computeInteractiveExpiration(currentTime);</span><br><span class=\"line\">        <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">case</span> NormalPriority:</span><br><span class=\"line\">      <span class=\"hljs-keyword\">case</span> LowPriority: <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Handle LowPriority</span></span><br><span class=\"line\">        <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Rename this to... something better.</span></span><br><span class=\"line\">        expirationTime = computeAsyncExpiration(currentTime);</span><br><span class=\"line\">        <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">case</span> IdlePriority:</span><br><span class=\"line\">        expirationTime = Never;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">default</span>:</span><br><span class=\"line\">        invariant(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">'Expected a valid priority level'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// If we're in the middle of rendering a tree, do not update at the same</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// expiration time that is already rendering.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> We shouldn't have to do this if the update is on a different root.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// Refactor computeExpirationForFiber + scheduleUpdate so we have access to</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// the root when we check for this condition.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (workInProgressRoot !== <span class=\"hljs-literal\">null</span> &amp;&amp; expirationTime === renderExpirationTime) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// This is a trick to move this update into a separate batch</span></span><br><span class=\"line\">    expirationTime -= <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> expirationTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;计算出了<code>ExpirationTime</code>之后接着就使用<code>ExpirationTime</code>来更新<code>container</code>了。调用<code>updateContainerAtExpirationTime</code>的部分。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateContainerAtExpirationTime</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  element: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  container: OpaqueRoot,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  expirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> If this is a nested container, this won't be the root.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> current = container.current;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 省略掉context相关的逻辑...</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> scheduleRootUpdate(</span><br><span class=\"line\">    current,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    expirationTime,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">scheduleRootUpdate</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  current: Fiber, <span class=\"hljs-regexp\">//</span> 当前的Fiber节点</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  element: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  expirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// @todo 标记节点哪些地方需要更新，创建update对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> update = createUpdate(expirationTime, suspenseConfig);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Caution: React DevTools currently depends on this property</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// being called \"element\".</span></span><br><span class=\"line\">  update.payload = &#123;element&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  callback = callback === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-literal\">null</span> : callback;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (callback !== <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">    update.callback = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 创建或者更新enqueue的过程</span></span><br><span class=\"line\">  enqueueUpdate(current, update);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 开始进行任务调度</span></span><br><span class=\"line\">  scheduleWork(current, expirationTime);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> expirationTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;省略掉<code>updateContainerAtExpirationTime</code>函数中关于<code>context</code>以及<code>DEV</code>相关的逻辑后，剩下的便是直接调用<code>scheduleRootUpdate</code>，调度root的更新。<code>scheduleRootUpdate</code>中首先创建了一个<code>update</code>对象，然后把<code>element</code>赋值给这个对象的payload属性。接着针对callback做一个处理，如果callback存在，赋值给<code>update</code>对象。使用enqueueUpdate对<code>update</code>对象进行创建。最后开始任务调度。这一章的代码就看到<code>scheduleWork</code>，如何进行调度工作为止。调度流程是一个很庞大的工作流程，到后面会拆分几个章节来讲这部分的代码。目前只需要知道<code>scheduleWork</code>是对当前标识的<code>update</code>对象进行更新调度到dom上面的流程就可以了。我们接下来来看一下这个<code>update</code>对象到底是什么。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUpdate</span>(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  expirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">Update</span>&lt;*&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"line\">    expirationTime,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">    <span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">      tag对应</span></span><br><span class=\"line\"><span class=\"hljs-comment\">      export const UpdateState = 0;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">      export const ReplaceState = 1;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">      export const ForceUpdate = 2;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">      // 渲染的错误</span></span><br><span class=\"line\"><span class=\"hljs-comment\">      export const CaptureUpdate = 3;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    */</span></span><br><span class=\"line\">    tag: UpdateState,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 渲染更新的功能，比如element(render初始化的时候)，setState对应的就是第一个参数</span></span><br><span class=\"line\">    payload: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    callback: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 指向下一个更新</span></span><br><span class=\"line\">    next: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    nextEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>update</code>对象其实和<code>fiber</code>对象一样，就是一个带着标识符的对象。它是用来标识<code>react</code>当前需要更新的内容。有多少个<code>update</code>，就表示<code>react</code>接下来需要更新多少内容。比如<code>render</code>函数调用，或者<code>setState</code>调用的时候，都会创建<code>update</code>更新对象。<code>update</code>对象彼此通过next相互连接，形成一个单向链表的数据结构。了解了<code>update</code>，我们再来看一下<code>enqueueUpdate</code>做了什么。</p>\n<p>&emsp;&emsp;<code>enqueueUpdate</code>其实就是把<code>update</code>放入<code>updateQueue</code>的过程。而<code>updateQueue</code>其实就是用于保存记录<code>update</code>的一个队列。我调整了函数的顺序，把<code>createUpdateQueue</code>放在最前面，先来看一下创建的<code>updateQueue</code>内容。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUpdateQueue</span>&lt;<span class=\"hljs-title\">State</span>&gt;(<span class=\"hljs-params\">baseState: State</span>): <span class=\"hljs-title\">UpdateQueue</span>&lt;<span class=\"hljs-title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 每次更新完的state</span></span><br><span class=\"line\">    baseState,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 单向链表记录最后第一项</span></span><br><span class=\"line\">    firstUpdate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastUpdate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 错误捕获产生的update</span></span><br><span class=\"line\">    firstCapturedUpdate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastCapturedUpdate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    firstEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    firstCapturedEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastCapturedEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>UpdateQueue</code>也是一个标识符的对象，它维护着所有需要进行更新的<code>update</code>。<code>firstUpdate</code>和<code>lastUpdate</code>分别指向第一个和最后一个<code>update</code>。<code>firstCapturedUpdate</code>和<code>lastCapturedUpdate</code>用来指向抓取的错误更新的<code>update</code>，是为新增加的<code>componentDidCatch</code>来服务的。了解了<code>UpdateQueue</code>是什么了之后，我们来看下<code>enqueueUpdate</code>做了什么。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">enqueueUpdate</span>&lt;<span class=\"hljs-title\">State</span>&gt;(<span class=\"hljs-params\">fiber: Fiber, update: Update&lt;State&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Update queues are created lazily.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// current(fiber对象)到workInProcess的对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> alternate = fiber.alternate;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> queue1;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> queue2;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// react dom render第一次的情况</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (alternate === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// There's only one fiber.</span></span><br><span class=\"line\">    queue1 = fiber.updateQueue;</span><br><span class=\"line\">    queue2 = <span class=\"hljs-literal\">null</span>;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (queue1 === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// There are two owners.</span></span><br><span class=\"line\">    queue1 = fiber.updateQueue;</span><br><span class=\"line\">    queue2 = alternate.updateQueue;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (queue1 === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (queue2 === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// Neither fiber has an update queue. Create new ones.</span></span><br><span class=\"line\">        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class=\"line\">        queue2 = alternate.updateQueue = createUpdateQueue(</span><br><span class=\"line\">          alternate.memoizedState,</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class=\"line\">        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (queue2 === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class=\"line\">        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// Both owners have an update queue.</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 第一次渲染时queue2为null</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (queue2 === <span class=\"hljs-literal\">null</span> || queue1 === queue2) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// There's only a single queue.</span></span><br><span class=\"line\">    appendUpdateToQueue(queue1, update);</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// There are two queues. We need to append the update to both queues,</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// while accounting for the persistent structure of the list — we don't</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// want the same update to be added multiple times.</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (queue1.lastUpdate === <span class=\"hljs-literal\">null</span> || queue2.lastUpdate === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// One of the queues is not empty. We must add the update to both queues.</span></span><br><span class=\"line\">      appendUpdateToQueue(queue1, update);</span><br><span class=\"line\">      appendUpdateToQueue(queue2, update);</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// Both queues are non-empty. The last update is the same in both lists,</span></span><br><span class=\"line\">      <span class=\"hljs-comment\">// because of structural sharing. So, only append to one of the lists.</span></span><br><span class=\"line\">      appendUpdateToQueue(queue1, update);</span><br><span class=\"line\">      <span class=\"hljs-comment\">// But we still need to update the `lastUpdate` pointer of queue2.</span></span><br><span class=\"line\">      queue2.lastUpdate = update;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">appendUpdateToQueue</span>&lt;<span class=\"hljs-title\">State</span>&gt;(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  update: Update&lt;State&gt;,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Append the update to the end of the list.</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (queue.lastUpdate === <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// Queue is empty</span></span><br><span class=\"line\">    queue.firstUpdate = queue.lastUpdate = update;</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    queue.lastUpdate.next = update;</span><br><span class=\"line\">    queue.lastUpdate = update;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 除 baseState/firstUpdate/lastUpdate之外的属性全部置为null</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cloneUpdateQueue</span>&lt;<span class=\"hljs-title\">State</span>&gt;(<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  currentQueue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UpdateQueue</span>&lt;<span class=\"hljs-title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    baseState: currentQueue.baseState,</span><br><span class=\"line\">    firstUpdate: currentQueue.firstUpdate,</span><br><span class=\"line\">    lastUpdate: currentQueue.lastUpdate,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> With resuming, if we bail out and resuse the child tree, we should</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// keep these effects.</span></span><br><span class=\"line\">    firstCapturedUpdate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastCapturedUpdate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    firstEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    firstCapturedEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    lastCapturedEffect: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>enqueueUpdate</code>根据<code>fiber.alternate</code>的情况，来获得<code>queue1</code>和<code>queue2</code>，添加到<code>UpdateQueue</code>的<code>firstUpdate</code>和<code>lastUpdate</code>上面去。<code>alternate</code>用来标识<code>current(fiber对象)到workInProcess的对象</code>关系，后续讲到<code>scheduleWork</code>部分的时候会提及到。</p>\n<p>&emsp;&emsp;本章节讲述了<code>updateContainer</code>部分的逻辑，提及到了一个<code>ExpirationTime</code>的概念，它是<code>react</code>进行任务调度的依据，根据不同的调度等级获得不同的<code>ExpirationTime</code>。然后根据<code>ExpirationTime</code>和<code>Fiber</code>对象，创建<code>update</code>对象和维护<code>update</code>对象的<code>UpdateQueue</code>队列，它们是<code>react</code>应用更新的依据和基础。完成之后就可以使用<code>scheduleWork</code>函数进行调度工作了。</p>\n<p>&emsp;&emsp;本章挖下的两个大坑，一个<code>ExpirationTime</code>，它到底代表什么，是如何计算的，将在下章阐述。阐述完毕<code>ExpirationTime</code>后，会带一下<code>setState</code>的内容，你会发现<code>setState</code>的代码逻辑和<code>render</code>代码逻辑结构是非常接近的。完成后，将会进入<code>scheduleWork</code>，<code>react</code>整个调度的章节源码阅读。</p>\n","site":{"data":{}},"excerpt":"<p>react-dom后续updateContainer部分。阅读React包的源码版本为<strong>16.8.6</strong>。<br></p>","more":"<br>&emsp;&emsp;在<a href=\"../reactCode-react-2-2020-03-22/\" target=\"_blank\">上一章节中</a>我们看到了<code>react-dom</code>中<code>render</code>函数的逻辑是给传入的React组件创建了一个<code>fiberRoot</code>对象，用于标识它是整个应用的起点，上面拥有很多应用更新相关的表示符。然后创建对应的<code>fiber</code>给<code>fiberRoot</code>节点，<code>fiber</code>对象是每一个<code>ReactElement</code>都拥有的节点，它标识了更新时间的一些信息，props和state的一些信息，以及相关联的节点信息。<code>ReactElement</code>彼此是通过一个单向链表的数据结构联系在一起的。</p>\n<p>&emsp;&emsp;这一章我们接着<code>legacyRenderSubtreeIntoContainer</code>函数创建完<code>fiber</code>相关对象的部分，查看接下来<code>updateContainer</code>相关的逻辑。我们先回顾一下这部分的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">legacyRenderSubtreeIntoContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  children: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: DOMContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"regexp\">//</span> 是否复用dom节点，服务端渲染调用</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  forceHydrate: boolean,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略创建fiber节点相关部分逻辑</span></span><br><span class=\"line\">  <span class=\"comment\">// 初次使用render不存在root节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略创建fiber节点相关部分逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Initial mount should not be batched.</span></span><br><span class=\"line\">    unbatchedUpdates(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fiberRoot = root._internalRoot;</span><br><span class=\"line\">    <span class=\"comment\">// 有无callback 逻辑同上</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> originalCallback = callback;</span><br><span class=\"line\">      callback = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> instance = getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">        originalCallback.call(instance);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Update</span></span><br><span class=\"line\">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getPublicRootInstance(fiberRoot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们先看<code>callback</code>部分的处理，在<code>render</code>函数中<code>callback</code>是传入的第三个参数，根据<code>react文档</code>，该回调将在组件被渲染或更新之后被执行，并且在非箭头函数的情况下，该回调的this指向<code>render</code>渲染的那个组件。我们先来回顾下这个入参的使用方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> instance = render(</span><br><span class=\"line\">  &lt;Hello text=<span class=\"string\">\"123\"</span> /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page\"</span>),</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">this === instance === Hello</span></span><br><span class=\"line\"><span class=\"comment\">Hello &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  isMounted: (...)</span></span><br><span class=\"line\"><span class=\"comment\">  replaceState: (...)</span></span><br><span class=\"line\"><span class=\"comment\">  props: &#123;text: \"123\"&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  context: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  refs: &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  updater: &#123;isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  _reactInternalFiber: FiberNode &#123;tag: 1, key: null, stateNode: Hello, elementType: ƒ, type: ƒ, …&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  _reactInternalInstance: &#123;_processChildContext: ƒ&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  state: null</span></span><br><span class=\"line\"><span class=\"comment\">  __proto__: Component</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在上述代码中使用<code>render</code>函数时，传入了一个匿名函数作为<code>render</code>的第三个入参，并打印了<code>this</code>，然后将<code>render</code>函数的返回值赋予了<code>instance</code>变量并打印出来。我们可以看到，输出的是一个对象信息，其实使用过<code>react</code>测试相关诸如<code>react-test-renderer</code>等框架的，应该对这个<code>instance</code>比较熟悉。它标志了一个由<code>fiberRoot</code>开始的完整的组件信息。</p>\n<p>&emsp;&emsp;现在回到源码，我们可以看到我们在调用<code>render</code>时候，<code>callback</code>的this和<code>render</code>返回的组件<code>instance</code>信息都是由<code>getPublicRootInstance</code>创建的。<code>react</code>将我们传入的<code>callback</code>赋值给了变量<code>originalCallback</code>，然后声明一个新的<code>callback</code>，新的<code>callback</code>创建了一个<code>instance</code>，然后用<code>call</code>让<code>originalCallback</code>的this指向它，把它传入到了<code>updateContainer</code>的<code>callback</code>参数中。</p>\n<p>&emsp;&emsp;至于<code>getPublicRootInstance</code>如何创建一个<code>Instance</code>的细节代码与主流程牵扯不大，这边就跳过。只要知道该函数根据<code>fiberRoot</code>提供了一个<code>Instance</code>信息对象即可。接着我们可以看到，无论是否是初次使用<code>render</code>函数（初次调用render函数不存在root节点），<code>legacyRenderSubtreeIntoContainer</code>都调用了<code>updateContainer</code>方法，区别就是初次使用<code>render</code>的时候，<code>updateContainer</code>是在<code>unbatchedUpdates</code>方法回调中使用的。<code>unbatchedUpdates</code>做的事情实际就是在<code>render</code>初次调用的时候，不用去批量更新<code>updateContainer</code>，这个函数做的事情仅仅是改变了几个标志符，然后立即更新了<code>CallbackQueue</code>，我们也略过这部分逻辑，重点来看一下<code>updateContainer</code>相关的部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateContainer</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: OpaqueRoot, <span class=\"regexp\">//</span> root</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  parentComponent: ?React$Component&lt;any, any&gt;, <span class=\"regexp\">//</span> 根节点是null</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// fiberRoot的current为fiberRoot的fiber对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> current = container.current;</span><br><span class=\"line\">  <span class=\"comment\">// 获得当前时间到js加载完时间的时间差值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> currentTime = requestCurrentTime();</span><br><span class=\"line\">  <span class=\"comment\">// 得到当前update的配置</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class=\"line\">  <span class=\"comment\">// @todo 及时更新，计算出了一个expirationTime</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> expirationTime = computeExpirationForFiber(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    current,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">return</span> updateContainerAtExpirationTime(</span><br><span class=\"line\">    element, <span class=\"comment\">// 更新的element</span></span><br><span class=\"line\">    container, <span class=\"comment\">// root</span></span><br><span class=\"line\">    parentComponent, <span class=\"comment\">// 根节点null</span></span><br><span class=\"line\">    expirationTime,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>updateContainer</code>函数中，采用的全是语义化的函数，整个代码逻辑看上去非常的清晰。先是拿到<code>container</code>上的<code>current</code>对象，即<code>rootFiber</code>上的<code>Fiber</code>对象。然后根据<code>requestCurrentTime</code>取得一个<code>currentTime</code>,计算出一个<code>suspenseConfig</code>用于标识的配置，计算<code>computeExpirationForFiber</code>然后使用<code>computeExpirationForFiber</code>更新<code>container</code>。其实我们不用太深究细节的<code>currentTime</code>和<code>suspenseConfig</code>是什么，而把重点放在<code>ExpirationTime</code>上面。我们来简单看下<code>requestCurrentSuspenseConfig</code>和<code>requestCurrentSuspenseConfig</code>做了什么。这边把涉及到变量相关的内容都摘抄出来汇总在一起。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in react-reconciler/src/ReactFiberExpirationTime.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> NoWork = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> NoContext = <span class=\"comment\">/*                    */</span> <span class=\"number\">0b000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> BatchedContext = <span class=\"comment\">/*               */</span> <span class=\"number\">0b000001</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> EventContext = <span class=\"comment\">/*                 */</span> <span class=\"number\">0b000010</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> DiscreteEventContext = <span class=\"comment\">/*         */</span> <span class=\"number\">0b000100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> LegacyUnbatchedContext = <span class=\"comment\">/*       */</span> <span class=\"number\">0b001000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> RenderContext = <span class=\"comment\">/*                */</span> <span class=\"number\">0b010000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> CommitContext = <span class=\"comment\">/*                */</span> <span class=\"number\">0b100000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Describes where we are in the React execution stack</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> executionContext: number = NoContext;</span><br><span class=\"line\"><span class=\"keyword\">let</span> currentEventTime: number = NoWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requestCurrentTime</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((executionContext &amp; (RenderContext | CommitContext)) !== NoContext) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// We're inside React, so it's fine to read the actual time.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> msToExpirationTime(now());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// We're not inside React, so we may be in the middle of a browser event.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currentEventTime !== NoWork) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use the same start time for all updates until we enter React again.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentEventTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// This is the first update since React yielded. Compute a new start time.</span></span><br><span class=\"line\">  currentEventTime = msToExpirationTime(now());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> currentEventTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>requestCurrentTime</code>其实做的事情很简单，就是根据当前标识的几个状态，返回对应的时间，这里涉及<strong>位操作来标识状态</strong>的一种设计模式，不了解具体原理可以查看我的<a href=\"../../js/numberStoreInBit-2020-03-30/\" target=\"_blank\">《关于JS中number位(Bit)操作的一些思考》</a>的文章。</p>\n<p>&emsp;&emsp;<code>requestCurrentTime</code>三个<code>if</code>分支情况分别对应：在<em>React调度中</em>，在<em>浏览器事件调度中</em>，以及<em>初次更新</em>。这里面的now方法可以理解为就相当于<code>Date.now()</code>。在非<em>浏览器事件</em>情况下，就是通过当前的时间戳计算出了一个<code>currentEventTime</code>并返回。<code>msToExpirationTime</code>具体做了什么，<code>expirationTime</code>是什么，我们卖个关子，到下个专门讲<code>expirationTime</code>章节的时候一起来看。</p>\n<p>&emsp;&emsp;我们继续来看<code>requestCurrentSuspenseConfig</code>的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// shared/ReactSharedInternals.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ReactSharedInternals =</span><br><span class=\"line\">  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prevent newer renderers from RTE when used with older react package versions.</span></span><br><span class=\"line\"><span class=\"comment\">// Current owner and dispatcher used to share the same ref,</span></span><br><span class=\"line\"><span class=\"comment\">// but PR #14548 split them out to better support the react-debug-tools package.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!ReactSharedInternals.hasOwnProperty(<span class=\"string\">'ReactCurrentDispatcher'</span>)) &#123;</span><br><span class=\"line\">  ReactSharedInternals.ReactCurrentDispatcher = &#123;</span><br><span class=\"line\">    current: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!ReactSharedInternals.hasOwnProperty(<span class=\"string\">'ReactCurrentBatchConfig'</span>)) &#123;</span><br><span class=\"line\">  ReactSharedInternals.ReactCurrentBatchConfig = &#123;</span><br><span class=\"line\">    suspense: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ReactSharedInternals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// react-reconciler/src/ReactFiberSuspenseConfig.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;ReactCurrentBatchConfig&#125; = ReactSharedInternals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requestCurrentSuspenseConfig</span>(<span class=\"params\"></span>): <span class=\"title\">null</span> | <span class=\"title\">SuspenseConfig</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ReactCurrentBatchConfig.suspense;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;Suspense是React新加入的特性，能够让你的组件等待某些操作完成之后，再进行渲染。<code>requestCurrentSuspenseConfig</code>就是设置一个对应的标识符以便进行后续的操作。</p>\n<p>&emsp;&emsp;我们继续看函数<code>updateContainer</code>的逻辑剩下的两个函数<code>computeExpirationForFiber</code>和<code>updateContainerAtExpirationTime</code>。<code>computeExpirationForFiber</code>代码其实也都是根据标识符来进行计算不同的<code>ExpirationTime</code>，其中涉及到的几种不同的计算<code>expirationTime</code>的方式我们统一放到下一章专门讲<code>expirationTime</code>的部分来解释。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeExpirationForFiber</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  currentTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  fiber: Fiber,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">ExpirationTime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mode = fiber.mode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((mode &amp; BatchedMode) === NoMode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Sync;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    得到一个调度的优先级</span></span><br><span class=\"line\"><span class=\"comment\">    几种优先级方式</span></span><br><span class=\"line\"><span class=\"comment\">    ImmediatePriority 99</span></span><br><span class=\"line\"><span class=\"comment\">    UserBlockingPriority 98</span></span><br><span class=\"line\"><span class=\"comment\">    NormalPriority 97</span></span><br><span class=\"line\"><span class=\"comment\">    LowPriority 96</span></span><br><span class=\"line\"><span class=\"comment\">    IdlePriority 95</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> priorityLevel = getCurrentPriorityLevel();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((mode &amp; ConcurrentMode) === NoMode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> priorityLevel === ImmediatePriority ? Sync : Batched;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((executionContext &amp; RenderContext) !== NoContext) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use whatever time we're already rendering</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> renderExpirationTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> expirationTime;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (suspenseConfig !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Compute an expiration time based on the Suspense timeout.</span></span><br><span class=\"line\">    expirationTime = computeSuspenseExpiration(</span><br><span class=\"line\">      currentTime,</span><br><span class=\"line\">      suspenseConfig.timeoutMs | <span class=\"number\">0</span> || LOW_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Compute an expiration time based on the Scheduler priority.</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (priorityLevel) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> ImmediatePriority:</span><br><span class=\"line\">        expirationTime = Sync;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> UserBlockingPriority:</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Rename this to computeUserBlockingExpiration</span></span><br><span class=\"line\">        expirationTime = computeInteractiveExpiration(currentTime);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> NormalPriority:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> LowPriority: <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Handle LowPriority</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Rename this to... something better.</span></span><br><span class=\"line\">        expirationTime = computeAsyncExpiration(currentTime);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> IdlePriority:</span><br><span class=\"line\">        expirationTime = Never;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        invariant(<span class=\"literal\">false</span>, <span class=\"string\">'Expected a valid priority level'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// If we're in the middle of rendering a tree, do not update at the same</span></span><br><span class=\"line\">  <span class=\"comment\">// expiration time that is already rendering.</span></span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> We shouldn't have to do this if the update is on a different root.</span></span><br><span class=\"line\">  <span class=\"comment\">// Refactor computeExpirationForFiber + scheduleUpdate so we have access to</span></span><br><span class=\"line\">  <span class=\"comment\">// the root when we check for this condition.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (workInProgressRoot !== <span class=\"literal\">null</span> &amp;&amp; expirationTime === renderExpirationTime) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This is a trick to move this update into a separate batch</span></span><br><span class=\"line\">    expirationTime -= <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> expirationTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;计算出了<code>ExpirationTime</code>之后接着就使用<code>ExpirationTime</code>来更新<code>container</code>了。调用<code>updateContainerAtExpirationTime</code>的部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateContainerAtExpirationTime</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  container: OpaqueRoot,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  expirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> If this is a nested container, this won't be the root.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> current = container.current;</span><br><span class=\"line\">  <span class=\"comment\">// 省略掉context相关的逻辑...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> scheduleRootUpdate(</span><br><span class=\"line\">    current,</span><br><span class=\"line\">    element,</span><br><span class=\"line\">    expirationTime,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">    callback,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">scheduleRootUpdate</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  current: Fiber, <span class=\"regexp\">//</span> 当前的Fiber节点</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  element: ReactNodeList,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  expirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// @todo 标记节点哪些地方需要更新，创建update对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = createUpdate(expirationTime, suspenseConfig);</span><br><span class=\"line\">  <span class=\"comment\">// Caution: React DevTools currently depends on this property</span></span><br><span class=\"line\">  <span class=\"comment\">// being called \"element\".</span></span><br><span class=\"line\">  update.payload = &#123;element&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    update.callback = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 创建或者更新enqueue的过程</span></span><br><span class=\"line\">  enqueueUpdate(current, update);</span><br><span class=\"line\">  <span class=\"comment\">// 开始进行任务调度</span></span><br><span class=\"line\">  scheduleWork(current, expirationTime);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> expirationTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;省略掉<code>updateContainerAtExpirationTime</code>函数中关于<code>context</code>以及<code>DEV</code>相关的逻辑后，剩下的便是直接调用<code>scheduleRootUpdate</code>，调度root的更新。<code>scheduleRootUpdate</code>中首先创建了一个<code>update</code>对象，然后把<code>element</code>赋值给这个对象的payload属性。接着针对callback做一个处理，如果callback存在，赋值给<code>update</code>对象。使用enqueueUpdate对<code>update</code>对象进行创建。最后开始任务调度。这一章的代码就看到<code>scheduleWork</code>，如何进行调度工作为止。调度流程是一个很庞大的工作流程，到后面会拆分几个章节来讲这部分的代码。目前只需要知道<code>scheduleWork</code>是对当前标识的<code>update</code>对象进行更新调度到dom上面的流程就可以了。我们接下来来看一下这个<code>update</code>对象到底是什么。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createUpdate</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  expirationTime: ExpirationTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  suspenseConfig: null | SuspenseConfig,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Update</span>&lt;*&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    expirationTime,</span><br><span class=\"line\">    suspenseConfig,</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      tag对应</span></span><br><span class=\"line\"><span class=\"comment\">      export const UpdateState = 0;</span></span><br><span class=\"line\"><span class=\"comment\">      export const ReplaceState = 1;</span></span><br><span class=\"line\"><span class=\"comment\">      export const ForceUpdate = 2;</span></span><br><span class=\"line\"><span class=\"comment\">      // 渲染的错误</span></span><br><span class=\"line\"><span class=\"comment\">      export const CaptureUpdate = 3;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    tag: UpdateState,</span><br><span class=\"line\">    <span class=\"comment\">// 渲染更新的功能，比如element(render初始化的时候)，setState对应的就是第一个参数</span></span><br><span class=\"line\">    payload: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    callback: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 指向下一个更新</span></span><br><span class=\"line\">    next: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    nextEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>update</code>对象其实和<code>fiber</code>对象一样，就是一个带着标识符的对象。它是用来标识<code>react</code>当前需要更新的内容。有多少个<code>update</code>，就表示<code>react</code>接下来需要更新多少内容。比如<code>render</code>函数调用，或者<code>setState</code>调用的时候，都会创建<code>update</code>更新对象。<code>update</code>对象彼此通过next相互连接，形成一个单向链表的数据结构。了解了<code>update</code>，我们再来看一下<code>enqueueUpdate</code>做了什么。</p>\n<p>&emsp;&emsp;<code>enqueueUpdate</code>其实就是把<code>update</code>放入<code>updateQueue</code>的过程。而<code>updateQueue</code>其实就是用于保存记录<code>update</code>的一个队列。我调整了函数的顺序，把<code>createUpdateQueue</code>放在最前面，先来看一下创建的<code>updateQueue</code>内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createUpdateQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\">baseState: State</span>): <span class=\"title\">UpdateQueue</span>&lt;<span class=\"title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次更新完的state</span></span><br><span class=\"line\">    baseState,</span><br><span class=\"line\">    <span class=\"comment\">// 单向链表记录最后第一项</span></span><br><span class=\"line\">    firstUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 错误捕获产生的update</span></span><br><span class=\"line\">    firstCapturedUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastCapturedUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    firstEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    firstCapturedEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastCapturedEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>UpdateQueue</code>也是一个标识符的对象，它维护着所有需要进行更新的<code>update</code>。<code>firstUpdate</code>和<code>lastUpdate</code>分别指向第一个和最后一个<code>update</code>。<code>firstCapturedUpdate</code>和<code>lastCapturedUpdate</code>用来指向抓取的错误更新的<code>update</code>，是为新增加的<code>componentDidCatch</code>来服务的。了解了<code>UpdateQueue</code>是什么了之后，我们来看下<code>enqueueUpdate</code>做了什么。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enqueueUpdate</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\">fiber: Fiber, update: Update&lt;State&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Update queues are created lazily.</span></span><br><span class=\"line\">  <span class=\"comment\">// current(fiber对象)到workInProcess的对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> alternate = fiber.alternate;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> queue1;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> queue2;</span><br><span class=\"line\">  <span class=\"comment\">// react dom render第一次的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (alternate === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There's only one fiber.</span></span><br><span class=\"line\">    queue1 = fiber.updateQueue;</span><br><span class=\"line\">    queue2 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue1 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There are two owners.</span></span><br><span class=\"line\">    queue1 = fiber.updateQueue;</span><br><span class=\"line\">    queue2 = alternate.updateQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue1 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (queue2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Neither fiber has an update queue. Create new ones.</span></span><br><span class=\"line\">        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class=\"line\">        queue2 = alternate.updateQueue = createUpdateQueue(</span><br><span class=\"line\">          alternate.memoizedState,</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class=\"line\">        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (queue2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class=\"line\">        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Both owners have an update queue.</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 第一次渲染时queue2为null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (queue2 === <span class=\"literal\">null</span> || queue1 === queue2) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There's only a single queue.</span></span><br><span class=\"line\">    appendUpdateToQueue(queue1, update);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There are two queues. We need to append the update to both queues,</span></span><br><span class=\"line\">    <span class=\"comment\">// while accounting for the persistent structure of the list — we don't</span></span><br><span class=\"line\">    <span class=\"comment\">// want the same update to be added multiple times.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue1.lastUpdate === <span class=\"literal\">null</span> || queue2.lastUpdate === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// One of the queues is not empty. We must add the update to both queues.</span></span><br><span class=\"line\">      appendUpdateToQueue(queue1, update);</span><br><span class=\"line\">      appendUpdateToQueue(queue2, update);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Both queues are non-empty. The last update is the same in both lists,</span></span><br><span class=\"line\">      <span class=\"comment\">// because of structural sharing. So, only append to one of the lists.</span></span><br><span class=\"line\">      appendUpdateToQueue(queue1, update);</span><br><span class=\"line\">      <span class=\"comment\">// But we still need to update the `lastUpdate` pointer of queue2.</span></span><br><span class=\"line\">      queue2.lastUpdate = update;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendUpdateToQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  update: Update&lt;State&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Append the update to the end of the list.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (queue.lastUpdate === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Queue is empty</span></span><br><span class=\"line\">    queue.firstUpdate = queue.lastUpdate = update;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    queue.lastUpdate.next = update;</span><br><span class=\"line\">    queue.lastUpdate = update;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 除 baseState/firstUpdate/lastUpdate之外的属性全部置为null</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneUpdateQueue</span>&lt;<span class=\"title\">State</span>&gt;(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  currentQueue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">UpdateQueue</span>&lt;<span class=\"title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class=\"line\">    baseState: currentQueue.baseState,</span><br><span class=\"line\">    firstUpdate: currentQueue.firstUpdate,</span><br><span class=\"line\">    lastUpdate: currentQueue.lastUpdate,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> With resuming, if we bail out and resuse the child tree, we should</span></span><br><span class=\"line\">    <span class=\"comment\">// keep these effects.</span></span><br><span class=\"line\">    firstCapturedUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastCapturedUpdate: <span class=\"literal\">null</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    firstEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    firstCapturedEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    lastCapturedEffect: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>enqueueUpdate</code>根据<code>fiber.alternate</code>的情况，来获得<code>queue1</code>和<code>queue2</code>，添加到<code>UpdateQueue</code>的<code>firstUpdate</code>和<code>lastUpdate</code>上面去。<code>alternate</code>用来标识<code>current(fiber对象)到workInProcess的对象</code>关系，后续讲到<code>scheduleWork</code>部分的时候会提及到。</p>\n<p>&emsp;&emsp;本章节讲述了<code>updateContainer</code>部分的逻辑，提及到了一个<code>ExpirationTime</code>的概念，它是<code>react</code>进行任务调度的依据，根据不同的调度等级获得不同的<code>ExpirationTime</code>。然后根据<code>ExpirationTime</code>和<code>Fiber</code>对象，创建<code>update</code>对象和维护<code>update</code>对象的<code>UpdateQueue</code>队列，它们是<code>react</code>应用更新的依据和基础。完成之后就可以使用<code>scheduleWork</code>函数进行调度工作了。</p>\n<p>&emsp;&emsp;本章挖下的两个大坑，一个<code>ExpirationTime</code>，它到底代表什么，是如何计算的，将在下章阐述。阐述完毕<code>ExpirationTime</code>后，会带一下<code>setState</code>的内容，你会发现<code>setState</code>的代码逻辑和<code>render</code>代码逻辑结构是非常接近的。完成后，将会进入<code>scheduleWork</code>，<code>react</code>整个调度的章节源码阅读。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-2.2","date":"2019-07-14T11:40:00.000Z","_content":"## 第二章第二节 层次性数据和闭包性质\n&emsp;&emsp;本节对复合的层次性数据抽象进行重点探讨，讨论如何进行复合数据进行处理。\n<!--more-->\n&emsp;&emsp;在第一节当中，我们学习了使用`cons`作为一种粘合剂的方式，把两个数据**粘在**一起，形成一种复合的数据结构。这种数据结构的表示方式，可以形象的形容为**盒子和指针**(形象见图)。\n&emsp;&emsp;实际上构成序对的数据中，可以存在序对。即可以嵌套序对构成，如`(cons (cons 1 2) 3)`。这种数据结构复合的能力，lisp社区称之为**闭包**。这与常规意义的闭包概念不同，如`js`中，闭包指的是在变量作用域外，仍然能范问操作该变量的能力，通常使用两个函数来实现。lisp社区的闭包的概念为`如果某种组合数据对象满足闭包性质，那就是说，通过它组合数据对象得到的结果本身还可以通过同样的操作再进行组合`，你可以简单的理解为俄罗斯套娃的概念。\n![盒子与指针的闭包](/blog/public/imgs/scip/scip2-2.jpg)\n&emsp;&emsp;本章将对层次性数据和闭包性质进行重点的探讨。\n## 2.2层次性数据和闭包性质\n\n### 2.2.1 序列的表示\n&emsp;&emsp;我们可以通过连续嵌套`cons`形成一个类似于`链表`的数据结构。\n```scheme\n(cons 1\n    (cons 2 \n        (cons 3\n            ;; 实际上，现在scheme版本已经移除了 nil 关键字，改为使用()空表来代替\n            (cons 4 nil))))\n```\n&emsp;&emsp;这么去定义未免太过繁琐，scheme提供了使用list的方式来定义一个表(类似于数组的概念)。你可以使用`car`取出表的第一项，也可以使用`cdr`取出表剩余的部分。\n```scheme\n(list <a1> <a2> <a3>)\n;; 等价于\n(const <a1> (cons <a2> (cons <a3> nil)))\n(define list-demo (list 1 2 3 4))\n(display list-demo) ;; (1 2 3 4)\n(car list-demo) ;; 1\n(cdr list-demo) ;; (2 3 4)\n```\n\n#### 对表的操作\n&emsp;&emsp;接下来我们来进行表操作，实现一个`list-ref`，接受一个表以及任意数字n，运行返回该表的第n项。\n```scheme\n;; 利用表的特性，完成一个表操作函数list-ref，给定数字取出表的n项的数据\n(define (list-ref input-list n)\n  (if (= n 0)  \n    (car input-list)\n    (list-ref (cdr input-list) (- n 1))\n  )\n)\n```\n&emsp;&emsp;schme提供了`null?`函数来判断一个表是否是空表，该函数接受一个表为参数，返回一个布尔值，为`#t`时为空表。依靠`null?`函数我们可以写出`length`函数，接受一个表为参数，返回该表存在多少项。简单思路为：\n1. 空表的length为0\n2. 任意一个表的length为该表`cdr`的长度加一\n\n```scheme\n(define (length input-list)\n  (if (null? input-list)\n    0\n    (+ 1 (length (cdr input-list)))\n  )\n)\n```\n\n#### 对表的映射\n&emsp;&emsp;现在先来实现一个函数`scale-list`。该函数可以对表的所有参数做一个缩放操作，它接受两个参数，一个为表，另一个为缩放的倍数，返回一个经过缩放的新表。\n```scheme\n(define (scale-list items factor)\n    (if (null? items)\n        ;; 如果该表为空返回一个空表\n        ()\n        (cons (* (car items) factor)\n            (scale-list (car items) factor)\n        )\n    )\n)\n```\n&emsp;&emsp;实际上我们可以根据这个逻辑抽象出一个一般的过程，不单单只对表做一个缩放的操作，而是可以传入一个外部定义的过程，能够让使用者自己去**定义对表每一项的操作**。我们做的是抽象出来通用的逻辑:\n\n1. 对表的循环\n2. 对表每一项做外部定义的操作\n3. 返回每一项操作后连接的新表\n\n```scheme\n(define (map proc items)\n    (if \n        (null? items) ()\n        (cons (proc (car items))\n            (map proc (cdr items))\n        )\n    )\n)\n```\n&emsp;&emsp;这就是高阶`map`函数用到的抽象思想。从作用上来看，`map`帮助我们建起了一层抽象屏障，将实现表变换的过程，与如何提取表元素以及组合的细节隔离开来。这种抽象也提供了新的灵活性，使我们有可能保持从序列到序列的变换操作框架的同时，改变序列实现的低层细节。\n\n### 2.2.2 层次性结构\n&emsp;&emsp;由于list本身还能嵌套list的特性，很可能定义出来一个存在基本项和list的list。比如：\n```scheme\n(define list-list (list (list 1 2) 3 4))\n(display list-list) ;; ((1 2) 3 4)\n```\n&emsp;&emsp;此时多list嵌套，形成一个类似树状的复合结构。如图：\n![树状](/blog/public/imgs/scip/scip2-3.jpg)\n&emsp;&emsp;scheme提供了`pair?`函数，可以判断一个值是否为序对。我们可以利用`pair?`以前前面`length`函数的抽象思想，写出一个可以递归树结构长度的函数`count-leaves`。\n```scheme\n(define (count-leaves x)\n    (cond \n        ;; 空值返回0\n        ((null? x) 0)\n        ;; 非list返回1(因为此时为基本型)\n        ((mot (pair? x)) 1)\n        ;; 否则拆除基本型已经剩余的表\n        (else (+ (count-leaves (car x)) (count-leaves (cdr x))))\n    )\n)\n```\n\n### 2.2.3 序列作为一种约定的界面\n&emsp;&emsp;我们先来使用`count-leaves`的抽象过程，来定义一个新的函数`sum-odd-squares`，该函数接受一个**树形的多级嵌套列表**，返回其中奇数项的平方和。\n```scheme\n(define (sum-odd-squares tree)\n    (cond\n        ((null? tree) 0)\n        ((not (pair? tree))\n\n            (if (odd? tree) (square tree) 0))\n        (else (+ (sum-odd-squares (car tree))\n                 (sum-odd-squares (cdr tree))))\n        )\n    )\n)\n```\n&emsp;&emsp;实际上这整个过程体现了一个类似**信号流**的概念，树的每一项，像是信号一样流过一个**通用的抽象过程**，经过筛选处理后，返回一个经过处理的**结果**。如图：\n![序对抽象过程](/blog/public/imgs/scip/scip2-4.jpg)\n&emsp;&emsp;我们需要改变`sum-odd-squares`函数，抽象出来**信号流动**的过程，而不是仅仅只能处理奇数的平方和。让外部可以定义筛选树结构项的方式和如何去进行累计的处理。我们需要定义两个函数，一个`filter`函数，能够筛选出来树中所有**符合外部定义的项**(如大于等于1)。一个`accumlate`，类似于用于累计计算的一个函数。\n&emsp;&emsp;我们没有把这个抽象过程合在一起，而是单独定义两个模块`filter`和`accumlate`。实际上这种拆分的模块化的方式，更有利于程序的维护以及可读性。此时我们就可以使用**信号流**的感觉，`tree -> filter -> accumlate -> result`，把tree流出一个想要的结果。\n```scheme\n;; filter funciton\n;; @param {lambda} predicate handler tree function\n;; @param {list} sequence tree data\n;; @return {list} filtered tree\n(define (filter predicate sequence)\n  (cond ((null? sequence) ())\n    ;; 判定取出的数字是否符合\n    ((predicate (car sequence))\n      (cons (car sequence) (filter predicate (cdr sequence)))\n    )\n    (else (filter predicate (cdr sequence)))\n  )\n)\n\n;; filter funciton\n;; @param {lambda} op handler accumlate function\n;; @param {number} initial initial accumlate value\n;; @param {list} sequence tree data\n;; @return {number} accumlate\n(define (accumlate op initial sequence)\n  ;;\n  (if (null? sequence)\n      initial\n      ;; 这里op可以接受类似 + - * / 的符号\n      (op\n        (car sequence)\n        (accumlate op initial (cdr sequence))\n      )\n  )\n)\n```\n&emsp;&emsp;此时我们可以使用`accumlate`和`filter`来改写一下上面的`sum-odd-squares`。\n```scheme\n(define (sum-odd-squares tree)\n    (accumlate + 0 \n        (map square\n            (filter odd?\n                (\n                    (enumerate-tree tree)\n                )\n            )\n        )\n    )\n)\n```\n&emsp;&emsp;`tree -> enumerate-tree -> filter -> map -> accumlate -> result`是不是很像一个**流动的信号流**。上一个函数的结果是下一个函数的输入。不单是增加了代码的可读性，还合理的拆分了模块，似的后期的维护和改动都能很方便的去执行。这种思想类似于函柯科里化的思想。","source":"_posts/scip/scip(chap2-2).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-2.2\ndate: 2019/7/14 19:40:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第二章第二节 层次性数据和闭包性质\n&emsp;&emsp;本节对复合的层次性数据抽象进行重点探讨，讨论如何进行复合数据进行处理。\n<!--more-->\n&emsp;&emsp;在第一节当中，我们学习了使用`cons`作为一种粘合剂的方式，把两个数据**粘在**一起，形成一种复合的数据结构。这种数据结构的表示方式，可以形象的形容为**盒子和指针**(形象见图)。\n&emsp;&emsp;实际上构成序对的数据中，可以存在序对。即可以嵌套序对构成，如`(cons (cons 1 2) 3)`。这种数据结构复合的能力，lisp社区称之为**闭包**。这与常规意义的闭包概念不同，如`js`中，闭包指的是在变量作用域外，仍然能范问操作该变量的能力，通常使用两个函数来实现。lisp社区的闭包的概念为`如果某种组合数据对象满足闭包性质，那就是说，通过它组合数据对象得到的结果本身还可以通过同样的操作再进行组合`，你可以简单的理解为俄罗斯套娃的概念。\n![盒子与指针的闭包](/blog/public/imgs/scip/scip2-2.jpg)\n&emsp;&emsp;本章将对层次性数据和闭包性质进行重点的探讨。\n## 2.2层次性数据和闭包性质\n\n### 2.2.1 序列的表示\n&emsp;&emsp;我们可以通过连续嵌套`cons`形成一个类似于`链表`的数据结构。\n```scheme\n(cons 1\n    (cons 2 \n        (cons 3\n            ;; 实际上，现在scheme版本已经移除了 nil 关键字，改为使用()空表来代替\n            (cons 4 nil))))\n```\n&emsp;&emsp;这么去定义未免太过繁琐，scheme提供了使用list的方式来定义一个表(类似于数组的概念)。你可以使用`car`取出表的第一项，也可以使用`cdr`取出表剩余的部分。\n```scheme\n(list <a1> <a2> <a3>)\n;; 等价于\n(const <a1> (cons <a2> (cons <a3> nil)))\n(define list-demo (list 1 2 3 4))\n(display list-demo) ;; (1 2 3 4)\n(car list-demo) ;; 1\n(cdr list-demo) ;; (2 3 4)\n```\n\n#### 对表的操作\n&emsp;&emsp;接下来我们来进行表操作，实现一个`list-ref`，接受一个表以及任意数字n，运行返回该表的第n项。\n```scheme\n;; 利用表的特性，完成一个表操作函数list-ref，给定数字取出表的n项的数据\n(define (list-ref input-list n)\n  (if (= n 0)  \n    (car input-list)\n    (list-ref (cdr input-list) (- n 1))\n  )\n)\n```\n&emsp;&emsp;schme提供了`null?`函数来判断一个表是否是空表，该函数接受一个表为参数，返回一个布尔值，为`#t`时为空表。依靠`null?`函数我们可以写出`length`函数，接受一个表为参数，返回该表存在多少项。简单思路为：\n1. 空表的length为0\n2. 任意一个表的length为该表`cdr`的长度加一\n\n```scheme\n(define (length input-list)\n  (if (null? input-list)\n    0\n    (+ 1 (length (cdr input-list)))\n  )\n)\n```\n\n#### 对表的映射\n&emsp;&emsp;现在先来实现一个函数`scale-list`。该函数可以对表的所有参数做一个缩放操作，它接受两个参数，一个为表，另一个为缩放的倍数，返回一个经过缩放的新表。\n```scheme\n(define (scale-list items factor)\n    (if (null? items)\n        ;; 如果该表为空返回一个空表\n        ()\n        (cons (* (car items) factor)\n            (scale-list (car items) factor)\n        )\n    )\n)\n```\n&emsp;&emsp;实际上我们可以根据这个逻辑抽象出一个一般的过程，不单单只对表做一个缩放的操作，而是可以传入一个外部定义的过程，能够让使用者自己去**定义对表每一项的操作**。我们做的是抽象出来通用的逻辑:\n\n1. 对表的循环\n2. 对表每一项做外部定义的操作\n3. 返回每一项操作后连接的新表\n\n```scheme\n(define (map proc items)\n    (if \n        (null? items) ()\n        (cons (proc (car items))\n            (map proc (cdr items))\n        )\n    )\n)\n```\n&emsp;&emsp;这就是高阶`map`函数用到的抽象思想。从作用上来看，`map`帮助我们建起了一层抽象屏障，将实现表变换的过程，与如何提取表元素以及组合的细节隔离开来。这种抽象也提供了新的灵活性，使我们有可能保持从序列到序列的变换操作框架的同时，改变序列实现的低层细节。\n\n### 2.2.2 层次性结构\n&emsp;&emsp;由于list本身还能嵌套list的特性，很可能定义出来一个存在基本项和list的list。比如：\n```scheme\n(define list-list (list (list 1 2) 3 4))\n(display list-list) ;; ((1 2) 3 4)\n```\n&emsp;&emsp;此时多list嵌套，形成一个类似树状的复合结构。如图：\n![树状](/blog/public/imgs/scip/scip2-3.jpg)\n&emsp;&emsp;scheme提供了`pair?`函数，可以判断一个值是否为序对。我们可以利用`pair?`以前前面`length`函数的抽象思想，写出一个可以递归树结构长度的函数`count-leaves`。\n```scheme\n(define (count-leaves x)\n    (cond \n        ;; 空值返回0\n        ((null? x) 0)\n        ;; 非list返回1(因为此时为基本型)\n        ((mot (pair? x)) 1)\n        ;; 否则拆除基本型已经剩余的表\n        (else (+ (count-leaves (car x)) (count-leaves (cdr x))))\n    )\n)\n```\n\n### 2.2.3 序列作为一种约定的界面\n&emsp;&emsp;我们先来使用`count-leaves`的抽象过程，来定义一个新的函数`sum-odd-squares`，该函数接受一个**树形的多级嵌套列表**，返回其中奇数项的平方和。\n```scheme\n(define (sum-odd-squares tree)\n    (cond\n        ((null? tree) 0)\n        ((not (pair? tree))\n\n            (if (odd? tree) (square tree) 0))\n        (else (+ (sum-odd-squares (car tree))\n                 (sum-odd-squares (cdr tree))))\n        )\n    )\n)\n```\n&emsp;&emsp;实际上这整个过程体现了一个类似**信号流**的概念，树的每一项，像是信号一样流过一个**通用的抽象过程**，经过筛选处理后，返回一个经过处理的**结果**。如图：\n![序对抽象过程](/blog/public/imgs/scip/scip2-4.jpg)\n&emsp;&emsp;我们需要改变`sum-odd-squares`函数，抽象出来**信号流动**的过程，而不是仅仅只能处理奇数的平方和。让外部可以定义筛选树结构项的方式和如何去进行累计的处理。我们需要定义两个函数，一个`filter`函数，能够筛选出来树中所有**符合外部定义的项**(如大于等于1)。一个`accumlate`，类似于用于累计计算的一个函数。\n&emsp;&emsp;我们没有把这个抽象过程合在一起，而是单独定义两个模块`filter`和`accumlate`。实际上这种拆分的模块化的方式，更有利于程序的维护以及可读性。此时我们就可以使用**信号流**的感觉，`tree -> filter -> accumlate -> result`，把tree流出一个想要的结果。\n```scheme\n;; filter funciton\n;; @param {lambda} predicate handler tree function\n;; @param {list} sequence tree data\n;; @return {list} filtered tree\n(define (filter predicate sequence)\n  (cond ((null? sequence) ())\n    ;; 判定取出的数字是否符合\n    ((predicate (car sequence))\n      (cons (car sequence) (filter predicate (cdr sequence)))\n    )\n    (else (filter predicate (cdr sequence)))\n  )\n)\n\n;; filter funciton\n;; @param {lambda} op handler accumlate function\n;; @param {number} initial initial accumlate value\n;; @param {list} sequence tree data\n;; @return {number} accumlate\n(define (accumlate op initial sequence)\n  ;;\n  (if (null? sequence)\n      initial\n      ;; 这里op可以接受类似 + - * / 的符号\n      (op\n        (car sequence)\n        (accumlate op initial (cdr sequence))\n      )\n  )\n)\n```\n&emsp;&emsp;此时我们可以使用`accumlate`和`filter`来改写一下上面的`sum-odd-squares`。\n```scheme\n(define (sum-odd-squares tree)\n    (accumlate + 0 \n        (map square\n            (filter odd?\n                (\n                    (enumerate-tree tree)\n                )\n            )\n        )\n    )\n)\n```\n&emsp;&emsp;`tree -> enumerate-tree -> filter -> map -> accumlate -> result`是不是很像一个**流动的信号流**。上一个函数的结果是下一个函数的输入。不单是增加了代码的可读性，还合理的拆分了模块，似的后期的维护和改动都能很方便的去执行。这种思想类似于函柯科里化的思想。","slug":"scip/scip(chap2-2)","published":1,"updated":"2020-06-11T01:43:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy200209r2vprspcjzg","content":"<h2 id=\"第二章第二节-层次性数据和闭包性质\"><a href=\"#第二章第二节-层次性数据和闭包性质\" class=\"headerlink\" title=\"第二章第二节 层次性数据和闭包性质\"></a>第二章第二节 层次性数据和闭包性质</h2><p>&emsp;&emsp;本节对复合的层次性数据抽象进行重点探讨，讨论如何进行复合数据进行处理。<br><a id=\"more\"></a><br>&emsp;&emsp;在第一节当中，我们学习了使用<code>cons</code>作为一种粘合剂的方式，把两个数据<strong>粘在</strong>一起，形成一种复合的数据结构。这种数据结构的表示方式，可以形象的形容为<strong>盒子和指针</strong>(形象见图)。<br>&emsp;&emsp;实际上构成序对的数据中，可以存在序对。即可以嵌套序对构成，如<code>(cons (cons 1 2) 3)</code>。这种数据结构复合的能力，lisp社区称之为<strong>闭包</strong>。这与常规意义的闭包概念不同，如<code>js</code>中，闭包指的是在变量作用域外，仍然能范问操作该变量的能力，通常使用两个函数来实现。lisp社区的闭包的概念为<code>如果某种组合数据对象满足闭包性质，那就是说，通过它组合数据对象得到的结果本身还可以通过同样的操作再进行组合</code>，你可以简单的理解为俄罗斯套娃的概念。<br><img src=\"/blog/public/imgs/scip/scip2-2.jpg\" alt=\"盒子与指针的闭包\"><br>&emsp;&emsp;本章将对层次性数据和闭包性质进行重点的探讨。</p>\n<h2 id=\"2-2层次性数据和闭包性质\"><a href=\"#2-2层次性数据和闭包性质\" class=\"headerlink\" title=\"2.2层次性数据和闭包性质\"></a>2.2层次性数据和闭包性质</h2><h3 id=\"2-2-1-序列的表示\"><a href=\"#2-2-1-序列的表示\" class=\"headerlink\" title=\"2.2.1 序列的表示\"></a>2.2.1 序列的表示</h3><p>&emsp;&emsp;我们可以通过连续嵌套<code>cons</code>形成一个类似于<code>链表</code>的数据结构。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> <span class=\"hljs-number\">1</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> <span class=\"hljs-number\">2</span> </span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> <span class=\"hljs-number\">3</span></span><br><span class=\"line\">            <span class=\"hljs-comment\">;; 实际上，现在scheme版本已经移除了 nil 关键字，改为使用()空表来代替</span></span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> <span class=\"hljs-number\">4</span> nil))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这么去定义未免太过繁琐，scheme提供了使用list的方式来定义一个表(类似于数组的概念)。你可以使用<code>car</code>取出表的第一项，也可以使用<code>cdr</code>取出表剩余的部分。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> &lt;a1&gt; &lt;a2&gt; &lt;a3&gt;)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 等价于</span></span><br><span class=\"line\">(<span class=\"hljs-name\">const</span> &lt;a1&gt; (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> &lt;a2&gt; (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> &lt;a3&gt; nil)))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> list-demo (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> list-demo) <span class=\"hljs-comment\">;; (1 2 3 4)</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> list-demo) <span class=\"hljs-comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> list-demo) <span class=\"hljs-comment\">;; (2 3 4)</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对表的操作\"><a href=\"#对表的操作\" class=\"headerlink\" title=\"对表的操作\"></a>对表的操作</h4><p>&emsp;&emsp;接下来我们来进行表操作，实现一个<code>list-ref</code>，接受一个表以及任意数字n，运行返回该表的第n项。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 利用表的特性，完成一个表操作函数list-ref，给定数字取出表的n项的数据</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list-ref</span></span> input-list n)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> n <span class=\"hljs-number\">0</span>)  </span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> input-list)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list-ref</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> input-list) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> n <span class=\"hljs-number\">1</span>))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;schme提供了<code>null?</code>函数来判断一个表是否是空表，该函数接受一个表为参数，返回一个布尔值，为<code>#t</code>时为空表。依靠<code>null?</code>函数我们可以写出<code>length</code>函数，接受一个表为参数，返回该表存在多少项。简单思路为：</p>\n<ol>\n<li>空表的length为0</li>\n<li>任意一个表的length为该表<code>cdr</code>的长度加一</li>\n</ol>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">length</span></span> input-list)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> input-list)</span><br><span class=\"line\">    <span class=\"hljs-number\">0</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> <span class=\"hljs-number\">1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">length</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> input-list)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"对表的映射\"><a href=\"#对表的映射\" class=\"headerlink\" title=\"对表的映射\"></a>对表的映射</h4><p>&emsp;&emsp;现在先来实现一个函数<code>scale-list</code>。该函数可以对表的所有参数做一个缩放操作，它接受两个参数，一个为表，另一个为缩放的倍数，返回一个经过缩放的新表。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">scale-list</span> items factor)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> items)</span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 如果该表为空返回一个空表</span></span><br><span class=\"line\">        ()</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> items) factor)</span><br><span class=\"line\">            (<span class=\"hljs-name\">scale-list</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> items) factor)</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上我们可以根据这个逻辑抽象出一个一般的过程，不单单只对表做一个缩放的操作，而是可以传入一个外部定义的过程，能够让使用者自己去<strong>定义对表每一项的操作</strong>。我们做的是抽象出来通用的逻辑:</p>\n<ol>\n<li>对表的循环</li>\n<li>对表每一项做外部定义的操作</li>\n<li>返回每一项操作后连接的新表</li>\n</ol>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">map</span></span> proc items)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> </span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> items) ()</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\">proc</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> items))</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">map</span></span> proc (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> items))</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这就是高阶<code>map</code>函数用到的抽象思想。从作用上来看，<code>map</code>帮助我们建起了一层抽象屏障，将实现表变换的过程，与如何提取表元素以及组合的细节隔离开来。这种抽象也提供了新的灵活性，使我们有可能保持从序列到序列的变换操作框架的同时，改变序列实现的低层细节。</p>\n<h3 id=\"2-2-2-层次性结构\"><a href=\"#2-2-2-层次性结构\" class=\"headerlink\" title=\"2.2.2 层次性结构\"></a>2.2.2 层次性结构</h3><p>&emsp;&emsp;由于list本身还能嵌套list的特性，很可能定义出来一个存在基本项和list的list。比如：<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> list-list (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>) <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> list-list) <span class=\"hljs-comment\">;; ((1 2) 3 4)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时多list嵌套，形成一个类似树状的复合结构。如图：<br><img src=\"/blog/public/imgs/scip/scip2-3.jpg\" alt=\"树状\"><br>&emsp;&emsp;scheme提供了<code>pair?</code>函数，可以判断一个值是否为序对。我们可以利用<code>pair?</code>以前前面<code>length</code>函数的抽象思想，写出一个可以递归树结构长度的函数<code>count-leaves</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">count-leaves</span> x)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> </span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 空值返回0</span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> x) <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 非list返回1(因为此时为基本型)</span></span><br><span class=\"line\">        ((<span class=\"hljs-name\">mot</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">pair?</span></span> x)) <span class=\"hljs-number\">1</span>)</span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 否则拆除基本型已经剩余的表</span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">count-leaves</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> x)) (<span class=\"hljs-name\">count-leaves</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> x))))</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-3-序列作为一种约定的界面\"><a href=\"#2-2-3-序列作为一种约定的界面\" class=\"headerlink\" title=\"2.2.3 序列作为一种约定的界面\"></a>2.2.3 序列作为一种约定的界面</h3><p>&emsp;&emsp;我们先来使用<code>count-leaves</code>的抽象过程，来定义一个新的函数<code>sum-odd-squares</code>，该函数接受一个<strong>树形的多级嵌套列表</strong>，返回其中奇数项的平方和。<br><figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sum-odd-squares</span> tree)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> tree) <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">pair?</span></span> tree))</span><br><span class=\"line\"></span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">odd?</span></span> tree) (<span class=\"hljs-name\">square</span> tree) <span class=\"hljs-number\">0</span>))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">sum-odd-squares</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> tree))</span><br><span class=\"line\">                 (<span class=\"hljs-name\">sum-odd-squares</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> tree))))</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上这整个过程体现了一个类似<strong>信号流</strong>的概念，树的每一项，像是信号一样流过一个<strong>通用的抽象过程</strong>，经过筛选处理后，返回一个经过处理的<strong>结果</strong>。如图：<br><img src=\"/blog/public/imgs/scip/scip2-4.jpg\" alt=\"序对抽象过程\"><br>&emsp;&emsp;我们需要改变<code>sum-odd-squares</code>函数，抽象出来<strong>信号流动</strong>的过程，而不是仅仅只能处理奇数的平方和。让外部可以定义筛选树结构项的方式和如何去进行累计的处理。我们需要定义两个函数，一个<code>filter</code>函数，能够筛选出来树中所有<strong>符合外部定义的项</strong>(如大于等于1)。一个<code>accumlate</code>，类似于用于累计计算的一个函数。<br>&emsp;&emsp;我们没有把这个抽象过程合在一起，而是单独定义两个模块<code>filter</code>和<code>accumlate</code>。实际上这种拆分的模块化的方式，更有利于程序的维护以及可读性。此时我们就可以使用<strong>信号流</strong>的感觉，<code>tree -&gt; filter -&gt; accumlate -&gt; result</code>，把tree流出一个想要的结果。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; filter funciton</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @param &#123;lambda&#125; predicate handler tree function</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @param &#123;list&#125; sequence tree data</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @return &#123;list&#125; filtered tree</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">filter</span> predicate sequence)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> sequence) ())</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 判定取出的数字是否符合</span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">predicate</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> sequence))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> sequence) (<span class=\"hljs-name\">filter</span> predicate (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> sequence)))</span><br><span class=\"line\">    )</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">filter</span> predicate (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> sequence)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; filter funciton</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @param &#123;lambda&#125; op handler accumlate function</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @param &#123;number&#125; initial initial accumlate value</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @param &#123;list&#125; sequence tree data</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; @return &#123;number&#125; accumlate</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">accumlate</span> op initial sequence)</span><br><span class=\"line\">  <span class=\"hljs-comment\">;;</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> sequence)</span><br><span class=\"line\">      initial</span><br><span class=\"line\">      <span class=\"hljs-comment\">;; 这里op可以接受类似 + - * / 的符号</span></span><br><span class=\"line\">      (<span class=\"hljs-name\">op</span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> sequence)</span><br><span class=\"line\">        (<span class=\"hljs-name\">accumlate</span> op initial (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> sequence))</span><br><span class=\"line\">      )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时我们可以使用<code>accumlate</code>和<code>filter</code>来改写一下上面的<code>sum-odd-squares</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sum-odd-squares</span> tree)</span><br><span class=\"line\">    (<span class=\"hljs-name\">accumlate</span> + <span class=\"hljs-number\">0</span> </span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">map</span></span> square</span><br><span class=\"line\">            (<span class=\"hljs-name\">filter</span> odd?</span><br><span class=\"line\">                (</span><br><span class=\"line\">                    (<span class=\"hljs-name\">enumerate-tree</span> tree)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>tree -&gt; enumerate-tree -&gt; filter -&gt; map -&gt; accumlate -&gt; result</code>是不是很像一个<strong>流动的信号流</strong>。上一个函数的结果是下一个函数的输入。不单是增加了代码的可读性，还合理的拆分了模块，似的后期的维护和改动都能很方便的去执行。这种思想类似于函柯科里化的思想。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第二章第二节-层次性数据和闭包性质\"><a href=\"#第二章第二节-层次性数据和闭包性质\" class=\"headerlink\" title=\"第二章第二节 层次性数据和闭包性质\"></a>第二章第二节 层次性数据和闭包性质</h2><p>&emsp;&emsp;本节对复合的层次性数据抽象进行重点探讨，讨论如何进行复合数据进行处理。<br></p>","more":"<br>&emsp;&emsp;在第一节当中，我们学习了使用<code>cons</code>作为一种粘合剂的方式，把两个数据<strong>粘在</strong>一起，形成一种复合的数据结构。这种数据结构的表示方式，可以形象的形容为<strong>盒子和指针</strong>(形象见图)。<br>&emsp;&emsp;实际上构成序对的数据中，可以存在序对。即可以嵌套序对构成，如<code>(cons (cons 1 2) 3)</code>。这种数据结构复合的能力，lisp社区称之为<strong>闭包</strong>。这与常规意义的闭包概念不同，如<code>js</code>中，闭包指的是在变量作用域外，仍然能范问操作该变量的能力，通常使用两个函数来实现。lisp社区的闭包的概念为<code>如果某种组合数据对象满足闭包性质，那就是说，通过它组合数据对象得到的结果本身还可以通过同样的操作再进行组合</code>，你可以简单的理解为俄罗斯套娃的概念。<br><img src=\"/blog/public/imgs/scip/scip2-2.jpg\" alt=\"盒子与指针的闭包\"><br>&emsp;&emsp;本章将对层次性数据和闭包性质进行重点的探讨。</p>\n<h2 id=\"2-2层次性数据和闭包性质\"><a href=\"#2-2层次性数据和闭包性质\" class=\"headerlink\" title=\"2.2层次性数据和闭包性质\"></a>2.2层次性数据和闭包性质</h2><h3 id=\"2-2-1-序列的表示\"><a href=\"#2-2-1-序列的表示\" class=\"headerlink\" title=\"2.2.1 序列的表示\"></a>2.2.1 序列的表示</h3><p>&emsp;&emsp;我们可以通过连续嵌套<code>cons</code>形成一个类似于<code>链表</code>的数据结构。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">1</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">2</span> </span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span></span><br><span class=\"line\">            <span class=\"comment\">;; 实际上，现在scheme版本已经移除了 nil 关键字，改为使用()空表来代替</span></span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">4</span> nil))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这么去定义未免太过繁琐，scheme提供了使用list的方式来定义一个表(类似于数组的概念)。你可以使用<code>car</code>取出表的第一项，也可以使用<code>cdr</code>取出表剩余的部分。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list</span></span> &lt;a1&gt; &lt;a2&gt; &lt;a3&gt;)</span><br><span class=\"line\"><span class=\"comment\">;; 等价于</span></span><br><span class=\"line\">(<span class=\"name\">const</span> &lt;a1&gt; (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> &lt;a2&gt; (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> &lt;a3&gt; nil)))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-demo (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">display</span></span> list-demo) <span class=\"comment\">;; (1 2 3 4)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">car</span></span> list-demo) <span class=\"comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> list-demo) <span class=\"comment\">;; (2 3 4)</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"对表的操作\"><a href=\"#对表的操作\" class=\"headerlink\" title=\"对表的操作\"></a>对表的操作</h4><p>&emsp;&emsp;接下来我们来进行表操作，实现一个<code>list-ref</code>，接受一个表以及任意数字n，运行返回该表的第n项。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 利用表的特性，完成一个表操作函数list-ref，给定数字取出表的n项的数据</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> input-list n)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)  </span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">car</span></span> input-list)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> input-list) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;schme提供了<code>null?</code>函数来判断一个表是否是空表，该函数接受一个表为参数，返回一个布尔值，为<code>#t</code>时为空表。依靠<code>null?</code>函数我们可以写出<code>length</code>函数，接受一个表为参数，返回该表存在多少项。简单思路为：</p>\n<ol>\n<li>空表的length为0</li>\n<li>任意一个表的length为该表<code>cdr</code>的长度加一</li>\n</ol>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> input-list)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> input-list)</span><br><span class=\"line\">    <span class=\"number\">0</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> input-list)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"对表的映射\"><a href=\"#对表的映射\" class=\"headerlink\" title=\"对表的映射\"></a>对表的映射</h4><p>&emsp;&emsp;现在先来实现一个函数<code>scale-list</code>。该函数可以对表的所有参数做一个缩放操作，它接受两个参数，一个为表，另一个为缩放的倍数，返回一个经过缩放的新表。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">scale-list</span> items factor)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> items)</span><br><span class=\"line\">        <span class=\"comment\">;; 如果该表为空返回一个空表</span></span><br><span class=\"line\">        ()</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> items) factor)</span><br><span class=\"line\">            (<span class=\"name\">scale-list</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> items) factor)</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上我们可以根据这个逻辑抽象出一个一般的过程，不单单只对表做一个缩放的操作，而是可以传入一个外部定义的过程，能够让使用者自己去<strong>定义对表每一项的操作</strong>。我们做的是抽象出来通用的逻辑:</p>\n<ol>\n<li>对表的循环</li>\n<li>对表每一项做外部定义的操作</li>\n<li>返回每一项操作后连接的新表</li>\n</ol>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> proc items)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> </span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> items) ()</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\">proc</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> items))</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">map</span></span> proc (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> items))</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这就是高阶<code>map</code>函数用到的抽象思想。从作用上来看，<code>map</code>帮助我们建起了一层抽象屏障，将实现表变换的过程，与如何提取表元素以及组合的细节隔离开来。这种抽象也提供了新的灵活性，使我们有可能保持从序列到序列的变换操作框架的同时，改变序列实现的低层细节。</p>\n<h3 id=\"2-2-2-层次性结构\"><a href=\"#2-2-2-层次性结构\" class=\"headerlink\" title=\"2.2.2 层次性结构\"></a>2.2.2 层次性结构</h3><p>&emsp;&emsp;由于list本身还能嵌套list的特性，很可能定义出来一个存在基本项和list的list。比如：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-list (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">display</span></span> list-list) <span class=\"comment\">;; ((1 2) 3 4)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时多list嵌套，形成一个类似树状的复合结构。如图：<br><img src=\"/blog/public/imgs/scip/scip2-3.jpg\" alt=\"树状\"><br>&emsp;&emsp;scheme提供了<code>pair?</code>函数，可以判断一个值是否为序对。我们可以利用<code>pair?</code>以前前面<code>length</code>函数的抽象思想，写出一个可以递归树结构长度的函数<code>count-leaves</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">count-leaves</span> x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> </span><br><span class=\"line\">        <span class=\"comment\">;; 空值返回0</span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> x) <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">;; 非list返回1(因为此时为基本型)</span></span><br><span class=\"line\">        ((<span class=\"name\">mot</span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x)) <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\">;; 否则拆除基本型已经剩余的表</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">count-leaves</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x)) (<span class=\"name\">count-leaves</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x))))</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-3-序列作为一种约定的界面\"><a href=\"#2-2-3-序列作为一种约定的界面\" class=\"headerlink\" title=\"2.2.3 序列作为一种约定的界面\"></a>2.2.3 序列作为一种约定的界面</h3><p>&emsp;&emsp;我们先来使用<code>count-leaves</code>的抽象过程，来定义一个新的函数<code>sum-odd-squares</code>，该函数接受一个<strong>树形的多级嵌套列表</strong>，返回其中奇数项的平方和。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sum-odd-squares</span> tree)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> tree) <span class=\"number\">0</span>)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> tree))</span><br><span class=\"line\"></span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> tree) (<span class=\"name\">square</span> tree) <span class=\"number\">0</span>))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">sum-odd-squares</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> tree))</span><br><span class=\"line\">                 (<span class=\"name\">sum-odd-squares</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tree))))</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上这整个过程体现了一个类似<strong>信号流</strong>的概念，树的每一项，像是信号一样流过一个<strong>通用的抽象过程</strong>，经过筛选处理后，返回一个经过处理的<strong>结果</strong>。如图：<br><img src=\"/blog/public/imgs/scip/scip2-4.jpg\" alt=\"序对抽象过程\"><br>&emsp;&emsp;我们需要改变<code>sum-odd-squares</code>函数，抽象出来<strong>信号流动</strong>的过程，而不是仅仅只能处理奇数的平方和。让外部可以定义筛选树结构项的方式和如何去进行累计的处理。我们需要定义两个函数，一个<code>filter</code>函数，能够筛选出来树中所有<strong>符合外部定义的项</strong>(如大于等于1)。一个<code>accumlate</code>，类似于用于累计计算的一个函数。<br>&emsp;&emsp;我们没有把这个抽象过程合在一起，而是单独定义两个模块<code>filter</code>和<code>accumlate</code>。实际上这种拆分的模块化的方式，更有利于程序的维护以及可读性。此时我们就可以使用<strong>信号流</strong>的感觉，<code>tree -&gt; filter -&gt; accumlate -&gt; result</code>，把tree流出一个想要的结果。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; filter funciton</span></span><br><span class=\"line\"><span class=\"comment\">;; @param &#123;lambda&#125; predicate handler tree function</span></span><br><span class=\"line\"><span class=\"comment\">;; @param &#123;list&#125; sequence tree data</span></span><br><span class=\"line\"><span class=\"comment\">;; @return &#123;list&#125; filtered tree</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">filter</span> predicate sequence)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> sequence) ())</span><br><span class=\"line\">    <span class=\"comment\">;; 判定取出的数字是否符合</span></span><br><span class=\"line\">    ((<span class=\"name\">predicate</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> sequence))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> sequence) (<span class=\"name\">filter</span> predicate (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> sequence)))</span><br><span class=\"line\">    )</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">filter</span> predicate (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> sequence)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; filter funciton</span></span><br><span class=\"line\"><span class=\"comment\">;; @param &#123;lambda&#125; op handler accumlate function</span></span><br><span class=\"line\"><span class=\"comment\">;; @param &#123;number&#125; initial initial accumlate value</span></span><br><span class=\"line\"><span class=\"comment\">;; @param &#123;list&#125; sequence tree data</span></span><br><span class=\"line\"><span class=\"comment\">;; @return &#123;number&#125; accumlate</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">accumlate</span> op initial sequence)</span><br><span class=\"line\">  <span class=\"comment\">;;</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> sequence)</span><br><span class=\"line\">      initial</span><br><span class=\"line\">      <span class=\"comment\">;; 这里op可以接受类似 + - * / 的符号</span></span><br><span class=\"line\">      (<span class=\"name\">op</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> sequence)</span><br><span class=\"line\">        (<span class=\"name\">accumlate</span> op initial (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> sequence))</span><br><span class=\"line\">      )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此时我们可以使用<code>accumlate</code>和<code>filter</code>来改写一下上面的<code>sum-odd-squares</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sum-odd-squares</span> tree)</span><br><span class=\"line\">    (<span class=\"name\">accumlate</span> + <span class=\"number\">0</span> </span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">map</span></span> square</span><br><span class=\"line\">            (<span class=\"name\">filter</span> odd?</span><br><span class=\"line\">                (</span><br><span class=\"line\">                    (<span class=\"name\">enumerate-tree</span> tree)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>tree -&gt; enumerate-tree -&gt; filter -&gt; map -&gt; accumlate -&gt; result</code>是不是很像一个<strong>流动的信号流</strong>。上一个函数的结果是下一个函数的输入。不单是增加了代码的可读性，还合理的拆分了模块，似的后期的维护和改动都能很方便的去执行。这种思想类似于函柯科里化的思想。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-2.3","date":"2019-07-21T13:20:00.000Z","_content":"## 第二章 第三节 符号数据\n&emsp;&emsp;利用符号(打标)的概念，形成抽象数据屏障，保证外部调库的精准性。\n<!--more-->\n&emsp;&emsp;本节将引入**符号**的概念，使得前两章单纯使用数据粘合构造而成的复合数据更有张合理，能够表示更多的复合数据结构。\n\n&emsp;&emsp;这里的所谓**符号**，在我看来是类似于**类**的概念。通过特定的**符号**对某一类数据结构进行标注，然后创建一系列方法针对性的对其进行操作。因为`scheme`的函数式编程的特定，不得不说，这一节**符号**用起来让人感觉有些别扭。\n\n&emsp;&emsp;首先是如何使用`scheme`来创建一个**符号**。`scheme`当中使用`'`以及`list`相关的操作可以创建一个**符号**。\n```scheme\n(list 'a 'b) ;; (a b)\n'(a b c) ;; (a b c)\n```\n&emsp;&emsp;这里的符号你可以简单理解为字符串，也可以理解为一个独特的打标。同时，`scheme`给我们提供了`eq?`函数，用于判断传入的两个**符号**是否相等。我们可以使用这个函数创建一个名为`memq`函数，接受一个**符号**和**符号组(list)**，用于判断**符号组**当中是否存在该**符号**。\n```scheme\n(define (memq item x)\n    (cond\n        ((null? x) #f)\n        ((eq? item (car x)) x)\n        (else (memq item (cdr x)))))\n```\n&emsp;&emsp;书本上第一个实例使用了**求导**来让人理解**符号**在复合数据结构当中的扩充作用。但该实例还要配解**导数**的相对复杂数学概念，这里崛起，使用第二个实例**集合**的表示来进行展示。\n\n&emsp;&emsp;**集合**可以把它理解为一个枚举列表，就是一个不带重复元素的list。我们从基本的集合开始，一步步扩充复合数据结构，来体会**符号**在构建新的复合数据结构当中所加入带来的能力。\n\n&emsp;&emsp;先来创建两个最基本的与**集合**相关的方法，`element-of-set?`和`adjoin-set`。一个用于判断集合当中是否存在某个元素，另一个用于往集合当中添加元素。\n```scheme\n;; x element\n;; set set-list\n;; return #t or #f\n(define (element-of-set? x set)\n    (cond\n        ((null? set) #f)\n        ((eq? x (car set)) #t)\n        (else (element-of-set? x (cdr set)))))\n\n;; 如果set当中存在x 那么就直接返回set\n(define (adjoin-set x set)\n  (if (element-of-set? x set) set (cons x set)))\n```\n&emsp;&emsp;接下来可以创建操作两个集合相关的一些方法，如求两个集合的**交集**和**并集**。\n```scheme\n;; 两个集合的交集\n(define (intersection-set set1 set2)\n  (cond\n    ((or (null? set1) (null? set2) ()))\n    ;; 如果set1取出项是set2的成员，那么把他填入\n    ((element-of-set? (car set1) set2)\n      (cons (car set1) (intersection-set (cdr set1) set2)))\n    (else (intersection-set (cdr set1) set2))\n  )\n)\n;; 两个集合的并集\n(define (union-set set1 set2)\n  (cond\n    ;; 只去操作set1\n    ((null? set1) set2)\n    ;; 如果set1的这一项是set2的成员\n    ((element-of-set? (car set1) set2)\n      (intersection-set (cdr set1) set2))\n    ;; 否则就把set1这一项放入到set2当中\n    (else (intersection-set (cdr set1) (cons (car set1) set2)))\n  )\n)\n```\n&emsp;&emsp;这里我们可以发现一个问题，`intersection-set`和`union-set`方法每次操作两个**集合**的时候，都需要从集合1当中取出一个元素，在集合2当中遍历完全。集合1长度固定为`n`，当集合2的长度以n速度增长的时候，整个程序的运算将会以`m * n`增加整个运行的复杂度。如何去减少这个计算的复杂度，最好的办法就是使得集合本身按照某种规则进行**排序**。\n\n&emsp;&emsp;我们把复杂情况简单化，在只考虑数值的情况下，存在一个`(1 2 3 4)`的集合，当我拿出一个0来和第一项进行比较时，0比1小，此时就不需要再去循环剩下的元素，因为剩下的元素只会比1大，因此0肯定不存在于集合`(1 2 3 4)`当中。\n\n&emsp;&emsp;这样看来，最坏情况，拿出的数字比集合的最后一项还要大，我们将会比较到整个**集合**的长度n，比较到最后一项；最好的情况拿出的数字比集合的第一项还要小，只需要比较一次。这样平均下来，我们程序的复杂度预期降低到`n / 2`。\n\n&emsp;&emsp;在排序集合的情况下，我们可以优化上面的几个函数如下：\n```scheme\n;; 加速集合查找，似的集合按照顺序排列\n;; 在按照顺序排列的集合情况下优化的element-of-set\n(define (element-of-set? x set)\n  (cond\n    ((null? set) #f)\n    ((= x (car set)) #t)\n    ((< x) (car set) #f)\n    (else (element-of-set? x (cdr set)))\n  )\n)\n;; 在按照顺序排列的集合情况下优化的intersection-set\n(define (intersection-set set1 set2)\n  (if (or (null? set1) (null? set2))\n    () \n    (let\n      (\n        (x1 (car set1))\n        (x2 (car set2)))\n      (cond(\n        ;; 相当的时候直接放入\n        ((= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2))))\n        ;;小于直接就pass\n        ((< x1 x2)\n          (intersection-set (cdr set1) set2))\n        ;; 大于继续\n        ((< x2 x1)\n          (intersection-set set1 (cdr set2)))))\n    )\n  )\n)\n;; 优化的adjoin-set\n(define (adjoin-set x set)\n  (cond\n    ((null? set) (cons x set))\n    ((< x (car set) (cons x set)))\n    ((= x (car set) set))\n    ((> x (car set) (adjoin-set x (cdr set))))\n  )\n)\n```\n&emsp;&emsp;实际上复杂度还可以进一步进行优化，就是使用**二叉树**的数据结构。**二叉树**的基本特征是根节点出发，左侧节点的值永远小于右侧节点。如下图，为`{1,3,5,7,9,11}`的集合的二叉树排版形式。\n![二叉树](/blog/public/imgs/scip/scip2-5.jpg)\n&emsp;&emsp;不难发现，当一个集合长度为`n`。使用横向的排序方式进行搜索的时候，取出一项之后，剩下的长度为`n - 1`。但是使用二叉树进行比较的时候，走一个分支，每一次都能**减少一半**的数据规模。即下一次的数据规模为`n = next ^ 2 -> log 2 n -> log n`。(这里书上复杂度以及二叉树的讨论是建立在**二叉平衡树**这一概念上的，即一颗二叉树中，左节点和右节点的数量大致相等，实际的数据结构中，二叉树的分叉情况更为复杂)。\n\n&emsp;&emsp;我们可以把**根节点**、**左节点**、**右节点**看成一个列表，使用list来定义出来一个树结构。\n```scheme\n;; 二叉集合树\n(define (entry tree) (car tree))\n(define (left-branch tree) (cadr tree))\n(define (right-branch tree) (caddr tree))\n(define (make-tree entry left right) (list entry left right))\n```\n&emsp;&emsp;根据二叉树的数据结构，我们可以优化我们之前的对集合的操作。\n```scheme\n;; 二叉树改写 element-of-set, 建立在二叉平衡树的基础上\n(define (element-of-set? x set)\n  (cond\n    ((null? set) #f)\n    ((= x (entry tree)) #t)\n    ((< x (entry tree)) (element-of-set? x (left-branch set)))\n    ((> x (entry tree)) (element-of-set? x (right-branch set)))\n  )\n)\n;; adjoin-set 二叉树改写\n(define (adjoin-set x set)\n  (cond\n    ((null? set) (make-tree x '() '()))\n    ((= x (entry set)) set)\n    ((< x (entry set))\n      (make-tree (entry set)\n        (adjoin-set x (left-branch set))\n        (right-branch set)))\n    ((> x (entry set))\n      (make-tree (entry set)\n        (left-branch set)\n        (adjoin-set x (right-branch set))))\n  )\n)\n```\n&emsp;&emsp;上面无论是**排序集合**还是**二叉树**都是针对纯数字集合的情况下，现在如果是加上字母表之后，应该如何处理，是我们接下来需要讨论的问题。其实思路很简单，就是使用**编码**的概念，把**字母**映射为**数字**。最常见的是使用**等长编码**就行映射，如：\n```javascript\n/*\n    如下二进制编码 三个为一位等长编码\n    A 000 B 001 C 010 D 011\n    存在如下英文\n    BACDA\n    就会被编译成\n    001000010011000\n*/\n```\n&emsp;&emsp;等长编码的特定就是每个字符映射的二进制长度是一样的。方便之处就是不需要特殊的分隔符，就能够对连续的编码进行反编译回字符。缺点也很明显，就是浪费了储存空间。我们不妨和**非等长**字符比较一下。\n```javascript\n/*\n    如下二进制编码 非等长编码\n    A 0 B 10 C 100 D 1\n    存在如下英文\n    BACDA\n    就会被编译成\n    10 0 100 1 0\n*/\n```\n&emsp;&emsp;我们不难发现非等长的编码大大缩小了储存的长度，但是这也导致了一个问题，因为每一个字符表示的二进制码长度是不同的，你不知道到哪里完结。此时就需要加入特定的分隔符来进行处理（莫斯码就是著名的非等长编码，它对常用英文如字母E的编码为1位，大大缩小了传递信息所占用的空间）。\n\n&emsp;&emsp;实际上使用二叉树的数据结构来改造**等长编码**能够综合达到节省空间以及不用分隔符的优点，这种树形结构被称为**Huffman树**。如图：\n![Huffman树](/blog/public/imgs/scip/scip2-6.jpeg)\n&emsp;&emsp;在Huffman树中，0和1两个数字代表往**左节点**或者**右节点**走，当移动到字母位的时候，就能够把相应的编码转换为字母。如何判断当前的节点为**空表**还是**树叶子节点**，此时我们可以引入**符号标识**的概念，通过打标一个`leaf`，来标识当前节点为**树叶子节点**，告诉程序应该继续走下去。每一个**树叶子节点**都应该存在一个`leaf`标识，一个权重，以及对应的**字符符号**。\n&emsp;&emsp;我们可以根据这个基础写出一系列操作**Huffman Tree**的相关函数以及其对应的解码过程。\n```scheme\n;; huffman tree\n;; define huffman tree\n;; 一个树包含标识 leaf 符号 权重\n(define (make-leaf symbol weight)\n  (list 'leaf symbol weight)\n)\n;; 是否是树结构\n(define (leaf? object)\n  (eq? (car object) 'leaf)\n)\n;; 获得树的符号\n(define (symbol-leaf x) (cadr x))\n;; 获得树的权重\n(define (weight-leaf x) (caddr x))\n\n(define (left-branch tree) (car tree))\n(define (right-branch tree) (cadr tree))\n(define (symbols tree)\n  (if (leaf? tree)\n    (list (symbol-leaf tree))\n    (caddr tree)\n  )\n)\n(define (weight tree)\n  (if (leaf? tree)\n    (weight-leaf tree)\n    (cadddr tree)\n  )\n)\n;; make tree\n(define (make-code-tree left right)\n  (list left right \n    （append (symbols left) (symbols right))\n     (+ (weight left) (weight right))\n  )\n)\n(define (decode bit tree)\n  (define (decode-1 bite current-branch)\n    (if (null? bite)\n      ;;空的返回一个空表\n      '()\n      (let \n      ((next-branch (choose-branch (car bits) current-branch)))\n      ;; 如果下一个树杈是树形 \n      (if (leaf? next-branch)\n        (cons\n          ;; 获得树的符号列表\n          (symbol-leaf next-branch)\n          ;;\n          (decode-1 (cdr bits) next-branch)\n        )\n        ;; 1\n        (decode-1 (cdr bits) next-branch)\n      )\n      )\n    )\n  )\n  (decode-1 bits tree)\n)\n```\n\n&emsp;&emsp;本章引入的**符号数据**的概念结合书实例来看最大的作用是进行一个**打标**。通过标识，来启用对应的操作特定数据结构的方法，从而在多种复合数据输入的时候，能够准确的进行特定的数据结构操作。这种方式在**函数式**编程，递归为王的`scheme`中使用显得十分的怪异，在我的理解看来，是面向对象编程思想的另类诠释。","source":"_posts/scip/scip(chap2-3).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-2.3\ndate: 2019/7/21 21:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第二章 第三节 符号数据\n&emsp;&emsp;利用符号(打标)的概念，形成抽象数据屏障，保证外部调库的精准性。\n<!--more-->\n&emsp;&emsp;本节将引入**符号**的概念，使得前两章单纯使用数据粘合构造而成的复合数据更有张合理，能够表示更多的复合数据结构。\n\n&emsp;&emsp;这里的所谓**符号**，在我看来是类似于**类**的概念。通过特定的**符号**对某一类数据结构进行标注，然后创建一系列方法针对性的对其进行操作。因为`scheme`的函数式编程的特定，不得不说，这一节**符号**用起来让人感觉有些别扭。\n\n&emsp;&emsp;首先是如何使用`scheme`来创建一个**符号**。`scheme`当中使用`'`以及`list`相关的操作可以创建一个**符号**。\n```scheme\n(list 'a 'b) ;; (a b)\n'(a b c) ;; (a b c)\n```\n&emsp;&emsp;这里的符号你可以简单理解为字符串，也可以理解为一个独特的打标。同时，`scheme`给我们提供了`eq?`函数，用于判断传入的两个**符号**是否相等。我们可以使用这个函数创建一个名为`memq`函数，接受一个**符号**和**符号组(list)**，用于判断**符号组**当中是否存在该**符号**。\n```scheme\n(define (memq item x)\n    (cond\n        ((null? x) #f)\n        ((eq? item (car x)) x)\n        (else (memq item (cdr x)))))\n```\n&emsp;&emsp;书本上第一个实例使用了**求导**来让人理解**符号**在复合数据结构当中的扩充作用。但该实例还要配解**导数**的相对复杂数学概念，这里崛起，使用第二个实例**集合**的表示来进行展示。\n\n&emsp;&emsp;**集合**可以把它理解为一个枚举列表，就是一个不带重复元素的list。我们从基本的集合开始，一步步扩充复合数据结构，来体会**符号**在构建新的复合数据结构当中所加入带来的能力。\n\n&emsp;&emsp;先来创建两个最基本的与**集合**相关的方法，`element-of-set?`和`adjoin-set`。一个用于判断集合当中是否存在某个元素，另一个用于往集合当中添加元素。\n```scheme\n;; x element\n;; set set-list\n;; return #t or #f\n(define (element-of-set? x set)\n    (cond\n        ((null? set) #f)\n        ((eq? x (car set)) #t)\n        (else (element-of-set? x (cdr set)))))\n\n;; 如果set当中存在x 那么就直接返回set\n(define (adjoin-set x set)\n  (if (element-of-set? x set) set (cons x set)))\n```\n&emsp;&emsp;接下来可以创建操作两个集合相关的一些方法，如求两个集合的**交集**和**并集**。\n```scheme\n;; 两个集合的交集\n(define (intersection-set set1 set2)\n  (cond\n    ((or (null? set1) (null? set2) ()))\n    ;; 如果set1取出项是set2的成员，那么把他填入\n    ((element-of-set? (car set1) set2)\n      (cons (car set1) (intersection-set (cdr set1) set2)))\n    (else (intersection-set (cdr set1) set2))\n  )\n)\n;; 两个集合的并集\n(define (union-set set1 set2)\n  (cond\n    ;; 只去操作set1\n    ((null? set1) set2)\n    ;; 如果set1的这一项是set2的成员\n    ((element-of-set? (car set1) set2)\n      (intersection-set (cdr set1) set2))\n    ;; 否则就把set1这一项放入到set2当中\n    (else (intersection-set (cdr set1) (cons (car set1) set2)))\n  )\n)\n```\n&emsp;&emsp;这里我们可以发现一个问题，`intersection-set`和`union-set`方法每次操作两个**集合**的时候，都需要从集合1当中取出一个元素，在集合2当中遍历完全。集合1长度固定为`n`，当集合2的长度以n速度增长的时候，整个程序的运算将会以`m * n`增加整个运行的复杂度。如何去减少这个计算的复杂度，最好的办法就是使得集合本身按照某种规则进行**排序**。\n\n&emsp;&emsp;我们把复杂情况简单化，在只考虑数值的情况下，存在一个`(1 2 3 4)`的集合，当我拿出一个0来和第一项进行比较时，0比1小，此时就不需要再去循环剩下的元素，因为剩下的元素只会比1大，因此0肯定不存在于集合`(1 2 3 4)`当中。\n\n&emsp;&emsp;这样看来，最坏情况，拿出的数字比集合的最后一项还要大，我们将会比较到整个**集合**的长度n，比较到最后一项；最好的情况拿出的数字比集合的第一项还要小，只需要比较一次。这样平均下来，我们程序的复杂度预期降低到`n / 2`。\n\n&emsp;&emsp;在排序集合的情况下，我们可以优化上面的几个函数如下：\n```scheme\n;; 加速集合查找，似的集合按照顺序排列\n;; 在按照顺序排列的集合情况下优化的element-of-set\n(define (element-of-set? x set)\n  (cond\n    ((null? set) #f)\n    ((= x (car set)) #t)\n    ((< x) (car set) #f)\n    (else (element-of-set? x (cdr set)))\n  )\n)\n;; 在按照顺序排列的集合情况下优化的intersection-set\n(define (intersection-set set1 set2)\n  (if (or (null? set1) (null? set2))\n    () \n    (let\n      (\n        (x1 (car set1))\n        (x2 (car set2)))\n      (cond(\n        ;; 相当的时候直接放入\n        ((= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2))))\n        ;;小于直接就pass\n        ((< x1 x2)\n          (intersection-set (cdr set1) set2))\n        ;; 大于继续\n        ((< x2 x1)\n          (intersection-set set1 (cdr set2)))))\n    )\n  )\n)\n;; 优化的adjoin-set\n(define (adjoin-set x set)\n  (cond\n    ((null? set) (cons x set))\n    ((< x (car set) (cons x set)))\n    ((= x (car set) set))\n    ((> x (car set) (adjoin-set x (cdr set))))\n  )\n)\n```\n&emsp;&emsp;实际上复杂度还可以进一步进行优化，就是使用**二叉树**的数据结构。**二叉树**的基本特征是根节点出发，左侧节点的值永远小于右侧节点。如下图，为`{1,3,5,7,9,11}`的集合的二叉树排版形式。\n![二叉树](/blog/public/imgs/scip/scip2-5.jpg)\n&emsp;&emsp;不难发现，当一个集合长度为`n`。使用横向的排序方式进行搜索的时候，取出一项之后，剩下的长度为`n - 1`。但是使用二叉树进行比较的时候，走一个分支，每一次都能**减少一半**的数据规模。即下一次的数据规模为`n = next ^ 2 -> log 2 n -> log n`。(这里书上复杂度以及二叉树的讨论是建立在**二叉平衡树**这一概念上的，即一颗二叉树中，左节点和右节点的数量大致相等，实际的数据结构中，二叉树的分叉情况更为复杂)。\n\n&emsp;&emsp;我们可以把**根节点**、**左节点**、**右节点**看成一个列表，使用list来定义出来一个树结构。\n```scheme\n;; 二叉集合树\n(define (entry tree) (car tree))\n(define (left-branch tree) (cadr tree))\n(define (right-branch tree) (caddr tree))\n(define (make-tree entry left right) (list entry left right))\n```\n&emsp;&emsp;根据二叉树的数据结构，我们可以优化我们之前的对集合的操作。\n```scheme\n;; 二叉树改写 element-of-set, 建立在二叉平衡树的基础上\n(define (element-of-set? x set)\n  (cond\n    ((null? set) #f)\n    ((= x (entry tree)) #t)\n    ((< x (entry tree)) (element-of-set? x (left-branch set)))\n    ((> x (entry tree)) (element-of-set? x (right-branch set)))\n  )\n)\n;; adjoin-set 二叉树改写\n(define (adjoin-set x set)\n  (cond\n    ((null? set) (make-tree x '() '()))\n    ((= x (entry set)) set)\n    ((< x (entry set))\n      (make-tree (entry set)\n        (adjoin-set x (left-branch set))\n        (right-branch set)))\n    ((> x (entry set))\n      (make-tree (entry set)\n        (left-branch set)\n        (adjoin-set x (right-branch set))))\n  )\n)\n```\n&emsp;&emsp;上面无论是**排序集合**还是**二叉树**都是针对纯数字集合的情况下，现在如果是加上字母表之后，应该如何处理，是我们接下来需要讨论的问题。其实思路很简单，就是使用**编码**的概念，把**字母**映射为**数字**。最常见的是使用**等长编码**就行映射，如：\n```javascript\n/*\n    如下二进制编码 三个为一位等长编码\n    A 000 B 001 C 010 D 011\n    存在如下英文\n    BACDA\n    就会被编译成\n    001000010011000\n*/\n```\n&emsp;&emsp;等长编码的特定就是每个字符映射的二进制长度是一样的。方便之处就是不需要特殊的分隔符，就能够对连续的编码进行反编译回字符。缺点也很明显，就是浪费了储存空间。我们不妨和**非等长**字符比较一下。\n```javascript\n/*\n    如下二进制编码 非等长编码\n    A 0 B 10 C 100 D 1\n    存在如下英文\n    BACDA\n    就会被编译成\n    10 0 100 1 0\n*/\n```\n&emsp;&emsp;我们不难发现非等长的编码大大缩小了储存的长度，但是这也导致了一个问题，因为每一个字符表示的二进制码长度是不同的，你不知道到哪里完结。此时就需要加入特定的分隔符来进行处理（莫斯码就是著名的非等长编码，它对常用英文如字母E的编码为1位，大大缩小了传递信息所占用的空间）。\n\n&emsp;&emsp;实际上使用二叉树的数据结构来改造**等长编码**能够综合达到节省空间以及不用分隔符的优点，这种树形结构被称为**Huffman树**。如图：\n![Huffman树](/blog/public/imgs/scip/scip2-6.jpeg)\n&emsp;&emsp;在Huffman树中，0和1两个数字代表往**左节点**或者**右节点**走，当移动到字母位的时候，就能够把相应的编码转换为字母。如何判断当前的节点为**空表**还是**树叶子节点**，此时我们可以引入**符号标识**的概念，通过打标一个`leaf`，来标识当前节点为**树叶子节点**，告诉程序应该继续走下去。每一个**树叶子节点**都应该存在一个`leaf`标识，一个权重，以及对应的**字符符号**。\n&emsp;&emsp;我们可以根据这个基础写出一系列操作**Huffman Tree**的相关函数以及其对应的解码过程。\n```scheme\n;; huffman tree\n;; define huffman tree\n;; 一个树包含标识 leaf 符号 权重\n(define (make-leaf symbol weight)\n  (list 'leaf symbol weight)\n)\n;; 是否是树结构\n(define (leaf? object)\n  (eq? (car object) 'leaf)\n)\n;; 获得树的符号\n(define (symbol-leaf x) (cadr x))\n;; 获得树的权重\n(define (weight-leaf x) (caddr x))\n\n(define (left-branch tree) (car tree))\n(define (right-branch tree) (cadr tree))\n(define (symbols tree)\n  (if (leaf? tree)\n    (list (symbol-leaf tree))\n    (caddr tree)\n  )\n)\n(define (weight tree)\n  (if (leaf? tree)\n    (weight-leaf tree)\n    (cadddr tree)\n  )\n)\n;; make tree\n(define (make-code-tree left right)\n  (list left right \n    （append (symbols left) (symbols right))\n     (+ (weight left) (weight right))\n  )\n)\n(define (decode bit tree)\n  (define (decode-1 bite current-branch)\n    (if (null? bite)\n      ;;空的返回一个空表\n      '()\n      (let \n      ((next-branch (choose-branch (car bits) current-branch)))\n      ;; 如果下一个树杈是树形 \n      (if (leaf? next-branch)\n        (cons\n          ;; 获得树的符号列表\n          (symbol-leaf next-branch)\n          ;;\n          (decode-1 (cdr bits) next-branch)\n        )\n        ;; 1\n        (decode-1 (cdr bits) next-branch)\n      )\n      )\n    )\n  )\n  (decode-1 bits tree)\n)\n```\n\n&emsp;&emsp;本章引入的**符号数据**的概念结合书实例来看最大的作用是进行一个**打标**。通过标识，来启用对应的操作特定数据结构的方法，从而在多种复合数据输入的时候，能够准确的进行特定的数据结构操作。这种方式在**函数式**编程，递归为王的`scheme`中使用显得十分的怪异，在我的理解看来，是面向对象编程思想的另类诠释。","slug":"scip/scip(chap2-3)","published":1,"updated":"2020-06-11T01:43:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy300249r2vlf81gmlf","content":"<h2 id=\"第二章-第三节-符号数据\"><a href=\"#第二章-第三节-符号数据\" class=\"headerlink\" title=\"第二章 第三节 符号数据\"></a>第二章 第三节 符号数据</h2><p>&emsp;&emsp;利用符号(打标)的概念，形成抽象数据屏障，保证外部调库的精准性。<br><a id=\"more\"></a><br>&emsp;&emsp;本节将引入<strong>符号</strong>的概念，使得前两章单纯使用数据粘合构造而成的复合数据更有张合理，能够表示更多的复合数据结构。</p>\n<p>&emsp;&emsp;这里的所谓<strong>符号</strong>，在我看来是类似于<strong>类</strong>的概念。通过特定的<strong>符号</strong>对某一类数据结构进行标注，然后创建一系列方法针对性的对其进行操作。因为<code>scheme</code>的函数式编程的特定，不得不说，这一节<strong>符号</strong>用起来让人感觉有些别扭。</p>\n<p>&emsp;&emsp;首先是如何使用<code>scheme</code>来创建一个<strong>符号</strong>。<code>scheme</code>当中使用<code>&#39;</code>以及<code>list</code>相关的操作可以创建一个<strong>符号</strong>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> <span class=\"hljs-symbol\">'a</span> <span class=\"hljs-symbol\">'b</span>) <span class=\"hljs-comment\">;; (a b)</span></span><br><span class=\"line\">'(a b c) <span class=\"hljs-comment\">;; (a b c)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里的符号你可以简单理解为字符串，也可以理解为一个独特的打标。同时，<code>scheme</code>给我们提供了<code>eq?</code>函数，用于判断传入的两个<strong>符号</strong>是否相等。我们可以使用这个函数创建一个名为<code>memq</code>函数，接受一个<strong>符号</strong>和<strong>符号组(list)</strong>，用于判断<strong>符号组</strong>当中是否存在该<strong>符号</strong>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">memq</span></span> item x)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> x) <span class=\"hljs-literal\">#f</span>)</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> item (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> x)) x)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">memq</span></span> item (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> x)))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;书本上第一个实例使用了<strong>求导</strong>来让人理解<strong>符号</strong>在复合数据结构当中的扩充作用。但该实例还要配解<strong>导数</strong>的相对复杂数学概念，这里崛起，使用第二个实例<strong>集合</strong>的表示来进行展示。</p>\n<p>&emsp;&emsp;<strong>集合</strong>可以把它理解为一个枚举列表，就是一个不带重复元素的list。我们从基本的集合开始，一步步扩充复合数据结构，来体会<strong>符号</strong>在构建新的复合数据结构当中所加入带来的能力。</p>\n<p>&emsp;&emsp;先来创建两个最基本的与<strong>集合</strong>相关的方法，<code>element-of-set?</code>和<code>adjoin-set</code>。一个用于判断集合当中是否存在某个元素，另一个用于往集合当中添加元素。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; x element</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; set set-list</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; return #t or #f</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set) <span class=\"hljs-literal\">#f</span>)</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set)) <span class=\"hljs-literal\">#t</span>)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">element-of-set?</span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set)))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 如果set当中存在x 那么就直接返回set</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">adjoin-set</span> x set)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set) set (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x set)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;接下来可以创建操作两个集合相关的一些方法，如求两个集合的<strong>交集</strong>和<strong>并集</strong>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 两个集合的交集</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">intersection-set</span> set1 set2)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set2) ()))</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 如果set1取出项是set2的成员，那么把他填入</span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">element-of-set?</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set1) set2)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set1) (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set1) set2)))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set1) set2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 两个集合的并集</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">union-set</span> set1 set2)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 只去操作set1</span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set1) set2)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 如果set1的这一项是set2的成员</span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">element-of-set?</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set1) set2)</span><br><span class=\"line\">      (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set1) set2))</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 否则就把set1这一项放入到set2当中</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set1) set2)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里我们可以发现一个问题，<code>intersection-set</code>和<code>union-set</code>方法每次操作两个<strong>集合</strong>的时候，都需要从集合1当中取出一个元素，在集合2当中遍历完全。集合1长度固定为<code>n</code>，当集合2的长度以n速度增长的时候，整个程序的运算将会以<code>m * n</code>增加整个运行的复杂度。如何去减少这个计算的复杂度，最好的办法就是使得集合本身按照某种规则进行<strong>排序</strong>。</p>\n<p>&emsp;&emsp;我们把复杂情况简单化，在只考虑数值的情况下，存在一个<code>(1 2 3 4)</code>的集合，当我拿出一个0来和第一项进行比较时，0比1小，此时就不需要再去循环剩下的元素，因为剩下的元素只会比1大，因此0肯定不存在于集合<code>(1 2 3 4)</code>当中。</p>\n<p>&emsp;&emsp;这样看来，最坏情况，拿出的数字比集合的最后一项还要大，我们将会比较到整个<strong>集合</strong>的长度n，比较到最后一项；最好的情况拿出的数字比集合的第一项还要小，只需要比较一次。这样平均下来，我们程序的复杂度预期降低到<code>n / 2</code>。</p>\n<p>&emsp;&emsp;在排序集合的情况下，我们可以优化上面的几个函数如下：<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 加速集合查找，似的集合按照顺序排列</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 在按照顺序排列的集合情况下优化的element-of-set</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set) <span class=\"hljs-literal\">#f</span>)</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set)) <span class=\"hljs-literal\">#t</span>)</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set) <span class=\"hljs-literal\">#f</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">element-of-set?</span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 在按照顺序排列的集合情况下优化的intersection-set</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">intersection-set</span> set1 set2)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set2))</span><br><span class=\"line\">    () </span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">      (</span><br><span class=\"line\">        (<span class=\"hljs-name\">x1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set1))</span><br><span class=\"line\">        (<span class=\"hljs-name\">x2</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set2)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span>(</span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 相当的时候直接放入</span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> x1 x2) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x1 (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set2))))</span><br><span class=\"line\">        <span class=\"hljs-comment\">;;小于直接就pass</span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x1 x2)</span><br><span class=\"line\">          (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set1) set2))</span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 大于继续</span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x2 x1)</span><br><span class=\"line\">          (<span class=\"hljs-name\">intersection-set</span> set1 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set2)))))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 优化的adjoin-set</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">adjoin-set</span> x set)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x set))</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x set)))</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set) set))</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> set) (<span class=\"hljs-name\">adjoin-set</span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> set))))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上复杂度还可以进一步进行优化，就是使用<strong>二叉树</strong>的数据结构。<strong>二叉树</strong>的基本特征是根节点出发，左侧节点的值永远小于右侧节点。如下图，为<code>{1,3,5,7,9,11}</code>的集合的二叉树排版形式。<br><img src=\"/blog/public/imgs/scip/scip2-5.jpg\" alt=\"二叉树\"><br>&emsp;&emsp;不难发现，当一个集合长度为<code>n</code>。使用横向的排序方式进行搜索的时候，取出一项之后，剩下的长度为<code>n - 1</code>。但是使用二叉树进行比较的时候，走一个分支，每一次都能<strong>减少一半</strong>的数据规模。即下一次的数据规模为<code>n = next ^ 2 -&gt; log 2 n -&gt; log n</code>。(这里书上复杂度以及二叉树的讨论是建立在<strong>二叉平衡树</strong>这一概念上的，即一颗二叉树中，左节点和右节点的数量大致相等，实际的数据结构中，二叉树的分叉情况更为复杂)。</p>\n<p>&emsp;&emsp;我们可以把<strong>根节点</strong>、<strong>左节点</strong>、<strong>右节点</strong>看成一个列表，使用list来定义出来一个树结构。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 二叉集合树</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">entry</span> tree) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> tree))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">left-branch</span> tree) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cadr</span></span> tree))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">right-branch</span> tree) (<span class=\"hljs-name\">caddr</span> tree))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-tree</span> entry left right) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> entry left right))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;根据二叉树的数据结构，我们可以优化我们之前的对集合的操作。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 二叉树改写 element-of-set, 建立在二叉平衡树的基础上</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set) <span class=\"hljs-literal\">#f</span>)</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> x (<span class=\"hljs-name\">entry</span> tree)) <span class=\"hljs-literal\">#t</span>)</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x (<span class=\"hljs-name\">entry</span> tree)) (<span class=\"hljs-name\">element-of-set?</span> x (<span class=\"hljs-name\">left-branch</span> set)))</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> x (<span class=\"hljs-name\">entry</span> tree)) (<span class=\"hljs-name\">element-of-set?</span> x (<span class=\"hljs-name\">right-branch</span> set)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; adjoin-set 二叉树改写</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">adjoin-set</span> x set)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> set) (<span class=\"hljs-name\">make-tree</span> x '() '()))</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> x (<span class=\"hljs-name\">entry</span> set)) set)</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x (<span class=\"hljs-name\">entry</span> set))</span><br><span class=\"line\">      (<span class=\"hljs-name\">make-tree</span> (<span class=\"hljs-name\">entry</span> set)</span><br><span class=\"line\">        (<span class=\"hljs-name\">adjoin-set</span> x (<span class=\"hljs-name\">left-branch</span> set))</span><br><span class=\"line\">        (<span class=\"hljs-name\">right-branch</span> set)))</span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> x (<span class=\"hljs-name\">entry</span> set))</span><br><span class=\"line\">      (<span class=\"hljs-name\">make-tree</span> (<span class=\"hljs-name\">entry</span> set)</span><br><span class=\"line\">        (<span class=\"hljs-name\">left-branch</span> set)</span><br><span class=\"line\">        (<span class=\"hljs-name\">adjoin-set</span> x (<span class=\"hljs-name\">right-branch</span> set))))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;上面无论是<strong>排序集合</strong>还是<strong>二叉树</strong>都是针对纯数字集合的情况下，现在如果是加上字母表之后，应该如何处理，是我们接下来需要讨论的问题。其实思路很简单，就是使用<strong>编码</strong>的概念，把<strong>字母</strong>映射为<strong>数字</strong>。最常见的是使用<strong>等长编码</strong>就行映射，如：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    如下二进制编码 三个为一位等长编码</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    A 000 B 001 C 010 D 011</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    存在如下英文</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    BACDA</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    就会被编译成</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    001000010011000</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;等长编码的特定就是每个字符映射的二进制长度是一样的。方便之处就是不需要特殊的分隔符，就能够对连续的编码进行反编译回字符。缺点也很明显，就是浪费了储存空间。我们不妨和<strong>非等长</strong>字符比较一下。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    如下二进制编码 非等长编码</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    A 0 B 10 C 100 D 1</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    存在如下英文</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    BACDA</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    就会被编译成</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    10 0 100 1 0</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们不难发现非等长的编码大大缩小了储存的长度，但是这也导致了一个问题，因为每一个字符表示的二进制码长度是不同的，你不知道到哪里完结。此时就需要加入特定的分隔符来进行处理（莫斯码就是著名的非等长编码，它对常用英文如字母E的编码为1位，大大缩小了传递信息所占用的空间）。</p>\n<p>&emsp;&emsp;实际上使用二叉树的数据结构来改造<strong>等长编码</strong>能够综合达到节省空间以及不用分隔符的优点，这种树形结构被称为<strong>Huffman树</strong>。如图：<br><img src=\"/blog/public/imgs/scip/scip2-6.jpeg\" alt=\"Huffman树\"><br>&emsp;&emsp;在Huffman树中，0和1两个数字代表往<strong>左节点</strong>或者<strong>右节点</strong>走，当移动到字母位的时候，就能够把相应的编码转换为字母。如何判断当前的节点为<strong>空表</strong>还是<strong>树叶子节点</strong>，此时我们可以引入<strong>符号标识</strong>的概念，通过打标一个<code>leaf</code>，来标识当前节点为<strong>树叶子节点</strong>，告诉程序应该继续走下去。每一个<strong>树叶子节点</strong>都应该存在一个<code>leaf</code>标识，一个权重，以及对应的<strong>字符符号</strong>。<br>&emsp;&emsp;我们可以根据这个基础写出一系列操作<strong>Huffman Tree</strong>的相关函数以及其对应的解码过程。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; huffman tree</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; define huffman tree</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 一个树包含标识 leaf 符号 权重</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-leaf</span> symbol weight)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> <span class=\"hljs-symbol\">'leaf</span> symbol weight)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 是否是树结构</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">leaf?</span> object)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> object) <span class=\"hljs-symbol\">'leaf</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 获得树的符号</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">symbol-leaf</span> x) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cadr</span></span> x))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 获得树的权重</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">weight-leaf</span> x) (<span class=\"hljs-name\">caddr</span> x))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">left-branch</span> tree) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> tree))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">right-branch</span> tree) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cadr</span></span> tree))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">symbols</span> tree)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">leaf?</span> tree)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> (<span class=\"hljs-name\">symbol-leaf</span> tree))</span><br><span class=\"line\">    (<span class=\"hljs-name\">caddr</span> tree)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">weight</span> tree)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">leaf?</span> tree)</span><br><span class=\"line\">    (<span class=\"hljs-name\">weight-leaf</span> tree)</span><br><span class=\"line\">    (<span class=\"hljs-name\">cadddr</span> tree)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; make tree</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-code-tree</span> left right)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> left right </span><br><span class=\"line\">    （append (<span class=\"hljs-name\">symbols</span> left) (<span class=\"hljs-name\">symbols</span> right))</span><br><span class=\"line\">     (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">weight</span> left) (<span class=\"hljs-name\">weight</span> right))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">decode</span> bit tree)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">decode-1</span> bite current-branch)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> bite)</span><br><span class=\"line\">      <span class=\"hljs-comment\">;;空的返回一个空表</span></span><br><span class=\"line\">      '()</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> </span><br><span class=\"line\">      ((<span class=\"hljs-name\">next-branch</span> (<span class=\"hljs-name\">choose-branch</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> bits) current-branch)))</span><br><span class=\"line\">      <span class=\"hljs-comment\">;; 如果下一个树杈是树形 </span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">leaf?</span> next-branch)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span></span><br><span class=\"line\">          <span class=\"hljs-comment\">;; 获得树的符号列表</span></span><br><span class=\"line\">          (<span class=\"hljs-name\">symbol-leaf</span> next-branch)</span><br><span class=\"line\">          <span class=\"hljs-comment\">;;</span></span><br><span class=\"line\">          (<span class=\"hljs-name\">decode-1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> bits) next-branch)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"hljs-comment\">;; 1</span></span><br><span class=\"line\">        (<span class=\"hljs-name\">decode-1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> bits) next-branch)</span><br><span class=\"line\">      )</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"hljs-name\">decode-1</span> bits tree)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;本章引入的<strong>符号数据</strong>的概念结合书实例来看最大的作用是进行一个<strong>打标</strong>。通过标识，来启用对应的操作特定数据结构的方法，从而在多种复合数据输入的时候，能够准确的进行特定的数据结构操作。这种方式在<strong>函数式</strong>编程，递归为王的<code>scheme</code>中使用显得十分的怪异，在我的理解看来，是面向对象编程思想的另类诠释。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第二章-第三节-符号数据\"><a href=\"#第二章-第三节-符号数据\" class=\"headerlink\" title=\"第二章 第三节 符号数据\"></a>第二章 第三节 符号数据</h2><p>&emsp;&emsp;利用符号(打标)的概念，形成抽象数据屏障，保证外部调库的精准性。<br></p>","more":"<br>&emsp;&emsp;本节将引入<strong>符号</strong>的概念，使得前两章单纯使用数据粘合构造而成的复合数据更有张合理，能够表示更多的复合数据结构。</p>\n<p>&emsp;&emsp;这里的所谓<strong>符号</strong>，在我看来是类似于<strong>类</strong>的概念。通过特定的<strong>符号</strong>对某一类数据结构进行标注，然后创建一系列方法针对性的对其进行操作。因为<code>scheme</code>的函数式编程的特定，不得不说，这一节<strong>符号</strong>用起来让人感觉有些别扭。</p>\n<p>&emsp;&emsp;首先是如何使用<code>scheme</code>来创建一个<strong>符号</strong>。<code>scheme</code>当中使用<code>&#39;</code>以及<code>list</code>相关的操作可以创建一个<strong>符号</strong>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">'a</span> <span class=\"symbol\">'b</span>) <span class=\"comment\">;; (a b)</span></span><br><span class=\"line\">'(a b c) <span class=\"comment\">;; (a b c)</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里的符号你可以简单理解为字符串，也可以理解为一个独特的打标。同时，<code>scheme</code>给我们提供了<code>eq?</code>函数，用于判断传入的两个<strong>符号</strong>是否相等。我们可以使用这个函数创建一个名为<code>memq</code>函数，接受一个<strong>符号</strong>和<strong>符号组(list)</strong>，用于判断<strong>符号组</strong>当中是否存在该<strong>符号</strong>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">memq</span></span> item x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> x) <span class=\"literal\">#f</span>)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> item (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x)) x)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\"><span class=\"builtin-name\">memq</span></span> item (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x)))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;书本上第一个实例使用了<strong>求导</strong>来让人理解<strong>符号</strong>在复合数据结构当中的扩充作用。但该实例还要配解<strong>导数</strong>的相对复杂数学概念，这里崛起，使用第二个实例<strong>集合</strong>的表示来进行展示。</p>\n<p>&emsp;&emsp;<strong>集合</strong>可以把它理解为一个枚举列表，就是一个不带重复元素的list。我们从基本的集合开始，一步步扩充复合数据结构，来体会<strong>符号</strong>在构建新的复合数据结构当中所加入带来的能力。</p>\n<p>&emsp;&emsp;先来创建两个最基本的与<strong>集合</strong>相关的方法，<code>element-of-set?</code>和<code>adjoin-set</code>。一个用于判断集合当中是否存在某个元素，另一个用于往集合当中添加元素。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; x element</span></span><br><span class=\"line\"><span class=\"comment\">;; set set-list</span></span><br><span class=\"line\"><span class=\"comment\">;; return #t or #f</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">element-of-set?</span> x set)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set) <span class=\"literal\">#f</span>)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> x (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set)) <span class=\"literal\">#t</span>)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">element-of-set?</span> x (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set)))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 如果set当中存在x 那么就直接返回set</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">adjoin-set</span> x set)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">element-of-set?</span> x set) set (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x set)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;接下来可以创建操作两个集合相关的一些方法，如求两个集合的<strong>交集</strong>和<strong>并集</strong>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 两个集合的交集</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">intersection-set</span> set1 set2)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set1) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set2) ()))</span><br><span class=\"line\">    <span class=\"comment\">;; 如果set1取出项是set2的成员，那么把他填入</span></span><br><span class=\"line\">    ((<span class=\"name\">element-of-set?</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set1) set2)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set1) (<span class=\"name\">intersection-set</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set1) set2)))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">intersection-set</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set1) set2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 两个集合的并集</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">union-set</span> set1 set2)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    <span class=\"comment\">;; 只去操作set1</span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set1) set2)</span><br><span class=\"line\">    <span class=\"comment\">;; 如果set1的这一项是set2的成员</span></span><br><span class=\"line\">    ((<span class=\"name\">element-of-set?</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set1) set2)</span><br><span class=\"line\">      (<span class=\"name\">intersection-set</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set1) set2))</span><br><span class=\"line\">    <span class=\"comment\">;; 否则就把set1这一项放入到set2当中</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">intersection-set</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set1) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set1) set2)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这里我们可以发现一个问题，<code>intersection-set</code>和<code>union-set</code>方法每次操作两个<strong>集合</strong>的时候，都需要从集合1当中取出一个元素，在集合2当中遍历完全。集合1长度固定为<code>n</code>，当集合2的长度以n速度增长的时候，整个程序的运算将会以<code>m * n</code>增加整个运行的复杂度。如何去减少这个计算的复杂度，最好的办法就是使得集合本身按照某种规则进行<strong>排序</strong>。</p>\n<p>&emsp;&emsp;我们把复杂情况简单化，在只考虑数值的情况下，存在一个<code>(1 2 3 4)</code>的集合，当我拿出一个0来和第一项进行比较时，0比1小，此时就不需要再去循环剩下的元素，因为剩下的元素只会比1大，因此0肯定不存在于集合<code>(1 2 3 4)</code>当中。</p>\n<p>&emsp;&emsp;这样看来，最坏情况，拿出的数字比集合的最后一项还要大，我们将会比较到整个<strong>集合</strong>的长度n，比较到最后一项；最好的情况拿出的数字比集合的第一项还要小，只需要比较一次。这样平均下来，我们程序的复杂度预期降低到<code>n / 2</code>。</p>\n<p>&emsp;&emsp;在排序集合的情况下，我们可以优化上面的几个函数如下：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 加速集合查找，似的集合按照顺序排列</span></span><br><span class=\"line\"><span class=\"comment\">;; 在按照顺序排列的集合情况下优化的element-of-set</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">element-of-set?</span> x set)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set) <span class=\"literal\">#f</span>)</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> x (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set)) <span class=\"literal\">#t</span>)</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set) <span class=\"literal\">#f</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">element-of-set?</span> x (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 在按照顺序排列的集合情况下优化的intersection-set</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">intersection-set</span> set1 set2)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set1) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set2))</span><br><span class=\"line\">    () </span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">      (</span><br><span class=\"line\">        (<span class=\"name\">x1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set1))</span><br><span class=\"line\">        (<span class=\"name\">x2</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set2)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span>(</span><br><span class=\"line\">        <span class=\"comment\">;; 相当的时候直接放入</span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> x1 x2) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x1 (<span class=\"name\">intersection-set</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set1) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set2))))</span><br><span class=\"line\">        <span class=\"comment\">;;小于直接就pass</span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x1 x2)</span><br><span class=\"line\">          (<span class=\"name\">intersection-set</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set1) set2))</span><br><span class=\"line\">        <span class=\"comment\">;; 大于继续</span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x2 x1)</span><br><span class=\"line\">          (<span class=\"name\">intersection-set</span> set1 (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set2)))))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 优化的adjoin-set</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">adjoin-set</span> x set)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x set))</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x set)))</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> x (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set) set))</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> x (<span class=\"name\"><span class=\"builtin-name\">car</span></span> set) (<span class=\"name\">adjoin-set</span> x (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> set))))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;实际上复杂度还可以进一步进行优化，就是使用<strong>二叉树</strong>的数据结构。<strong>二叉树</strong>的基本特征是根节点出发，左侧节点的值永远小于右侧节点。如下图，为<code>{1,3,5,7,9,11}</code>的集合的二叉树排版形式。<br><img src=\"/blog/public/imgs/scip/scip2-5.jpg\" alt=\"二叉树\"><br>&emsp;&emsp;不难发现，当一个集合长度为<code>n</code>。使用横向的排序方式进行搜索的时候，取出一项之后，剩下的长度为<code>n - 1</code>。但是使用二叉树进行比较的时候，走一个分支，每一次都能<strong>减少一半</strong>的数据规模。即下一次的数据规模为<code>n = next ^ 2 -&gt; log 2 n -&gt; log n</code>。(这里书上复杂度以及二叉树的讨论是建立在<strong>二叉平衡树</strong>这一概念上的，即一颗二叉树中，左节点和右节点的数量大致相等，实际的数据结构中，二叉树的分叉情况更为复杂)。</p>\n<p>&emsp;&emsp;我们可以把<strong>根节点</strong>、<strong>左节点</strong>、<strong>右节点</strong>看成一个列表，使用list来定义出来一个树结构。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 二叉集合树</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">entry</span> tree) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> tree))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">left-branch</span> tree) (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> tree))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">right-branch</span> tree) (<span class=\"name\">caddr</span> tree))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-tree</span> entry left right) (<span class=\"name\"><span class=\"builtin-name\">list</span></span> entry left right))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;根据二叉树的数据结构，我们可以优化我们之前的对集合的操作。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 二叉树改写 element-of-set, 建立在二叉平衡树的基础上</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">element-of-set?</span> x set)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set) <span class=\"literal\">#f</span>)</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> x (<span class=\"name\">entry</span> tree)) <span class=\"literal\">#t</span>)</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x (<span class=\"name\">entry</span> tree)) (<span class=\"name\">element-of-set?</span> x (<span class=\"name\">left-branch</span> set)))</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> x (<span class=\"name\">entry</span> tree)) (<span class=\"name\">element-of-set?</span> x (<span class=\"name\">right-branch</span> set)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; adjoin-set 二叉树改写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">adjoin-set</span> x set)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> set) (<span class=\"name\">make-tree</span> x '() '()))</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> x (<span class=\"name\">entry</span> set)) set)</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x (<span class=\"name\">entry</span> set))</span><br><span class=\"line\">      (<span class=\"name\">make-tree</span> (<span class=\"name\">entry</span> set)</span><br><span class=\"line\">        (<span class=\"name\">adjoin-set</span> x (<span class=\"name\">left-branch</span> set))</span><br><span class=\"line\">        (<span class=\"name\">right-branch</span> set)))</span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> x (<span class=\"name\">entry</span> set))</span><br><span class=\"line\">      (<span class=\"name\">make-tree</span> (<span class=\"name\">entry</span> set)</span><br><span class=\"line\">        (<span class=\"name\">left-branch</span> set)</span><br><span class=\"line\">        (<span class=\"name\">adjoin-set</span> x (<span class=\"name\">right-branch</span> set))))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;上面无论是<strong>排序集合</strong>还是<strong>二叉树</strong>都是针对纯数字集合的情况下，现在如果是加上字母表之后，应该如何处理，是我们接下来需要讨论的问题。其实思路很简单，就是使用<strong>编码</strong>的概念，把<strong>字母</strong>映射为<strong>数字</strong>。最常见的是使用<strong>等长编码</strong>就行映射，如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    如下二进制编码 三个为一位等长编码</span></span><br><span class=\"line\"><span class=\"comment\">    A 000 B 001 C 010 D 011</span></span><br><span class=\"line\"><span class=\"comment\">    存在如下英文</span></span><br><span class=\"line\"><span class=\"comment\">    BACDA</span></span><br><span class=\"line\"><span class=\"comment\">    就会被编译成</span></span><br><span class=\"line\"><span class=\"comment\">    001000010011000</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;等长编码的特定就是每个字符映射的二进制长度是一样的。方便之处就是不需要特殊的分隔符，就能够对连续的编码进行反编译回字符。缺点也很明显，就是浪费了储存空间。我们不妨和<strong>非等长</strong>字符比较一下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    如下二进制编码 非等长编码</span></span><br><span class=\"line\"><span class=\"comment\">    A 0 B 10 C 100 D 1</span></span><br><span class=\"line\"><span class=\"comment\">    存在如下英文</span></span><br><span class=\"line\"><span class=\"comment\">    BACDA</span></span><br><span class=\"line\"><span class=\"comment\">    就会被编译成</span></span><br><span class=\"line\"><span class=\"comment\">    10 0 100 1 0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们不难发现非等长的编码大大缩小了储存的长度，但是这也导致了一个问题，因为每一个字符表示的二进制码长度是不同的，你不知道到哪里完结。此时就需要加入特定的分隔符来进行处理（莫斯码就是著名的非等长编码，它对常用英文如字母E的编码为1位，大大缩小了传递信息所占用的空间）。</p>\n<p>&emsp;&emsp;实际上使用二叉树的数据结构来改造<strong>等长编码</strong>能够综合达到节省空间以及不用分隔符的优点，这种树形结构被称为<strong>Huffman树</strong>。如图：<br><img src=\"/blog/public/imgs/scip/scip2-6.jpeg\" alt=\"Huffman树\"><br>&emsp;&emsp;在Huffman树中，0和1两个数字代表往<strong>左节点</strong>或者<strong>右节点</strong>走，当移动到字母位的时候，就能够把相应的编码转换为字母。如何判断当前的节点为<strong>空表</strong>还是<strong>树叶子节点</strong>，此时我们可以引入<strong>符号标识</strong>的概念，通过打标一个<code>leaf</code>，来标识当前节点为<strong>树叶子节点</strong>，告诉程序应该继续走下去。每一个<strong>树叶子节点</strong>都应该存在一个<code>leaf</code>标识，一个权重，以及对应的<strong>字符符号</strong>。<br>&emsp;&emsp;我们可以根据这个基础写出一系列操作<strong>Huffman Tree</strong>的相关函数以及其对应的解码过程。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; huffman tree</span></span><br><span class=\"line\"><span class=\"comment\">;; define huffman tree</span></span><br><span class=\"line\"><span class=\"comment\">;; 一个树包含标识 leaf 符号 权重</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-leaf</span> symbol weight)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"symbol\">'leaf</span> symbol weight)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 是否是树结构</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">leaf?</span> object)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> object) <span class=\"symbol\">'leaf</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 获得树的符号</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">symbol-leaf</span> x) (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> x))</span><br><span class=\"line\"><span class=\"comment\">;; 获得树的权重</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">weight-leaf</span> x) (<span class=\"name\">caddr</span> x))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">left-branch</span> tree) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> tree))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">right-branch</span> tree) (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> tree))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">symbols</span> tree)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">leaf?</span> tree)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\">symbol-leaf</span> tree))</span><br><span class=\"line\">    (<span class=\"name\">caddr</span> tree)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">weight</span> tree)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">leaf?</span> tree)</span><br><span class=\"line\">    (<span class=\"name\">weight-leaf</span> tree)</span><br><span class=\"line\">    (<span class=\"name\">cadddr</span> tree)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; make tree</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-code-tree</span> left right)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">list</span></span> left right </span><br><span class=\"line\">    （append (<span class=\"name\">symbols</span> left) (<span class=\"name\">symbols</span> right))</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">weight</span> left) (<span class=\"name\">weight</span> right))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">decode</span> bit tree)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">decode-1</span> bite current-branch)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> bite)</span><br><span class=\"line\">      <span class=\"comment\">;;空的返回一个空表</span></span><br><span class=\"line\">      '()</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">let</span></span> </span><br><span class=\"line\">      ((<span class=\"name\">next-branch</span> (<span class=\"name\">choose-branch</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> bits) current-branch)))</span><br><span class=\"line\">      <span class=\"comment\">;; 如果下一个树杈是树形 </span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">leaf?</span> next-branch)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cons</span></span></span><br><span class=\"line\">          <span class=\"comment\">;; 获得树的符号列表</span></span><br><span class=\"line\">          (<span class=\"name\">symbol-leaf</span> next-branch)</span><br><span class=\"line\">          <span class=\"comment\">;;</span></span><br><span class=\"line\">          (<span class=\"name\">decode-1</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> bits) next-branch)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"comment\">;; 1</span></span><br><span class=\"line\">        (<span class=\"name\">decode-1</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> bits) next-branch)</span><br><span class=\"line\">      )</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"name\">decode-1</span> bits tree)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;本章引入的<strong>符号数据</strong>的概念结合书实例来看最大的作用是进行一个<strong>打标</strong>。通过标识，来启用对应的操作特定数据结构的方法，从而在多种复合数据输入的时候，能够准确的进行特定的数据结构操作。这种方式在<strong>函数式</strong>编程，递归为王的<code>scheme</code>中使用显得十分的怪异，在我的理解看来，是面向对象编程思想的另类诠释。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-2.4","date":"2019-08-03T09:20:00.000Z","_content":"## 第二章 第四节 抽象数据的多重表示\n&emsp;&emsp;这一节我们将综合前三节的内容，利用抽象屏障，构造一个复数相关数据结构运算，并使用符号数据标识两种复数标识类型，使得底层的方法能够支持两种复数数据结构表示方法运算。\n<!--more-->\n&emsp;&emsp;本章核心是利用**标识**结合**通用模块**创建适配多种复合数据结构的抽象屏障。大型程序往往是多个新旧模块的结合。平常我们经常引的著名的包库，本质上就是一种**通用性过程**的**旧模块**。我们将这些通用性模块，根据业务逻辑拼接组合起来，形成我们适配业务过程的一个个的应用程序。这一节，我们利用复数两种表达形式，从功能过程性的设计开始，到适配两种复数数据结构表现形式，最后到拆分通用性功能模块，感受这一变化进程当中的思考和对程序设计的感悟。\n\n&emsp;&emsp;一个复数由**实部**和**虚步**构成，把它放到一个虚轴和实轴构成的直接坐标系当中，可以把任意一个**复数**表现为直角坐标系上面的一个点。场景如下：\n![复数的表达方式](/blog/public/imgs/scip/scip2-7.jpg)\n\n&emsp;&emsp;至此，我们可以把复数用两种方式表达出来，**坐标形式（实部和虚部）**以及**极坐标形式（模和幅角）**。通过图上两种表达方式的特点以及下方复数运算的公式，我们不难发现，在复数**加减**的时候，采用**坐标形式**的复数表达方式更容易计算，**乘除**的时候则是**极坐标**的构成方式更为方便。\n\n```JavaScript\n/** 复数的加减\n  * 实部(z1 +/- z2)=实部(z1) +/- 实部(z2)\n  * 虚部(z1 +/- z2)=虚部(z1) +/- 虚部(z2)\n  */\n\n/** 复数的乘除\n  * //* 标识 / 或者 *\n  * 实部(z1 //* z2)=实部(z1) //* 实部(z2)\n  * 虚部(z1 //* z2)=虚部(z1) -/+ 虚部(z2)\n  */\n```\n&emsp;&emsp;我们可以很方便的根据公式来写出复数的加减乘除的运算函数。\n\n```scheme\n;; 复数的操作方法 加 减 乘 除\n(define (add-complex z1 z2)\n  (make-from-real-imag\n    (+ (real-part z1) (real-part z2))\n    (+ (imag-part z1) (imag-part z2))\n  )\n)\n(define (sub-complex z1 z2)\n  (make-from-real-imag\n    (- (real-part z1) (real-part z2))\n    (- (imag-part z1) (imag-part z2))\n  )\n)\n(define (mul-complex z1 z2)\n  (make-from-mag-ang\n    (* (magnitude z1) (magnitude z2))\n    (+ (angle z1) (angle z2))\n  )\n)\n(define (div-complex z1 z2)\n  (make-from-mag-ang\n    (/ (magnitude z1) (magnitude z2))\n    (- (angle z1) (angle z2))\n  )\n)\n```\n\n&emsp;&emsp;接着我们列出**坐标形式**和**极坐标**形式的两种复数构造关系。\n\n```scheme\n;; 直角坐标方式\n(define (real-part z) (car z))\n(define (imag-part z) (cdr z))\n(define (magnitude z)\n  (sqrt\n    (+ (square (real-part z)) (square (imag-part z)))\n  )\n)\n(define (angle z)\n  ;; atan scheme 自带的反正切函数  y x 返回 y/x 的角度 参数的符号决定角度的象限\n  (atan (imag-part z) (real-part z))\n)\n(define (make-from-real-imag x y)\n  (cons x y)\n)\n(define (make-from-mag-ang r a)\n  (cons (* r (cos a)) (* r (sin a )))\n)\n\n;; 极坐标方式\n(define (real-part z)\n  (* (magnitude z) (cos (angle z)))\n)\n(define (imag-part z)\n  (* (magnitude z) (sin (angle z)))\n)\n(define (magnitude z) (car z))\n(define (angle z) (cdr z))\n\n(define (make-from-real-imag x y)\n  (cons (sqrt (+ (square x) (square y)) (atan y x)))\n)\n(define (make-from-mag-imag r a)\n  (cons r a)\n)\n```\n&emsp;&emsp;这种构造加减乘除的构造方式，通过拆分**虚部**和**实部**为输入，来保证针对两种复数表示方式均可以使用。而复数的两种表现形式则是根据**坐标**和**极坐标**的公式分别取定义的过程。在需要取出复数**虚部**和**实部**的时候，则需要针对过程分别去定义不同的取值方式。实际上可以再在上方抽象一层，通过打一个**符号**作为标识哪种复数构成的方式，来区分这两种复数的构成。\n```scheme\n;; 抽象出打标 取标层数据层\n;; 利用标志来实现两种坐标方式融合\n;; type-tag 标志字符，rectangular 坐标 polar 极坐标\n;; content 数据结构的内容\n(define (attach-tag type-tag content)\n  (cons (type-tag content))\n)\n(define (type-tag datum)\n  (if (pair? datum)\n    (car datum)\n    (display \"Bad tagged datum -- type-TAG\")\n  )\n)\n(define (contents datum)\n  (if (pair? datum)\n    (cdr datum)\n    (display \"bad tagged datum -- CONTENTS\")\n  )\n)\n;; 判断是哪种数据结构\n(define (rectangular? z)\n  (eq? (type-tag z) 'rectangular)\n)\n(define (polar? z)\n  (eq? (type-tag z) 'polar)\n)\n```\n&emsp;&emsp;现在我们加入**打标**的抽象层以后，来修改对应的两种复数表示方式(坐标和极坐标表示方式)。\n```scheme\n;; 加入标识层之后的直角坐标和极坐标表示方式\n;; rectangular直角坐标表示方式\n(define (real-part-rectangular z) (car z))\n(define (imag-part-rectangular z) (cdr z))\n(define (magnitude-rectangular z)\n  (sqrt (+\n    (saquare (real-part-rectangular z))\n    (saquare (imag-part-rectangular z))\n  ))\n)\n(define (angle-rectangular z)\n  (atan\n    (imag-part-rectangular z)\n    (real-part-rectangular z)\n  )\n)\n(define (make-from-real-imag-rectangular x y)\n  (attach-tag 'rectangular (cons x y))\n)\n(define (make-from-mag-ang-rectangular r a)\n  (attach-tag\n    'rectangular\n    (cons\n      (* r (cos a))\n      (* r (sin a))\n    )\n  )\n)\n;; 极坐标方式\n(define (real-part-polar z)\n  (* (magnitude-polar z) (cos (angle-polar z)))\n)\n(define (imag-part-polar z)\n  (* (magnitude-polar z) (sin (angle-polar z)))\n)\n(define (magnitude-polar z) (car z))\n(define (angle-polar z) (cdr z))\n\n(define (make-from-real-imag-polar x y)\n  (attach-tag\n    'polar\n    (cons (sqrt (+ (square x) (square y)) (atan y x)))\n  )\n  \n)\n(define (make-from-mag-imag r a)\n  (attach-tag\n    'polar\n    (cons r a)\n  )\n)\n```\n\n&emsp;&emsp;修改的部分仅仅是：\n&emsp;&emsp;1. 操作的函数名字加上了对应的坐标系表示\n&emsp;&emsp;2. 创建复数的函数，在外部加上了一层`attach-tag`函数。创建了一个`(标识 (复数内容))`的数据结构。\n\n&emsp;&emsp;修改之后，可以发现，由于四则运算函数采用的是**实部**以及**虚部**输入的方式构建的，修改复数的构造函数不对其部分造成任何影响。至此，我们成功建立起了`运算-复数算数-底层表示方式`三层的数据结构屏障。\n\n```\n----- add sub mul div -----\n-----    复数算数包     ----- \n-----   real  imag    ----- \n直角坐标系    |      极坐标系\n```\n&emsp;&emsp;实际上，这种模块的构造方式仍然存在缺点，增加新类型的维护成本高。如果现在为复数的组成方式添加新的构成方式，就需要添加新的表示符号，检查操作方法重名问题，牵扯到维护的地方很多。书上提到的解决方法，是使用`put set`加上`lambda`的方式来解决。即把所有的函数对应操作一一整合到一个类似表的函数中，使用标识符作为取出的方法。如图：\n![复数的操作规整](/blog/public/imgs/scip/scip2-8.jpg)\n&emsp;&emsp;以`real-part`为例，我在构造的时候只需要往`real-part`当中put函数和**标志符**储存，需要的时候根据**标识符**取出即可。\n```scheme\n;; 储存 rectangular 和 polar 的两种构成方式的 real-part 函数\n(put 'real-part 'rectangular real-part-rectangular)\n(put 'real-part 'polar real-part-polar)\n;; 取出对应的操作方法\n((get 'real-part 'polar) z)\n```\n&emsp;&emsp;这种类似于JS对象中的储存概念:\n```JavaScript\nvar realPart = {\n    rectangular: real-part-rectangular,\n    polar: real-part-polar,\n};\nrealPart['polar'](z);\n```\n&emsp;&emsp;这种组成方式易于维护（添加和获取方法），可读性也很强。是一种非常优秀的模块设计方式。","source":"_posts/scip/scip(chap2-4).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-2.4\ndate: 2019/8/3 17:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第二章 第四节 抽象数据的多重表示\n&emsp;&emsp;这一节我们将综合前三节的内容，利用抽象屏障，构造一个复数相关数据结构运算，并使用符号数据标识两种复数标识类型，使得底层的方法能够支持两种复数数据结构表示方法运算。\n<!--more-->\n&emsp;&emsp;本章核心是利用**标识**结合**通用模块**创建适配多种复合数据结构的抽象屏障。大型程序往往是多个新旧模块的结合。平常我们经常引的著名的包库，本质上就是一种**通用性过程**的**旧模块**。我们将这些通用性模块，根据业务逻辑拼接组合起来，形成我们适配业务过程的一个个的应用程序。这一节，我们利用复数两种表达形式，从功能过程性的设计开始，到适配两种复数数据结构表现形式，最后到拆分通用性功能模块，感受这一变化进程当中的思考和对程序设计的感悟。\n\n&emsp;&emsp;一个复数由**实部**和**虚步**构成，把它放到一个虚轴和实轴构成的直接坐标系当中，可以把任意一个**复数**表现为直角坐标系上面的一个点。场景如下：\n![复数的表达方式](/blog/public/imgs/scip/scip2-7.jpg)\n\n&emsp;&emsp;至此，我们可以把复数用两种方式表达出来，**坐标形式（实部和虚部）**以及**极坐标形式（模和幅角）**。通过图上两种表达方式的特点以及下方复数运算的公式，我们不难发现，在复数**加减**的时候，采用**坐标形式**的复数表达方式更容易计算，**乘除**的时候则是**极坐标**的构成方式更为方便。\n\n```JavaScript\n/** 复数的加减\n  * 实部(z1 +/- z2)=实部(z1) +/- 实部(z2)\n  * 虚部(z1 +/- z2)=虚部(z1) +/- 虚部(z2)\n  */\n\n/** 复数的乘除\n  * //* 标识 / 或者 *\n  * 实部(z1 //* z2)=实部(z1) //* 实部(z2)\n  * 虚部(z1 //* z2)=虚部(z1) -/+ 虚部(z2)\n  */\n```\n&emsp;&emsp;我们可以很方便的根据公式来写出复数的加减乘除的运算函数。\n\n```scheme\n;; 复数的操作方法 加 减 乘 除\n(define (add-complex z1 z2)\n  (make-from-real-imag\n    (+ (real-part z1) (real-part z2))\n    (+ (imag-part z1) (imag-part z2))\n  )\n)\n(define (sub-complex z1 z2)\n  (make-from-real-imag\n    (- (real-part z1) (real-part z2))\n    (- (imag-part z1) (imag-part z2))\n  )\n)\n(define (mul-complex z1 z2)\n  (make-from-mag-ang\n    (* (magnitude z1) (magnitude z2))\n    (+ (angle z1) (angle z2))\n  )\n)\n(define (div-complex z1 z2)\n  (make-from-mag-ang\n    (/ (magnitude z1) (magnitude z2))\n    (- (angle z1) (angle z2))\n  )\n)\n```\n\n&emsp;&emsp;接着我们列出**坐标形式**和**极坐标**形式的两种复数构造关系。\n\n```scheme\n;; 直角坐标方式\n(define (real-part z) (car z))\n(define (imag-part z) (cdr z))\n(define (magnitude z)\n  (sqrt\n    (+ (square (real-part z)) (square (imag-part z)))\n  )\n)\n(define (angle z)\n  ;; atan scheme 自带的反正切函数  y x 返回 y/x 的角度 参数的符号决定角度的象限\n  (atan (imag-part z) (real-part z))\n)\n(define (make-from-real-imag x y)\n  (cons x y)\n)\n(define (make-from-mag-ang r a)\n  (cons (* r (cos a)) (* r (sin a )))\n)\n\n;; 极坐标方式\n(define (real-part z)\n  (* (magnitude z) (cos (angle z)))\n)\n(define (imag-part z)\n  (* (magnitude z) (sin (angle z)))\n)\n(define (magnitude z) (car z))\n(define (angle z) (cdr z))\n\n(define (make-from-real-imag x y)\n  (cons (sqrt (+ (square x) (square y)) (atan y x)))\n)\n(define (make-from-mag-imag r a)\n  (cons r a)\n)\n```\n&emsp;&emsp;这种构造加减乘除的构造方式，通过拆分**虚部**和**实部**为输入，来保证针对两种复数表示方式均可以使用。而复数的两种表现形式则是根据**坐标**和**极坐标**的公式分别取定义的过程。在需要取出复数**虚部**和**实部**的时候，则需要针对过程分别去定义不同的取值方式。实际上可以再在上方抽象一层，通过打一个**符号**作为标识哪种复数构成的方式，来区分这两种复数的构成。\n```scheme\n;; 抽象出打标 取标层数据层\n;; 利用标志来实现两种坐标方式融合\n;; type-tag 标志字符，rectangular 坐标 polar 极坐标\n;; content 数据结构的内容\n(define (attach-tag type-tag content)\n  (cons (type-tag content))\n)\n(define (type-tag datum)\n  (if (pair? datum)\n    (car datum)\n    (display \"Bad tagged datum -- type-TAG\")\n  )\n)\n(define (contents datum)\n  (if (pair? datum)\n    (cdr datum)\n    (display \"bad tagged datum -- CONTENTS\")\n  )\n)\n;; 判断是哪种数据结构\n(define (rectangular? z)\n  (eq? (type-tag z) 'rectangular)\n)\n(define (polar? z)\n  (eq? (type-tag z) 'polar)\n)\n```\n&emsp;&emsp;现在我们加入**打标**的抽象层以后，来修改对应的两种复数表示方式(坐标和极坐标表示方式)。\n```scheme\n;; 加入标识层之后的直角坐标和极坐标表示方式\n;; rectangular直角坐标表示方式\n(define (real-part-rectangular z) (car z))\n(define (imag-part-rectangular z) (cdr z))\n(define (magnitude-rectangular z)\n  (sqrt (+\n    (saquare (real-part-rectangular z))\n    (saquare (imag-part-rectangular z))\n  ))\n)\n(define (angle-rectangular z)\n  (atan\n    (imag-part-rectangular z)\n    (real-part-rectangular z)\n  )\n)\n(define (make-from-real-imag-rectangular x y)\n  (attach-tag 'rectangular (cons x y))\n)\n(define (make-from-mag-ang-rectangular r a)\n  (attach-tag\n    'rectangular\n    (cons\n      (* r (cos a))\n      (* r (sin a))\n    )\n  )\n)\n;; 极坐标方式\n(define (real-part-polar z)\n  (* (magnitude-polar z) (cos (angle-polar z)))\n)\n(define (imag-part-polar z)\n  (* (magnitude-polar z) (sin (angle-polar z)))\n)\n(define (magnitude-polar z) (car z))\n(define (angle-polar z) (cdr z))\n\n(define (make-from-real-imag-polar x y)\n  (attach-tag\n    'polar\n    (cons (sqrt (+ (square x) (square y)) (atan y x)))\n  )\n  \n)\n(define (make-from-mag-imag r a)\n  (attach-tag\n    'polar\n    (cons r a)\n  )\n)\n```\n\n&emsp;&emsp;修改的部分仅仅是：\n&emsp;&emsp;1. 操作的函数名字加上了对应的坐标系表示\n&emsp;&emsp;2. 创建复数的函数，在外部加上了一层`attach-tag`函数。创建了一个`(标识 (复数内容))`的数据结构。\n\n&emsp;&emsp;修改之后，可以发现，由于四则运算函数采用的是**实部**以及**虚部**输入的方式构建的，修改复数的构造函数不对其部分造成任何影响。至此，我们成功建立起了`运算-复数算数-底层表示方式`三层的数据结构屏障。\n\n```\n----- add sub mul div -----\n-----    复数算数包     ----- \n-----   real  imag    ----- \n直角坐标系    |      极坐标系\n```\n&emsp;&emsp;实际上，这种模块的构造方式仍然存在缺点，增加新类型的维护成本高。如果现在为复数的组成方式添加新的构成方式，就需要添加新的表示符号，检查操作方法重名问题，牵扯到维护的地方很多。书上提到的解决方法，是使用`put set`加上`lambda`的方式来解决。即把所有的函数对应操作一一整合到一个类似表的函数中，使用标识符作为取出的方法。如图：\n![复数的操作规整](/blog/public/imgs/scip/scip2-8.jpg)\n&emsp;&emsp;以`real-part`为例，我在构造的时候只需要往`real-part`当中put函数和**标志符**储存，需要的时候根据**标识符**取出即可。\n```scheme\n;; 储存 rectangular 和 polar 的两种构成方式的 real-part 函数\n(put 'real-part 'rectangular real-part-rectangular)\n(put 'real-part 'polar real-part-polar)\n;; 取出对应的操作方法\n((get 'real-part 'polar) z)\n```\n&emsp;&emsp;这种类似于JS对象中的储存概念:\n```JavaScript\nvar realPart = {\n    rectangular: real-part-rectangular,\n    polar: real-part-polar,\n};\nrealPart['polar'](z);\n```\n&emsp;&emsp;这种组成方式易于维护（添加和获取方法），可读性也很强。是一种非常优秀的模块设计方式。","slug":"scip/scip(chap2-4)","published":1,"updated":"2020-06-11T01:43:32.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy400289r2vf6s4r0sv","content":"<h2 id=\"第二章-第四节-抽象数据的多重表示\"><a href=\"#第二章-第四节-抽象数据的多重表示\" class=\"headerlink\" title=\"第二章 第四节 抽象数据的多重表示\"></a>第二章 第四节 抽象数据的多重表示</h2><p>&emsp;&emsp;这一节我们将综合前三节的内容，利用抽象屏障，构造一个复数相关数据结构运算，并使用符号数据标识两种复数标识类型，使得底层的方法能够支持两种复数数据结构表示方法运算。<br><a id=\"more\"></a><br>&emsp;&emsp;本章核心是利用<strong>标识</strong>结合<strong>通用模块</strong>创建适配多种复合数据结构的抽象屏障。大型程序往往是多个新旧模块的结合。平常我们经常引的著名的包库，本质上就是一种<strong>通用性过程</strong>的<strong>旧模块</strong>。我们将这些通用性模块，根据业务逻辑拼接组合起来，形成我们适配业务过程的一个个的应用程序。这一节，我们利用复数两种表达形式，从功能过程性的设计开始，到适配两种复数数据结构表现形式，最后到拆分通用性功能模块，感受这一变化进程当中的思考和对程序设计的感悟。</p>\n<p>&emsp;&emsp;一个复数由<strong>实部</strong>和<strong>虚步</strong>构成，把它放到一个虚轴和实轴构成的直接坐标系当中，可以把任意一个<strong>复数</strong>表现为直角坐标系上面的一个点。场景如下：<br><img src=\"/blog/public/imgs/scip/scip2-7.jpg\" alt=\"复数的表达方式\"></p>\n<p>&emsp;&emsp;至此，我们可以把复数用两种方式表达出来，<strong>坐标形式（实部和虚部）</strong>以及<strong>极坐标形式（模和幅角）</strong>。通过图上两种表达方式的特点以及下方复数运算的公式，我们不难发现，在复数<strong>加减</strong>的时候，采用<strong>坐标形式</strong>的复数表达方式更容易计算，<strong>乘除</strong>的时候则是<strong>极坐标</strong>的构成方式更为方便。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** 复数的加减</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * 实部(z1 +/- z2)=实部(z1) +/- 实部(z2)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * 虚部(z1 +/- z2)=虚部(z1) +/- 虚部(z2)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/** 复数的乘除</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * //* 标识 / 或者 *</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * 实部(z1 //* z2)=实部(z1) //* 实部(z2)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  * 虚部(z1 //* z2)=虚部(z1) -/+ 虚部(z2)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">  */</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以很方便的根据公式来写出复数的加减乘除的运算函数。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 复数的操作方法 加 减 乘 除</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">add-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"hljs-name\">make-from-real-imag</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sub-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"hljs-name\">make-from-real-imag</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">mul-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"hljs-name\">make-from-mag-ang</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">div-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"hljs-name\">make-from-mag-ang</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;接着我们列出<strong>坐标形式</strong>和<strong>极坐标</strong>形式的两种复数构造关系。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 直角坐标方式</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> z))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sqrt</span></span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">square</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z)) (<span class=\"hljs-name\">square</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z)</span><br><span class=\"line\">  <span class=\"hljs-comment\">;; atan scheme 自带的反正切函数  y x 返回 y/x 的角度 参数的符号决定角度的象限</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">atan</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-real-imag</span> x y)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x y)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-mag-ang</span> r a)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> r (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cos</span></span> a)) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> r (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sin</span></span> a )))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 极坐标方式</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cos</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> z))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-real-imag</span> x y)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sqrt</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">square</span> x) (<span class=\"hljs-name\">square</span> y)) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">atan</span></span> y x)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-mag-imag</span> r a)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> r a)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种构造加减乘除的构造方式，通过拆分<strong>虚部</strong>和<strong>实部</strong>为输入，来保证针对两种复数表示方式均可以使用。而复数的两种表现形式则是根据<strong>坐标</strong>和<strong>极坐标</strong>的公式分别取定义的过程。在需要取出复数<strong>虚部</strong>和<strong>实部</strong>的时候，则需要针对过程分别去定义不同的取值方式。实际上可以再在上方抽象一层，通过打一个<strong>符号</strong>作为标识哪种复数构成的方式，来区分这两种复数的构成。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 抽象出打标 取标层数据层</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 利用标志来实现两种坐标方式融合</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; type-tag 标志字符，rectangular 坐标 polar 极坐标</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; content 数据结构的内容</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">attach-tag</span> type-tag content)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\">type-tag</span> content))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">type-tag</span> datum)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">pair?</span></span> datum)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> datum)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\"Bad tagged datum -- type-TAG\"</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">contents</span> datum)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">pair?</span></span> datum)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> datum)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\"bad tagged datum -- CONTENTS\"</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 判断是哪种数据结构</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">rectangular?</span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> (<span class=\"hljs-name\">type-tag</span> z) <span class=\"hljs-symbol\">'rectangular</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">polar?</span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> (<span class=\"hljs-name\">type-tag</span> z) <span class=\"hljs-symbol\">'polar</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们加入<strong>打标</strong>的抽象层以后，来修改对应的两种复数表示方式(坐标和极坐标表示方式)。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 加入标识层之后的直角坐标和极坐标表示方式</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; rectangular直角坐标表示方式</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">real-part-rectangular</span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">imag-part-rectangular</span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> z))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">magnitude-rectangular</span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sqrt</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"hljs-name\">saquare</span> (<span class=\"hljs-name\">real-part-rectangular</span> z))</span><br><span class=\"line\">    (<span class=\"hljs-name\">saquare</span> (<span class=\"hljs-name\">imag-part-rectangular</span> z))</span><br><span class=\"line\">  ))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">angle-rectangular</span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">atan</span></span></span><br><span class=\"line\">    (<span class=\"hljs-name\">imag-part-rectangular</span> z)</span><br><span class=\"line\">    (<span class=\"hljs-name\">real-part-rectangular</span> z)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-real-imag-rectangular</span> x y)</span><br><span class=\"line\">  (<span class=\"hljs-name\">attach-tag</span> <span class=\"hljs-symbol\">'rectangular</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> x y))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-mag-ang-rectangular</span> r a)</span><br><span class=\"line\">  (<span class=\"hljs-name\">attach-tag</span></span><br><span class=\"line\">    <span class=\"hljs-symbol\">'rectangular</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> r (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cos</span></span> a))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> r (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sin</span></span> a))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 极坐标方式</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">real-part-polar</span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">magnitude-polar</span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cos</span></span> (<span class=\"hljs-name\">angle-polar</span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">imag-part-polar</span> z)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">magnitude-polar</span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sin</span></span> (<span class=\"hljs-name\">angle-polar</span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">magnitude-polar</span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">angle-polar</span> z) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> z))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-real-imag-polar</span> x y)</span><br><span class=\"line\">  (<span class=\"hljs-name\">attach-tag</span></span><br><span class=\"line\">    <span class=\"hljs-symbol\">'polar</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sqrt</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">square</span> x) (<span class=\"hljs-name\">square</span> y)) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">atan</span></span> y x)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">  </span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-mag-imag</span> r a)</span><br><span class=\"line\">  (<span class=\"hljs-name\">attach-tag</span></span><br><span class=\"line\">    <span class=\"hljs-symbol\">'polar</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> r a)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;修改的部分仅仅是：<br>&emsp;&emsp;1. 操作的函数名字加上了对应的坐标系表示<br>&emsp;&emsp;2. 创建复数的函数，在外部加上了一层<code>attach-tag</code>函数。创建了一个<code>(标识 (复数内容))</code>的数据结构。</p>\n<p>&emsp;&emsp;修改之后，可以发现，由于四则运算函数采用的是<strong>实部</strong>以及<strong>虚部</strong>输入的方式构建的，修改复数的构造函数不对其部分造成任何影响。至此，我们成功建立起了<code>运算-复数算数-底层表示方式</code>三层的数据结构屏障。</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----- add sub mul div -----</span><br><span class=\"line\">-----    复数算数包     ----- </span><br><span class=\"line\">-----   real  imag    ----- </span><br><span class=\"line\">直角坐标系    |      极坐标系</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;实际上，这种模块的构造方式仍然存在缺点，增加新类型的维护成本高。如果现在为复数的组成方式添加新的构成方式，就需要添加新的表示符号，检查操作方法重名问题，牵扯到维护的地方很多。书上提到的解决方法，是使用<code>put set</code>加上<code>lambda</code>的方式来解决。即把所有的函数对应操作一一整合到一个类似表的函数中，使用标识符作为取出的方法。如图：<br><img src=\"/blog/public/imgs/scip/scip2-8.jpg\" alt=\"复数的操作规整\"><br>&emsp;&emsp;以<code>real-part</code>为例，我在构造的时候只需要往<code>real-part</code>当中put函数和<strong>标志符</strong>储存，需要的时候根据<strong>标识符</strong>取出即可。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 储存 rectangular 和 polar 的两种构成方式的 real-part 函数</span></span><br><span class=\"line\">(<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'real-part</span> <span class=\"hljs-symbol\">'rectangular</span> real-part-rectangular)</span><br><span class=\"line\">(<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'real-part</span> <span class=\"hljs-symbol\">'polar</span> real-part-polar)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 取出对应的操作方法</span></span><br><span class=\"line\">((<span class=\"hljs-name\">get</span> <span class=\"hljs-symbol\">'real-part</span> <span class=\"hljs-symbol\">'polar</span>) z)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这种类似于JS对象中的储存概念:<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> realPart = &#123;</span><br><span class=\"line\">    rectangular: real-part-rectangular,</span><br><span class=\"line\">    polar: real-part-polar,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">realPart[<span class=\"hljs-string\">'polar'</span>](z);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这种组成方式易于维护（添加和获取方法），可读性也很强。是一种非常优秀的模块设计方式。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第二章-第四节-抽象数据的多重表示\"><a href=\"#第二章-第四节-抽象数据的多重表示\" class=\"headerlink\" title=\"第二章 第四节 抽象数据的多重表示\"></a>第二章 第四节 抽象数据的多重表示</h2><p>&emsp;&emsp;这一节我们将综合前三节的内容，利用抽象屏障，构造一个复数相关数据结构运算，并使用符号数据标识两种复数标识类型，使得底层的方法能够支持两种复数数据结构表示方法运算。<br></p>","more":"<br>&emsp;&emsp;本章核心是利用<strong>标识</strong>结合<strong>通用模块</strong>创建适配多种复合数据结构的抽象屏障。大型程序往往是多个新旧模块的结合。平常我们经常引的著名的包库，本质上就是一种<strong>通用性过程</strong>的<strong>旧模块</strong>。我们将这些通用性模块，根据业务逻辑拼接组合起来，形成我们适配业务过程的一个个的应用程序。这一节，我们利用复数两种表达形式，从功能过程性的设计开始，到适配两种复数数据结构表现形式，最后到拆分通用性功能模块，感受这一变化进程当中的思考和对程序设计的感悟。</p>\n<p>&emsp;&emsp;一个复数由<strong>实部</strong>和<strong>虚步</strong>构成，把它放到一个虚轴和实轴构成的直接坐标系当中，可以把任意一个<strong>复数</strong>表现为直角坐标系上面的一个点。场景如下：<br><img src=\"/blog/public/imgs/scip/scip2-7.jpg\" alt=\"复数的表达方式\"></p>\n<p>&emsp;&emsp;至此，我们可以把复数用两种方式表达出来，<strong>坐标形式（实部和虚部）</strong>以及<strong>极坐标形式（模和幅角）</strong>。通过图上两种表达方式的特点以及下方复数运算的公式，我们不难发现，在复数<strong>加减</strong>的时候，采用<strong>坐标形式</strong>的复数表达方式更容易计算，<strong>乘除</strong>的时候则是<strong>极坐标</strong>的构成方式更为方便。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 复数的加减</span></span><br><span class=\"line\"><span class=\"comment\">  * 实部(z1 +/- z2)=实部(z1) +/- 实部(z2)</span></span><br><span class=\"line\"><span class=\"comment\">  * 虚部(z1 +/- z2)=虚部(z1) +/- 虚部(z2)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 复数的乘除</span></span><br><span class=\"line\"><span class=\"comment\">  * //* 标识 / 或者 *</span></span><br><span class=\"line\"><span class=\"comment\">  * 实部(z1 //* z2)=实部(z1) //* 实部(z2)</span></span><br><span class=\"line\"><span class=\"comment\">  * 虚部(z1 //* z2)=虚部(z1) -/+ 虚部(z2)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以很方便的根据公式来写出复数的加减乘除的运算函数。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 复数的操作方法 加 减 乘 除</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">add-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"name\">make-from-real-imag</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sub-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"name\">make-from-real-imag</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">mul-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"name\">make-from-mag-ang</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">div-complex</span> z1 z2)</span><br><span class=\"line\">  (<span class=\"name\">make-from-mag-ang</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">/</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z2))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;接着我们列出<strong>坐标形式</strong>和<strong>极坐标</strong>形式的两种复数构造关系。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 直角坐标方式</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> z))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">sqrt</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">square</span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z)) (<span class=\"name\">square</span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z)</span><br><span class=\"line\">  <span class=\"comment\">;; atan scheme 自带的反正切函数  y x 返回 y/x 的角度 参数的符号决定角度的象限</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">atan</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-real-imag</span> x y)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x y)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-mag-ang</span> r a)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> r (<span class=\"name\"><span class=\"builtin-name\">cos</span></span> a)) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> r (<span class=\"name\"><span class=\"builtin-name\">sin</span></span> a )))</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 极坐标方式</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">cos</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">sin</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> z))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-real-imag</span> x y)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">sqrt</span></span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">square</span> x) (<span class=\"name\">square</span> y)) (<span class=\"name\"><span class=\"builtin-name\">atan</span></span> y x)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-mag-imag</span> r a)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> r a)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这种构造加减乘除的构造方式，通过拆分<strong>虚部</strong>和<strong>实部</strong>为输入，来保证针对两种复数表示方式均可以使用。而复数的两种表现形式则是根据<strong>坐标</strong>和<strong>极坐标</strong>的公式分别取定义的过程。在需要取出复数<strong>虚部</strong>和<strong>实部</strong>的时候，则需要针对过程分别去定义不同的取值方式。实际上可以再在上方抽象一层，通过打一个<strong>符号</strong>作为标识哪种复数构成的方式，来区分这两种复数的构成。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 抽象出打标 取标层数据层</span></span><br><span class=\"line\"><span class=\"comment\">;; 利用标志来实现两种坐标方式融合</span></span><br><span class=\"line\"><span class=\"comment\">;; type-tag 标志字符，rectangular 坐标 polar 极坐标</span></span><br><span class=\"line\"><span class=\"comment\">;; content 数据结构的内容</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">attach-tag</span> type-tag content)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\">type-tag</span> content))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">type-tag</span> datum)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> datum)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">car</span></span> datum)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\"Bad tagged datum -- type-TAG\"</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">contents</span> datum)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> datum)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> datum)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\"bad tagged datum -- CONTENTS\"</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 判断是哪种数据结构</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">rectangular?</span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\">type-tag</span> z) <span class=\"symbol\">'rectangular</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">polar?</span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\">type-tag</span> z) <span class=\"symbol\">'polar</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们加入<strong>打标</strong>的抽象层以后，来修改对应的两种复数表示方式(坐标和极坐标表示方式)。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 加入标识层之后的直角坐标和极坐标表示方式</span></span><br><span class=\"line\"><span class=\"comment\">;; rectangular直角坐标表示方式</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">real-part-rectangular</span> z) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">imag-part-rectangular</span> z) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> z))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">magnitude-rectangular</span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">sqrt</span></span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"name\">saquare</span> (<span class=\"name\">real-part-rectangular</span> z))</span><br><span class=\"line\">    (<span class=\"name\">saquare</span> (<span class=\"name\">imag-part-rectangular</span> z))</span><br><span class=\"line\">  ))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">angle-rectangular</span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">atan</span></span></span><br><span class=\"line\">    (<span class=\"name\">imag-part-rectangular</span> z)</span><br><span class=\"line\">    (<span class=\"name\">real-part-rectangular</span> z)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-real-imag-rectangular</span> x y)</span><br><span class=\"line\">  (<span class=\"name\">attach-tag</span> <span class=\"symbol\">'rectangular</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x y))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-mag-ang-rectangular</span> r a)</span><br><span class=\"line\">  (<span class=\"name\">attach-tag</span></span><br><span class=\"line\">    <span class=\"symbol\">'rectangular</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> r (<span class=\"name\"><span class=\"builtin-name\">cos</span></span> a))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> r (<span class=\"name\"><span class=\"builtin-name\">sin</span></span> a))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 极坐标方式</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">real-part-polar</span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">magnitude-polar</span> z) (<span class=\"name\"><span class=\"builtin-name\">cos</span></span> (<span class=\"name\">angle-polar</span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">imag-part-polar</span> z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">magnitude-polar</span> z) (<span class=\"name\"><span class=\"builtin-name\">sin</span></span> (<span class=\"name\">angle-polar</span> z)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">magnitude-polar</span> z) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> z))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">angle-polar</span> z) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> z))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-real-imag-polar</span> x y)</span><br><span class=\"line\">  (<span class=\"name\">attach-tag</span></span><br><span class=\"line\">    <span class=\"symbol\">'polar</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">sqrt</span></span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">square</span> x) (<span class=\"name\">square</span> y)) (<span class=\"name\"><span class=\"builtin-name\">atan</span></span> y x)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">  </span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-mag-imag</span> r a)</span><br><span class=\"line\">  (<span class=\"name\">attach-tag</span></span><br><span class=\"line\">    <span class=\"symbol\">'polar</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> r a)</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;修改的部分仅仅是：<br>&emsp;&emsp;1. 操作的函数名字加上了对应的坐标系表示<br>&emsp;&emsp;2. 创建复数的函数，在外部加上了一层<code>attach-tag</code>函数。创建了一个<code>(标识 (复数内容))</code>的数据结构。</p>\n<p>&emsp;&emsp;修改之后，可以发现，由于四则运算函数采用的是<strong>实部</strong>以及<strong>虚部</strong>输入的方式构建的，修改复数的构造函数不对其部分造成任何影响。至此，我们成功建立起了<code>运算-复数算数-底层表示方式</code>三层的数据结构屏障。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----- add sub mul div -----</span><br><span class=\"line\">-----    复数算数包     ----- </span><br><span class=\"line\">-----   real  imag    ----- </span><br><span class=\"line\">直角坐标系    |      极坐标系</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;实际上，这种模块的构造方式仍然存在缺点，增加新类型的维护成本高。如果现在为复数的组成方式添加新的构成方式，就需要添加新的表示符号，检查操作方法重名问题，牵扯到维护的地方很多。书上提到的解决方法，是使用<code>put set</code>加上<code>lambda</code>的方式来解决。即把所有的函数对应操作一一整合到一个类似表的函数中，使用标识符作为取出的方法。如图：<br><img src=\"/blog/public/imgs/scip/scip2-8.jpg\" alt=\"复数的操作规整\"><br>&emsp;&emsp;以<code>real-part</code>为例，我在构造的时候只需要往<code>real-part</code>当中put函数和<strong>标志符</strong>储存，需要的时候根据<strong>标识符</strong>取出即可。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 储存 rectangular 和 polar 的两种构成方式的 real-part 函数</span></span><br><span class=\"line\">(<span class=\"name\">put</span> <span class=\"symbol\">'real-part</span> <span class=\"symbol\">'rectangular</span> real-part-rectangular)</span><br><span class=\"line\">(<span class=\"name\">put</span> <span class=\"symbol\">'real-part</span> <span class=\"symbol\">'polar</span> real-part-polar)</span><br><span class=\"line\"><span class=\"comment\">;; 取出对应的操作方法</span></span><br><span class=\"line\">((<span class=\"name\">get</span> <span class=\"symbol\">'real-part</span> <span class=\"symbol\">'polar</span>) z)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这种类似于JS对象中的储存概念:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> realPart = &#123;</span><br><span class=\"line\">    rectangular: real-part-rectangular,</span><br><span class=\"line\">    polar: real-part-polar,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">realPart[<span class=\"string\">'polar'</span>](z);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;这种组成方式易于维护（添加和获取方法），可读性也很强。是一种非常优秀的模块设计方式。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-2.5","date":"2019-08-17T09:20:00.000Z","_content":"## 第二章 第五节 带有通用型操作的系统\n&emsp;&emsp;这一节讲去思考如何设计一个系统，使其中的数据对象可以多于一种方式表示。\n<!--more-->\n&emsp;&emsp;最简单的四则运算，基于数据结构的不同，需要对应不同的运算模式。本节将以四则运算作为切入点，抽象出一个应对多个复杂数据结构的通用型的四则运算计算系统。\n```md\n            外部调用\n--------- add sub mul div ---------\n           通用型数据包\n  -- 有理数 -- 复数运算 -- 常规算数\n    add-rat   add-cox     add\n    sub-rat   sub-cox     sub\n    mul-rat   mul-cox     mul\n    div-rat   div-cox     div\n```\n&emsp;&emsp;如上，在通用型系统设计中，我们希望外部调用系统时在调用运算函数（譬如加法函数）的时候，不需要根据输入的数据类型来调用不同的加法函数。而是调用加法函数，放入数据类型。系统内部能够根据放入的数据类型去匹配不同的加法函数。根据这个设计理念，我们来定义一下通用型系统的框架。\n```scheme\n(define (add x y) (apply-generic 'add x y))\n(define (sub x y) (apply-generic 'sub x y))\n(define (mul x y) (apply-generic 'mul x y))\n(define (div x y) (apply-generic 'div x y))\n\n;; 后续新增新的数据结构，只需要来维护 apply-generic\n(define (apply-generic method x y)\n    ;; 所有带标志的数据结构，应该都是 (const tag data)形式，这里使用car取出标志\n    ((get method (car x)) x y)\n)\n```\n&emsp;&emsp;现在我们需要建立一个类似包的函数结构，运行一次函数后，能够将**一类数据结构**注册进通用型系统。我们使用常数作为示例，建立一个基础的`install-scheme-number-package`。\n```scheme\n(define (install-scheme-number-package)\n  ;;声明 tag x\n  (define (tag x)\n    ;; 打标\n    (attach-tag 'scheme-number x))\n  (define scheme-numer-tag '(scheme-numer scheme-number))\n  (put 'add scheme-numer-tag (lambda (x y) (tag (+ x y))))\n  (put 'sub scheme-numer-tag (lambda (x y) (tag (- x y))))\n  (put 'mul scheme-numer-tag (lambda (x y) (tag (* x y))))\n  (put 'div scheme-numer-tag(lambda (x y) (tag (/ x y))))\n  (put 'make 'scheme-number (lambda (x) (tag x)))\n  'done\n)\n```\n&emsp;&emsp;install某个数据结构的package，本质上就是put了带着特定**标志**的加减乘除到对应的`add sub mul div`当中去。方便`apply-generic`根据运算方式和数据标志取出对应的数据进行调用。现在我们根据这个规则和前四节的内容，往系统当中添加**无理数**和**复数**数据结构处理的包`install-rational-package`和`install-complex-package`。\n```scheme\n;; 无理数包\n(define (install-rational-package)\n  (define (number x) (car x))\n\n  (define (denom x ) (cdr x))\n\n  (define (make-rat n d)\n    (let\n      ((g (gcd n d)))\n      (cons (/ n g) (/ d g))))\n\n  (define (add-rat x y)\n    (make-rat\n      (+\n        (* (number x) (denom y))\n        (* (number y) (denom x)))\n      (* (denom x) (denom y))))\n\n  (define (sub-rat x y)\n    (make-rat\n      (-\n        (* (number x) (denom y))\n        (* (number y) (denom x)))\n      (* (denom x) (denom y))))\n\n  (define (mul-rat x y)\n    (make-rat\n      (* (number x) (number y))\n      (* (denom x) (denom y))))\n\n  (define (div-rat x y)\n    (make-rat\n      (* (number x) (denom y))\n      (* (denom x) (number y))))\n;; interface to rest of the system\n  (define (tag x) (attach-tag 'rational x))\n  (define rational-tag '(rational rational))\n  (put 'add rational-tag (lambda (x y) (tag (add-rat x y))))\n  (put 'sub rational-tag (lambda (x y) (tag (sub-rat x y))))\n  (put 'mul rational-tag (lambda (x y) (tag (mul-rat x y))))\n  (put 'div rational-tag (lambda (x y) (tag (div-rat x y))))\n  'done\n)\n\n;; 复数处理包 complex\n(define (install-complex-package)\n  (define (make-from-real-imag x y)\n    ((get 'make-from-real-imag 'rectangular) x y))\n  (define (make-from-mag-ang r a)\n    ((get 'make-from-mag-ang 'polar) r a))\n  (define (add-complex z1 z3)\n    (make-from-real-imag\n      (+ (real-part z1) (real-part z2))\n      (+ (imag-part z1) (imag-part z2))))\n  (define (sub-complex z1 z2)\n    (make-from-real-imag\n      (- (real-part z1) (real-part z2))\n      (- (imag-part z1) (imag-part z2))))\n  (define (mul-complex z1 z2)\n    (make-from-mag-ang\n      (* (magnitude z1) (magnitude z2))\n      (+ (angle z1) (angle z2))))\n  (define (div-complex z1 z2)\n    (make-from-mag-ang\n      (/ (magnitude z1) (magnitude z2))\n      (- (angle z1) (angle z2))))\n  ;;interface to rest of the system\n  (define (tag z) (attach-tag 'complex z))\n  (define tag-name '(complex complex))\n  (put 'add tag-name (lambda (z1 z2) (tag (add-complex z1 z2))))\n  (put 'sub tag-name (lambda (z1 z2) (tag (sub-complex z1 z2))))\n  (put 'mul tag-name (lambda (z1 z2) (tag (mul-complex z1 z2))))\n  (put 'div tag-name (lambda (z1 z2) (tag (div-complex z1 z2))))\n  (put 'make-from-real-imag 'complex\n    (lambda (z1 z2) (tag (make-from-real-imag x y)))\n  )\n  (put 'make-from-mag-and 'complex\n    (lambda (r a) (tag (make-from-mag-ang r a)))\n  )\n  'done\n)\n```\n&emsp;&emsp;在2-4当中讨论过，复数可以用两种形式构成，`实部虚部直角坐标系`和`模和幅角`。因此我们在复数`install-complex-package`包中,定义了两种创建复数数据类型的函数`make-from-real-imag`和`make-from-mag-and`。外部可以自己喜欢的方式去创建对应的复数数据结构。\n```scheme\n;; 复数的两种创建模式，角度和坐标定义\n(define (make-complex-from-real-imag x y)\n  ((get 'make-from-real-imag 'complex) x y)\n)\n(define (make-complex-from-mag-ang r a)\n  ((get 'make-from-mag-ang 'complex) r a)\n)\n```\n&emsp;&emsp;在上述的通用型系统设计模式中，我们设计理念遵循，**外部调用运算函数**，内部根据**运算函数**和**传入的数据类型标识**来匹配到细节函数的方式，完成了一个简易的通用型系统。接下来，介绍另外一种不同于匹配分发设计思想的**组合**的通用型系统设计。\n\n&emsp;&emsp;所谓**组合**的通用型系统，即是把多种数据类型**强制**转换为一种数据类型，采用一套运算函数的方式。比如常规的数字和复数之间，我们可以把常规数字看做虚部为0的复数，来把所有输入系统的**常规数**类型转换为**虚数类型**。\n```scheme\n;; 强制的概念，把一种数据类型强制转换为另一种数据类型，使得两包想通\n;; scheme-number -> complex-number 普通数看为虚部为0的复数\n(define (scheme-number->complex n)\n  (make-complex-from-real-imag (contents n) 0))\n(put-coercion 'scheme-number 'complex scheme-number->complex)\n```\n&emsp;&emsp;根据配装，我们重新设计一下`apply-generic`。\n```scheme\n(define (apply-generic op , args)\n  (let ((type-tags (map type-tag args)))\n    (let ((proc (get op type-tags)))\n      (if proc\n        (apply proc (map contents args))\n        (if (= (length args) 2)\n          (let ((type1 (car type-tags))\n            (type2 (cadr type-tags))\n            (a1 (car args))\n            (a2 (cadr args)))\n            (let ((t1->t2 (get-coercion type1 typ2))\n              (t2->t1 (get-coercion type2 typ1))))\n              (cond\n                (t1->t2\n                  (apply-generic op (t1->t2 a1) a2))\n                (t2->t1\n                  (apply-generic op a1 (t2->t1 a2)))))))))))\n```\n&emsp;&emsp;**组合**设计通用操作系统与**打标分配**的方式相比，有比较大的优越性，虽然我们需要书写强制转换数据结构的类型，但是由于数据结构被转换为一种，一个对应的操作（诸如四则）只需要书写一个函数即可。但是这种设计严重依赖输入的数据结构之间需要**能够强制转换**。\n\n&emsp;&emsp;实际生活中，我们更多使用的是类似于**组合强制**的一种**塔型**的层次性结构。拿上面的集中数据结构为例。形成一个`整数 -> 有理数 -> 实数 -> 复数`的类型塔。\n\n&emsp;&emsp;在**塔型**的设计思想中，我们需要一个类似`apply-generic`的过程，能够把一种数据类型**提升**到更高一层次的类型。每个类型能够**继承**其超类型中定义的所有操作。但这种数据结构在大型系统设计时，面对一大批相互有关系的类型，如何处理好同时保持模块性。是一个非常复杂而又困难的事情。\n","source":"_posts/scip/scip(chap2-5).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-2.5\ndate: 2019/8/17 17:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第二章 第五节 带有通用型操作的系统\n&emsp;&emsp;这一节讲去思考如何设计一个系统，使其中的数据对象可以多于一种方式表示。\n<!--more-->\n&emsp;&emsp;最简单的四则运算，基于数据结构的不同，需要对应不同的运算模式。本节将以四则运算作为切入点，抽象出一个应对多个复杂数据结构的通用型的四则运算计算系统。\n```md\n            外部调用\n--------- add sub mul div ---------\n           通用型数据包\n  -- 有理数 -- 复数运算 -- 常规算数\n    add-rat   add-cox     add\n    sub-rat   sub-cox     sub\n    mul-rat   mul-cox     mul\n    div-rat   div-cox     div\n```\n&emsp;&emsp;如上，在通用型系统设计中，我们希望外部调用系统时在调用运算函数（譬如加法函数）的时候，不需要根据输入的数据类型来调用不同的加法函数。而是调用加法函数，放入数据类型。系统内部能够根据放入的数据类型去匹配不同的加法函数。根据这个设计理念，我们来定义一下通用型系统的框架。\n```scheme\n(define (add x y) (apply-generic 'add x y))\n(define (sub x y) (apply-generic 'sub x y))\n(define (mul x y) (apply-generic 'mul x y))\n(define (div x y) (apply-generic 'div x y))\n\n;; 后续新增新的数据结构，只需要来维护 apply-generic\n(define (apply-generic method x y)\n    ;; 所有带标志的数据结构，应该都是 (const tag data)形式，这里使用car取出标志\n    ((get method (car x)) x y)\n)\n```\n&emsp;&emsp;现在我们需要建立一个类似包的函数结构，运行一次函数后，能够将**一类数据结构**注册进通用型系统。我们使用常数作为示例，建立一个基础的`install-scheme-number-package`。\n```scheme\n(define (install-scheme-number-package)\n  ;;声明 tag x\n  (define (tag x)\n    ;; 打标\n    (attach-tag 'scheme-number x))\n  (define scheme-numer-tag '(scheme-numer scheme-number))\n  (put 'add scheme-numer-tag (lambda (x y) (tag (+ x y))))\n  (put 'sub scheme-numer-tag (lambda (x y) (tag (- x y))))\n  (put 'mul scheme-numer-tag (lambda (x y) (tag (* x y))))\n  (put 'div scheme-numer-tag(lambda (x y) (tag (/ x y))))\n  (put 'make 'scheme-number (lambda (x) (tag x)))\n  'done\n)\n```\n&emsp;&emsp;install某个数据结构的package，本质上就是put了带着特定**标志**的加减乘除到对应的`add sub mul div`当中去。方便`apply-generic`根据运算方式和数据标志取出对应的数据进行调用。现在我们根据这个规则和前四节的内容，往系统当中添加**无理数**和**复数**数据结构处理的包`install-rational-package`和`install-complex-package`。\n```scheme\n;; 无理数包\n(define (install-rational-package)\n  (define (number x) (car x))\n\n  (define (denom x ) (cdr x))\n\n  (define (make-rat n d)\n    (let\n      ((g (gcd n d)))\n      (cons (/ n g) (/ d g))))\n\n  (define (add-rat x y)\n    (make-rat\n      (+\n        (* (number x) (denom y))\n        (* (number y) (denom x)))\n      (* (denom x) (denom y))))\n\n  (define (sub-rat x y)\n    (make-rat\n      (-\n        (* (number x) (denom y))\n        (* (number y) (denom x)))\n      (* (denom x) (denom y))))\n\n  (define (mul-rat x y)\n    (make-rat\n      (* (number x) (number y))\n      (* (denom x) (denom y))))\n\n  (define (div-rat x y)\n    (make-rat\n      (* (number x) (denom y))\n      (* (denom x) (number y))))\n;; interface to rest of the system\n  (define (tag x) (attach-tag 'rational x))\n  (define rational-tag '(rational rational))\n  (put 'add rational-tag (lambda (x y) (tag (add-rat x y))))\n  (put 'sub rational-tag (lambda (x y) (tag (sub-rat x y))))\n  (put 'mul rational-tag (lambda (x y) (tag (mul-rat x y))))\n  (put 'div rational-tag (lambda (x y) (tag (div-rat x y))))\n  'done\n)\n\n;; 复数处理包 complex\n(define (install-complex-package)\n  (define (make-from-real-imag x y)\n    ((get 'make-from-real-imag 'rectangular) x y))\n  (define (make-from-mag-ang r a)\n    ((get 'make-from-mag-ang 'polar) r a))\n  (define (add-complex z1 z3)\n    (make-from-real-imag\n      (+ (real-part z1) (real-part z2))\n      (+ (imag-part z1) (imag-part z2))))\n  (define (sub-complex z1 z2)\n    (make-from-real-imag\n      (- (real-part z1) (real-part z2))\n      (- (imag-part z1) (imag-part z2))))\n  (define (mul-complex z1 z2)\n    (make-from-mag-ang\n      (* (magnitude z1) (magnitude z2))\n      (+ (angle z1) (angle z2))))\n  (define (div-complex z1 z2)\n    (make-from-mag-ang\n      (/ (magnitude z1) (magnitude z2))\n      (- (angle z1) (angle z2))))\n  ;;interface to rest of the system\n  (define (tag z) (attach-tag 'complex z))\n  (define tag-name '(complex complex))\n  (put 'add tag-name (lambda (z1 z2) (tag (add-complex z1 z2))))\n  (put 'sub tag-name (lambda (z1 z2) (tag (sub-complex z1 z2))))\n  (put 'mul tag-name (lambda (z1 z2) (tag (mul-complex z1 z2))))\n  (put 'div tag-name (lambda (z1 z2) (tag (div-complex z1 z2))))\n  (put 'make-from-real-imag 'complex\n    (lambda (z1 z2) (tag (make-from-real-imag x y)))\n  )\n  (put 'make-from-mag-and 'complex\n    (lambda (r a) (tag (make-from-mag-ang r a)))\n  )\n  'done\n)\n```\n&emsp;&emsp;在2-4当中讨论过，复数可以用两种形式构成，`实部虚部直角坐标系`和`模和幅角`。因此我们在复数`install-complex-package`包中,定义了两种创建复数数据类型的函数`make-from-real-imag`和`make-from-mag-and`。外部可以自己喜欢的方式去创建对应的复数数据结构。\n```scheme\n;; 复数的两种创建模式，角度和坐标定义\n(define (make-complex-from-real-imag x y)\n  ((get 'make-from-real-imag 'complex) x y)\n)\n(define (make-complex-from-mag-ang r a)\n  ((get 'make-from-mag-ang 'complex) r a)\n)\n```\n&emsp;&emsp;在上述的通用型系统设计模式中，我们设计理念遵循，**外部调用运算函数**，内部根据**运算函数**和**传入的数据类型标识**来匹配到细节函数的方式，完成了一个简易的通用型系统。接下来，介绍另外一种不同于匹配分发设计思想的**组合**的通用型系统设计。\n\n&emsp;&emsp;所谓**组合**的通用型系统，即是把多种数据类型**强制**转换为一种数据类型，采用一套运算函数的方式。比如常规的数字和复数之间，我们可以把常规数字看做虚部为0的复数，来把所有输入系统的**常规数**类型转换为**虚数类型**。\n```scheme\n;; 强制的概念，把一种数据类型强制转换为另一种数据类型，使得两包想通\n;; scheme-number -> complex-number 普通数看为虚部为0的复数\n(define (scheme-number->complex n)\n  (make-complex-from-real-imag (contents n) 0))\n(put-coercion 'scheme-number 'complex scheme-number->complex)\n```\n&emsp;&emsp;根据配装，我们重新设计一下`apply-generic`。\n```scheme\n(define (apply-generic op , args)\n  (let ((type-tags (map type-tag args)))\n    (let ((proc (get op type-tags)))\n      (if proc\n        (apply proc (map contents args))\n        (if (= (length args) 2)\n          (let ((type1 (car type-tags))\n            (type2 (cadr type-tags))\n            (a1 (car args))\n            (a2 (cadr args)))\n            (let ((t1->t2 (get-coercion type1 typ2))\n              (t2->t1 (get-coercion type2 typ1))))\n              (cond\n                (t1->t2\n                  (apply-generic op (t1->t2 a1) a2))\n                (t2->t1\n                  (apply-generic op a1 (t2->t1 a2)))))))))))\n```\n&emsp;&emsp;**组合**设计通用操作系统与**打标分配**的方式相比，有比较大的优越性，虽然我们需要书写强制转换数据结构的类型，但是由于数据结构被转换为一种，一个对应的操作（诸如四则）只需要书写一个函数即可。但是这种设计严重依赖输入的数据结构之间需要**能够强制转换**。\n\n&emsp;&emsp;实际生活中，我们更多使用的是类似于**组合强制**的一种**塔型**的层次性结构。拿上面的集中数据结构为例。形成一个`整数 -> 有理数 -> 实数 -> 复数`的类型塔。\n\n&emsp;&emsp;在**塔型**的设计思想中，我们需要一个类似`apply-generic`的过程，能够把一种数据类型**提升**到更高一层次的类型。每个类型能够**继承**其超类型中定义的所有操作。但这种数据结构在大型系统设计时，面对一大批相互有关系的类型，如何处理好同时保持模块性。是一个非常复杂而又困难的事情。\n","slug":"scip/scip(chap2-5)","published":1,"updated":"2020-06-11T01:43:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy5002a9r2vmodzwgp2","content":"<h2 id=\"第二章-第五节-带有通用型操作的系统\"><a href=\"#第二章-第五节-带有通用型操作的系统\" class=\"headerlink\" title=\"第二章 第五节 带有通用型操作的系统\"></a>第二章 第五节 带有通用型操作的系统</h2><p>&emsp;&emsp;这一节讲去思考如何设计一个系统，使其中的数据对象可以多于一种方式表示。<br><a id=\"more\"></a><br>&emsp;&emsp;最简单的四则运算，基于数据结构的不同，需要对应不同的运算模式。本节将以四则运算作为切入点，抽象出一个应对多个复杂数据结构的通用型的四则运算计算系统。<br><figure class=\"highlight md hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-code\">            外部调用</span></span><br><span class=\"line\">--------- add sub mul div ---------</span><br><span class=\"line\"><span class=\"hljs-code\">           通用型数据包</span></span><br><span class=\"line\">  -- 有理数 -- 复数运算 -- 常规算数</span><br><span class=\"line\"><span class=\"hljs-code\">    add-rat   add-cox     add</span></span><br><span class=\"line\"><span class=\"hljs-code\">    sub-rat   sub-cox     sub</span></span><br><span class=\"line\"><span class=\"hljs-code\">    mul-rat   mul-cox     mul</span></span><br><span class=\"line\"><span class=\"hljs-code\">    div-rat   div-cox     div</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;如上，在通用型系统设计中，我们希望外部调用系统时在调用运算函数（譬如加法函数）的时候，不需要根据输入的数据类型来调用不同的加法函数。而是调用加法函数，放入数据类型。系统内部能够根据放入的数据类型去匹配不同的加法函数。根据这个设计理念，我们来定义一下通用型系统的框架。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">add</span> x y) (<span class=\"hljs-name\">apply-generic</span> <span class=\"hljs-symbol\">'add</span> x y))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sub</span> x y) (<span class=\"hljs-name\">apply-generic</span> <span class=\"hljs-symbol\">'sub</span> x y))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">mul</span> x y) (<span class=\"hljs-name\">apply-generic</span> <span class=\"hljs-symbol\">'mul</span> x y))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">div</span> x y) (<span class=\"hljs-name\">apply-generic</span> <span class=\"hljs-symbol\">'div</span> x y))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 后续新增新的数据结构，只需要来维护 apply-generic</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">apply-generic</span> method x y)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 所有带标志的数据结构，应该都是 (const tag data)形式，这里使用car取出标志</span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">get</span> method (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> x)) x y)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们需要建立一个类似包的函数结构，运行一次函数后，能够将<strong>一类数据结构</strong>注册进通用型系统。我们使用常数作为示例，建立一个基础的<code>install-scheme-number-package</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">install-scheme-number-package</span>)</span><br><span class=\"line\">  <span class=\"hljs-comment\">;;声明 tag x</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">tag</span> x)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 打标</span></span><br><span class=\"line\">    (<span class=\"hljs-name\">attach-tag</span> <span class=\"hljs-symbol\">'scheme-number</span> x))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> scheme-numer-tag '(scheme-numer scheme-number))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'add</span> scheme-numer-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'sub</span> scheme-numer-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'mul</span> scheme-numer-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'div</span> scheme-numer-tag(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'make</span> <span class=\"hljs-symbol\">'scheme-number</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x) (<span class=\"hljs-name\">tag</span> x)))</span><br><span class=\"line\">  <span class=\"hljs-symbol\">'done</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;install某个数据结构的package，本质上就是put了带着特定<strong>标志</strong>的加减乘除到对应的<code>add sub mul div</code>当中去。方便<code>apply-generic</code>根据运算方式和数据标志取出对应的数据进行调用。现在我们根据这个规则和前四节的内容，往系统当中添加<strong>无理数</strong>和<strong>复数</strong>数据结构处理的包<code>install-rational-package</code>和<code>install-complex-package</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 无理数包</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">install-rational-package</span>)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">number</span> x) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> x))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">denom</span> x ) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> x))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-rat</span> n d)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\">g</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">gcd</span></span> n d)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> n g) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> d g))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">add-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">number</span> x) (<span class=\"hljs-name\">denom</span> y))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">number</span> y) (<span class=\"hljs-name\">denom</span> x)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">denom</span> x) (<span class=\"hljs-name\">denom</span> y))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sub-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">number</span> x) (<span class=\"hljs-name\">denom</span> y))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">number</span> y) (<span class=\"hljs-name\">denom</span> x)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">denom</span> x) (<span class=\"hljs-name\">denom</span> y))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">mul-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">number</span> x) (<span class=\"hljs-name\">number</span> y))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">denom</span> x) (<span class=\"hljs-name\">denom</span> y))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">div-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">number</span> x) (<span class=\"hljs-name\">denom</span> y))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">denom</span> x) (<span class=\"hljs-name\">number</span> y))))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; interface to rest of the system</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">tag</span> x) (<span class=\"hljs-name\">attach-tag</span> <span class=\"hljs-symbol\">'rational</span> x))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> rational-tag '(rational rational))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'add</span> rational-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">add-rat</span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'sub</span> rational-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">sub-rat</span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'mul</span> rational-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">mul-rat</span> x y))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'div</span> rational-tag (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x y) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">div-rat</span> x y))))</span><br><span class=\"line\">  <span class=\"hljs-symbol\">'done</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 复数处理包 complex</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">install-complex-package</span>)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-real-imag</span> x y)</span><br><span class=\"line\">    ((<span class=\"hljs-name\">get</span> <span class=\"hljs-symbol\">'make-from-real-imag</span> <span class=\"hljs-symbol\">'rectangular</span>) x y))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-from-mag-ang</span> r a)</span><br><span class=\"line\">    ((<span class=\"hljs-name\">get</span> <span class=\"hljs-symbol\">'make-from-mag-ang</span> <span class=\"hljs-symbol\">'polar</span>) r a))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">add-complex</span> z1 z3)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-from-real-imag</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sub-complex</span> z1 z2)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-from-real-imag</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">imag-part</span></span> z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">mul-complex</span> z1 z2)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-from-mag-ang</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">div-complex</span> z1 z2)</span><br><span class=\"line\">    (<span class=\"hljs-name\">make-from-mag-ang</span></span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">angle</span></span> z2))))</span><br><span class=\"line\">  <span class=\"hljs-comment\">;;interface to rest of the system</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">tag</span> z) (<span class=\"hljs-name\">attach-tag</span> <span class=\"hljs-symbol\">'complex</span> z))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> tag-name '(complex complex))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'add</span> tag-name (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (z1 z2) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">add-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'sub</span> tag-name (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (z1 z2) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">sub-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'mul</span> tag-name (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (z1 z2) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">mul-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'div</span> tag-name (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (z1 z2) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">div-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'make-from-real-imag</span> <span class=\"hljs-symbol\">'complex</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (z1 z2) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">make-from-real-imag</span> x y)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"hljs-name\">put</span> <span class=\"hljs-symbol\">'make-from-mag-and</span> <span class=\"hljs-symbol\">'complex</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (r a) (<span class=\"hljs-name\">tag</span> (<span class=\"hljs-name\">make-from-mag-ang</span> r a)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"hljs-symbol\">'done</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在2-4当中讨论过，复数可以用两种形式构成，<code>实部虚部直角坐标系</code>和<code>模和幅角</code>。因此我们在复数<code>install-complex-package</code>包中,定义了两种创建复数数据类型的函数<code>make-from-real-imag</code>和<code>make-from-mag-and</code>。外部可以自己喜欢的方式去创建对应的复数数据结构。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 复数的两种创建模式，角度和坐标定义</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-complex-from-real-imag</span> x y)</span><br><span class=\"line\">  ((<span class=\"hljs-name\">get</span> <span class=\"hljs-symbol\">'make-from-real-imag</span> <span class=\"hljs-symbol\">'complex</span>) x y)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-complex-from-mag-ang</span> r a)</span><br><span class=\"line\">  ((<span class=\"hljs-name\">get</span> <span class=\"hljs-symbol\">'make-from-mag-ang</span> <span class=\"hljs-symbol\">'complex</span>) r a)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在上述的通用型系统设计模式中，我们设计理念遵循，<strong>外部调用运算函数</strong>，内部根据<strong>运算函数</strong>和<strong>传入的数据类型标识</strong>来匹配到细节函数的方式，完成了一个简易的通用型系统。接下来，介绍另外一种不同于匹配分发设计思想的<strong>组合</strong>的通用型系统设计。</p>\n<p>&emsp;&emsp;所谓<strong>组合</strong>的通用型系统，即是把多种数据类型<strong>强制</strong>转换为一种数据类型，采用一套运算函数的方式。比如常规的数字和复数之间，我们可以把常规数字看做虚部为0的复数，来把所有输入系统的<strong>常规数</strong>类型转换为<strong>虚数类型</strong>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 强制的概念，把一种数据类型强制转换为另一种数据类型，使得两包想通</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; scheme-number -&gt; complex-number 普通数看为虚部为0的复数</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">scheme-number-&gt;complex</span> n)</span><br><span class=\"line\">  (<span class=\"hljs-name\">make-complex-from-real-imag</span> (<span class=\"hljs-name\">contents</span> n) <span class=\"hljs-number\">0</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\">put-coercion</span> <span class=\"hljs-symbol\">'scheme-number</span> <span class=\"hljs-symbol\">'complex</span> scheme-number-&gt;complex)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;根据配装，我们重新设计一下<code>apply-generic</code>。<br><figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">apply-generic</span> op , args)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">type-tags</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">map</span></span> type-tag args)))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">proc</span> (<span class=\"hljs-name\">get</span> op type-tags)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> proc</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">apply</span></span> proc (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">map</span></span> contents args))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">length</span></span> args) <span class=\"hljs-number\">2</span>)</span><br><span class=\"line\">          (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">type1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> type-tags))</span><br><span class=\"line\">            (<span class=\"hljs-name\">type2</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cadr</span></span> type-tags))</span><br><span class=\"line\">            (<span class=\"hljs-name\">a1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> args))</span><br><span class=\"line\">            (<span class=\"hljs-name\">a2</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cadr</span></span> args)))</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">t1-&gt;t2</span> (<span class=\"hljs-name\">get-coercion</span> type1 typ2))</span><br><span class=\"line\">              (<span class=\"hljs-name\">t2-&gt;t1</span> (<span class=\"hljs-name\">get-coercion</span> type2 typ1))))</span><br><span class=\"line\">              (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">                (<span class=\"hljs-name\">t1-&gt;t2</span></span><br><span class=\"line\">                  (<span class=\"hljs-name\">apply-generic</span> op (<span class=\"hljs-name\">t1-&gt;t2</span> a1) a2))</span><br><span class=\"line\">                (<span class=\"hljs-name\">t2-&gt;t1</span></span><br><span class=\"line\">                  (apply-generic op a1 (t2-&gt;t1 a2)))))))))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<strong>组合</strong>设计通用操作系统与<strong>打标分配</strong>的方式相比，有比较大的优越性，虽然我们需要书写强制转换数据结构的类型，但是由于数据结构被转换为一种，一个对应的操作（诸如四则）只需要书写一个函数即可。但是这种设计严重依赖输入的数据结构之间需要<strong>能够强制转换</strong>。</p>\n<p>&emsp;&emsp;实际生活中，我们更多使用的是类似于<strong>组合强制</strong>的一种<strong>塔型</strong>的层次性结构。拿上面的集中数据结构为例。形成一个<code>整数 -&gt; 有理数 -&gt; 实数 -&gt; 复数</code>的类型塔。</p>\n<p>&emsp;&emsp;在<strong>塔型</strong>的设计思想中，我们需要一个类似<code>apply-generic</code>的过程，能够把一种数据类型<strong>提升</strong>到更高一层次的类型。每个类型能够<strong>继承</strong>其超类型中定义的所有操作。但这种数据结构在大型系统设计时，面对一大批相互有关系的类型，如何处理好同时保持模块性。是一个非常复杂而又困难的事情。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第二章-第五节-带有通用型操作的系统\"><a href=\"#第二章-第五节-带有通用型操作的系统\" class=\"headerlink\" title=\"第二章 第五节 带有通用型操作的系统\"></a>第二章 第五节 带有通用型操作的系统</h2><p>&emsp;&emsp;这一节讲去思考如何设计一个系统，使其中的数据对象可以多于一种方式表示。<br></p>","more":"<br>&emsp;&emsp;最简单的四则运算，基于数据结构的不同，需要对应不同的运算模式。本节将以四则运算作为切入点，抽象出一个应对多个复杂数据结构的通用型的四则运算计算系统。<br><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">            外部调用</span></span><br><span class=\"line\">--------- add sub mul div ---------</span><br><span class=\"line\"><span class=\"code\">           通用型数据包</span></span><br><span class=\"line\">  -- 有理数 -- 复数运算 -- 常规算数</span><br><span class=\"line\"><span class=\"code\">    add-rat   add-cox     add</span></span><br><span class=\"line\"><span class=\"code\">    sub-rat   sub-cox     sub</span></span><br><span class=\"line\"><span class=\"code\">    mul-rat   mul-cox     mul</span></span><br><span class=\"line\"><span class=\"code\">    div-rat   div-cox     div</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;如上，在通用型系统设计中，我们希望外部调用系统时在调用运算函数（譬如加法函数）的时候，不需要根据输入的数据类型来调用不同的加法函数。而是调用加法函数，放入数据类型。系统内部能够根据放入的数据类型去匹配不同的加法函数。根据这个设计理念，我们来定义一下通用型系统的框架。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">add</span> x y) (<span class=\"name\">apply-generic</span> <span class=\"symbol\">'add</span> x y))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sub</span> x y) (<span class=\"name\">apply-generic</span> <span class=\"symbol\">'sub</span> x y))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">mul</span> x y) (<span class=\"name\">apply-generic</span> <span class=\"symbol\">'mul</span> x y))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">div</span> x y) (<span class=\"name\">apply-generic</span> <span class=\"symbol\">'div</span> x y))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 后续新增新的数据结构，只需要来维护 apply-generic</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">apply-generic</span> method x y)</span><br><span class=\"line\">    <span class=\"comment\">;; 所有带标志的数据结构，应该都是 (const tag data)形式，这里使用car取出标志</span></span><br><span class=\"line\">    ((<span class=\"name\">get</span> method (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x)) x y)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们需要建立一个类似包的函数结构，运行一次函数后，能够将<strong>一类数据结构</strong>注册进通用型系统。我们使用常数作为示例，建立一个基础的<code>install-scheme-number-package</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">install-scheme-number-package</span>)</span><br><span class=\"line\">  <span class=\"comment\">;;声明 tag x</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">tag</span> x)</span><br><span class=\"line\">    <span class=\"comment\">;; 打标</span></span><br><span class=\"line\">    (<span class=\"name\">attach-tag</span> <span class=\"symbol\">'scheme-number</span> x))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> scheme-numer-tag '(scheme-numer scheme-number))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'add</span> scheme-numer-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'sub</span> scheme-numer-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'mul</span> scheme-numer-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'div</span> scheme-numer-tag(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'make</span> <span class=\"symbol\">'scheme-number</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x) (<span class=\"name\">tag</span> x)))</span><br><span class=\"line\">  <span class=\"symbol\">'done</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;install某个数据结构的package，本质上就是put了带着特定<strong>标志</strong>的加减乘除到对应的<code>add sub mul div</code>当中去。方便<code>apply-generic</code>根据运算方式和数据标志取出对应的数据进行调用。现在我们根据这个规则和前四节的内容，往系统当中添加<strong>无理数</strong>和<strong>复数</strong>数据结构处理的包<code>install-rational-package</code>和<code>install-complex-package</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 无理数包</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">install-rational-package</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">number</span> x) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">denom</span> x ) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-rat</span> n d)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">      ((<span class=\"name\">g</span> (<span class=\"name\"><span class=\"builtin-name\">gcd</span></span> n d)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n g) (<span class=\"name\"><span class=\"builtin-name\">/</span></span> d g))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">add-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">+</span></span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">number</span> x) (<span class=\"name\">denom</span> y))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">number</span> y) (<span class=\"name\">denom</span> x)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">denom</span> x) (<span class=\"name\">denom</span> y))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sub-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">-</span></span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">number</span> x) (<span class=\"name\">denom</span> y))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">number</span> y) (<span class=\"name\">denom</span> x)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">denom</span> x) (<span class=\"name\">denom</span> y))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">mul-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">number</span> x) (<span class=\"name\">number</span> y))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">denom</span> x) (<span class=\"name\">denom</span> y))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">div-rat</span> x y)</span><br><span class=\"line\">    (<span class=\"name\">make-rat</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">number</span> x) (<span class=\"name\">denom</span> y))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">denom</span> x) (<span class=\"name\">number</span> y))))</span><br><span class=\"line\"><span class=\"comment\">;; interface to rest of the system</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">tag</span> x) (<span class=\"name\">attach-tag</span> <span class=\"symbol\">'rational</span> x))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> rational-tag '(rational rational))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'add</span> rational-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\">add-rat</span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'sub</span> rational-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\">sub-rat</span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'mul</span> rational-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\">mul-rat</span> x y))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'div</span> rational-tag (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x y) (<span class=\"name\">tag</span> (<span class=\"name\">div-rat</span> x y))))</span><br><span class=\"line\">  <span class=\"symbol\">'done</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 复数处理包 complex</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">install-complex-package</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-real-imag</span> x y)</span><br><span class=\"line\">    ((<span class=\"name\">get</span> <span class=\"symbol\">'make-from-real-imag</span> <span class=\"symbol\">'rectangular</span>) x y))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-from-mag-ang</span> r a)</span><br><span class=\"line\">    ((<span class=\"name\">get</span> <span class=\"symbol\">'make-from-mag-ang</span> <span class=\"symbol\">'polar</span>) r a))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">add-complex</span> z1 z3)</span><br><span class=\"line\">    (<span class=\"name\">make-from-real-imag</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z2))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sub-complex</span> z1 z2)</span><br><span class=\"line\">    (<span class=\"name\">make-from-real-imag</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">real-part</span></span> z2))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">imag-part</span></span> z2))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">mul-complex</span> z1 z2)</span><br><span class=\"line\">    (<span class=\"name\">make-from-mag-ang</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z2))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">div-complex</span> z1 z2)</span><br><span class=\"line\">    (<span class=\"name\">make-from-mag-ang</span></span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">/</span></span> (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">magnitude</span></span> z2))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z1) (<span class=\"name\"><span class=\"builtin-name\">angle</span></span> z2))))</span><br><span class=\"line\">  <span class=\"comment\">;;interface to rest of the system</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">tag</span> z) (<span class=\"name\">attach-tag</span> <span class=\"symbol\">'complex</span> z))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> tag-name '(complex complex))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'add</span> tag-name (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (z1 z2) (<span class=\"name\">tag</span> (<span class=\"name\">add-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'sub</span> tag-name (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (z1 z2) (<span class=\"name\">tag</span> (<span class=\"name\">sub-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'mul</span> tag-name (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (z1 z2) (<span class=\"name\">tag</span> (<span class=\"name\">mul-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'div</span> tag-name (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (z1 z2) (<span class=\"name\">tag</span> (<span class=\"name\">div-complex</span> z1 z2))))</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'make-from-real-imag</span> <span class=\"symbol\">'complex</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (z1 z2) (<span class=\"name\">tag</span> (<span class=\"name\">make-from-real-imag</span> x y)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"name\">put</span> <span class=\"symbol\">'make-from-mag-and</span> <span class=\"symbol\">'complex</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (r a) (<span class=\"name\">tag</span> (<span class=\"name\">make-from-mag-ang</span> r a)))</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"symbol\">'done</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在2-4当中讨论过，复数可以用两种形式构成，<code>实部虚部直角坐标系</code>和<code>模和幅角</code>。因此我们在复数<code>install-complex-package</code>包中,定义了两种创建复数数据类型的函数<code>make-from-real-imag</code>和<code>make-from-mag-and</code>。外部可以自己喜欢的方式去创建对应的复数数据结构。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 复数的两种创建模式，角度和坐标定义</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-complex-from-real-imag</span> x y)</span><br><span class=\"line\">  ((<span class=\"name\">get</span> <span class=\"symbol\">'make-from-real-imag</span> <span class=\"symbol\">'complex</span>) x y)</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-complex-from-mag-ang</span> r a)</span><br><span class=\"line\">  ((<span class=\"name\">get</span> <span class=\"symbol\">'make-from-mag-ang</span> <span class=\"symbol\">'complex</span>) r a)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在上述的通用型系统设计模式中，我们设计理念遵循，<strong>外部调用运算函数</strong>，内部根据<strong>运算函数</strong>和<strong>传入的数据类型标识</strong>来匹配到细节函数的方式，完成了一个简易的通用型系统。接下来，介绍另外一种不同于匹配分发设计思想的<strong>组合</strong>的通用型系统设计。</p>\n<p>&emsp;&emsp;所谓<strong>组合</strong>的通用型系统，即是把多种数据类型<strong>强制</strong>转换为一种数据类型，采用一套运算函数的方式。比如常规的数字和复数之间，我们可以把常规数字看做虚部为0的复数，来把所有输入系统的<strong>常规数</strong>类型转换为<strong>虚数类型</strong>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 强制的概念，把一种数据类型强制转换为另一种数据类型，使得两包想通</span></span><br><span class=\"line\"><span class=\"comment\">;; scheme-number -&gt; complex-number 普通数看为虚部为0的复数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">scheme-number-&gt;complex</span> n)</span><br><span class=\"line\">  (<span class=\"name\">make-complex-from-real-imag</span> (<span class=\"name\">contents</span> n) <span class=\"number\">0</span>))</span><br><span class=\"line\">(<span class=\"name\">put-coercion</span> <span class=\"symbol\">'scheme-number</span> <span class=\"symbol\">'complex</span> scheme-number-&gt;complex)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;根据配装，我们重新设计一下<code>apply-generic</code>。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">apply-generic</span> op , args)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">type-tags</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> type-tag args)))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">proc</span> (<span class=\"name\">get</span> op type-tags)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> proc</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">apply</span></span> proc (<span class=\"name\"><span class=\"builtin-name\">map</span></span> contents args))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> args) <span class=\"number\">2</span>)</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">type1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> type-tags))</span><br><span class=\"line\">            (<span class=\"name\">type2</span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> type-tags))</span><br><span class=\"line\">            (<span class=\"name\">a1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))</span><br><span class=\"line\">            (<span class=\"name\">a2</span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args)))</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">t1-&gt;t2</span> (<span class=\"name\">get-coercion</span> type1 typ2))</span><br><span class=\"line\">              (<span class=\"name\">t2-&gt;t1</span> (<span class=\"name\">get-coercion</span> type2 typ1))))</span><br><span class=\"line\">              (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">                (<span class=\"name\">t1-&gt;t2</span></span><br><span class=\"line\">                  (<span class=\"name\">apply-generic</span> op (<span class=\"name\">t1-&gt;t2</span> a1) a2))</span><br><span class=\"line\">                (<span class=\"name\">t2-&gt;t1</span></span><br><span class=\"line\">                  (apply-generic op a1 (t2-&gt;t1 a2)))))))))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<strong>组合</strong>设计通用操作系统与<strong>打标分配</strong>的方式相比，有比较大的优越性，虽然我们需要书写强制转换数据结构的类型，但是由于数据结构被转换为一种，一个对应的操作（诸如四则）只需要书写一个函数即可。但是这种设计严重依赖输入的数据结构之间需要<strong>能够强制转换</strong>。</p>\n<p>&emsp;&emsp;实际生活中，我们更多使用的是类似于<strong>组合强制</strong>的一种<strong>塔型</strong>的层次性结构。拿上面的集中数据结构为例。形成一个<code>整数 -&gt; 有理数 -&gt; 实数 -&gt; 复数</code>的类型塔。</p>\n<p>&emsp;&emsp;在<strong>塔型</strong>的设计思想中，我们需要一个类似<code>apply-generic</code>的过程，能够把一种数据类型<strong>提升</strong>到更高一层次的类型。每个类型能够<strong>继承</strong>其超类型中定义的所有操作。但这种数据结构在大型系统设计时，面对一大批相互有关系的类型，如何处理好同时保持模块性。是一个非常复杂而又困难的事情。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-3.1","date":"2019-08-31T15:20:00.000Z","_content":"## 第三章 第一节 赋值和局部状态\n> 即是在变化中，它也是丝毫未变。 —— Heraclitus\n> 变得越多，它越是原来的样子。 ——Alphons Karr\n\n&emsp;&emsp;前两章介绍组成程序的各种基本元素，基本过程和基本数据组合起来，构造复合的实体。在第三章中，重点研究两种特定鲜明的计算机程序组织策略，**面向对象**和**函数式编程**。\n<!--more-->\n&emsp;&emsp;在认识事物的时候，我们经常产生`类`和`对象`的认识概念。比如，人类，猫，狗。这些把一些具有共同能力的对象事物抽象为`类`。`类`的每一个个例称之为`对象`。比如我们每一个人，都属于人类，都具备人类所拥有的共同的能力，如:吃喝拉撒奔跑等。在`对象`具有`类`能力的同时，也保存有自己特有的一能力和各自的数值。比如每一个人都具有年龄，但是每一个人年龄的数值是不同的。\n\n&emsp;&emsp;计算机系统设计可以使用诸如此类的抽象概念，根据共同能力分解模块化的对象，同时拥有自己一些局部状态变量，跟随自己特有的运行环境产生。接下来我们用一个设计银行账户的例子，来体会局部状态变量的意义。\n\n&emsp;&emsp;先来设计一个`withdraw`函数，它用来往银行账户当中取钱，当银行账户余额不足时，会报出`Insufficient funds`的错误。就像这样：\n```scheme\n;; 假设账户余额为100\n;; 取出25\n(withdraw 25) ;; 返回剩余值75\n;; 取出85\n(withdraw 85) ;; Insufficient funds 余额不足\n```\n&emsp;&emsp;为了实现这个功能，我们首先需要一个变量`balance`表示账户余额，供`withdraw`去操作，然后实现`withdraw`函数。在这里我们使用`scheme`当中的`set!`函数，它能够改变一个变量的值。使用方法为`(set! <name> <new-value>)`。\n```scheme\n;; 使用set \n(define balance 100)\n(define (withdraw amount)\n  (if (>= balance amount)\n    ;; (begin <exp1> <exp2>) 按照顺序求值\n    (begin (set! balance (- amount)) balance)\n    \"Insufficient funds\"\n  )\n)\n```\n&emsp;&emsp;完成`withdraw`函数后，我们不难发现一个问题，`balance`目前是一个全局变量的账户余额，谁都可以去操作它。当我们需要多个账户表示多个人的余额，同时去操作不同账户使用`withdraw`时，这种全局变量的设计就不能满足需求了。我们要么每一个账户去设置一个账户余额名称，然后让`withdraw`分别取操作它们，这样做混乱不堪的全局变量和函数调用，想想都后怕。还有一种方法，是让`balance`到`withdraw`函数内部，每一个`withdraw`都拥有自己独立的`balance`去操作。这样每个`balance`能被外部访问的途径就只有`withdraw`。我们使用这种思路，来改写`withdraw`函数。\n```scheme\n;; 封存局部变量到函数内部\n(define new-withdraw\n  (let \n  (\n    (balance 100)) \n    (lambda (amount)\n      (if (>= balance amount)\n        (begin (set! balance (- balance amount)) balance)\n        \"Insufficient funds\"))))\n;; 使用\n(define account-a (new-withdraw 10)) ;; 90\n(define account-b (new-withdraw 30)) ;; 70\n```\n&emsp;&emsp;我们来继续优化一下`new-withdraw`函数，使得它初始化的时候能够决定账户余额，而不是只能固定的100。\n```scheme\n;; 提款处理器,独立的对象\n;; balance 账户余额\n(define (make-withdraw balance)\n  (lambda (amount)\n    (if (>= balance amount)\n      (begin (set! balance (- balance amount)) balance)\n      \"Insufficient funds\")))\n```\n&emsp;&emsp;只能减不能加对我这种穷人来说不大友好，我们再优化下，给它提供增加账户余额的能力。我们通过`withdraw`和`deposit`。在外部加减账户。\n```scheme\n(define (make-account balance)\n  ;; 账户取钱函数\n  (define (withdraw amount)\n    (if (>= balance amount)\n      (begin (set! balance (- balance amount)) balance)\n      \"Insufficient funds\"\n    )\n  )\n  ;;\n  (define (deposit amount)\n    (set! balance (+ balance amount))\n    balance\n  )\n  (define (dispatch m)\n    (cond\n      ((eq? m 'withdraw) withdraw)\n      ((eq? m 'deposit deposit))\n      (else (error \"unkonw request -- MAKE-ACCOUNT\" m))))\n  dispatch\n)\n;; 使用\n(define bob-account (make-account 100))\n(define my-account (make-account 500))\n(bob-account 'withdraw 90) ;; 10\n(my-account 'deposit 500) ;; 1000\n```\n&emsp;&emsp;至此，我们引入了使用`(set!)`来进行赋值的概念，带来便利的同时，也给程序设计带来不小的麻烦。我们来结合一个随机数的实例来体会一下。我们现在假定存在函数`rand-update`，能够根据给定的一个值，根据一定的规律生成一个随机数。然后我们来实现`rand`函数。\n```scheme\n;; 假设存在一个过程 rend-update 从一个给定的数开始形成一系列随机数\n(define rand\n  (let\n    ((x random-init))\n    (lambda ()\n      (set! x (rand-update x))\n      x)))\n```\n&emsp;&emsp;我们先把这个生成的随机数保存在`rand`函数的内部，来完成接下来的操作。我们利用实现的这个`rand`函数，来使用蒙特卡罗方法估算π的值。蒙特卡罗方法，指的是`任意两个整数之前最大公约数为1的几率为 6 / π`。\n```scheme\n;; 蒙特卡罗 利用6/π 是随机选取两个整数最大公约数为1的几率，求出π的值\n(define (estimate-pi trials) (sqrt (/ 6 (monte-carlo trials cesaro-test))))\n;; gcd 为前面写的求最大公约数的函数\n(define (cesaro-test) (= (gcd (rand) (rand)) 1))\n\n(define (monte-carlo trials experiment)\n  (define (iter trials-remaining trials-passed)\n    (cond\n      ((= trials-remaining 0) (/ trials-passed trials))\n      ((experiment)\n        (iter (- trials-remaining 1) (+ trials-passed 1)))\n      (else\n        (iter (- trials-remaining 1) (trials-passed)))))\n  (iter trials 0)\n)\n```\n&emsp;&emsp;现在我们在这个实力中不适用保存随机数在内部的`rand`方法，直接使用`rand-update`完成改变随机数变量赋值的计算。\n```scheme\n;; 不适用局部变量 直接操作update\n(define (eastimate-pi trials)\n  (sqrt (/ 6 (random-god-test trials random-init))))\n(define (random-gcd-test trials initial-x)\n  (define (iter trials-remaining trials-passed)\n    (let ((x1 (rand-update x1)))\n      (let ((x2 (rand-update x1)))\n        (cond \n          ((= trials-remaining 0) (/ trials-passed trials))\n          ((= (gcd x1 x2) 1)\n            (iter (- trials-remaining 1) (+ trials-passed 1) x2))\n          (else\n            (iter (- trials-remaining 1) trials-passed x2))))))\n  (iter trials 0 initial-x)\n)\n```\n&emsp;&emsp;我们发现在这么简单的例子中，我们在引入赋值计算的时候，我们都要在代码中关心`初始随机数的变量问题`。我们最后来总结一下在程序中引入赋值的代价。\n\n&emsp;&emsp;在引入赋值变量之后，最大的问题点在于你的每一步程序，在操作变量的时候，都要关心`操作的顺序`以及`变量值的变化`。到这个时候，我们发现我们在1.5节当中使用的代换模型将不能进入赋值变量的程序代换。\n\n&emsp;&emsp;而在引入赋值变量概念前，我们一直使用函数式编程的概念。之所以叫`函数式`编程，是因为我们编程设计像数学的函数一样，只根据一个特定的过程来对数据进行操作，没有任何对数据进行赋值，只要是相同的`输入`永远得到相同的`输出`。\n\n&emsp;&emsp;与之相对的，引入赋值操作的编程被称为`命令式`编程，命令式编程最大的问题就是赋值的步骤必须严格正确。我们引用一下在1.2.1节中迭代求乘阶的程序。\n```scheme\n(define (factorial n)\n    (define (iter product counter)\n        (if (> counter n)\n            product\n            (iter\n                (* counter product)\n                (+ counter 1))))\n    (iter 1 1))\n```\n&emsp;&emsp;我们改为命令式的编程方式。\n\n```scheme\n(define (factorial n)\n    (let\n    ((product 1)\n    (counter 1)) \n    (define (iter)\n        (if (> counter n)\n            product\n            (begin\n                (set! product (* counter product))\n                (set! counter (+ counter 1))\n                (iter)\n            )))\n    (iter)))\n    \n```\n&emsp;&emsp;我们发现，我们必须开始关系`product`和`counter`设置值的顺序。即`(* counter product)`和`(+ counter 1)`这两个操作步骤一旦出错。我们的`factorial`函数就出错了。这在函数式编程当中是绝对不可能发生的事情。","source":"_posts/scip/scip(chap3-1).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-3.1\ndate: 2019/8/31 23:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第三章 第一节 赋值和局部状态\n> 即是在变化中，它也是丝毫未变。 —— Heraclitus\n> 变得越多，它越是原来的样子。 ——Alphons Karr\n\n&emsp;&emsp;前两章介绍组成程序的各种基本元素，基本过程和基本数据组合起来，构造复合的实体。在第三章中，重点研究两种特定鲜明的计算机程序组织策略，**面向对象**和**函数式编程**。\n<!--more-->\n&emsp;&emsp;在认识事物的时候，我们经常产生`类`和`对象`的认识概念。比如，人类，猫，狗。这些把一些具有共同能力的对象事物抽象为`类`。`类`的每一个个例称之为`对象`。比如我们每一个人，都属于人类，都具备人类所拥有的共同的能力，如:吃喝拉撒奔跑等。在`对象`具有`类`能力的同时，也保存有自己特有的一能力和各自的数值。比如每一个人都具有年龄，但是每一个人年龄的数值是不同的。\n\n&emsp;&emsp;计算机系统设计可以使用诸如此类的抽象概念，根据共同能力分解模块化的对象，同时拥有自己一些局部状态变量，跟随自己特有的运行环境产生。接下来我们用一个设计银行账户的例子，来体会局部状态变量的意义。\n\n&emsp;&emsp;先来设计一个`withdraw`函数，它用来往银行账户当中取钱，当银行账户余额不足时，会报出`Insufficient funds`的错误。就像这样：\n```scheme\n;; 假设账户余额为100\n;; 取出25\n(withdraw 25) ;; 返回剩余值75\n;; 取出85\n(withdraw 85) ;; Insufficient funds 余额不足\n```\n&emsp;&emsp;为了实现这个功能，我们首先需要一个变量`balance`表示账户余额，供`withdraw`去操作，然后实现`withdraw`函数。在这里我们使用`scheme`当中的`set!`函数，它能够改变一个变量的值。使用方法为`(set! <name> <new-value>)`。\n```scheme\n;; 使用set \n(define balance 100)\n(define (withdraw amount)\n  (if (>= balance amount)\n    ;; (begin <exp1> <exp2>) 按照顺序求值\n    (begin (set! balance (- amount)) balance)\n    \"Insufficient funds\"\n  )\n)\n```\n&emsp;&emsp;完成`withdraw`函数后，我们不难发现一个问题，`balance`目前是一个全局变量的账户余额，谁都可以去操作它。当我们需要多个账户表示多个人的余额，同时去操作不同账户使用`withdraw`时，这种全局变量的设计就不能满足需求了。我们要么每一个账户去设置一个账户余额名称，然后让`withdraw`分别取操作它们，这样做混乱不堪的全局变量和函数调用，想想都后怕。还有一种方法，是让`balance`到`withdraw`函数内部，每一个`withdraw`都拥有自己独立的`balance`去操作。这样每个`balance`能被外部访问的途径就只有`withdraw`。我们使用这种思路，来改写`withdraw`函数。\n```scheme\n;; 封存局部变量到函数内部\n(define new-withdraw\n  (let \n  (\n    (balance 100)) \n    (lambda (amount)\n      (if (>= balance amount)\n        (begin (set! balance (- balance amount)) balance)\n        \"Insufficient funds\"))))\n;; 使用\n(define account-a (new-withdraw 10)) ;; 90\n(define account-b (new-withdraw 30)) ;; 70\n```\n&emsp;&emsp;我们来继续优化一下`new-withdraw`函数，使得它初始化的时候能够决定账户余额，而不是只能固定的100。\n```scheme\n;; 提款处理器,独立的对象\n;; balance 账户余额\n(define (make-withdraw balance)\n  (lambda (amount)\n    (if (>= balance amount)\n      (begin (set! balance (- balance amount)) balance)\n      \"Insufficient funds\")))\n```\n&emsp;&emsp;只能减不能加对我这种穷人来说不大友好，我们再优化下，给它提供增加账户余额的能力。我们通过`withdraw`和`deposit`。在外部加减账户。\n```scheme\n(define (make-account balance)\n  ;; 账户取钱函数\n  (define (withdraw amount)\n    (if (>= balance amount)\n      (begin (set! balance (- balance amount)) balance)\n      \"Insufficient funds\"\n    )\n  )\n  ;;\n  (define (deposit amount)\n    (set! balance (+ balance amount))\n    balance\n  )\n  (define (dispatch m)\n    (cond\n      ((eq? m 'withdraw) withdraw)\n      ((eq? m 'deposit deposit))\n      (else (error \"unkonw request -- MAKE-ACCOUNT\" m))))\n  dispatch\n)\n;; 使用\n(define bob-account (make-account 100))\n(define my-account (make-account 500))\n(bob-account 'withdraw 90) ;; 10\n(my-account 'deposit 500) ;; 1000\n```\n&emsp;&emsp;至此，我们引入了使用`(set!)`来进行赋值的概念，带来便利的同时，也给程序设计带来不小的麻烦。我们来结合一个随机数的实例来体会一下。我们现在假定存在函数`rand-update`，能够根据给定的一个值，根据一定的规律生成一个随机数。然后我们来实现`rand`函数。\n```scheme\n;; 假设存在一个过程 rend-update 从一个给定的数开始形成一系列随机数\n(define rand\n  (let\n    ((x random-init))\n    (lambda ()\n      (set! x (rand-update x))\n      x)))\n```\n&emsp;&emsp;我们先把这个生成的随机数保存在`rand`函数的内部，来完成接下来的操作。我们利用实现的这个`rand`函数，来使用蒙特卡罗方法估算π的值。蒙特卡罗方法，指的是`任意两个整数之前最大公约数为1的几率为 6 / π`。\n```scheme\n;; 蒙特卡罗 利用6/π 是随机选取两个整数最大公约数为1的几率，求出π的值\n(define (estimate-pi trials) (sqrt (/ 6 (monte-carlo trials cesaro-test))))\n;; gcd 为前面写的求最大公约数的函数\n(define (cesaro-test) (= (gcd (rand) (rand)) 1))\n\n(define (monte-carlo trials experiment)\n  (define (iter trials-remaining trials-passed)\n    (cond\n      ((= trials-remaining 0) (/ trials-passed trials))\n      ((experiment)\n        (iter (- trials-remaining 1) (+ trials-passed 1)))\n      (else\n        (iter (- trials-remaining 1) (trials-passed)))))\n  (iter trials 0)\n)\n```\n&emsp;&emsp;现在我们在这个实力中不适用保存随机数在内部的`rand`方法，直接使用`rand-update`完成改变随机数变量赋值的计算。\n```scheme\n;; 不适用局部变量 直接操作update\n(define (eastimate-pi trials)\n  (sqrt (/ 6 (random-god-test trials random-init))))\n(define (random-gcd-test trials initial-x)\n  (define (iter trials-remaining trials-passed)\n    (let ((x1 (rand-update x1)))\n      (let ((x2 (rand-update x1)))\n        (cond \n          ((= trials-remaining 0) (/ trials-passed trials))\n          ((= (gcd x1 x2) 1)\n            (iter (- trials-remaining 1) (+ trials-passed 1) x2))\n          (else\n            (iter (- trials-remaining 1) trials-passed x2))))))\n  (iter trials 0 initial-x)\n)\n```\n&emsp;&emsp;我们发现在这么简单的例子中，我们在引入赋值计算的时候，我们都要在代码中关心`初始随机数的变量问题`。我们最后来总结一下在程序中引入赋值的代价。\n\n&emsp;&emsp;在引入赋值变量之后，最大的问题点在于你的每一步程序，在操作变量的时候，都要关心`操作的顺序`以及`变量值的变化`。到这个时候，我们发现我们在1.5节当中使用的代换模型将不能进入赋值变量的程序代换。\n\n&emsp;&emsp;而在引入赋值变量概念前，我们一直使用函数式编程的概念。之所以叫`函数式`编程，是因为我们编程设计像数学的函数一样，只根据一个特定的过程来对数据进行操作，没有任何对数据进行赋值，只要是相同的`输入`永远得到相同的`输出`。\n\n&emsp;&emsp;与之相对的，引入赋值操作的编程被称为`命令式`编程，命令式编程最大的问题就是赋值的步骤必须严格正确。我们引用一下在1.2.1节中迭代求乘阶的程序。\n```scheme\n(define (factorial n)\n    (define (iter product counter)\n        (if (> counter n)\n            product\n            (iter\n                (* counter product)\n                (+ counter 1))))\n    (iter 1 1))\n```\n&emsp;&emsp;我们改为命令式的编程方式。\n\n```scheme\n(define (factorial n)\n    (let\n    ((product 1)\n    (counter 1)) \n    (define (iter)\n        (if (> counter n)\n            product\n            (begin\n                (set! product (* counter product))\n                (set! counter (+ counter 1))\n                (iter)\n            )))\n    (iter)))\n    \n```\n&emsp;&emsp;我们发现，我们必须开始关系`product`和`counter`设置值的顺序。即`(* counter product)`和`(+ counter 1)`这两个操作步骤一旦出错。我们的`factorial`函数就出错了。这在函数式编程当中是绝对不可能发生的事情。","slug":"scip/scip(chap3-1)","published":1,"updated":"2020-06-11T01:43:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy6002c9r2v9jsoifdb","content":"<h2 id=\"第三章-第一节-赋值和局部状态\"><a href=\"#第三章-第一节-赋值和局部状态\" class=\"headerlink\" title=\"第三章 第一节 赋值和局部状态\"></a>第三章 第一节 赋值和局部状态</h2><blockquote>\n<p>即是在变化中，它也是丝毫未变。 —— Heraclitus<br>变得越多，它越是原来的样子。 ——Alphons Karr</p>\n</blockquote>\n<p>&emsp;&emsp;前两章介绍组成程序的各种基本元素，基本过程和基本数据组合起来，构造复合的实体。在第三章中，重点研究两种特定鲜明的计算机程序组织策略，<strong>面向对象</strong>和<strong>函数式编程</strong>。<br><a id=\"more\"></a><br>&emsp;&emsp;在认识事物的时候，我们经常产生<code>类</code>和<code>对象</code>的认识概念。比如，人类，猫，狗。这些把一些具有共同能力的对象事物抽象为<code>类</code>。<code>类</code>的每一个个例称之为<code>对象</code>。比如我们每一个人，都属于人类，都具备人类所拥有的共同的能力，如:吃喝拉撒奔跑等。在<code>对象</code>具有<code>类</code>能力的同时，也保存有自己特有的一能力和各自的数值。比如每一个人都具有年龄，但是每一个人年龄的数值是不同的。</p>\n<p>&emsp;&emsp;计算机系统设计可以使用诸如此类的抽象概念，根据共同能力分解模块化的对象，同时拥有自己一些局部状态变量，跟随自己特有的运行环境产生。接下来我们用一个设计银行账户的例子，来体会局部状态变量的意义。</p>\n<p>&emsp;&emsp;先来设计一个<code>withdraw</code>函数，它用来往银行账户当中取钱，当银行账户余额不足时，会报出<code>Insufficient funds</code>的错误。就像这样：<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 假设账户余额为100</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 取出25</span></span><br><span class=\"line\">(<span class=\"hljs-name\">withdraw</span> <span class=\"hljs-number\">25</span>) <span class=\"hljs-comment\">;; 返回剩余值75</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 取出85</span></span><br><span class=\"line\">(<span class=\"hljs-name\">withdraw</span> <span class=\"hljs-number\">85</span>) <span class=\"hljs-comment\">;; Insufficient funds 余额不足</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;为了实现这个功能，我们首先需要一个变量<code>balance</code>表示账户余额，供<code>withdraw</code>去操作，然后实现<code>withdraw</code>函数。在这里我们使用<code>scheme</code>当中的<code>set!</code>函数，它能够改变一个变量的值。使用方法为<code>(set! &lt;name&gt; &lt;new-value&gt;)</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 使用set </span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> balance <span class=\"hljs-number\">100</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">withdraw</span> amount)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; (begin &lt;exp1&gt; &lt;exp2&gt;) 按照顺序求值</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> amount)) balance)</span><br><span class=\"line\">    <span class=\"hljs-string\">\"Insufficient funds\"</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;完成<code>withdraw</code>函数后，我们不难发现一个问题，<code>balance</code>目前是一个全局变量的账户余额，谁都可以去操作它。当我们需要多个账户表示多个人的余额，同时去操作不同账户使用<code>withdraw</code>时，这种全局变量的设计就不能满足需求了。我们要么每一个账户去设置一个账户余额名称，然后让<code>withdraw</code>分别取操作它们，这样做混乱不堪的全局变量和函数调用，想想都后怕。还有一种方法，是让<code>balance</code>到<code>withdraw</code>函数内部，每一个<code>withdraw</code>都拥有自己独立的<code>balance</code>去操作。这样每个<code>balance</code>能被外部访问的途径就只有<code>withdraw</code>。我们使用这种思路，来改写<code>withdraw</code>函数。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 封存局部变量到函数内部</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> new-withdraw</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> </span><br><span class=\"line\">  (</span><br><span class=\"line\">    (<span class=\"hljs-name\">balance</span> <span class=\"hljs-number\">100</span>)) </span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (amount)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">        <span class=\"hljs-string\">\"Insufficient funds\"</span>))))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 使用</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> account-a (<span class=\"hljs-name\">new-withdraw</span> <span class=\"hljs-number\">10</span>)) <span class=\"hljs-comment\">;; 90</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> account-b (<span class=\"hljs-name\">new-withdraw</span> <span class=\"hljs-number\">30</span>)) <span class=\"hljs-comment\">;; 70</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们来继续优化一下<code>new-withdraw</code>函数，使得它初始化的时候能够决定账户余额，而不是只能固定的100。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 提款处理器,独立的对象</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; balance 账户余额</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-withdraw</span> balance)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (amount)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">      <span class=\"hljs-string\">\"Insufficient funds\"</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;只能减不能加对我这种穷人来说不大友好，我们再优化下，给它提供增加账户余额的能力。我们通过<code>withdraw</code>和<code>deposit</code>。在外部加减账户。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-account</span> balance)</span><br><span class=\"line\">  <span class=\"hljs-comment\">;; 账户取钱函数</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">withdraw</span> amount)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">      <span class=\"hljs-string\">\"Insufficient funds\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"hljs-comment\">;;</span></span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">deposit</span> amount)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> balance amount))</span><br><span class=\"line\">    balance</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">dispatch</span> m)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'withdraw</span>) withdraw)</span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'deposit</span> deposit))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"unkonw request -- MAKE-ACCOUNT\"</span> m))))</span><br><span class=\"line\">  dispatch</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 使用</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> bob-account (<span class=\"hljs-name\">make-account</span> <span class=\"hljs-number\">100</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> my-account (<span class=\"hljs-name\">make-account</span> <span class=\"hljs-number\">500</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\">bob-account</span> <span class=\"hljs-symbol\">'withdraw</span> <span class=\"hljs-number\">90</span>) <span class=\"hljs-comment\">;; 10</span></span><br><span class=\"line\">(<span class=\"hljs-name\">my-account</span> <span class=\"hljs-symbol\">'deposit</span> <span class=\"hljs-number\">500</span>) <span class=\"hljs-comment\">;; 1000</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;至此，我们引入了使用<code>(set!)</code>来进行赋值的概念，带来便利的同时，也给程序设计带来不小的麻烦。我们来结合一个随机数的实例来体会一下。我们现在假定存在函数<code>rand-update</code>，能够根据给定的一个值，根据一定的规律生成一个随机数。然后我们来实现<code>rand</code>函数。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 假设存在一个过程 rend-update 从一个给定的数开始形成一系列随机数</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> rand</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">x</span> random-init))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> x (<span class=\"hljs-name\">rand-update</span> x))</span><br><span class=\"line\">      x)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们先把这个生成的随机数保存在<code>rand</code>函数的内部，来完成接下来的操作。我们利用实现的这个<code>rand</code>函数，来使用蒙特卡罗方法估算π的值。蒙特卡罗方法，指的是<code>任意两个整数之前最大公约数为1的几率为 6 / π</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 蒙特卡罗 利用6/π 是随机选取两个整数最大公约数为1的几率，求出π的值</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">estimate-pi</span> trials) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sqrt</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> <span class=\"hljs-number\">6</span> (<span class=\"hljs-name\">monte-carlo</span> trials cesaro-test))))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; gcd 为前面写的求最大公约数的函数</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">cesaro-test</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">gcd</span></span> (<span class=\"hljs-name\">rand</span>) (<span class=\"hljs-name\">rand</span>)) <span class=\"hljs-number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">monte-carlo</span> trials experiment)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">iter</span> trials-remaining trials-passed)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> trials-remaining <span class=\"hljs-number\">0</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> trials-passed trials))</span><br><span class=\"line\">      ((<span class=\"hljs-name\">experiment</span>)</span><br><span class=\"line\">        (<span class=\"hljs-name\">iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> trials-remaining <span class=\"hljs-number\">1</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> trials-passed <span class=\"hljs-number\">1</span>)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span></span><br><span class=\"line\">        (<span class=\"hljs-name\">iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> trials-remaining <span class=\"hljs-number\">1</span>) (<span class=\"hljs-name\">trials-passed</span>)))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">iter</span> trials <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们在这个实力中不适用保存随机数在内部的<code>rand</code>方法，直接使用<code>rand-update</code>完成改变随机数变量赋值的计算。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 不适用局部变量 直接操作update</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">eastimate-pi</span> trials)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">sqrt</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> <span class=\"hljs-number\">6</span> (<span class=\"hljs-name\">random-god-test</span> trials random-init))))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">random-gcd-test</span> trials initial-x)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">iter</span> trials-remaining trials-passed)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">x1</span> (<span class=\"hljs-name\">rand-update</span> x1)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">x2</span> (<span class=\"hljs-name\">rand-update</span> x1)))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> </span><br><span class=\"line\">          ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> trials-remaining <span class=\"hljs-number\">0</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> trials-passed trials))</span><br><span class=\"line\">          ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">gcd</span></span> x1 x2) <span class=\"hljs-number\">1</span>)</span><br><span class=\"line\">            (<span class=\"hljs-name\">iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> trials-remaining <span class=\"hljs-number\">1</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> trials-passed <span class=\"hljs-number\">1</span>) x2))</span><br><span class=\"line\">          (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span></span><br><span class=\"line\">            (<span class=\"hljs-name\">iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> trials-remaining <span class=\"hljs-number\">1</span>) trials-passed x2))))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">iter</span> trials <span class=\"hljs-number\">0</span> initial-x)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们发现在这么简单的例子中，我们在引入赋值计算的时候，我们都要在代码中关心<code>初始随机数的变量问题</code>。我们最后来总结一下在程序中引入赋值的代价。</p>\n<p>&emsp;&emsp;在引入赋值变量之后，最大的问题点在于你的每一步程序，在操作变量的时候，都要关心<code>操作的顺序</code>以及<code>变量值的变化</code>。到这个时候，我们发现我们在1.5节当中使用的代换模型将不能进入赋值变量的程序代换。</p>\n<p>&emsp;&emsp;而在引入赋值变量概念前，我们一直使用函数式编程的概念。之所以叫<code>函数式</code>编程，是因为我们编程设计像数学的函数一样，只根据一个特定的过程来对数据进行操作，没有任何对数据进行赋值，只要是相同的<code>输入</code>永远得到相同的<code>输出</code>。</p>\n<p>&emsp;&emsp;与之相对的，引入赋值操作的编程被称为<code>命令式</code>编程，命令式编程最大的问题就是赋值的步骤必须严格正确。我们引用一下在1.2.1节中迭代求乘阶的程序。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">factorial</span> n)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">iter</span> product counter)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> counter n)</span><br><span class=\"line\">            product</span><br><span class=\"line\">            (<span class=\"hljs-name\">iter</span></span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> counter product)</span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> counter <span class=\"hljs-number\">1</span>))))</span><br><span class=\"line\">    (<span class=\"hljs-name\">iter</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span>))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们改为命令式的编程方式。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">factorial</span> n)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">product</span> <span class=\"hljs-number\">1</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">counter</span> <span class=\"hljs-number\">1</span>)) </span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">iter</span>)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> counter n)</span><br><span class=\"line\">            product</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span></span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> product (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> counter product))</span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> counter (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> counter <span class=\"hljs-number\">1</span>))</span><br><span class=\"line\">                (<span class=\"hljs-name\">iter</span>)</span><br><span class=\"line\">            )))</span><br><span class=\"line\">    (<span class=\"hljs-name\">iter</span>)))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们发现，我们必须开始关系<code>product</code>和<code>counter</code>设置值的顺序。即<code>(* counter product)</code>和<code>(+ counter 1)</code>这两个操作步骤一旦出错。我们的<code>factorial</code>函数就出错了。这在函数式编程当中是绝对不可能发生的事情。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第三章-第一节-赋值和局部状态\"><a href=\"#第三章-第一节-赋值和局部状态\" class=\"headerlink\" title=\"第三章 第一节 赋值和局部状态\"></a>第三章 第一节 赋值和局部状态</h2><blockquote>\n<p>即是在变化中，它也是丝毫未变。 —— Heraclitus<br>变得越多，它越是原来的样子。 ——Alphons Karr</p>\n</blockquote>\n<p>&emsp;&emsp;前两章介绍组成程序的各种基本元素，基本过程和基本数据组合起来，构造复合的实体。在第三章中，重点研究两种特定鲜明的计算机程序组织策略，<strong>面向对象</strong>和<strong>函数式编程</strong>。<br></p>","more":"<br>&emsp;&emsp;在认识事物的时候，我们经常产生<code>类</code>和<code>对象</code>的认识概念。比如，人类，猫，狗。这些把一些具有共同能力的对象事物抽象为<code>类</code>。<code>类</code>的每一个个例称之为<code>对象</code>。比如我们每一个人，都属于人类，都具备人类所拥有的共同的能力，如:吃喝拉撒奔跑等。在<code>对象</code>具有<code>类</code>能力的同时，也保存有自己特有的一能力和各自的数值。比如每一个人都具有年龄，但是每一个人年龄的数值是不同的。</p>\n<p>&emsp;&emsp;计算机系统设计可以使用诸如此类的抽象概念，根据共同能力分解模块化的对象，同时拥有自己一些局部状态变量，跟随自己特有的运行环境产生。接下来我们用一个设计银行账户的例子，来体会局部状态变量的意义。</p>\n<p>&emsp;&emsp;先来设计一个<code>withdraw</code>函数，它用来往银行账户当中取钱，当银行账户余额不足时，会报出<code>Insufficient funds</code>的错误。就像这样：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 假设账户余额为100</span></span><br><span class=\"line\"><span class=\"comment\">;; 取出25</span></span><br><span class=\"line\">(<span class=\"name\">withdraw</span> <span class=\"number\">25</span>) <span class=\"comment\">;; 返回剩余值75</span></span><br><span class=\"line\"><span class=\"comment\">;; 取出85</span></span><br><span class=\"line\">(<span class=\"name\">withdraw</span> <span class=\"number\">85</span>) <span class=\"comment\">;; Insufficient funds 余额不足</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;为了实现这个功能，我们首先需要一个变量<code>balance</code>表示账户余额，供<code>withdraw</code>去操作，然后实现<code>withdraw</code>函数。在这里我们使用<code>scheme</code>当中的<code>set!</code>函数，它能够改变一个变量的值。使用方法为<code>(set! &lt;name&gt; &lt;new-value&gt;)</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 使用set </span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> balance <span class=\"number\">100</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">withdraw</span> amount)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">    <span class=\"comment\">;; (begin &lt;exp1&gt; &lt;exp2&gt;) 按照顺序求值</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">-</span></span> amount)) balance)</span><br><span class=\"line\">    <span class=\"string\">\"Insufficient funds\"</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;完成<code>withdraw</code>函数后，我们不难发现一个问题，<code>balance</code>目前是一个全局变量的账户余额，谁都可以去操作它。当我们需要多个账户表示多个人的余额，同时去操作不同账户使用<code>withdraw</code>时，这种全局变量的设计就不能满足需求了。我们要么每一个账户去设置一个账户余额名称，然后让<code>withdraw</code>分别取操作它们，这样做混乱不堪的全局变量和函数调用，想想都后怕。还有一种方法，是让<code>balance</code>到<code>withdraw</code>函数内部，每一个<code>withdraw</code>都拥有自己独立的<code>balance</code>去操作。这样每个<code>balance</code>能被外部访问的途径就只有<code>withdraw</code>。我们使用这种思路，来改写<code>withdraw</code>函数。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 封存局部变量到函数内部</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> new-withdraw</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> </span><br><span class=\"line\">  (</span><br><span class=\"line\">    (<span class=\"name\">balance</span> <span class=\"number\">100</span>)) </span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (amount)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">        <span class=\"string\">\"Insufficient funds\"</span>))))</span><br><span class=\"line\"><span class=\"comment\">;; 使用</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> account-a (<span class=\"name\">new-withdraw</span> <span class=\"number\">10</span>)) <span class=\"comment\">;; 90</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> account-b (<span class=\"name\">new-withdraw</span> <span class=\"number\">30</span>)) <span class=\"comment\">;; 70</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们来继续优化一下<code>new-withdraw</code>函数，使得它初始化的时候能够决定账户余额，而不是只能固定的100。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 提款处理器,独立的对象</span></span><br><span class=\"line\"><span class=\"comment\">;; balance 账户余额</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-withdraw</span> balance)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (amount)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">      <span class=\"string\">\"Insufficient funds\"</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;只能减不能加对我这种穷人来说不大友好，我们再优化下，给它提供增加账户余额的能力。我们通过<code>withdraw</code>和<code>deposit</code>。在外部加减账户。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-account</span> balance)</span><br><span class=\"line\">  <span class=\"comment\">;; 账户取钱函数</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">withdraw</span> amount)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">      <span class=\"string\">\"Insufficient funds\"</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">;;</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">deposit</span> amount)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">+</span></span> balance amount))</span><br><span class=\"line\">    balance</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dispatch</span> m)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'withdraw</span>) withdraw)</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'deposit</span> deposit))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"unkonw request -- MAKE-ACCOUNT\"</span> m))))</span><br><span class=\"line\">  dispatch</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 使用</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> bob-account (<span class=\"name\">make-account</span> <span class=\"number\">100</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> my-account (<span class=\"name\">make-account</span> <span class=\"number\">500</span>))</span><br><span class=\"line\">(<span class=\"name\">bob-account</span> <span class=\"symbol\">'withdraw</span> <span class=\"number\">90</span>) <span class=\"comment\">;; 10</span></span><br><span class=\"line\">(<span class=\"name\">my-account</span> <span class=\"symbol\">'deposit</span> <span class=\"number\">500</span>) <span class=\"comment\">;; 1000</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;至此，我们引入了使用<code>(set!)</code>来进行赋值的概念，带来便利的同时，也给程序设计带来不小的麻烦。我们来结合一个随机数的实例来体会一下。我们现在假定存在函数<code>rand-update</code>，能够根据给定的一个值，根据一定的规律生成一个随机数。然后我们来实现<code>rand</code>函数。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 假设存在一个过程 rend-update 从一个给定的数开始形成一系列随机数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> rand</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"name\">x</span> random-init))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> x (<span class=\"name\">rand-update</span> x))</span><br><span class=\"line\">      x)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们先把这个生成的随机数保存在<code>rand</code>函数的内部，来完成接下来的操作。我们利用实现的这个<code>rand</code>函数，来使用蒙特卡罗方法估算π的值。蒙特卡罗方法，指的是<code>任意两个整数之前最大公约数为1的几率为 6 / π</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 蒙特卡罗 利用6/π 是随机选取两个整数最大公约数为1的几率，求出π的值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">estimate-pi</span> trials) (<span class=\"name\"><span class=\"builtin-name\">sqrt</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> <span class=\"number\">6</span> (<span class=\"name\">monte-carlo</span> trials cesaro-test))))</span><br><span class=\"line\"><span class=\"comment\">;; gcd 为前面写的求最大公约数的函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">cesaro-test</span>) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">gcd</span></span> (<span class=\"name\">rand</span>) (<span class=\"name\">rand</span>)) <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">monte-carlo</span> trials experiment)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">iter</span> trials-remaining trials-passed)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> trials-remaining <span class=\"number\">0</span>) (<span class=\"name\"><span class=\"builtin-name\">/</span></span> trials-passed trials))</span><br><span class=\"line\">      ((<span class=\"name\">experiment</span>)</span><br><span class=\"line\">        (<span class=\"name\">iter</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> trials-remaining <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> trials-passed <span class=\"number\">1</span>)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span></span><br><span class=\"line\">        (<span class=\"name\">iter</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> trials-remaining <span class=\"number\">1</span>) (<span class=\"name\">trials-passed</span>)))))</span><br><span class=\"line\">  (<span class=\"name\">iter</span> trials <span class=\"number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在我们在这个实力中不适用保存随机数在内部的<code>rand</code>方法，直接使用<code>rand-update</code>完成改变随机数变量赋值的计算。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 不适用局部变量 直接操作update</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">eastimate-pi</span> trials)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">sqrt</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> <span class=\"number\">6</span> (<span class=\"name\">random-god-test</span> trials random-init))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">random-gcd-test</span> trials initial-x)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">iter</span> trials-remaining trials-passed)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">x1</span> (<span class=\"name\">rand-update</span> x1)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">x2</span> (<span class=\"name\">rand-update</span> x1)))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> </span><br><span class=\"line\">          ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> trials-remaining <span class=\"number\">0</span>) (<span class=\"name\"><span class=\"builtin-name\">/</span></span> trials-passed trials))</span><br><span class=\"line\">          ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">gcd</span></span> x1 x2) <span class=\"number\">1</span>)</span><br><span class=\"line\">            (<span class=\"name\">iter</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> trials-remaining <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> trials-passed <span class=\"number\">1</span>) x2))</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">else</span></span></span><br><span class=\"line\">            (<span class=\"name\">iter</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> trials-remaining <span class=\"number\">1</span>) trials-passed x2))))))</span><br><span class=\"line\">  (<span class=\"name\">iter</span> trials <span class=\"number\">0</span> initial-x)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们发现在这么简单的例子中，我们在引入赋值计算的时候，我们都要在代码中关心<code>初始随机数的变量问题</code>。我们最后来总结一下在程序中引入赋值的代价。</p>\n<p>&emsp;&emsp;在引入赋值变量之后，最大的问题点在于你的每一步程序，在操作变量的时候，都要关心<code>操作的顺序</code>以及<code>变量值的变化</code>。到这个时候，我们发现我们在1.5节当中使用的代换模型将不能进入赋值变量的程序代换。</p>\n<p>&emsp;&emsp;而在引入赋值变量概念前，我们一直使用函数式编程的概念。之所以叫<code>函数式</code>编程，是因为我们编程设计像数学的函数一样，只根据一个特定的过程来对数据进行操作，没有任何对数据进行赋值，只要是相同的<code>输入</code>永远得到相同的<code>输出</code>。</p>\n<p>&emsp;&emsp;与之相对的，引入赋值操作的编程被称为<code>命令式</code>编程，命令式编程最大的问题就是赋值的步骤必须严格正确。我们引用一下在1.2.1节中迭代求乘阶的程序。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">factorial</span> n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">iter</span> product counter)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> counter n)</span><br><span class=\"line\">            product</span><br><span class=\"line\">            (<span class=\"name\">iter</span></span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">*</span></span> counter product)</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">+</span></span> counter <span class=\"number\">1</span>))))</span><br><span class=\"line\">    (<span class=\"name\">iter</span> <span class=\"number\">1</span> <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们改为命令式的编程方式。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">factorial</span> n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"name\">product</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">    (<span class=\"name\">counter</span> <span class=\"number\">1</span>)) </span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">iter</span>)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> counter n)</span><br><span class=\"line\">            product</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> product (<span class=\"name\"><span class=\"builtin-name\">*</span></span> counter product))</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> counter (<span class=\"name\"><span class=\"builtin-name\">+</span></span> counter <span class=\"number\">1</span>))</span><br><span class=\"line\">                (<span class=\"name\">iter</span>)</span><br><span class=\"line\">            )))</span><br><span class=\"line\">    (<span class=\"name\">iter</span>)))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们发现，我们必须开始关系<code>product</code>和<code>counter</code>设置值的顺序。即<code>(* counter product)</code>和<code>(+ counter 1)</code>这两个操作步骤一旦出错。我们的<code>factorial</code>函数就出错了。这在函数式编程当中是绝对不可能发生的事情。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-3.2","date":"2019-10-19T15:20:00.000Z","_content":"&emsp;&emsp;程序引入**赋值**概念后，程序运行的复杂性大大增强。其复杂性不单单体现在代码执行顺序的执行上，赋值的引用，环境模型，模块设计与代换模型都与之前大不相同，这一章我们需要掌握赋值概念下产生的**环境**的程序结构概念，并了解**环境**结构下，变量独特的访问规则。\n<!--more-->\n\n&emsp;&emsp;引入赋值的概念之后，变量的意义发生巨大的改变。因为变量可以被随时的赋值和改变各种数据格式形态，变量不单单指代一个具体的结果，而应该看为一个类似容器的概念，可以随时的**放入**和**取出**值的一个容器。而在新的代换模型中，这种读取容器运行的过程运行在被称为**环境**的一种结构中。\n\n&emsp;&emsp;来举一个简单的实例，我们声明一个简单的求平方的函数square，放入x，返回x的平方。`(define (square x) (* x x))`。其实这种定义函数的本质为定义了一个变量`square`，然后把它赋值为一个函数。写法其实等同于`(define square (lambda (x) (* x x)))`。写法二中我们可以很直观的感觉到，定义`square`并且把一个lambda的运行过程赋予它。接着我们定义一个变量，然后运行它：\n```scheme\n;; 定义square为乘方函数\n(define square\n    (lambda (x) (* x x)))\n;; 定义变量a为10\n(define a 10)\n;; 运行square\n(square a)\n```\n&emsp;&emsp;在上面的过程中，我们把整个过程理解为一个**全局环境**，在全局环境中，我们定义了两个变量`square`和`a`。在最后一步运行`square`过程中，实质上构建起了一个**局部运行环境**，我们在局部运行环境中定义了一个名为`x`的变量，然后把取出全局环境中变量`a`的值10，赋予了`x`，然后运算求`x`的平方。可以看到，在这个局部环境中，我们可以定义**局部环境的变量**，也可以访问到**全局环境**中的一些变量。在引入赋值概念后，这个环境与变量的层级关系就显得尤为重要。因为我们需要知道，我们赋值改变的底是哪个变量。\n\n```scheme\n(define a 10)\n(define (change-value)\n    (set! a 20))\n(define (change-value-mode2)\n    (let ((a 10)) (set! a 30))\n)\n(display a) ;; 10\n(change-value)\n(display a) ;; 20\n(change-value-mode2)\n(display a) ;; 20\n```\n\n&emsp;&emsp;我们定义了两个赋值函数`change-value`以及`change-value-mode2`,均对变量`a`进行了赋值。不同的是`change-value-mode2`在自己的局部环境内部定义了一个变量`a`。我们可以看到运行`change-value`时，变量`a`如预期变为了20.但是调用`change-value-mode2`之后，`a`没有成功被赋值改变，因为`change-value-mode2`的局部环境中已经找到了变量`a`，直接对局部环境中的变量`a`进行了操作。\n\n&emsp;&emsp;我们可以把全局环境想象为一个大房间，每一个函数形成的局部环境想成一个个小房间。在函数运行过程中,会现在自己的小房间查找所需要的变量和值，在找不到的情况下会往外部去寻找。在实际代码过程中，函数可以再嵌套函数，形成局部环境中的局部环境。此时外部的局部环境，对于内部局部环境也是可以访问的。\n\n```\n------------- 全局 --------------\n               a\n---------------------------------\n               |          a\nchange-value   |   change-value-mode2\n```\n\n&emsp;&emsp;平行的局部环境。相互之间并不能访问改变到对方环境中存在的变量。这也是面向对象编程的编程`多态`概念能够存在的原理。每个对象是一个保存了各种所需值的**局部环境**，通过访问**全局环境**中共有的方法，对自身局部环境中的变量值进行操作计算。\n\n&emsp;&emsp;赋值概念的引入，使得变量的含义拓展为变为一个可供存取的容器，一个指向存储环境的地址。程序运行的过程产生了**环境**的结构概念，也使得原来在不赋值情况下代换模型产生了变更，形成了环境嵌套，内部访问外部，同级局部之间互相独立的程序模型。在这种程序模型下产生了独特的程序设计思想，面向对象就是其中一个成熟的例子。","source":"_posts/scip/scip(chap3-2).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-3.2\ndate: 2019/10/19 23:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n&emsp;&emsp;程序引入**赋值**概念后，程序运行的复杂性大大增强。其复杂性不单单体现在代码执行顺序的执行上，赋值的引用，环境模型，模块设计与代换模型都与之前大不相同，这一章我们需要掌握赋值概念下产生的**环境**的程序结构概念，并了解**环境**结构下，变量独特的访问规则。\n<!--more-->\n\n&emsp;&emsp;引入赋值的概念之后，变量的意义发生巨大的改变。因为变量可以被随时的赋值和改变各种数据格式形态，变量不单单指代一个具体的结果，而应该看为一个类似容器的概念，可以随时的**放入**和**取出**值的一个容器。而在新的代换模型中，这种读取容器运行的过程运行在被称为**环境**的一种结构中。\n\n&emsp;&emsp;来举一个简单的实例，我们声明一个简单的求平方的函数square，放入x，返回x的平方。`(define (square x) (* x x))`。其实这种定义函数的本质为定义了一个变量`square`，然后把它赋值为一个函数。写法其实等同于`(define square (lambda (x) (* x x)))`。写法二中我们可以很直观的感觉到，定义`square`并且把一个lambda的运行过程赋予它。接着我们定义一个变量，然后运行它：\n```scheme\n;; 定义square为乘方函数\n(define square\n    (lambda (x) (* x x)))\n;; 定义变量a为10\n(define a 10)\n;; 运行square\n(square a)\n```\n&emsp;&emsp;在上面的过程中，我们把整个过程理解为一个**全局环境**，在全局环境中，我们定义了两个变量`square`和`a`。在最后一步运行`square`过程中，实质上构建起了一个**局部运行环境**，我们在局部运行环境中定义了一个名为`x`的变量，然后把取出全局环境中变量`a`的值10，赋予了`x`，然后运算求`x`的平方。可以看到，在这个局部环境中，我们可以定义**局部环境的变量**，也可以访问到**全局环境**中的一些变量。在引入赋值概念后，这个环境与变量的层级关系就显得尤为重要。因为我们需要知道，我们赋值改变的底是哪个变量。\n\n```scheme\n(define a 10)\n(define (change-value)\n    (set! a 20))\n(define (change-value-mode2)\n    (let ((a 10)) (set! a 30))\n)\n(display a) ;; 10\n(change-value)\n(display a) ;; 20\n(change-value-mode2)\n(display a) ;; 20\n```\n\n&emsp;&emsp;我们定义了两个赋值函数`change-value`以及`change-value-mode2`,均对变量`a`进行了赋值。不同的是`change-value-mode2`在自己的局部环境内部定义了一个变量`a`。我们可以看到运行`change-value`时，变量`a`如预期变为了20.但是调用`change-value-mode2`之后，`a`没有成功被赋值改变，因为`change-value-mode2`的局部环境中已经找到了变量`a`，直接对局部环境中的变量`a`进行了操作。\n\n&emsp;&emsp;我们可以把全局环境想象为一个大房间，每一个函数形成的局部环境想成一个个小房间。在函数运行过程中,会现在自己的小房间查找所需要的变量和值，在找不到的情况下会往外部去寻找。在实际代码过程中，函数可以再嵌套函数，形成局部环境中的局部环境。此时外部的局部环境，对于内部局部环境也是可以访问的。\n\n```\n------------- 全局 --------------\n               a\n---------------------------------\n               |          a\nchange-value   |   change-value-mode2\n```\n\n&emsp;&emsp;平行的局部环境。相互之间并不能访问改变到对方环境中存在的变量。这也是面向对象编程的编程`多态`概念能够存在的原理。每个对象是一个保存了各种所需值的**局部环境**，通过访问**全局环境**中共有的方法，对自身局部环境中的变量值进行操作计算。\n\n&emsp;&emsp;赋值概念的引入，使得变量的含义拓展为变为一个可供存取的容器，一个指向存储环境的地址。程序运行的过程产生了**环境**的结构概念，也使得原来在不赋值情况下代换模型产生了变更，形成了环境嵌套，内部访问外部，同级局部之间互相独立的程序模型。在这种程序模型下产生了独特的程序设计思想，面向对象就是其中一个成熟的例子。","slug":"scip/scip(chap3-2)","published":1,"updated":"2020-06-11T01:43:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy7002f9r2vxwplpe1f","content":"<p>&emsp;&emsp;程序引入<strong>赋值</strong>概念后，程序运行的复杂性大大增强。其复杂性不单单体现在代码执行顺序的执行上，赋值的引用，环境模型，模块设计与代换模型都与之前大不相同，这一章我们需要掌握赋值概念下产生的<strong>环境</strong>的程序结构概念，并了解<strong>环境</strong>结构下，变量独特的访问规则。<br><a id=\"more\"></a></p>\n<p>&emsp;&emsp;引入赋值的概念之后，变量的意义发生巨大的改变。因为变量可以被随时的赋值和改变各种数据格式形态，变量不单单指代一个具体的结果，而应该看为一个类似容器的概念，可以随时的<strong>放入</strong>和<strong>取出</strong>值的一个容器。而在新的代换模型中，这种读取容器运行的过程运行在被称为<strong>环境</strong>的一种结构中。</p>\n<p>&emsp;&emsp;来举一个简单的实例，我们声明一个简单的求平方的函数square，放入x，返回x的平方。<code>(define (square x) (* x x))</code>。其实这种定义函数的本质为定义了一个变量<code>square</code>，然后把它赋值为一个函数。写法其实等同于<code>(define square (lambda (x) (* x x)))</code>。写法二中我们可以很直观的感觉到，定义<code>square</code>并且把一个lambda的运行过程赋予它。接着我们定义一个变量，然后运行它：<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 定义square为乘方函数</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> square</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> x x)))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 定义变量a为10</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> a <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 运行square</span></span><br><span class=\"line\">(<span class=\"hljs-name\">square</span> a)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在上面的过程中，我们把整个过程理解为一个<strong>全局环境</strong>，在全局环境中，我们定义了两个变量<code>square</code>和<code>a</code>。在最后一步运行<code>square</code>过程中，实质上构建起了一个<strong>局部运行环境</strong>，我们在局部运行环境中定义了一个名为<code>x</code>的变量，然后把取出全局环境中变量<code>a</code>的值10，赋予了<code>x</code>，然后运算求<code>x</code>的平方。可以看到，在这个局部环境中，我们可以定义<strong>局部环境的变量</strong>，也可以访问到<strong>全局环境</strong>中的一些变量。在引入赋值概念后，这个环境与变量的层级关系就显得尤为重要。因为我们需要知道，我们赋值改变的底是哪个变量。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> a <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">change-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> a <span class=\"hljs-number\">20</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">change-value-mode2</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">a</span> <span class=\"hljs-number\">10</span>)) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> a <span class=\"hljs-number\">30</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> a) <span class=\"hljs-comment\">;; 10</span></span><br><span class=\"line\">(<span class=\"hljs-name\">change-value</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> a) <span class=\"hljs-comment\">;; 20</span></span><br><span class=\"line\">(<span class=\"hljs-name\">change-value-mode2</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> a) <span class=\"hljs-comment\">;; 20</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们定义了两个赋值函数<code>change-value</code>以及<code>change-value-mode2</code>,均对变量<code>a</code>进行了赋值。不同的是<code>change-value-mode2</code>在自己的局部环境内部定义了一个变量<code>a</code>。我们可以看到运行<code>change-value</code>时，变量<code>a</code>如预期变为了20.但是调用<code>change-value-mode2</code>之后，<code>a</code>没有成功被赋值改变，因为<code>change-value-mode2</code>的局部环境中已经找到了变量<code>a</code>，直接对局部环境中的变量<code>a</code>进行了操作。</p>\n<p>&emsp;&emsp;我们可以把全局环境想象为一个大房间，每一个函数形成的局部环境想成一个个小房间。在函数运行过程中,会现在自己的小房间查找所需要的变量和值，在找不到的情况下会往外部去寻找。在实际代码过程中，函数可以再嵌套函数，形成局部环境中的局部环境。此时外部的局部环境，对于内部局部环境也是可以访问的。</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------- 全局 --------------</span><br><span class=\"line\">               a</span><br><span class=\"line\">---------------------------------</span><br><span class=\"line\">               |          a</span><br><span class=\"line\">change-value   |   change-value-mode2</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;平行的局部环境。相互之间并不能访问改变到对方环境中存在的变量。这也是面向对象编程的编程<code>多态</code>概念能够存在的原理。每个对象是一个保存了各种所需值的<strong>局部环境</strong>，通过访问<strong>全局环境</strong>中共有的方法，对自身局部环境中的变量值进行操作计算。</p>\n<p>&emsp;&emsp;赋值概念的引入，使得变量的含义拓展为变为一个可供存取的容器，一个指向存储环境的地址。程序运行的过程产生了<strong>环境</strong>的结构概念，也使得原来在不赋值情况下代换模型产生了变更，形成了环境嵌套，内部访问外部，同级局部之间互相独立的程序模型。在这种程序模型下产生了独特的程序设计思想，面向对象就是其中一个成熟的例子。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;程序引入<strong>赋值</strong>概念后，程序运行的复杂性大大增强。其复杂性不单单体现在代码执行顺序的执行上，赋值的引用，环境模型，模块设计与代换模型都与之前大不相同，这一章我们需要掌握赋值概念下产生的<strong>环境</strong>的程序结构概念，并了解<strong>环境</strong>结构下，变量独特的访问规则。<br></p>","more":"</p>\n<p>&emsp;&emsp;引入赋值的概念之后，变量的意义发生巨大的改变。因为变量可以被随时的赋值和改变各种数据格式形态，变量不单单指代一个具体的结果，而应该看为一个类似容器的概念，可以随时的<strong>放入</strong>和<strong>取出</strong>值的一个容器。而在新的代换模型中，这种读取容器运行的过程运行在被称为<strong>环境</strong>的一种结构中。</p>\n<p>&emsp;&emsp;来举一个简单的实例，我们声明一个简单的求平方的函数square，放入x，返回x的平方。<code>(define (square x) (* x x))</code>。其实这种定义函数的本质为定义了一个变量<code>square</code>，然后把它赋值为一个函数。写法其实等同于<code>(define square (lambda (x) (* x x)))</code>。写法二中我们可以很直观的感觉到，定义<code>square</code>并且把一个lambda的运行过程赋予它。接着我们定义一个变量，然后运行它：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 定义square为乘方函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> square</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x x)))</span><br><span class=\"line\"><span class=\"comment\">;; 定义变量a为10</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> a <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">;; 运行square</span></span><br><span class=\"line\">(<span class=\"name\">square</span> a)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在上面的过程中，我们把整个过程理解为一个<strong>全局环境</strong>，在全局环境中，我们定义了两个变量<code>square</code>和<code>a</code>。在最后一步运行<code>square</code>过程中，实质上构建起了一个<strong>局部运行环境</strong>，我们在局部运行环境中定义了一个名为<code>x</code>的变量，然后把取出全局环境中变量<code>a</code>的值10，赋予了<code>x</code>，然后运算求<code>x</code>的平方。可以看到，在这个局部环境中，我们可以定义<strong>局部环境的变量</strong>，也可以访问到<strong>全局环境</strong>中的一些变量。在引入赋值概念后，这个环境与变量的层级关系就显得尤为重要。因为我们需要知道，我们赋值改变的底是哪个变量。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> a <span class=\"number\">10</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">change-value</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> a <span class=\"number\">20</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">change-value-mode2</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">a</span> <span class=\"number\">10</span>)) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> a <span class=\"number\">30</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">display</span></span> a) <span class=\"comment\">;; 10</span></span><br><span class=\"line\">(<span class=\"name\">change-value</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">display</span></span> a) <span class=\"comment\">;; 20</span></span><br><span class=\"line\">(<span class=\"name\">change-value-mode2</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">display</span></span> a) <span class=\"comment\">;; 20</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们定义了两个赋值函数<code>change-value</code>以及<code>change-value-mode2</code>,均对变量<code>a</code>进行了赋值。不同的是<code>change-value-mode2</code>在自己的局部环境内部定义了一个变量<code>a</code>。我们可以看到运行<code>change-value</code>时，变量<code>a</code>如预期变为了20.但是调用<code>change-value-mode2</code>之后，<code>a</code>没有成功被赋值改变，因为<code>change-value-mode2</code>的局部环境中已经找到了变量<code>a</code>，直接对局部环境中的变量<code>a</code>进行了操作。</p>\n<p>&emsp;&emsp;我们可以把全局环境想象为一个大房间，每一个函数形成的局部环境想成一个个小房间。在函数运行过程中,会现在自己的小房间查找所需要的变量和值，在找不到的情况下会往外部去寻找。在实际代码过程中，函数可以再嵌套函数，形成局部环境中的局部环境。此时外部的局部环境，对于内部局部环境也是可以访问的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------- 全局 --------------</span><br><span class=\"line\">               a</span><br><span class=\"line\">---------------------------------</span><br><span class=\"line\">               |          a</span><br><span class=\"line\">change-value   |   change-value-mode2</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;平行的局部环境。相互之间并不能访问改变到对方环境中存在的变量。这也是面向对象编程的编程<code>多态</code>概念能够存在的原理。每个对象是一个保存了各种所需值的<strong>局部环境</strong>，通过访问<strong>全局环境</strong>中共有的方法，对自身局部环境中的变量值进行操作计算。</p>\n<p>&emsp;&emsp;赋值概念的引入，使得变量的含义拓展为变为一个可供存取的容器，一个指向存储环境的地址。程序运行的过程产生了<strong>环境</strong>的结构概念，也使得原来在不赋值情况下代换模型产生了变更，形成了环境嵌套，内部访问外部，同级局部之间互相独立的程序模型。在这种程序模型下产生了独特的程序设计思想，面向对象就是其中一个成熟的例子。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-3.3","date":"2019-10-26T06:20:00.000Z","_content":"&emsp;&emsp;本章使用实例来模拟不断变化状态组成的系统，除了需要做复合对象的构造和成分选择之后，还需要修改它们(赋值)。其中不单包含了选择函数和构造函数，还会引入**改变函数**的构造。\n<!--more-->\n&emsp;&emsp;在前面的阅读过程中，我们使用了针对序对的基本操作`cons`、`car`以及`cdr`。这三种方法仅仅是构造和读取表的操作，不能对表进行操作。现在我们需要引入对表进行**赋值**的概念，`set-car!`和`set-cdr!`，它们接受两个参数，第一个参数为需要赋值的序对，第二个参数为需要设置序对的新值。\n\n&emsp;&emsp;利用新的序对赋值的概念，我们可以创建出新的，在没有引入赋值序对概念前无法创建出来的数据结构，队列就是其中之一。队列是一个串形数据结构，在尾部加入数据，在顶部读取数据，遵循先进先出的原则。我们需要定义一个创建函数`make-queue`,它创建一个新的空队列，并创建两个**读取队列**函数，一个判断队列是否为空，一个返回队列的第一项。之后我们需要追加两个能够**操作队列**的函数，一个是插入(队列末端)数据，一个是删除(前端)数据。\n\n&emsp;&emsp;现在我们思考一下对队列操作的函数应该如何处理。首先删除数据，即在队列的头部删除一个数据，只需要使用`cdr`取队列除第一项之外剩下的值即可。但是在新增数据的时候，我们需要插入的是队列的末尾项，在没有其他特殊操作的情况下，读取队列的最后一项需要一直使用`cdr`遍历整个队列，扫描到最后一项，然后连接它插入构造项。队列为n的情况下，这个消耗为O(n)。\n\n```scheme\n(define queue (1 2 3 ...n项 n+1 n+2))\n;; 删除只需要cdr取队列\n(cdr queue)\n;; 新增需要遍历到最后一项，每一步\n(cdr queue) ;; n\n```\n\n&emsp;&emsp;其实我们只需要换一种思维方式，把队列首位形成一个序对记录下来。每次删除新增改变首位记录的序对。这样在新增删除的时候就不需要对队列进行遍历。\n我们使用`front-ptr`和`rear-ptr`来记录队列的首位操作。\n\n```scheme\n;; 防止每次插入队列都需要扫描到队列的最末端，非常低效，采用前端指针和后端指针\n;; 前后指针\n(define (front-ptr queue) (car queue))\n(define (rear-ptr queue) (cdr queue))\n;; 设置队列前后值\n(define (set-front-ptr! queue item) (set-car! queue item))\n(define (set-rear-ptr! queue item) (set-cdr! queue item))\n```\n&emsp;&emsp;接着我们可以基于`front-ptr`和`rear-ptr`来完成上面的构造队列，读取队列以及操作队列的函数。\n\n```scheme\n;; make-queue 返回一个初始的空表\n(define (make-queue) (cons '() '()))\n\n;; (empty-queue? <queue>) 队列是否为空 -> 队列头是否为null\n(define (empty-queue? queue) (null? (front-ptr queue)))\n\n;; (front-queue <queue>) 返回队列前端的对象，不修改队列\n(define (front-queue queue)\n  (if (empty-queue? queue)\n    (error \"empty\" queue)\n    (car (front-ptr queue))\n  )\n)\n\n;; (insert-queue! <queue>) 插入队列\n(define (insert-queue! queue item)\n  (let\n    ((new-pair (cons item '())))\n    ;; 如果是空的队列，那么前后\n    (cond\n      ((empty-queue? queue)\n        (set-front-ptr! queue new-pair)\n        (set-rear-ptr! queue new-pair)\n        queue\n      )\n      (else\n        (set-cdr! (rear-ptr queue) new-pair)\n        (set-rear-ptr! queue new-pair)\n        queue))))\n\n;; (delete-queue! <queue>) 删除队列\n(define (delete-queue! queue)\n  (cond\n    ((empty-queue? queue)\n      (error \"empty\" queue))\n    (else\n      (set-fornt-ptr queue (cdr (front-ptr queue))))\n    queue\n  )\n)\n```\n\n&emsp;&emsp;我们还可以利用序对赋值的概念，完成一个**表**的数据结构。**表**应该是一个`key-value`的映射结构，正好符号序对的构造方式。我们使用**table**作为表构建取来一个序对的入口。\n```\n table <-> cdr ->  key <-> key \n                    |\n               key <> value\n```\n&emsp;&emsp;利用指针，把储存value的序对和指向下一个key的序对使用队列的方式连接起来。使用这个数据结构，我们可以定义出**查询**和**插入**表两个操作。\n```scheme\n;; 查询表\n(define (lookup key table)\n  (let\n    ((record (assoc key (cdr table))))\n    (if record\n      (cdr record)\n      false)))\n\n(define (assoc key records)\n  (cond\n    ((null? records) false)\n    ;; 取出的 records 和 key 相同的话，返回这一项\n    ((equal? key (caar records)) (car records))\n  )\n)\n\n(define (insert! key value table)\n  (let\n    ((record (assoc key (cdr table))))\n    (if record\n      (set-cdr! record value)\n      (set-cdr! table (cons (cons key value) (cdr table)))\n    ))\n  'ok\n)\n```\n&emsp;&emsp;assoc函数是一个过程，每次查询的时候，会判断一下表格key的队列是否成空，如果成功就停止继续搜索表格。\n\n&emsp;&emsp;脱离数据结构，我们来看看序对的赋值带来的复杂数据结构的能力，我们引入一个**约束系统**的实例，并用这种模式来在代码层面实现它。\n\n&emsp;&emsp;所谓**约束系统**指的是双向控制的一个系统模型。比如我们知道的，摄氏度和华氏温度之间存在一个公式转换`9C=5(F-32)`。在这个摄氏度和华氏温度的公式中，我们只需要知道摄氏度(C)或者华氏温度(F),其中的一个值，就能定义下另一个值。这种双向关联的系统模型，就是**约束系统**。\n\n&emsp;&emsp;**约束系统**中重要的就是设置值时的**唤醒**的概念。在上面的公式中，当我设置C的值为5的时候，右侧的华氏温度模块就会左侧摄氏度模块45的模块值，并自己在内部计算出F的值并设置。我们利用这个模块的概念，先来设计出**约束系统**的使用。\n\n\n```scheme\n;; 3.5约束的概念 9C = 5(F-32)\n;; 约束的使用\n(define C (make-connector))\n(define F (make-connector))\n(celsius-fahrenheit-converter C F)\n(define (celsius-fahrenheit-converter C F)\n  (let\n    (\n      (u (make-connector))\n      (v (make-connector))\n      (w (make-connector))\n      (x (make-connector))\n      (y (make-connector))\n    )\n    (multiplier c w u)\n    (multiplier v x u)\n    (adder v y f)\n    (constant 9 w)\n    (constant 5 x)\n    (contant 32 y)\n    'ok))\n```\n&emsp;&emsp;`make-connector`是一个模块定义函数，它定义了C和F两个模块，暴露给外部，使得外部可以给C和F进行赋值。\n\n&emsp;&emsp;我们接着需要定义两个输出函数，来让约束系统的每次模块接收值都能够输出一个计算的数据，让我们知道约束系统的哪个模块被设置了什么值。\n\n```scheme\n;; 安装probe，使得每次赋予连接器一个值的时候，都会打印出来两个对应的值\n(probe \"celsius temp\" C)\n(probe \"Fahrenheit temp\" F)\n\n;; 给C设置，应该产生的输出\n(set-value! C 25 'user) ;; celsius temp 25  Fahrenheit temp 77\n```\n&emsp;&emsp;在明确调用方式的情况下，我们需要在内部实现我们的约束系统。它应该存在读取函数`(has-value? connector) 是否有值`和`(get-value connector) 返回连接器当前的值`。改变值的方法`(set-value! connector new-value informant) 通知informant信息员，设置新值`和`(forget-value! connector retractor) 通知撤销源忘记其值`。最后一个链接函数`(connect connector new-constraint) 通知连接器参与一个新约束`。\n\n```scheme\n(define (adder a1 a2 sum)\n  (define (process-new-value)\n    (cond\n      ((and (has-value? a1) (has-value? a2))\n        (set-value! sum (+ (get-value a1) (get-value a2)) me))\n\n      ((and (has-value? a1) (has-value? sum))\n        (set-value! a2 (- (get-value sum) (get-value a1)) me))\n      \n      ((and (has-value? a2) (has-value? sum))\n        (set-value! a1 (- (get-value sum) (get-value a2)) me))\n    )\n  )\n  (define (process-forget-value)\n    (forget-value! sum me)\n    (forget-value! a1 me)\n    (forget-value! a2 me)\n    (process-new-value))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-lost-my-value) (process-forget-value))\n      (else (error \"Unkonw request -- ADDER\" request))))\n  (connect a1 me)\n  (connect a2 me)\n  (connect sum me) me\n)\n;; 乘法的实现\n(define (multiplier m1 m2 product)\n  (define (process-new-value)\n    (cond\n      \n      ((or (and (has-value? m1) (= (get-value m1) 0))\n           (and (has-value? m2) (= (get-lvaue m2) 0)))\n        (set-value! product 0 me))\n      \n      ((and (has-value? m1) (has-value? m2))\n        (set-value! product (* (get-value m1) (get-value m2)) me))\n      \n      ((and (has-value? product) (has-value? m1))\n        (set-value! m2 (/ (get-value product) (get-value m1)) me))\n\n      ((and (has-value? product) (has-value? m2))\n        (set-value! m1 (/ (get-value product) (get-value m2)) me))\n    )\n  )\n  (define (process-forget-value)\n    (forget-value! product me)\n    (forget-value! m1 me)\n    (forget-value! m2 me)\n    (process-new-value))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-lost-my-value) (process-forget-value))\n      (else (error \"Unkonw request -- ADDER\" request))))\n  (connect m1 me)\n  (connect m2 me)\n  (connect product me) me\n)\n;; constant 简单的设置值， \n(define (constant value connector)\n  (define (me request)\n    (error \"Unknown request\" request))\n  (connect connector me)\n  (set-value! connector value me) me)\n\n;; 监视器 设置或者取消的时候打出一个值\n(define (probe name connector)\n  (define (print-probe value)\n    (newline)\n    (display \"Probe: \")\n    (display name)\n    (display \" = \")\n    (display value))\n  (define (process-new-value)\n    (print-probe (get-value connector)))\n  (define (process-forget-value)\n    (print-probe \"?\"))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-Lost-my-value) (process-forget-value))\n      (else (error \"Unknown request -- PROBE\" request))))\n  (connect connector me) me)\n```\n\n&emsp;&emsp;完成操作方法之后，我们需要给外部定义一个**监视器**，让每次值改变(设置新值或者遗忘)，都能打出日志，来报告设置的结果通知给外部。\n```scheme\n;; 监视器 设置或者取消的时候打出一个值\n(define (probe name connector)\n  (define (print-probe value)\n    (newline)\n    (display \"Probe: \")\n    (display name)\n    (display \" = \")\n    (display value))\n  (define (process-new-value)\n    (print-probe (get-value connector)))\n  (define (process-forget-value)\n    (print-probe \"?\"))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-Lost-my-value) (process-forget-value))\n      (else (error \"Unknown request -- PROBE\" request))))\n  (connect connector me) me)\n;; 连接器的表示\n;; value 值 informant 设置连接器的对象 constraints 所涉及的所有约束的表\n(define (make-connector)\n  (let\n    ((value false) (informant false) (constraints '()))\n    (define (set-my-value newval setter)\n      (cond (\n        (not (has-value? me))\n          (set! value newval)\n          (set! informant setter)\n          (for-each-except setter inform-about-value constraints))\n        ((not (= value newval))\n          (error \"Contradiction\" (list value newval)))\n        (else 'ignored)))\n    (define (forget-my-value retractor)\n      (if (eq? retractor informant)\n        (begin\n          (set! informant false)\n          (for-each-except retractor inform-about-no-value constraints))\n        'ignored))\n    (define (connect new-constraint)\n      (if (not (memq new-constraint constraints))\n        (set! constraints (cons new-constraint constraints)))\n      (if (has-value? me) (inform-about-value new-constraint))\n      'done)\n    (define (me request)\n      (cond\n        ((eq? request 'has-value?) (if informant true false))\n        ((eq? request 'value) value)\n        ((eq? request 'set-value!) set-my-value)\n        ((eq? request 'forget) forget-my-value)\n        ((eq? request 'connect) connect)\n        (else (error \"Unknown operation -- CONNECTOR\" request))))\n    me))\n```\n&emsp;&emsp;在引入序对的赋值能力后，我们可以构建起以操作数据为核心的复杂数据结构，比如**表**，比如**队列**。这些数据结构具备增删改查的能力，在这个能力基础上，可以完成各种复杂的实例，比如书本上的模拟电路和这里记录的约束系统，完成更加复杂的业务场景模型设计。","source":"_posts/scip/scip(chap3-3).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-3.3\ndate: 2019/10/26 14:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n&emsp;&emsp;本章使用实例来模拟不断变化状态组成的系统，除了需要做复合对象的构造和成分选择之后，还需要修改它们(赋值)。其中不单包含了选择函数和构造函数，还会引入**改变函数**的构造。\n<!--more-->\n&emsp;&emsp;在前面的阅读过程中，我们使用了针对序对的基本操作`cons`、`car`以及`cdr`。这三种方法仅仅是构造和读取表的操作，不能对表进行操作。现在我们需要引入对表进行**赋值**的概念，`set-car!`和`set-cdr!`，它们接受两个参数，第一个参数为需要赋值的序对，第二个参数为需要设置序对的新值。\n\n&emsp;&emsp;利用新的序对赋值的概念，我们可以创建出新的，在没有引入赋值序对概念前无法创建出来的数据结构，队列就是其中之一。队列是一个串形数据结构，在尾部加入数据，在顶部读取数据，遵循先进先出的原则。我们需要定义一个创建函数`make-queue`,它创建一个新的空队列，并创建两个**读取队列**函数，一个判断队列是否为空，一个返回队列的第一项。之后我们需要追加两个能够**操作队列**的函数，一个是插入(队列末端)数据，一个是删除(前端)数据。\n\n&emsp;&emsp;现在我们思考一下对队列操作的函数应该如何处理。首先删除数据，即在队列的头部删除一个数据，只需要使用`cdr`取队列除第一项之外剩下的值即可。但是在新增数据的时候，我们需要插入的是队列的末尾项，在没有其他特殊操作的情况下，读取队列的最后一项需要一直使用`cdr`遍历整个队列，扫描到最后一项，然后连接它插入构造项。队列为n的情况下，这个消耗为O(n)。\n\n```scheme\n(define queue (1 2 3 ...n项 n+1 n+2))\n;; 删除只需要cdr取队列\n(cdr queue)\n;; 新增需要遍历到最后一项，每一步\n(cdr queue) ;; n\n```\n\n&emsp;&emsp;其实我们只需要换一种思维方式，把队列首位形成一个序对记录下来。每次删除新增改变首位记录的序对。这样在新增删除的时候就不需要对队列进行遍历。\n我们使用`front-ptr`和`rear-ptr`来记录队列的首位操作。\n\n```scheme\n;; 防止每次插入队列都需要扫描到队列的最末端，非常低效，采用前端指针和后端指针\n;; 前后指针\n(define (front-ptr queue) (car queue))\n(define (rear-ptr queue) (cdr queue))\n;; 设置队列前后值\n(define (set-front-ptr! queue item) (set-car! queue item))\n(define (set-rear-ptr! queue item) (set-cdr! queue item))\n```\n&emsp;&emsp;接着我们可以基于`front-ptr`和`rear-ptr`来完成上面的构造队列，读取队列以及操作队列的函数。\n\n```scheme\n;; make-queue 返回一个初始的空表\n(define (make-queue) (cons '() '()))\n\n;; (empty-queue? <queue>) 队列是否为空 -> 队列头是否为null\n(define (empty-queue? queue) (null? (front-ptr queue)))\n\n;; (front-queue <queue>) 返回队列前端的对象，不修改队列\n(define (front-queue queue)\n  (if (empty-queue? queue)\n    (error \"empty\" queue)\n    (car (front-ptr queue))\n  )\n)\n\n;; (insert-queue! <queue>) 插入队列\n(define (insert-queue! queue item)\n  (let\n    ((new-pair (cons item '())))\n    ;; 如果是空的队列，那么前后\n    (cond\n      ((empty-queue? queue)\n        (set-front-ptr! queue new-pair)\n        (set-rear-ptr! queue new-pair)\n        queue\n      )\n      (else\n        (set-cdr! (rear-ptr queue) new-pair)\n        (set-rear-ptr! queue new-pair)\n        queue))))\n\n;; (delete-queue! <queue>) 删除队列\n(define (delete-queue! queue)\n  (cond\n    ((empty-queue? queue)\n      (error \"empty\" queue))\n    (else\n      (set-fornt-ptr queue (cdr (front-ptr queue))))\n    queue\n  )\n)\n```\n\n&emsp;&emsp;我们还可以利用序对赋值的概念，完成一个**表**的数据结构。**表**应该是一个`key-value`的映射结构，正好符号序对的构造方式。我们使用**table**作为表构建取来一个序对的入口。\n```\n table <-> cdr ->  key <-> key \n                    |\n               key <> value\n```\n&emsp;&emsp;利用指针，把储存value的序对和指向下一个key的序对使用队列的方式连接起来。使用这个数据结构，我们可以定义出**查询**和**插入**表两个操作。\n```scheme\n;; 查询表\n(define (lookup key table)\n  (let\n    ((record (assoc key (cdr table))))\n    (if record\n      (cdr record)\n      false)))\n\n(define (assoc key records)\n  (cond\n    ((null? records) false)\n    ;; 取出的 records 和 key 相同的话，返回这一项\n    ((equal? key (caar records)) (car records))\n  )\n)\n\n(define (insert! key value table)\n  (let\n    ((record (assoc key (cdr table))))\n    (if record\n      (set-cdr! record value)\n      (set-cdr! table (cons (cons key value) (cdr table)))\n    ))\n  'ok\n)\n```\n&emsp;&emsp;assoc函数是一个过程，每次查询的时候，会判断一下表格key的队列是否成空，如果成功就停止继续搜索表格。\n\n&emsp;&emsp;脱离数据结构，我们来看看序对的赋值带来的复杂数据结构的能力，我们引入一个**约束系统**的实例，并用这种模式来在代码层面实现它。\n\n&emsp;&emsp;所谓**约束系统**指的是双向控制的一个系统模型。比如我们知道的，摄氏度和华氏温度之间存在一个公式转换`9C=5(F-32)`。在这个摄氏度和华氏温度的公式中，我们只需要知道摄氏度(C)或者华氏温度(F),其中的一个值，就能定义下另一个值。这种双向关联的系统模型，就是**约束系统**。\n\n&emsp;&emsp;**约束系统**中重要的就是设置值时的**唤醒**的概念。在上面的公式中，当我设置C的值为5的时候，右侧的华氏温度模块就会左侧摄氏度模块45的模块值，并自己在内部计算出F的值并设置。我们利用这个模块的概念，先来设计出**约束系统**的使用。\n\n\n```scheme\n;; 3.5约束的概念 9C = 5(F-32)\n;; 约束的使用\n(define C (make-connector))\n(define F (make-connector))\n(celsius-fahrenheit-converter C F)\n(define (celsius-fahrenheit-converter C F)\n  (let\n    (\n      (u (make-connector))\n      (v (make-connector))\n      (w (make-connector))\n      (x (make-connector))\n      (y (make-connector))\n    )\n    (multiplier c w u)\n    (multiplier v x u)\n    (adder v y f)\n    (constant 9 w)\n    (constant 5 x)\n    (contant 32 y)\n    'ok))\n```\n&emsp;&emsp;`make-connector`是一个模块定义函数，它定义了C和F两个模块，暴露给外部，使得外部可以给C和F进行赋值。\n\n&emsp;&emsp;我们接着需要定义两个输出函数，来让约束系统的每次模块接收值都能够输出一个计算的数据，让我们知道约束系统的哪个模块被设置了什么值。\n\n```scheme\n;; 安装probe，使得每次赋予连接器一个值的时候，都会打印出来两个对应的值\n(probe \"celsius temp\" C)\n(probe \"Fahrenheit temp\" F)\n\n;; 给C设置，应该产生的输出\n(set-value! C 25 'user) ;; celsius temp 25  Fahrenheit temp 77\n```\n&emsp;&emsp;在明确调用方式的情况下，我们需要在内部实现我们的约束系统。它应该存在读取函数`(has-value? connector) 是否有值`和`(get-value connector) 返回连接器当前的值`。改变值的方法`(set-value! connector new-value informant) 通知informant信息员，设置新值`和`(forget-value! connector retractor) 通知撤销源忘记其值`。最后一个链接函数`(connect connector new-constraint) 通知连接器参与一个新约束`。\n\n```scheme\n(define (adder a1 a2 sum)\n  (define (process-new-value)\n    (cond\n      ((and (has-value? a1) (has-value? a2))\n        (set-value! sum (+ (get-value a1) (get-value a2)) me))\n\n      ((and (has-value? a1) (has-value? sum))\n        (set-value! a2 (- (get-value sum) (get-value a1)) me))\n      \n      ((and (has-value? a2) (has-value? sum))\n        (set-value! a1 (- (get-value sum) (get-value a2)) me))\n    )\n  )\n  (define (process-forget-value)\n    (forget-value! sum me)\n    (forget-value! a1 me)\n    (forget-value! a2 me)\n    (process-new-value))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-lost-my-value) (process-forget-value))\n      (else (error \"Unkonw request -- ADDER\" request))))\n  (connect a1 me)\n  (connect a2 me)\n  (connect sum me) me\n)\n;; 乘法的实现\n(define (multiplier m1 m2 product)\n  (define (process-new-value)\n    (cond\n      \n      ((or (and (has-value? m1) (= (get-value m1) 0))\n           (and (has-value? m2) (= (get-lvaue m2) 0)))\n        (set-value! product 0 me))\n      \n      ((and (has-value? m1) (has-value? m2))\n        (set-value! product (* (get-value m1) (get-value m2)) me))\n      \n      ((and (has-value? product) (has-value? m1))\n        (set-value! m2 (/ (get-value product) (get-value m1)) me))\n\n      ((and (has-value? product) (has-value? m2))\n        (set-value! m1 (/ (get-value product) (get-value m2)) me))\n    )\n  )\n  (define (process-forget-value)\n    (forget-value! product me)\n    (forget-value! m1 me)\n    (forget-value! m2 me)\n    (process-new-value))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-lost-my-value) (process-forget-value))\n      (else (error \"Unkonw request -- ADDER\" request))))\n  (connect m1 me)\n  (connect m2 me)\n  (connect product me) me\n)\n;; constant 简单的设置值， \n(define (constant value connector)\n  (define (me request)\n    (error \"Unknown request\" request))\n  (connect connector me)\n  (set-value! connector value me) me)\n\n;; 监视器 设置或者取消的时候打出一个值\n(define (probe name connector)\n  (define (print-probe value)\n    (newline)\n    (display \"Probe: \")\n    (display name)\n    (display \" = \")\n    (display value))\n  (define (process-new-value)\n    (print-probe (get-value connector)))\n  (define (process-forget-value)\n    (print-probe \"?\"))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-Lost-my-value) (process-forget-value))\n      (else (error \"Unknown request -- PROBE\" request))))\n  (connect connector me) me)\n```\n\n&emsp;&emsp;完成操作方法之后，我们需要给外部定义一个**监视器**，让每次值改变(设置新值或者遗忘)，都能打出日志，来报告设置的结果通知给外部。\n```scheme\n;; 监视器 设置或者取消的时候打出一个值\n(define (probe name connector)\n  (define (print-probe value)\n    (newline)\n    (display \"Probe: \")\n    (display name)\n    (display \" = \")\n    (display value))\n  (define (process-new-value)\n    (print-probe (get-value connector)))\n  (define (process-forget-value)\n    (print-probe \"?\"))\n  (define (me request)\n    (cond\n      ((eq? request 'I-have-a-value) (process-new-value))\n      ((eq? request 'I-Lost-my-value) (process-forget-value))\n      (else (error \"Unknown request -- PROBE\" request))))\n  (connect connector me) me)\n;; 连接器的表示\n;; value 值 informant 设置连接器的对象 constraints 所涉及的所有约束的表\n(define (make-connector)\n  (let\n    ((value false) (informant false) (constraints '()))\n    (define (set-my-value newval setter)\n      (cond (\n        (not (has-value? me))\n          (set! value newval)\n          (set! informant setter)\n          (for-each-except setter inform-about-value constraints))\n        ((not (= value newval))\n          (error \"Contradiction\" (list value newval)))\n        (else 'ignored)))\n    (define (forget-my-value retractor)\n      (if (eq? retractor informant)\n        (begin\n          (set! informant false)\n          (for-each-except retractor inform-about-no-value constraints))\n        'ignored))\n    (define (connect new-constraint)\n      (if (not (memq new-constraint constraints))\n        (set! constraints (cons new-constraint constraints)))\n      (if (has-value? me) (inform-about-value new-constraint))\n      'done)\n    (define (me request)\n      (cond\n        ((eq? request 'has-value?) (if informant true false))\n        ((eq? request 'value) value)\n        ((eq? request 'set-value!) set-my-value)\n        ((eq? request 'forget) forget-my-value)\n        ((eq? request 'connect) connect)\n        (else (error \"Unknown operation -- CONNECTOR\" request))))\n    me))\n```\n&emsp;&emsp;在引入序对的赋值能力后，我们可以构建起以操作数据为核心的复杂数据结构，比如**表**，比如**队列**。这些数据结构具备增删改查的能力，在这个能力基础上，可以完成各种复杂的实例，比如书本上的模拟电路和这里记录的约束系统，完成更加复杂的业务场景模型设计。","slug":"scip/scip(chap3-3)","published":1,"updated":"2020-06-11T01:43:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhy8002h9r2v6e3vul0o","content":"<p>&emsp;&emsp;本章使用实例来模拟不断变化状态组成的系统，除了需要做复合对象的构造和成分选择之后，还需要修改它们(赋值)。其中不单包含了选择函数和构造函数，还会引入<strong>改变函数</strong>的构造。<br><a id=\"more\"></a><br>&emsp;&emsp;在前面的阅读过程中，我们使用了针对序对的基本操作<code>cons</code>、<code>car</code>以及<code>cdr</code>。这三种方法仅仅是构造和读取表的操作，不能对表进行操作。现在我们需要引入对表进行<strong>赋值</strong>的概念，<code>set-car!</code>和<code>set-cdr!</code>，它们接受两个参数，第一个参数为需要赋值的序对，第二个参数为需要设置序对的新值。</p>\n<p>&emsp;&emsp;利用新的序对赋值的概念，我们可以创建出新的，在没有引入赋值序对概念前无法创建出来的数据结构，队列就是其中之一。队列是一个串形数据结构，在尾部加入数据，在顶部读取数据，遵循先进先出的原则。我们需要定义一个创建函数<code>make-queue</code>,它创建一个新的空队列，并创建两个<strong>读取队列</strong>函数，一个判断队列是否为空，一个返回队列的第一项。之后我们需要追加两个能够<strong>操作队列</strong>的函数，一个是插入(队列末端)数据，一个是删除(前端)数据。</p>\n<p>&emsp;&emsp;现在我们思考一下对队列操作的函数应该如何处理。首先删除数据，即在队列的头部删除一个数据，只需要使用<code>cdr</code>取队列除第一项之外剩下的值即可。但是在新增数据的时候，我们需要插入的是队列的末尾项，在没有其他特殊操作的情况下，读取队列的最后一项需要一直使用<code>cdr</code>遍历整个队列，扫描到最后一项，然后连接它插入构造项。队列为n的情况下，这个消耗为O(n)。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> queue (<span class=\"hljs-name\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> ...n项 n+1 n+2))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 删除只需要cdr取队列</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> queue)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 新增需要遍历到最后一项，每一步</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> queue) <span class=\"hljs-comment\">;; n</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其实我们只需要换一种思维方式，把队列首位形成一个序对记录下来。每次删除新增改变首位记录的序对。这样在新增删除的时候就不需要对队列进行遍历。<br>我们使用<code>front-ptr</code>和<code>rear-ptr</code>来记录队列的首位操作。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 防止每次插入队列都需要扫描到队列的最末端，非常低效，采用前端指针和后端指针</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 前后指针</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">front-ptr</span> queue) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> queue))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">rear-ptr</span> queue) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> queue))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 设置队列前后值</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">set-front-ptr!</span> queue item) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-car!</span></span> queue item))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">set-rear-ptr!</span> queue item) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-cdr!</span></span> queue item))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;接着我们可以基于<code>front-ptr</code>和<code>rear-ptr</code>来完成上面的构造队列，读取队列以及操作队列的函数。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; make-queue 返回一个初始的空表</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-queue</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> '() '()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (empty-queue? &lt;queue&gt;) 队列是否为空 -&gt; 队列头是否为null</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">empty-queue?</span> queue) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> (<span class=\"hljs-name\">front-ptr</span> queue)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (front-queue &lt;queue&gt;) 返回队列前端的对象，不修改队列</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">front-queue</span> queue)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">empty-queue?</span> queue)</span><br><span class=\"line\">    (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"empty\"</span> queue)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> (<span class=\"hljs-name\">front-ptr</span> queue))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (insert-queue! &lt;queue&gt;) 插入队列</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">insert-queue!</span> queue item)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">new-pair</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> item '())))</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 如果是空的队列，那么前后</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\">empty-queue?</span> queue)</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-front-ptr!</span> queue new-pair)</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-rear-ptr!</span> queue new-pair)</span><br><span class=\"line\">        queue</span><br><span class=\"line\">      )</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-cdr!</span></span> (<span class=\"hljs-name\">rear-ptr</span> queue) new-pair)</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-rear-ptr!</span> queue new-pair)</span><br><span class=\"line\">        queue))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (delete-queue! &lt;queue&gt;) 删除队列</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">delete-queue!</span> queue)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">empty-queue?</span> queue)</span><br><span class=\"line\">      (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"empty\"</span> queue))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span></span><br><span class=\"line\">      (<span class=\"hljs-name\">set-fornt-ptr</span> queue (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> (<span class=\"hljs-name\">front-ptr</span> queue))))</span><br><span class=\"line\">    queue</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们还可以利用序对赋值的概念，完成一个<strong>表</strong>的数据结构。<strong>表</strong>应该是一个<code>key-value</code>的映射结构，正好符号序对的构造方式。我们使用<strong>table</strong>作为表构建取来一个序对的入口。<br><figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table &lt;-&gt; cdr -&gt;  key &lt;-&gt; key </span><br><span class=\"line\">                   |</span><br><span class=\"line\">              key &lt;&gt; value</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;利用指针，把储存value的序对和指向下一个key的序对使用队列的方式连接起来。使用这个数据结构，我们可以定义出<strong>查询</strong>和<strong>插入</strong>表两个操作。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 查询表</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">lookup</span> key table)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">record</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">assoc</span></span> key (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> table))))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> record</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> record)</span><br><span class=\"line\">      false)))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">assoc</span></span> key records)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">null?</span></span> records) false)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 取出的 records 和 key 相同的话，返回这一项</span></span><br><span class=\"line\">    ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">equal?</span></span> key (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">caar</span></span> records)) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> records))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">insert!</span> key value table)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">record</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">assoc</span></span> key (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> table))))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> record</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-cdr!</span></span> record value)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-cdr!</span></span> table (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> key value) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cdr</span></span> table)))</span><br><span class=\"line\">    ))</span><br><span class=\"line\">  <span class=\"hljs-symbol\">'ok</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;assoc函数是一个过程，每次查询的时候，会判断一下表格key的队列是否成空，如果成功就停止继续搜索表格。</p>\n<p>&emsp;&emsp;脱离数据结构，我们来看看序对的赋值带来的复杂数据结构的能力，我们引入一个<strong>约束系统</strong>的实例，并用这种模式来在代码层面实现它。</p>\n<p>&emsp;&emsp;所谓<strong>约束系统</strong>指的是双向控制的一个系统模型。比如我们知道的，摄氏度和华氏温度之间存在一个公式转换<code>9C=5(F-32)</code>。在这个摄氏度和华氏温度的公式中，我们只需要知道摄氏度(C)或者华氏温度(F),其中的一个值，就能定义下另一个值。这种双向关联的系统模型，就是<strong>约束系统</strong>。</p>\n<p>&emsp;&emsp;<strong>约束系统</strong>中重要的就是设置值时的<strong>唤醒</strong>的概念。在上面的公式中，当我设置C的值为5的时候，右侧的华氏温度模块就会左侧摄氏度模块45的模块值，并自己在内部计算出F的值并设置。我们利用这个模块的概念，先来设计出<strong>约束系统</strong>的使用。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 3.5约束的概念 9C = 5(F-32)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 约束的使用</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> C (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> F (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">(<span class=\"hljs-name\">celsius-fahrenheit-converter</span> C F)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">celsius-fahrenheit-converter</span> C F)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    (</span><br><span class=\"line\">      (<span class=\"hljs-name\">u</span> (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\">v</span> (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\">w</span> (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\">x</span> (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\">y</span> (<span class=\"hljs-name\">make-connector</span>))</span><br><span class=\"line\">    )</span><br><span class=\"line\">    (<span class=\"hljs-name\">multiplier</span> c w u)</span><br><span class=\"line\">    (<span class=\"hljs-name\">multiplier</span> v x u)</span><br><span class=\"line\">    (<span class=\"hljs-name\">adder</span> v y f)</span><br><span class=\"line\">    (<span class=\"hljs-name\">constant</span> <span class=\"hljs-number\">9</span> w)</span><br><span class=\"line\">    (<span class=\"hljs-name\">constant</span> <span class=\"hljs-number\">5</span> x)</span><br><span class=\"line\">    (<span class=\"hljs-name\">contant</span> <span class=\"hljs-number\">32</span> y)</span><br><span class=\"line\">    <span class=\"hljs-symbol\">'ok</span>))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>make-connector</code>是一个模块定义函数，它定义了C和F两个模块，暴露给外部，使得外部可以给C和F进行赋值。</p>\n<p>&emsp;&emsp;我们接着需要定义两个输出函数，来让约束系统的每次模块接收值都能够输出一个计算的数据，让我们知道约束系统的哪个模块被设置了什么值。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 安装probe，使得每次赋予连接器一个值的时候，都会打印出来两个对应的值</span></span><br><span class=\"line\">(<span class=\"hljs-name\">probe</span> <span class=\"hljs-string\">\"celsius temp\"</span> C)</span><br><span class=\"line\">(<span class=\"hljs-name\">probe</span> <span class=\"hljs-string\">\"Fahrenheit temp\"</span> F)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 给C设置，应该产生的输出</span></span><br><span class=\"line\">(<span class=\"hljs-name\">set-value!</span> C <span class=\"hljs-number\">25</span> <span class=\"hljs-symbol\">'user</span>) <span class=\"hljs-comment\">;; celsius temp 25  Fahrenheit temp 77</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在明确调用方式的情况下，我们需要在内部实现我们的约束系统。它应该存在读取函数<code>(has-value? connector) 是否有值</code>和<code>(get-value connector) 返回连接器当前的值</code>。改变值的方法<code>(set-value! connector new-value informant) 通知informant信息员，设置新值</code>和<code>(forget-value! connector retractor) 通知撤销源忘记其值</code>。最后一个链接函数<code>(connect connector new-constraint) 通知连接器参与一个新约束</code>。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">adder</span> a1 a2 sum)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> a1) (<span class=\"hljs-name\">has-value?</span> a2))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> sum (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> (<span class=\"hljs-name\">get-value</span> a1) (<span class=\"hljs-name\">get-value</span> a2)) me))</span><br><span class=\"line\"></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> a1) (<span class=\"hljs-name\">has-value?</span> sum))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> a2 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\">get-value</span> sum) (<span class=\"hljs-name\">get-value</span> a1)) me))</span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> a2) (<span class=\"hljs-name\">has-value?</span> sum))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> a1 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> (<span class=\"hljs-name\">get-value</span> sum) (<span class=\"hljs-name\">get-value</span> a2)) me))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">forget-value!</span> sum me)</span><br><span class=\"line\">    (<span class=\"hljs-name\">forget-value!</span> a1 me)</span><br><span class=\"line\">    (<span class=\"hljs-name\">forget-value!</span> a2 me)</span><br><span class=\"line\">    (<span class=\"hljs-name\">process-new-value</span>))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-have-a-value</span>) (<span class=\"hljs-name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-lost-my-value</span>) (<span class=\"hljs-name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unkonw request -- ADDER\"</span> request))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> a1 me)</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> a2 me)</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> sum me) me</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 乘法的实现</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">multiplier</span> m1 m2 product)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> m1) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> (<span class=\"hljs-name\">get-value</span> m1) <span class=\"hljs-number\">0</span>))</span><br><span class=\"line\">           (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> m2) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> (<span class=\"hljs-name\">get-lvaue</span> m2) <span class=\"hljs-number\">0</span>)))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> product <span class=\"hljs-number\">0</span> me))</span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> m1) (<span class=\"hljs-name\">has-value?</span> m2))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> product (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> (<span class=\"hljs-name\">get-value</span> m1) (<span class=\"hljs-name\">get-value</span> m2)) me))</span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> product) (<span class=\"hljs-name\">has-value?</span> m1))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> m2 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> (<span class=\"hljs-name\">get-value</span> product) (<span class=\"hljs-name\">get-value</span> m1)) me))</span><br><span class=\"line\"></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> (<span class=\"hljs-name\">has-value?</span> product) (<span class=\"hljs-name\">has-value?</span> m2))</span><br><span class=\"line\">        (<span class=\"hljs-name\">set-value!</span> m1 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> (<span class=\"hljs-name\">get-value</span> product) (<span class=\"hljs-name\">get-value</span> m2)) me))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">forget-value!</span> product me)</span><br><span class=\"line\">    (<span class=\"hljs-name\">forget-value!</span> m1 me)</span><br><span class=\"line\">    (<span class=\"hljs-name\">forget-value!</span> m2 me)</span><br><span class=\"line\">    (<span class=\"hljs-name\">process-new-value</span>))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-have-a-value</span>) (<span class=\"hljs-name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-lost-my-value</span>) (<span class=\"hljs-name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unkonw request -- ADDER\"</span> request))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> m1 me)</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> m2 me)</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> product me) me</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; constant 简单的设置值， </span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">constant</span> value connector)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unknown request\"</span> request))</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> connector me)</span><br><span class=\"line\">  (<span class=\"hljs-name\">set-value!</span> connector value me) me)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 监视器 设置或者取消的时候打出一个值</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">probe</span> name connector)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">print-probe</span> value)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">newline</span></span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\"Probe: \"</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> name)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\" = \"</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> value))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">print-probe</span> (<span class=\"hljs-name\">get-value</span> connector)))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">print-probe</span> <span class=\"hljs-string\">\"?\"</span>))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-have-a-value</span>) (<span class=\"hljs-name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-Lost-my-value</span>) (<span class=\"hljs-name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unknown request -- PROBE\"</span> request))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> connector me) me)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;完成操作方法之后，我们需要给外部定义一个<strong>监视器</strong>，让每次值改变(设置新值或者遗忘)，都能打出日志，来报告设置的结果通知给外部。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 监视器 设置或者取消的时候打出一个值</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">probe</span> name connector)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">print-probe</span> value)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">newline</span></span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\"Probe: \"</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> name)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> <span class=\"hljs-string\">\" = \"</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">display</span></span> value))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">print-probe</span> (<span class=\"hljs-name\">get-value</span> connector)))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\">print-probe</span> <span class=\"hljs-string\">\"?\"</span>))</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-have-a-value</span>) (<span class=\"hljs-name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'I-Lost-my-value</span>) (<span class=\"hljs-name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unknown request -- PROBE\"</span> request))))</span><br><span class=\"line\">  (<span class=\"hljs-name\">connect</span> connector me) me)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 连接器的表示</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; value 值 informant 设置连接器的对象 constraints 所涉及的所有约束的表</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-connector</span>)</span><br><span class=\"line\">  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"hljs-name\">value</span> false) (<span class=\"hljs-name\">informant</span> false) (<span class=\"hljs-name\">constraints</span> '()))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">set-my-value</span> newval setter)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> (</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\">has-value?</span> me))</span><br><span class=\"line\">          (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> value newval)</span><br><span class=\"line\">          (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> informant setter)</span><br><span class=\"line\">          (<span class=\"hljs-name\">for-each-except</span> setter inform-about-value constraints))</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> value newval))</span><br><span class=\"line\">          (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Contradiction\"</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> value newval)))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> <span class=\"hljs-symbol\">'ignored</span>)))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">forget-my-value</span> retractor)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> retractor informant)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span></span><br><span class=\"line\">          (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> informant false)</span><br><span class=\"line\">          (<span class=\"hljs-name\">for-each-except</span> retractor inform-about-no-value constraints))</span><br><span class=\"line\">        <span class=\"hljs-symbol\">'ignored</span>))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">connect</span> new-constraint)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">memq</span></span> new-constraint constraints))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> constraints (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cons</span></span> new-constraint constraints)))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">has-value?</span> me) (<span class=\"hljs-name\">inform-about-value</span> new-constraint))</span><br><span class=\"line\">      <span class=\"hljs-symbol\">'done</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">me</span> request)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'has-value?</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> informant true false))</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'value</span>) value)</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'set-value!</span>) set-my-value)</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'forget</span>) forget-my-value)</span><br><span class=\"line\">        ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> request <span class=\"hljs-symbol\">'connect</span>) connect)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unknown operation -- CONNECTOR\"</span> request))))</span><br><span class=\"line\">    me))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在引入序对的赋值能力后，我们可以构建起以操作数据为核心的复杂数据结构，比如<strong>表</strong>，比如<strong>队列</strong>。这些数据结构具备增删改查的能力，在这个能力基础上，可以完成各种复杂的实例，比如书本上的模拟电路和这里记录的约束系统，完成更加复杂的业务场景模型设计。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;本章使用实例来模拟不断变化状态组成的系统，除了需要做复合对象的构造和成分选择之后，还需要修改它们(赋值)。其中不单包含了选择函数和构造函数，还会引入<strong>改变函数</strong>的构造。<br></p>","more":"<br>&emsp;&emsp;在前面的阅读过程中，我们使用了针对序对的基本操作<code>cons</code>、<code>car</code>以及<code>cdr</code>。这三种方法仅仅是构造和读取表的操作，不能对表进行操作。现在我们需要引入对表进行<strong>赋值</strong>的概念，<code>set-car!</code>和<code>set-cdr!</code>，它们接受两个参数，第一个参数为需要赋值的序对，第二个参数为需要设置序对的新值。</p>\n<p>&emsp;&emsp;利用新的序对赋值的概念，我们可以创建出新的，在没有引入赋值序对概念前无法创建出来的数据结构，队列就是其中之一。队列是一个串形数据结构，在尾部加入数据，在顶部读取数据，遵循先进先出的原则。我们需要定义一个创建函数<code>make-queue</code>,它创建一个新的空队列，并创建两个<strong>读取队列</strong>函数，一个判断队列是否为空，一个返回队列的第一项。之后我们需要追加两个能够<strong>操作队列</strong>的函数，一个是插入(队列末端)数据，一个是删除(前端)数据。</p>\n<p>&emsp;&emsp;现在我们思考一下对队列操作的函数应该如何处理。首先删除数据，即在队列的头部删除一个数据，只需要使用<code>cdr</code>取队列除第一项之外剩下的值即可。但是在新增数据的时候，我们需要插入的是队列的末尾项，在没有其他特殊操作的情况下，读取队列的最后一项需要一直使用<code>cdr</code>遍历整个队列，扫描到最后一项，然后连接它插入构造项。队列为n的情况下，这个消耗为O(n)。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> queue (<span class=\"name\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> ...n项 n+1 n+2))</span><br><span class=\"line\"><span class=\"comment\">;; 删除只需要cdr取队列</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> queue)</span><br><span class=\"line\"><span class=\"comment\">;; 新增需要遍历到最后一项，每一步</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> queue) <span class=\"comment\">;; n</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其实我们只需要换一种思维方式，把队列首位形成一个序对记录下来。每次删除新增改变首位记录的序对。这样在新增删除的时候就不需要对队列进行遍历。<br>我们使用<code>front-ptr</code>和<code>rear-ptr</code>来记录队列的首位操作。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 防止每次插入队列都需要扫描到队列的最末端，非常低效，采用前端指针和后端指针</span></span><br><span class=\"line\"><span class=\"comment\">;; 前后指针</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">front-ptr</span> queue) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> queue))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">rear-ptr</span> queue) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> queue))</span><br><span class=\"line\"><span class=\"comment\">;; 设置队列前后值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">set-front-ptr!</span> queue item) (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> queue item))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">set-rear-ptr!</span> queue item) (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> queue item))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;接着我们可以基于<code>front-ptr</code>和<code>rear-ptr</code>来完成上面的构造队列，读取队列以及操作队列的函数。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; make-queue 返回一个初始的空表</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-queue</span>) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> '() '()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; (empty-queue? &lt;queue&gt;) 队列是否为空 -&gt; 队列头是否为null</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">empty-queue?</span> queue) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> (<span class=\"name\">front-ptr</span> queue)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; (front-queue &lt;queue&gt;) 返回队列前端的对象，不修改队列</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">front-queue</span> queue)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">empty-queue?</span> queue)</span><br><span class=\"line\">    (<span class=\"name\">error</span> <span class=\"string\">\"empty\"</span> queue)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">car</span></span> (<span class=\"name\">front-ptr</span> queue))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; (insert-queue! &lt;queue&gt;) 插入队列</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">insert-queue!</span> queue item)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"name\">new-pair</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> item '())))</span><br><span class=\"line\">    <span class=\"comment\">;; 如果是空的队列，那么前后</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\">empty-queue?</span> queue)</span><br><span class=\"line\">        (<span class=\"name\">set-front-ptr!</span> queue new-pair)</span><br><span class=\"line\">        (<span class=\"name\">set-rear-ptr!</span> queue new-pair)</span><br><span class=\"line\">        queue</span><br><span class=\"line\">      )</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> (<span class=\"name\">rear-ptr</span> queue) new-pair)</span><br><span class=\"line\">        (<span class=\"name\">set-rear-ptr!</span> queue new-pair)</span><br><span class=\"line\">        queue))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; (delete-queue! &lt;queue&gt;) 删除队列</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">delete-queue!</span> queue)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\">empty-queue?</span> queue)</span><br><span class=\"line\">      (<span class=\"name\">error</span> <span class=\"string\">\"empty\"</span> queue))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">else</span></span></span><br><span class=\"line\">      (<span class=\"name\">set-fornt-ptr</span> queue (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\">front-ptr</span> queue))))</span><br><span class=\"line\">    queue</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们还可以利用序对赋值的概念，完成一个<strong>表</strong>的数据结构。<strong>表</strong>应该是一个<code>key-value</code>的映射结构，正好符号序对的构造方式。我们使用<strong>table</strong>作为表构建取来一个序对的入口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">table &lt;-&gt; cdr -&gt;  key &lt;-&gt; key </span><br><span class=\"line\">                   |</span><br><span class=\"line\">              key &lt;&gt; value</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;利用指针，把储存value的序对和指向下一个key的序对使用队列的方式连接起来。使用这个数据结构，我们可以定义出<strong>查询</strong>和<strong>插入</strong>表两个操作。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 查询表</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">lookup</span> key table)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"name\">record</span> (<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> key (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> table))))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> record</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> record)</span><br><span class=\"line\">      false)))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> key records)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">null?</span></span> records) false)</span><br><span class=\"line\">    <span class=\"comment\">;; 取出的 records 和 key 相同的话，返回这一项</span></span><br><span class=\"line\">    ((<span class=\"name\"><span class=\"builtin-name\">equal?</span></span> key (<span class=\"name\"><span class=\"builtin-name\">caar</span></span> records)) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> records))</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">insert!</span> key value table)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"name\">record</span> (<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> key (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> table))))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> record</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> record value)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> table (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> key value) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> table)))</span><br><span class=\"line\">    ))</span><br><span class=\"line\">  <span class=\"symbol\">'ok</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;assoc函数是一个过程，每次查询的时候，会判断一下表格key的队列是否成空，如果成功就停止继续搜索表格。</p>\n<p>&emsp;&emsp;脱离数据结构，我们来看看序对的赋值带来的复杂数据结构的能力，我们引入一个<strong>约束系统</strong>的实例，并用这种模式来在代码层面实现它。</p>\n<p>&emsp;&emsp;所谓<strong>约束系统</strong>指的是双向控制的一个系统模型。比如我们知道的，摄氏度和华氏温度之间存在一个公式转换<code>9C=5(F-32)</code>。在这个摄氏度和华氏温度的公式中，我们只需要知道摄氏度(C)或者华氏温度(F),其中的一个值，就能定义下另一个值。这种双向关联的系统模型，就是<strong>约束系统</strong>。</p>\n<p>&emsp;&emsp;<strong>约束系统</strong>中重要的就是设置值时的<strong>唤醒</strong>的概念。在上面的公式中，当我设置C的值为5的时候，右侧的华氏温度模块就会左侧摄氏度模块45的模块值，并自己在内部计算出F的值并设置。我们利用这个模块的概念，先来设计出<strong>约束系统</strong>的使用。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 3.5约束的概念 9C = 5(F-32)</span></span><br><span class=\"line\"><span class=\"comment\">;; 约束的使用</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> C (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> F (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">(<span class=\"name\">celsius-fahrenheit-converter</span> C F)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">celsius-fahrenheit-converter</span> C F)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    (</span><br><span class=\"line\">      (<span class=\"name\">u</span> (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"name\">v</span> (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"name\">w</span> (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"name\">x</span> (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">      (<span class=\"name\">y</span> (<span class=\"name\">make-connector</span>))</span><br><span class=\"line\">    )</span><br><span class=\"line\">    (<span class=\"name\">multiplier</span> c w u)</span><br><span class=\"line\">    (<span class=\"name\">multiplier</span> v x u)</span><br><span class=\"line\">    (<span class=\"name\">adder</span> v y f)</span><br><span class=\"line\">    (<span class=\"name\">constant</span> <span class=\"number\">9</span> w)</span><br><span class=\"line\">    (<span class=\"name\">constant</span> <span class=\"number\">5</span> x)</span><br><span class=\"line\">    (<span class=\"name\">contant</span> <span class=\"number\">32</span> y)</span><br><span class=\"line\">    <span class=\"symbol\">'ok</span>))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>make-connector</code>是一个模块定义函数，它定义了C和F两个模块，暴露给外部，使得外部可以给C和F进行赋值。</p>\n<p>&emsp;&emsp;我们接着需要定义两个输出函数，来让约束系统的每次模块接收值都能够输出一个计算的数据，让我们知道约束系统的哪个模块被设置了什么值。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 安装probe，使得每次赋予连接器一个值的时候，都会打印出来两个对应的值</span></span><br><span class=\"line\">(<span class=\"name\">probe</span> <span class=\"string\">\"celsius temp\"</span> C)</span><br><span class=\"line\">(<span class=\"name\">probe</span> <span class=\"string\">\"Fahrenheit temp\"</span> F)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 给C设置，应该产生的输出</span></span><br><span class=\"line\">(<span class=\"name\">set-value!</span> C <span class=\"number\">25</span> <span class=\"symbol\">'user</span>) <span class=\"comment\">;; celsius temp 25  Fahrenheit temp 77</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在明确调用方式的情况下，我们需要在内部实现我们的约束系统。它应该存在读取函数<code>(has-value? connector) 是否有值</code>和<code>(get-value connector) 返回连接器当前的值</code>。改变值的方法<code>(set-value! connector new-value informant) 通知informant信息员，设置新值</code>和<code>(forget-value! connector retractor) 通知撤销源忘记其值</code>。最后一个链接函数<code>(connect connector new-constraint) 通知连接器参与一个新约束</code>。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">adder</span> a1 a2 sum)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> a1) (<span class=\"name\">has-value?</span> a2))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> sum (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\">get-value</span> a1) (<span class=\"name\">get-value</span> a2)) me))</span><br><span class=\"line\"></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> a1) (<span class=\"name\">has-value?</span> sum))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> a2 (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\">get-value</span> sum) (<span class=\"name\">get-value</span> a1)) me))</span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> a2) (<span class=\"name\">has-value?</span> sum))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> a1 (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\">get-value</span> sum) (<span class=\"name\">get-value</span> a2)) me))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"name\">forget-value!</span> sum me)</span><br><span class=\"line\">    (<span class=\"name\">forget-value!</span> a1 me)</span><br><span class=\"line\">    (<span class=\"name\">forget-value!</span> a2 me)</span><br><span class=\"line\">    (<span class=\"name\">process-new-value</span>))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-have-a-value</span>) (<span class=\"name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-lost-my-value</span>) (<span class=\"name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Unkonw request -- ADDER\"</span> request))))</span><br><span class=\"line\">  (<span class=\"name\">connect</span> a1 me)</span><br><span class=\"line\">  (<span class=\"name\">connect</span> a2 me)</span><br><span class=\"line\">  (<span class=\"name\">connect</span> sum me) me</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 乘法的实现</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">multiplier</span> m1 m2 product)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> m1) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\">get-value</span> m1) <span class=\"number\">0</span>))</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> m2) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\">get-lvaue</span> m2) <span class=\"number\">0</span>)))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> product <span class=\"number\">0</span> me))</span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> m1) (<span class=\"name\">has-value?</span> m2))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> product (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\">get-value</span> m1) (<span class=\"name\">get-value</span> m2)) me))</span><br><span class=\"line\">      </span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> product) (<span class=\"name\">has-value?</span> m1))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> m2 (<span class=\"name\"><span class=\"builtin-name\">/</span></span> (<span class=\"name\">get-value</span> product) (<span class=\"name\">get-value</span> m1)) me))</span><br><span class=\"line\"></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\">has-value?</span> product) (<span class=\"name\">has-value?</span> m2))</span><br><span class=\"line\">        (<span class=\"name\">set-value!</span> m1 (<span class=\"name\"><span class=\"builtin-name\">/</span></span> (<span class=\"name\">get-value</span> product) (<span class=\"name\">get-value</span> m2)) me))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"name\">forget-value!</span> product me)</span><br><span class=\"line\">    (<span class=\"name\">forget-value!</span> m1 me)</span><br><span class=\"line\">    (<span class=\"name\">forget-value!</span> m2 me)</span><br><span class=\"line\">    (<span class=\"name\">process-new-value</span>))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-have-a-value</span>) (<span class=\"name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-lost-my-value</span>) (<span class=\"name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Unkonw request -- ADDER\"</span> request))))</span><br><span class=\"line\">  (<span class=\"name\">connect</span> m1 me)</span><br><span class=\"line\">  (<span class=\"name\">connect</span> m2 me)</span><br><span class=\"line\">  (<span class=\"name\">connect</span> product me) me</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; constant 简单的设置值， </span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">constant</span> value connector)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"name\">error</span> <span class=\"string\">\"Unknown request\"</span> request))</span><br><span class=\"line\">  (<span class=\"name\">connect</span> connector me)</span><br><span class=\"line\">  (<span class=\"name\">set-value!</span> connector value me) me)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 监视器 设置或者取消的时候打出一个值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">probe</span> name connector)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">print-probe</span> value)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">newline</span></span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\"Probe: \"</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> name)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\" = \"</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> value))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"name\">print-probe</span> (<span class=\"name\">get-value</span> connector)))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"name\">print-probe</span> <span class=\"string\">\"?\"</span>))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-have-a-value</span>) (<span class=\"name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-Lost-my-value</span>) (<span class=\"name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Unknown request -- PROBE\"</span> request))))</span><br><span class=\"line\">  (<span class=\"name\">connect</span> connector me) me)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;完成操作方法之后，我们需要给外部定义一个<strong>监视器</strong>，让每次值改变(设置新值或者遗忘)，都能打出日志，来报告设置的结果通知给外部。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 监视器 设置或者取消的时候打出一个值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">probe</span> name connector)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">print-probe</span> value)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">newline</span></span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\"Probe: \"</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> name)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> <span class=\"string\">\" = \"</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">display</span></span> value))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-new-value</span>)</span><br><span class=\"line\">    (<span class=\"name\">print-probe</span> (<span class=\"name\">get-value</span> connector)))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">process-forget-value</span>)</span><br><span class=\"line\">    (<span class=\"name\">print-probe</span> <span class=\"string\">\"?\"</span>))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">me</span> request)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-have-a-value</span>) (<span class=\"name\">process-new-value</span>))</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'I-Lost-my-value</span>) (<span class=\"name\">process-forget-value</span>))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Unknown request -- PROBE\"</span> request))))</span><br><span class=\"line\">  (<span class=\"name\">connect</span> connector me) me)</span><br><span class=\"line\"><span class=\"comment\">;; 连接器的表示</span></span><br><span class=\"line\"><span class=\"comment\">;; value 值 informant 设置连接器的对象 constraints 所涉及的所有约束的表</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-connector</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span></span><br><span class=\"line\">    ((<span class=\"name\">value</span> false) (<span class=\"name\">informant</span> false) (<span class=\"name\">constraints</span> '()))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">set-my-value</span> newval setter)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\">has-value?</span> me))</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> value newval)</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> informant setter)</span><br><span class=\"line\">          (<span class=\"name\">for-each-except</span> setter inform-about-value constraints))</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> value newval))</span><br><span class=\"line\">          (<span class=\"name\">error</span> <span class=\"string\">\"Contradiction\"</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> value newval)))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"symbol\">'ignored</span>)))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">forget-my-value</span> retractor)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> retractor informant)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> informant false)</span><br><span class=\"line\">          (<span class=\"name\">for-each-except</span> retractor inform-about-no-value constraints))</span><br><span class=\"line\">        <span class=\"symbol\">'ignored</span>))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">connect</span> new-constraint)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">memq</span></span> new-constraint constraints))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> constraints (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> new-constraint constraints)))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">has-value?</span> me) (<span class=\"name\">inform-about-value</span> new-constraint))</span><br><span class=\"line\">      <span class=\"symbol\">'done</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">me</span> request)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'has-value?</span>) (<span class=\"name\"><span class=\"builtin-name\">if</span></span> informant true false))</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'value</span>) value)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'set-value!</span>) set-my-value)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'forget</span>) forget-my-value)</span><br><span class=\"line\">        ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> request <span class=\"symbol\">'connect</span>) connect)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Unknown operation -- CONNECTOR\"</span> request))))</span><br><span class=\"line\">    me))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;在引入序对的赋值能力后，我们可以构建起以操作数据为核心的复杂数据结构，比如<strong>表</strong>，比如<strong>队列</strong>。这些数据结构具备增删改查的能力，在这个能力基础上，可以完成各种复杂的实例，比如书本上的模拟电路和这里记录的约束系统，完成更加复杂的业务场景模型设计。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-3.4","date":"2019-10-31T13:20:00.000Z","_content":"&emsp;&emsp;引入赋值概念后，我们不得不面对时间问题，特别是在**并发**的程序执行条件下。\n<!--more-->\n&emsp;&emsp;具有**赋值能力**的程序需要保证执行顺序的绝对正确。我们通过一个例子来感受下为什么并发条件下，程序执行顺序不对，会导致运行验证的后果。\n\n&emsp;&emsp;我们现在假设存在函数`(parallel-execute <p1> <p2> <p3>)`,它的入参是任意个无参过程，`parallel-execute`能够把所有入参过程**并发**的执行。我们现在来制定一个场景。\n\n```scheme\n(define x 10)\n(parallel-execute\n    (lambda () (set! x (* x x))) ;; 过程p1\n    (lambda () (set! x (+ x 1))) ;; 过程p2\n)\n```\n&emsp;&emsp;我们现在定义了两个过程`p1`、`p2`, 它们共同对x进行赋值操作，在不确定两个程序执行顺序的情况下，两个程序并发的对x进行操作，可能产生5个以上的结果：\n1. p1运行，x为100， p2运行，*x变为101*\n2. p2运行，x为11，p1运行运行，*x变为121*\n3. p1执行`x * x`，取第一个x值10之后，p2执行，x变为11，p1继续执行，取x为11，执行`10 * 11`，*x为110*\n4. p1,p2同时取值到x为10，p1先执行，赋值x为100，随后p2执行赋值*x为11*.\n5. 4的情况倒过来，p2先执行，x变为11，随后p1执行，*x变为100*。\n\n&emsp;&emsp;我们可以看到，在共享操作对象(例子中的x)的时候，并发的去对对象进行赋值，在不能保证执行顺序的情况下会产生结果不可控的问题，其根源就在于需要考虑到不同进程事件之间相互交错的情况。控制并发的机制，其实最简单有效的方式就是使用**串行化组**的方式，简单的来说，就是让并行程序在共同操作赋值一个对象的时候，排队来执行代码。\n\n&emsp;&emsp;虽然串行化能够轻松的解决一个赋值对象共享的问题，但是当场景引入多个共享赋值数据源的时候，串行运行程序也变得复杂了起来。我们现在来看一个实例，假设存在两个账户`account1`和`account2`，我们现在需要交互这两个账户当中的余额。我们的逻辑是计算出`account1-account2`的差额，然后让`account1`减去这个差额，让`account2`加上这个差额。\n\n```scheme\n(define (exchange account1 account2)\n    (let ((difference\n        (-\n            (account1 'balance')\n            (account2 'balance')\n        ))))\n    ((account1 'withdraw') difference)\n    ((account2 'deposit') difference))\n```\n\n&emsp;&emsp;假设当两个人A和B，同时能够访问这两个账户的时候，单个数据源串行化已经不能保证程序运行的准确性了。可能存在A计算出余额之差，但是B此时已经进行了两个账户交换的情况。我们需要使用两个账户的串行组将整个exchange的过程串行化，简单的说我们需要一把锁，在完成整个交换期间锁住这些账户的访问。我们优化一下第二章的`make-account`函数过程，除了加入一个串行化组之外，还将这个串行化组通过消息传递暴露出来。\n\n```scheme\n(define (make-account-and-serializer balance)\n    (define (withdraw amount)\n        (if (>= balance amount)\n            (begin (set! balance (- balance amount)) balance)\n            \"Insufficient funds\"))\n    (define (deposit amount)\n        (set! balance (+ balance amount))\n        balance)\n    (let ((balance-serializer (make-serializer)))\n        (define (dispatch m)\n            (cond ((eq? m 'withdraw) withdraw)\n                  ((eq? m 'deposit) deposit)\n                  ((eq? m 'balance) balance)\n                  ((eq? m 'serializer) balance-serializer)\n                  (else (error \"Unknown request -- make-account\" m))))\n    dispatch))\n```\n\n&emsp;&emsp;我们现在使用串行化组来重写一下账户的交换过程。\n\n```scheme\n;; 串行的exchange过程\n(define (serialized-exchange account1 account2)\n    (let ((serializer1 (account1 'serializer))\n         ((serializer2 (account2 'serializer)))\n    ((serializer1 (serializer2 exchange))\n        account1\n        account2\n    )))\n\n;; 串行化的实现\n(define (make-serializer)\n    (let ((mutex (make-mutex)))\n        (lambda (p) \n            (define (serialized-p . args)\n                (mutex 'acquire)\n                (let ((val (apply p args)))\n                    (mutex 'release)\n                    val))\n    serialized-p)))\n```\n\n&emsp;&emsp;我们接着来实现一下串行化的过程。我们使用`互斥元`的概念来实现串行化。`互斥元`是一个对象，它提供了两个操作，操作和获取。一旦某个`互斥元`被获取，其它对于这个`互斥元`的操作必须要等到`互斥元`再次被释放之后才能进行。\n\n```scheme\n;; 互斥元构造函数\n(define (make-mutex)\n    (let ((cell (list false)))\n        (define (the-mutex m)\n            (cond ((eq? m 'acquire)\n                (if (test-and-set! cell)\n                    (the-mutex 'acquire)))\n                ((eq? m 'release) (clear! cell))))\n        the-mutex))\n\n;; 释放互斥元\n(define (clear! cell)\n    (set-car! cell false)\n)\n\n;; 检查结构并返回\n(define (test-and-set! cell)\n    (if (car cell)\n        true\n        (begin (set-car! cell true) false)))\n```\n\n&emsp;&emsp;看似美好的串行组实际运行过程中却可能还存在**死锁**的问题。在程序读取账户，到触发串行组，最后加锁串行组，实际上存在三个程序时间运行节点。而在A触发串行组的同时，B也读取账户触发了串行组，结果就是A与B的访问都被加上了锁，A和B的都被锁死了。避免死锁的方式之一，我们还需要给每个账户确定一个唯一编号，针对每一个账户进行加锁操作，但是在实际业务场景中，还是存在很多情况时根本无法避免死锁的。","source":"_posts/scip/scip(chap3-4).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-3.4\ndate: 2019/10/31 21:20:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n&emsp;&emsp;引入赋值概念后，我们不得不面对时间问题，特别是在**并发**的程序执行条件下。\n<!--more-->\n&emsp;&emsp;具有**赋值能力**的程序需要保证执行顺序的绝对正确。我们通过一个例子来感受下为什么并发条件下，程序执行顺序不对，会导致运行验证的后果。\n\n&emsp;&emsp;我们现在假设存在函数`(parallel-execute <p1> <p2> <p3>)`,它的入参是任意个无参过程，`parallel-execute`能够把所有入参过程**并发**的执行。我们现在来制定一个场景。\n\n```scheme\n(define x 10)\n(parallel-execute\n    (lambda () (set! x (* x x))) ;; 过程p1\n    (lambda () (set! x (+ x 1))) ;; 过程p2\n)\n```\n&emsp;&emsp;我们现在定义了两个过程`p1`、`p2`, 它们共同对x进行赋值操作，在不确定两个程序执行顺序的情况下，两个程序并发的对x进行操作，可能产生5个以上的结果：\n1. p1运行，x为100， p2运行，*x变为101*\n2. p2运行，x为11，p1运行运行，*x变为121*\n3. p1执行`x * x`，取第一个x值10之后，p2执行，x变为11，p1继续执行，取x为11，执行`10 * 11`，*x为110*\n4. p1,p2同时取值到x为10，p1先执行，赋值x为100，随后p2执行赋值*x为11*.\n5. 4的情况倒过来，p2先执行，x变为11，随后p1执行，*x变为100*。\n\n&emsp;&emsp;我们可以看到，在共享操作对象(例子中的x)的时候，并发的去对对象进行赋值，在不能保证执行顺序的情况下会产生结果不可控的问题，其根源就在于需要考虑到不同进程事件之间相互交错的情况。控制并发的机制，其实最简单有效的方式就是使用**串行化组**的方式，简单的来说，就是让并行程序在共同操作赋值一个对象的时候，排队来执行代码。\n\n&emsp;&emsp;虽然串行化能够轻松的解决一个赋值对象共享的问题，但是当场景引入多个共享赋值数据源的时候，串行运行程序也变得复杂了起来。我们现在来看一个实例，假设存在两个账户`account1`和`account2`，我们现在需要交互这两个账户当中的余额。我们的逻辑是计算出`account1-account2`的差额，然后让`account1`减去这个差额，让`account2`加上这个差额。\n\n```scheme\n(define (exchange account1 account2)\n    (let ((difference\n        (-\n            (account1 'balance')\n            (account2 'balance')\n        ))))\n    ((account1 'withdraw') difference)\n    ((account2 'deposit') difference))\n```\n\n&emsp;&emsp;假设当两个人A和B，同时能够访问这两个账户的时候，单个数据源串行化已经不能保证程序运行的准确性了。可能存在A计算出余额之差，但是B此时已经进行了两个账户交换的情况。我们需要使用两个账户的串行组将整个exchange的过程串行化，简单的说我们需要一把锁，在完成整个交换期间锁住这些账户的访问。我们优化一下第二章的`make-account`函数过程，除了加入一个串行化组之外，还将这个串行化组通过消息传递暴露出来。\n\n```scheme\n(define (make-account-and-serializer balance)\n    (define (withdraw amount)\n        (if (>= balance amount)\n            (begin (set! balance (- balance amount)) balance)\n            \"Insufficient funds\"))\n    (define (deposit amount)\n        (set! balance (+ balance amount))\n        balance)\n    (let ((balance-serializer (make-serializer)))\n        (define (dispatch m)\n            (cond ((eq? m 'withdraw) withdraw)\n                  ((eq? m 'deposit) deposit)\n                  ((eq? m 'balance) balance)\n                  ((eq? m 'serializer) balance-serializer)\n                  (else (error \"Unknown request -- make-account\" m))))\n    dispatch))\n```\n\n&emsp;&emsp;我们现在使用串行化组来重写一下账户的交换过程。\n\n```scheme\n;; 串行的exchange过程\n(define (serialized-exchange account1 account2)\n    (let ((serializer1 (account1 'serializer))\n         ((serializer2 (account2 'serializer)))\n    ((serializer1 (serializer2 exchange))\n        account1\n        account2\n    )))\n\n;; 串行化的实现\n(define (make-serializer)\n    (let ((mutex (make-mutex)))\n        (lambda (p) \n            (define (serialized-p . args)\n                (mutex 'acquire)\n                (let ((val (apply p args)))\n                    (mutex 'release)\n                    val))\n    serialized-p)))\n```\n\n&emsp;&emsp;我们接着来实现一下串行化的过程。我们使用`互斥元`的概念来实现串行化。`互斥元`是一个对象，它提供了两个操作，操作和获取。一旦某个`互斥元`被获取，其它对于这个`互斥元`的操作必须要等到`互斥元`再次被释放之后才能进行。\n\n```scheme\n;; 互斥元构造函数\n(define (make-mutex)\n    (let ((cell (list false)))\n        (define (the-mutex m)\n            (cond ((eq? m 'acquire)\n                (if (test-and-set! cell)\n                    (the-mutex 'acquire)))\n                ((eq? m 'release) (clear! cell))))\n        the-mutex))\n\n;; 释放互斥元\n(define (clear! cell)\n    (set-car! cell false)\n)\n\n;; 检查结构并返回\n(define (test-and-set! cell)\n    (if (car cell)\n        true\n        (begin (set-car! cell true) false)))\n```\n\n&emsp;&emsp;看似美好的串行组实际运行过程中却可能还存在**死锁**的问题。在程序读取账户，到触发串行组，最后加锁串行组，实际上存在三个程序时间运行节点。而在A触发串行组的同时，B也读取账户触发了串行组，结果就是A与B的访问都被加上了锁，A和B的都被锁死了。避免死锁的方式之一，我们还需要给每个账户确定一个唯一编号，针对每一个账户进行加锁操作，但是在实际业务场景中，还是存在很多情况时根本无法避免死锁的。","slug":"scip/scip(chap3-4)","published":1,"updated":"2020-06-11T01:43:32.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhya002l9r2vp2np4bow","content":"<p>&emsp;&emsp;引入赋值概念后，我们不得不面对时间问题，特别是在<strong>并发</strong>的程序执行条件下。<br><a id=\"more\"></a><br>&emsp;&emsp;具有<strong>赋值能力</strong>的程序需要保证执行顺序的绝对正确。我们通过一个例子来感受下为什么并发条件下，程序执行顺序不对，会导致运行验证的后果。</p>\n<p>&emsp;&emsp;我们现在假设存在函数<code>(parallel-execute &lt;p1&gt; &lt;p2&gt; &lt;p3&gt;)</code>,它的入参是任意个无参过程，<code>parallel-execute</code>能够把所有入参过程<strong>并发</strong>的执行。我们现在来制定一个场景。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> x <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">parallel-execute</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> () (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> x x))) <span class=\"hljs-comment\">;; 过程p1</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> () (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> x <span class=\"hljs-number\">1</span>))) <span class=\"hljs-comment\">;; 过程p2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在定义了两个过程<code>p1</code>、<code>p2</code>, 它们共同对x进行赋值操作，在不确定两个程序执行顺序的情况下，两个程序并发的对x进行操作，可能产生5个以上的结果：</p>\n<ol>\n<li>p1运行，x为100， p2运行，<em>x变为101</em></li>\n<li>p2运行，x为11，p1运行运行，<em>x变为121</em></li>\n<li>p1执行<code>x * x</code>，取第一个x值10之后，p2执行，x变为11，p1继续执行，取x为11，执行<code>10 * 11</code>，<em>x为110</em></li>\n<li>p1,p2同时取值到x为10，p1先执行，赋值x为100，随后p2执行赋值<em>x为11</em>.</li>\n<li>4的情况倒过来，p2先执行，x变为11，随后p1执行，<em>x变为100</em>。</li>\n</ol>\n<p>&emsp;&emsp;我们可以看到，在共享操作对象(例子中的x)的时候，并发的去对对象进行赋值，在不能保证执行顺序的情况下会产生结果不可控的问题，其根源就在于需要考虑到不同进程事件之间相互交错的情况。控制并发的机制，其实最简单有效的方式就是使用<strong>串行化组</strong>的方式，简单的来说，就是让并行程序在共同操作赋值一个对象的时候，排队来执行代码。</p>\n<p>&emsp;&emsp;虽然串行化能够轻松的解决一个赋值对象共享的问题，但是当场景引入多个共享赋值数据源的时候，串行运行程序也变得复杂了起来。我们现在来看一个实例，假设存在两个账户<code>account1</code>和<code>account2</code>，我们现在需要交互这两个账户当中的余额。我们的逻辑是计算出<code>account1-account2</code>的差额，然后让<code>account1</code>减去这个差额，让<code>account2</code>加上这个差额。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">exchange</span> account1 account2)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">difference</span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span></span><br><span class=\"line\">            (<span class=\"hljs-name\">account1</span> <span class=\"hljs-symbol\">'balance</span>')</span><br><span class=\"line\">            (<span class=\"hljs-name\">account2</span> <span class=\"hljs-symbol\">'balance</span>')</span><br><span class=\"line\">        ))))</span><br><span class=\"line\">    ((<span class=\"hljs-name\">account1</span> <span class=\"hljs-symbol\">'withdraw</span>') difference)</span><br><span class=\"line\">    ((<span class=\"hljs-name\">account2</span> <span class=\"hljs-symbol\">'deposit</span>') difference))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;假设当两个人A和B，同时能够访问这两个账户的时候，单个数据源串行化已经不能保证程序运行的准确性了。可能存在A计算出余额之差，但是B此时已经进行了两个账户交换的情况。我们需要使用两个账户的串行组将整个exchange的过程串行化，简单的说我们需要一把锁，在完成整个交换期间锁住这些账户的访问。我们优化一下第二章的<code>make-account</code>函数过程，除了加入一个串行化组之外，还将这个串行化组通过消息传递暴露出来。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-account-and-serializer</span> balance)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">withdraw</span> amount)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">            <span class=\"hljs-string\">\"Insufficient funds\"</span>))</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">deposit</span> amount)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> balance amount))</span><br><span class=\"line\">        balance)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">balance-serializer</span> (<span class=\"hljs-name\">make-serializer</span>)))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">dispatch</span> m)</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'withdraw</span>) withdraw)</span><br><span class=\"line\">                  ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'deposit</span>) deposit)</span><br><span class=\"line\">                  ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'balance</span>) balance)</span><br><span class=\"line\">                  ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'serializer</span>) balance-serializer)</span><br><span class=\"line\">                  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">error</span> <span class=\"hljs-string\">\"Unknown request -- make-account\"</span> m))))</span><br><span class=\"line\">    dispatch))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在使用串行化组来重写一下账户的交换过程。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 串行的exchange过程</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">serialized-exchange</span> account1 account2)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">serializer1</span> (<span class=\"hljs-name\">account1</span> <span class=\"hljs-symbol\">'serializer</span>))</span><br><span class=\"line\">         ((<span class=\"hljs-name\">serializer2</span> (<span class=\"hljs-name\">account2</span> <span class=\"hljs-symbol\">'serializer</span>)))</span><br><span class=\"line\">    ((<span class=\"hljs-name\">serializer1</span> (<span class=\"hljs-name\">serializer2</span> exchange))</span><br><span class=\"line\">        account1</span><br><span class=\"line\">        account2</span><br><span class=\"line\">    )))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 串行化的实现</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-serializer</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">mutex</span> (<span class=\"hljs-name\">make-mutex</span>)))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (p) </span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">serialized-p</span> . args)</span><br><span class=\"line\">                (<span class=\"hljs-name\">mutex</span> <span class=\"hljs-symbol\">'acquire</span>)</span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">val</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">apply</span></span> p args)))</span><br><span class=\"line\">                    (<span class=\"hljs-name\">mutex</span> <span class=\"hljs-symbol\">'release</span>)</span><br><span class=\"line\">                    val))</span><br><span class=\"line\">    serialized-p)))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们接着来实现一下串行化的过程。我们使用<code>互斥元</code>的概念来实现串行化。<code>互斥元</code>是一个对象，它提供了两个操作，操作和获取。一旦某个<code>互斥元</code>被获取，其它对于这个<code>互斥元</code>的操作必须要等到<code>互斥元</code>再次被释放之后才能进行。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 互斥元构造函数</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-mutex</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> ((<span class=\"hljs-name\">cell</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">list</span></span> false)))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">the-mutex</span> m)</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'acquire</span>)</span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">test-and-set!</span> cell)</span><br><span class=\"line\">                    (<span class=\"hljs-name\">the-mutex</span> <span class=\"hljs-symbol\">'acquire</span>)))</span><br><span class=\"line\">                ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">eq?</span></span> m <span class=\"hljs-symbol\">'release</span>) (<span class=\"hljs-name\">clear!</span> cell))))</span><br><span class=\"line\">        the-mutex))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 释放互斥元</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">clear!</span> cell)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-car!</span></span> cell false)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 检查结构并返回</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">test-and-set!</span> cell)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">car</span></span> cell)</span><br><span class=\"line\">        true</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set-car!</span></span> cell true) false)))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;看似美好的串行组实际运行过程中却可能还存在<strong>死锁</strong>的问题。在程序读取账户，到触发串行组，最后加锁串行组，实际上存在三个程序时间运行节点。而在A触发串行组的同时，B也读取账户触发了串行组，结果就是A与B的访问都被加上了锁，A和B的都被锁死了。避免死锁的方式之一，我们还需要给每个账户确定一个唯一编号，针对每一个账户进行加锁操作，但是在实际业务场景中，还是存在很多情况时根本无法避免死锁的。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;引入赋值概念后，我们不得不面对时间问题，特别是在<strong>并发</strong>的程序执行条件下。<br></p>","more":"<br>&emsp;&emsp;具有<strong>赋值能力</strong>的程序需要保证执行顺序的绝对正确。我们通过一个例子来感受下为什么并发条件下，程序执行顺序不对，会导致运行验证的后果。</p>\n<p>&emsp;&emsp;我们现在假设存在函数<code>(parallel-execute &lt;p1&gt; &lt;p2&gt; &lt;p3&gt;)</code>,它的入参是任意个无参过程，<code>parallel-execute</code>能够把所有入参过程<strong>并发</strong>的执行。我们现在来制定一个场景。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> x <span class=\"number\">10</span>)</span><br><span class=\"line\">(<span class=\"name\">parallel-execute</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> () (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> x (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x x))) <span class=\"comment\">;; 过程p1</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> () (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> x (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">1</span>))) <span class=\"comment\">;; 过程p2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在定义了两个过程<code>p1</code>、<code>p2</code>, 它们共同对x进行赋值操作，在不确定两个程序执行顺序的情况下，两个程序并发的对x进行操作，可能产生5个以上的结果：</p>\n<ol>\n<li>p1运行，x为100， p2运行，<em>x变为101</em></li>\n<li>p2运行，x为11，p1运行运行，<em>x变为121</em></li>\n<li>p1执行<code>x * x</code>，取第一个x值10之后，p2执行，x变为11，p1继续执行，取x为11，执行<code>10 * 11</code>，<em>x为110</em></li>\n<li>p1,p2同时取值到x为10，p1先执行，赋值x为100，随后p2执行赋值<em>x为11</em>.</li>\n<li>4的情况倒过来，p2先执行，x变为11，随后p1执行，<em>x变为100</em>。</li>\n</ol>\n<p>&emsp;&emsp;我们可以看到，在共享操作对象(例子中的x)的时候，并发的去对对象进行赋值，在不能保证执行顺序的情况下会产生结果不可控的问题，其根源就在于需要考虑到不同进程事件之间相互交错的情况。控制并发的机制，其实最简单有效的方式就是使用<strong>串行化组</strong>的方式，简单的来说，就是让并行程序在共同操作赋值一个对象的时候，排队来执行代码。</p>\n<p>&emsp;&emsp;虽然串行化能够轻松的解决一个赋值对象共享的问题，但是当场景引入多个共享赋值数据源的时候，串行运行程序也变得复杂了起来。我们现在来看一个实例，假设存在两个账户<code>account1</code>和<code>account2</code>，我们现在需要交互这两个账户当中的余额。我们的逻辑是计算出<code>account1-account2</code>的差额，然后让<code>account1</code>减去这个差额，让<code>account2</code>加上这个差额。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">exchange</span> account1 account2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">difference</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">-</span></span></span><br><span class=\"line\">            (<span class=\"name\">account1</span> <span class=\"symbol\">'balance</span>')</span><br><span class=\"line\">            (<span class=\"name\">account2</span> <span class=\"symbol\">'balance</span>')</span><br><span class=\"line\">        ))))</span><br><span class=\"line\">    ((<span class=\"name\">account1</span> <span class=\"symbol\">'withdraw</span>') difference)</span><br><span class=\"line\">    ((<span class=\"name\">account2</span> <span class=\"symbol\">'deposit</span>') difference))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;假设当两个人A和B，同时能够访问这两个账户的时候，单个数据源串行化已经不能保证程序运行的准确性了。可能存在A计算出余额之差，但是B此时已经进行了两个账户交换的情况。我们需要使用两个账户的串行组将整个exchange的过程串行化，简单的说我们需要一把锁，在完成整个交换期间锁住这些账户的访问。我们优化一下第二章的<code>make-account</code>函数过程，除了加入一个串行化组之外，还将这个串行化组通过消息传递暴露出来。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-account-and-serializer</span> balance)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">withdraw</span> amount)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> balance amount)</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">-</span></span> balance amount)) balance)</span><br><span class=\"line\">            <span class=\"string\">\"Insufficient funds\"</span>))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">deposit</span> amount)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">+</span></span> balance amount))</span><br><span class=\"line\">        balance)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">balance-serializer</span> (<span class=\"name\">make-serializer</span>)))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">dispatch</span> m)</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'withdraw</span>) withdraw)</span><br><span class=\"line\">                  ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'deposit</span>) deposit)</span><br><span class=\"line\">                  ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'balance</span>) balance)</span><br><span class=\"line\">                  ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'serializer</span>) balance-serializer)</span><br><span class=\"line\">                  (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">error</span> <span class=\"string\">\"Unknown request -- make-account\"</span> m))))</span><br><span class=\"line\">    dispatch))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在使用串行化组来重写一下账户的交换过程。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 串行的exchange过程</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">serialized-exchange</span> account1 account2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">serializer1</span> (<span class=\"name\">account1</span> <span class=\"symbol\">'serializer</span>))</span><br><span class=\"line\">         ((<span class=\"name\">serializer2</span> (<span class=\"name\">account2</span> <span class=\"symbol\">'serializer</span>)))</span><br><span class=\"line\">    ((<span class=\"name\">serializer1</span> (<span class=\"name\">serializer2</span> exchange))</span><br><span class=\"line\">        account1</span><br><span class=\"line\">        account2</span><br><span class=\"line\">    )))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 串行化的实现</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-serializer</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">mutex</span> (<span class=\"name\">make-mutex</span>)))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (p) </span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">serialized-p</span> . args)</span><br><span class=\"line\">                (<span class=\"name\">mutex</span> <span class=\"symbol\">'acquire</span>)</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">val</span> (<span class=\"name\"><span class=\"builtin-name\">apply</span></span> p args)))</span><br><span class=\"line\">                    (<span class=\"name\">mutex</span> <span class=\"symbol\">'release</span>)</span><br><span class=\"line\">                    val))</span><br><span class=\"line\">    serialized-p)))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们接着来实现一下串行化的过程。我们使用<code>互斥元</code>的概念来实现串行化。<code>互斥元</code>是一个对象，它提供了两个操作，操作和获取。一旦某个<code>互斥元</code>被获取，其它对于这个<code>互斥元</code>的操作必须要等到<code>互斥元</code>再次被释放之后才能进行。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 互斥元构造函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-mutex</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">cell</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> false)))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">the-mutex</span> m)</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'acquire</span>)</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">test-and-set!</span> cell)</span><br><span class=\"line\">                    (<span class=\"name\">the-mutex</span> <span class=\"symbol\">'acquire</span>)))</span><br><span class=\"line\">                ((<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> m <span class=\"symbol\">'release</span>) (<span class=\"name\">clear!</span> cell))))</span><br><span class=\"line\">        the-mutex))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 释放互斥元</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">clear!</span> cell)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> cell false)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 检查结构并返回</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">test-and-set!</span> cell)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> cell)</span><br><span class=\"line\">        true</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> cell true) false)))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;看似美好的串行组实际运行过程中却可能还存在<strong>死锁</strong>的问题。在程序读取账户，到触发串行组，最后加锁串行组，实际上存在三个程序时间运行节点。而在A触发串行组的同时，B也读取账户触发了串行组，结果就是A与B的访问都被加上了锁，A和B的都被锁死了。避免死锁的方式之一，我们还需要给每个账户确定一个唯一编号，针对每一个账户进行加锁操作，但是在实际业务场景中，还是存在很多情况时根本无法避免死锁的。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-3.5","date":"2019-11-15T13:00:00.000Z","_content":"&emsp;&emsp;随着**赋值**和**时间**概念的引入，计算机模拟现实的模型越来越复杂。如何降低**时间**模型的复杂度，也许**流**的数据结构是一个答案。\n<!--more-->\n&emsp;&emsp;我们先来回忆下之前书写过的标准迭代风格的**根据区间求素数和**的函数。\n\n```scheme\n(define (sum-primes a b)\n    (define (iter count accum)\n        (cond ((> count b) accum)\n              ((prime? count) (iter (+ count 1) (+ count accum)))\n              (else (iter (+ count 1) accum))))\n    (iter a 0)\n)\n```\n&emsp;&emsp;我们使用第二章第二小节提到的序列操作来改造一下求区间内素数和的函数。使用`accumulate`来进行一个总和的累计，通过`filter`遍历区间`a到b`,筛选出所有为素数的数字。\n\n```scheme\n(define (sum-prime a b)\n    (accumulate + 0 (filter prime ? (enumerate-interval a b)))\n)\n```\n&emsp;&emsp;在对比两种方式，我们可以发现，迭代风格使用`递归的方式`。每一次更新`iter`函数的起点`count`和累计和`accum`，当count大于`b`区间终点的时候停止迭代。只需要保存两个数值，即可完成对区间内素数和计算。而第二种方式，确需要`enumerate-interval`，生成`a到b`之间的所有数值，然后对其进行循环遍历。这种储存开销，可以说是无法容忍的。\n\n&emsp;&emsp;流结构就是在此基础上面产生的，它的设计理念就是拥有`序列操作`的优雅，确能节省序列操作的储存列表的开销。\n\n&emsp;&emsp;从表面上看，流有点近似**表**，它满足以下操作规则。\n\n```scheme\n;; 构造流 const-stream\n;; 流基础结构满足\n;; (stream-car (cons-stream x y)) = x\n;; (stream-cdr (const-stream x y)) = y\n;; 判断是否是空流\n;; (stream-null? stream-list)\n;; 空流\n;; the-empty-stream\n;; 流的各种操作\n(define (stream-ref s n)\n    (if (= n 0)\n        (stream-car s)\n        (stream-ref (stream-cdr s) (- n 1))\n    )\n)\n;; map\n(define (stream-map proc s)\n    ;; 是否为空流\n    (if (stream-null? s)\n        the-empty-stream\n        (cons-stream (proc (stream-car s))\n            (stream-map proc (stream-cdr s)))))\n;; forEach\n(define (stream-for-each proc s)\n    (if (stream-null? s)\n        'done\n        (begin (proc (stream-car s))\n               (stream-for-each proc (stream-cdr s))))\n)\n```\n\n&emsp;&emsp;流的操作方式和序列的操作方式类似，不同的是，为了弥补序列操作需要生成整个需求的缺陷，流不是在构造`const-stream`的时候进行求值，而是保存一个生成过程，然后在`cdr-stream`的时候再去求值。因此`(cons-stream <a> <b>)`类似于`(const <a> (delay <b>))`的方式。保存了一个起始值和一个取值时的生成值的`delay`过程。因此，`stream-car`和`stream-car`应该是`(define (stream-car stream) (car stream))`和`(define (stream-cdr stream) (force (cdr stream)))`。\n\n&emsp;&emsp;我们现在使用`流`结构来改造重写一下求素数和的例子。\n```scheme\n(stream-car\n    (stream-cdr\n        (stream-filter prime?\n            (stream-enumerate-interval a b))))\n\n(define (stream-enumerate-interval low high)\n    (if (> low high)\n        the-empty-stream\n        (cons-stream\n            low\n            (stream-enumerate-interval (+ low 1) high))))\n```\n&emsp;&emsp;此处的`stream-enumerate-interval`返回的就是`流`的结构，它的第一项(`car`)值为流的起点，`cdr`的值为一个函数过程，也可以称之为`允诺`。当`stream-cdr`的时候，不是单单的取值，而且执行这个允诺，获得生成的新的`流`的值。我们可以根据这个思路来写出我们的`stream-filter`函数。\n\n```scheme\n(define (stream-filter pred stream)\n    (cond ((strean-null? stream) the-empty-stream)\n          ((pred (stream-car stream))\n            (cond-stream (stream-car stream)\n                (stream-filter pred (stream-cdr stream))))\n        (else (stream-filter pred (stream-cdr stream)))))\n```\n&emsp;&emsp;拥有了流的数据结构之后，因为流不是实际保存一个范围的数据，所以我们可以方便的定义各种特殊的无穷的流结构，比如`斐波那契`,比如`无穷素数流`。\n```scheme\n;; 不能被7整除的流\n(define (divisible? x y) (= (remainder x y) 0))\n\n(define no-sevens\n    (stream-filter (lambda (x) (not (divisible? x 7))) integers)\n)\n\n;; 斐波那契数列\n(define (fibgen a b)\n    (cons-stream a (fibgen b (+ a b)))\n)\n(define fibs (fibgen 0 1))\n\n;; 无穷素数集\n(define (sieve stream)\n    (cons-stream\n        (stream-car stream)\n        (sieve\n            (stream-filter\n                (lambda (x) (not (divisible? x (stream-car stream))))\n            (stream-cdr stream)))))\n\n(define primes (sieve (integers-starting-from 2)))\n```\n&emsp;&emsp;`流`结构的设计思想，补全了函数编程上范围需要储存的空缺。用`流`结构基础的函数式编程的方式，能够很大程度上解决开头提出的引入`赋值和变动对象`带来`时间`即程序执行顺序的问题。因为函数式编程，本质上是一个类似于管道流的序对的方式，来进行执行的。我们可以简单回顾下第三章刚开始提出的，关于银行余额存取的例子。\n\n```scheme\n;; 银行账户取值简化版\n(define (make-simplified-withdraw balance)\n    (lambda (amout)\n        (set! balance (- balance amout))\n        banlance\n    )\n)\n;; 流改造版\n(define (stream-withdraw balance amount-stream)\n    (cons-stream\n        balance\n        (stream-withdraw\n            (- balance (stream-car amount-stream))\n            (stream-cdr amount-stream)\n        )\n    )\n)\n```\n&emsp;&emsp;`流`改造后的取值，输出完全由输入决定，以一种**没有赋值**的状态，把变化的余额用`流`的方式保存了下来。在这种需要严格遵循执行顺序的现实场景下。`流`结构无异于是解决的最佳方案。\n\n&emsp;&emsp;但是`流`结构也有明显的问题，即执行处理的`流`的单一性。比如第三章提出的A和B共享账户的场景下，这种单一`流`就不能完美的处理产生的问题，需要将两个用户产生的两个流进行数据处理的**归并**。\n","source":"_posts/scip/scip(chap3-5).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-3.5\ndate: 2019/11/15 21:00:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n&emsp;&emsp;随着**赋值**和**时间**概念的引入，计算机模拟现实的模型越来越复杂。如何降低**时间**模型的复杂度，也许**流**的数据结构是一个答案。\n<!--more-->\n&emsp;&emsp;我们先来回忆下之前书写过的标准迭代风格的**根据区间求素数和**的函数。\n\n```scheme\n(define (sum-primes a b)\n    (define (iter count accum)\n        (cond ((> count b) accum)\n              ((prime? count) (iter (+ count 1) (+ count accum)))\n              (else (iter (+ count 1) accum))))\n    (iter a 0)\n)\n```\n&emsp;&emsp;我们使用第二章第二小节提到的序列操作来改造一下求区间内素数和的函数。使用`accumulate`来进行一个总和的累计，通过`filter`遍历区间`a到b`,筛选出所有为素数的数字。\n\n```scheme\n(define (sum-prime a b)\n    (accumulate + 0 (filter prime ? (enumerate-interval a b)))\n)\n```\n&emsp;&emsp;在对比两种方式，我们可以发现，迭代风格使用`递归的方式`。每一次更新`iter`函数的起点`count`和累计和`accum`，当count大于`b`区间终点的时候停止迭代。只需要保存两个数值，即可完成对区间内素数和计算。而第二种方式，确需要`enumerate-interval`，生成`a到b`之间的所有数值，然后对其进行循环遍历。这种储存开销，可以说是无法容忍的。\n\n&emsp;&emsp;流结构就是在此基础上面产生的，它的设计理念就是拥有`序列操作`的优雅，确能节省序列操作的储存列表的开销。\n\n&emsp;&emsp;从表面上看，流有点近似**表**，它满足以下操作规则。\n\n```scheme\n;; 构造流 const-stream\n;; 流基础结构满足\n;; (stream-car (cons-stream x y)) = x\n;; (stream-cdr (const-stream x y)) = y\n;; 判断是否是空流\n;; (stream-null? stream-list)\n;; 空流\n;; the-empty-stream\n;; 流的各种操作\n(define (stream-ref s n)\n    (if (= n 0)\n        (stream-car s)\n        (stream-ref (stream-cdr s) (- n 1))\n    )\n)\n;; map\n(define (stream-map proc s)\n    ;; 是否为空流\n    (if (stream-null? s)\n        the-empty-stream\n        (cons-stream (proc (stream-car s))\n            (stream-map proc (stream-cdr s)))))\n;; forEach\n(define (stream-for-each proc s)\n    (if (stream-null? s)\n        'done\n        (begin (proc (stream-car s))\n               (stream-for-each proc (stream-cdr s))))\n)\n```\n\n&emsp;&emsp;流的操作方式和序列的操作方式类似，不同的是，为了弥补序列操作需要生成整个需求的缺陷，流不是在构造`const-stream`的时候进行求值，而是保存一个生成过程，然后在`cdr-stream`的时候再去求值。因此`(cons-stream <a> <b>)`类似于`(const <a> (delay <b>))`的方式。保存了一个起始值和一个取值时的生成值的`delay`过程。因此，`stream-car`和`stream-car`应该是`(define (stream-car stream) (car stream))`和`(define (stream-cdr stream) (force (cdr stream)))`。\n\n&emsp;&emsp;我们现在使用`流`结构来改造重写一下求素数和的例子。\n```scheme\n(stream-car\n    (stream-cdr\n        (stream-filter prime?\n            (stream-enumerate-interval a b))))\n\n(define (stream-enumerate-interval low high)\n    (if (> low high)\n        the-empty-stream\n        (cons-stream\n            low\n            (stream-enumerate-interval (+ low 1) high))))\n```\n&emsp;&emsp;此处的`stream-enumerate-interval`返回的就是`流`的结构，它的第一项(`car`)值为流的起点，`cdr`的值为一个函数过程，也可以称之为`允诺`。当`stream-cdr`的时候，不是单单的取值，而且执行这个允诺，获得生成的新的`流`的值。我们可以根据这个思路来写出我们的`stream-filter`函数。\n\n```scheme\n(define (stream-filter pred stream)\n    (cond ((strean-null? stream) the-empty-stream)\n          ((pred (stream-car stream))\n            (cond-stream (stream-car stream)\n                (stream-filter pred (stream-cdr stream))))\n        (else (stream-filter pred (stream-cdr stream)))))\n```\n&emsp;&emsp;拥有了流的数据结构之后，因为流不是实际保存一个范围的数据，所以我们可以方便的定义各种特殊的无穷的流结构，比如`斐波那契`,比如`无穷素数流`。\n```scheme\n;; 不能被7整除的流\n(define (divisible? x y) (= (remainder x y) 0))\n\n(define no-sevens\n    (stream-filter (lambda (x) (not (divisible? x 7))) integers)\n)\n\n;; 斐波那契数列\n(define (fibgen a b)\n    (cons-stream a (fibgen b (+ a b)))\n)\n(define fibs (fibgen 0 1))\n\n;; 无穷素数集\n(define (sieve stream)\n    (cons-stream\n        (stream-car stream)\n        (sieve\n            (stream-filter\n                (lambda (x) (not (divisible? x (stream-car stream))))\n            (stream-cdr stream)))))\n\n(define primes (sieve (integers-starting-from 2)))\n```\n&emsp;&emsp;`流`结构的设计思想，补全了函数编程上范围需要储存的空缺。用`流`结构基础的函数式编程的方式，能够很大程度上解决开头提出的引入`赋值和变动对象`带来`时间`即程序执行顺序的问题。因为函数式编程，本质上是一个类似于管道流的序对的方式，来进行执行的。我们可以简单回顾下第三章刚开始提出的，关于银行余额存取的例子。\n\n```scheme\n;; 银行账户取值简化版\n(define (make-simplified-withdraw balance)\n    (lambda (amout)\n        (set! balance (- balance amout))\n        banlance\n    )\n)\n;; 流改造版\n(define (stream-withdraw balance amount-stream)\n    (cons-stream\n        balance\n        (stream-withdraw\n            (- balance (stream-car amount-stream))\n            (stream-cdr amount-stream)\n        )\n    )\n)\n```\n&emsp;&emsp;`流`改造后的取值，输出完全由输入决定，以一种**没有赋值**的状态，把变化的余额用`流`的方式保存了下来。在这种需要严格遵循执行顺序的现实场景下。`流`结构无异于是解决的最佳方案。\n\n&emsp;&emsp;但是`流`结构也有明显的问题，即执行处理的`流`的单一性。比如第三章提出的A和B共享账户的场景下，这种单一`流`就不能完美的处理产生的问题，需要将两个用户产生的两个流进行数据处理的**归并**。\n","slug":"scip/scip(chap3-5)","published":1,"updated":"2020-06-11T01:43:32.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhya002m9r2v4x5l6btc","content":"<p>&emsp;&emsp;随着<strong>赋值</strong>和<strong>时间</strong>概念的引入，计算机模拟现实的模型越来越复杂。如何降低<strong>时间</strong>模型的复杂度，也许<strong>流</strong>的数据结构是一个答案。<br><a id=\"more\"></a><br>&emsp;&emsp;我们先来回忆下之前书写过的标准迭代风格的<strong>根据区间求素数和</strong>的函数。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sum-primes</span> a b)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">iter</span> count accum)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> count b) accum)</span><br><span class=\"line\">              ((<span class=\"hljs-name\">prime?</span> count) (<span class=\"hljs-name\">iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> count <span class=\"hljs-number\">1</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> count accum)))</span><br><span class=\"line\">              (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> count <span class=\"hljs-number\">1</span>) accum))))</span><br><span class=\"line\">    (<span class=\"hljs-name\">iter</span> a <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们使用第二章第二小节提到的序列操作来改造一下求区间内素数和的函数。使用<code>accumulate</code>来进行一个总和的累计，通过<code>filter</code>遍历区间<code>a到b</code>,筛选出所有为素数的数字。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sum-prime</span> a b)</span><br><span class=\"line\">    (<span class=\"hljs-name\">accumulate</span> + <span class=\"hljs-number\">0</span> (<span class=\"hljs-name\">filter</span> prime ? (<span class=\"hljs-name\">enumerate-interval</span> a b)))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在对比两种方式，我们可以发现，迭代风格使用<code>递归的方式</code>。每一次更新<code>iter</code>函数的起点<code>count</code>和累计和<code>accum</code>，当count大于<code>b</code>区间终点的时候停止迭代。只需要保存两个数值，即可完成对区间内素数和计算。而第二种方式，确需要<code>enumerate-interval</code>，生成<code>a到b</code>之间的所有数值，然后对其进行循环遍历。这种储存开销，可以说是无法容忍的。</p>\n<p>&emsp;&emsp;流结构就是在此基础上面产生的，它的设计理念就是拥有<code>序列操作</code>的优雅，确能节省序列操作的储存列表的开销。</p>\n<p>&emsp;&emsp;从表面上看，流有点近似<strong>表</strong>，它满足以下操作规则。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 构造流 const-stream</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 流基础结构满足</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (stream-car (cons-stream x y)) = x</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (stream-cdr (const-stream x y)) = y</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 判断是否是空流</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; (stream-null? stream-list)</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 空流</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; the-empty-stream</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 流的各种操作</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">stream-ref</span> s n)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> n <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">        (<span class=\"hljs-name\">stream-car</span> s)</span><br><span class=\"line\">        (<span class=\"hljs-name\">stream-ref</span> (<span class=\"hljs-name\">stream-cdr</span> s) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> n <span class=\"hljs-number\">1</span>))</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; map</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">stream-map</span> proc s)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 是否为空流</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">stream-null?</span> s)</span><br><span class=\"line\">        the-empty-stream</span><br><span class=\"line\">        (<span class=\"hljs-name\">cons-stream</span> (<span class=\"hljs-name\">proc</span> (<span class=\"hljs-name\">stream-car</span> s))</span><br><span class=\"line\">            (<span class=\"hljs-name\">stream-map</span> proc (<span class=\"hljs-name\">stream-cdr</span> s)))))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; forEach</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">stream-for-each</span> proc s)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\">stream-null?</span> s)</span><br><span class=\"line\">        <span class=\"hljs-symbol\">'done</span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">begin</span></span> (<span class=\"hljs-name\">proc</span> (<span class=\"hljs-name\">stream-car</span> s))</span><br><span class=\"line\">               (<span class=\"hljs-name\">stream-for-each</span> proc (<span class=\"hljs-name\">stream-cdr</span> s))))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;流的操作方式和序列的操作方式类似，不同的是，为了弥补序列操作需要生成整个需求的缺陷，流不是在构造<code>const-stream</code>的时候进行求值，而是保存一个生成过程，然后在<code>cdr-stream</code>的时候再去求值。因此<code>(cons-stream &lt;a&gt; &lt;b&gt;)</code>类似于<code>(const &lt;a&gt; (delay &lt;b&gt;))</code>的方式。保存了一个起始值和一个取值时的生成值的<code>delay</code>过程。因此，<code>stream-car</code>和<code>stream-car</code>应该是<code>(define (stream-car stream) (car stream))</code>和<code>(define (stream-cdr stream) (force (cdr stream)))</code>。</p>\n<p>&emsp;&emsp;我们现在使用<code>流</code>结构来改造重写一下求素数和的例子。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\">stream-car</span></span><br><span class=\"line\">    (<span class=\"hljs-name\">stream-cdr</span></span><br><span class=\"line\">        (<span class=\"hljs-name\">stream-filter</span> prime?</span><br><span class=\"line\">            (<span class=\"hljs-name\">stream-enumerate-interval</span> a b))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">stream-enumerate-interval</span> low high)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> low high)</span><br><span class=\"line\">        the-empty-stream</span><br><span class=\"line\">        (<span class=\"hljs-name\">cons-stream</span></span><br><span class=\"line\">            low</span><br><span class=\"line\">            (<span class=\"hljs-name\">stream-enumerate-interval</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> low <span class=\"hljs-number\">1</span>) high))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此处的<code>stream-enumerate-interval</code>返回的就是<code>流</code>的结构，它的第一项(<code>car</code>)值为流的起点，<code>cdr</code>的值为一个函数过程，也可以称之为<code>允诺</code>。当<code>stream-cdr</code>的时候，不是单单的取值，而且执行这个允诺，获得生成的新的<code>流</code>的值。我们可以根据这个思路来写出我们的<code>stream-filter</code>函数。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">stream-filter</span> pred stream)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\">strean-null?</span> stream) the-empty-stream)</span><br><span class=\"line\">          ((<span class=\"hljs-name\">pred</span> (<span class=\"hljs-name\">stream-car</span> stream))</span><br><span class=\"line\">            (<span class=\"hljs-name\">cond-stream</span> (<span class=\"hljs-name\">stream-car</span> stream)</span><br><span class=\"line\">                (<span class=\"hljs-name\">stream-filter</span> pred (<span class=\"hljs-name\">stream-cdr</span> stream))))</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\">stream-filter</span> pred (<span class=\"hljs-name\">stream-cdr</span> stream)))))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;拥有了流的数据结构之后，因为流不是实际保存一个范围的数据，所以我们可以方便的定义各种特殊的无穷的流结构，比如<code>斐波那契</code>,比如<code>无穷素数流</code>。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 不能被7整除的流</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">divisible?</span> x y) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">remainder</span></span> x y) <span class=\"hljs-number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> no-sevens</span><br><span class=\"line\">    (<span class=\"hljs-name\">stream-filter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\">divisible?</span> x <span class=\"hljs-number\">7</span>))) integers)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 斐波那契数列</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">fibgen</span> a b)</span><br><span class=\"line\">    (<span class=\"hljs-name\">cons-stream</span> a (<span class=\"hljs-name\">fibgen</span> b (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> a b)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> fibs (<span class=\"hljs-name\">fibgen</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 无穷素数集</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sieve</span> stream)</span><br><span class=\"line\">    (<span class=\"hljs-name\">cons-stream</span></span><br><span class=\"line\">        (<span class=\"hljs-name\">stream-car</span> stream)</span><br><span class=\"line\">        (<span class=\"hljs-name\">sieve</span></span><br><span class=\"line\">            (<span class=\"hljs-name\">stream-filter</span></span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (x) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\">divisible?</span> x (<span class=\"hljs-name\">stream-car</span> stream))))</span><br><span class=\"line\">            (<span class=\"hljs-name\">stream-cdr</span> stream)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> primes (<span class=\"hljs-name\">sieve</span> (<span class=\"hljs-name\">integers-starting-from</span> <span class=\"hljs-number\">2</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>流</code>结构的设计思想，补全了函数编程上范围需要储存的空缺。用<code>流</code>结构基础的函数式编程的方式，能够很大程度上解决开头提出的引入<code>赋值和变动对象</code>带来<code>时间</code>即程序执行顺序的问题。因为函数式编程，本质上是一个类似于管道流的序对的方式，来进行执行的。我们可以简单回顾下第三章刚开始提出的，关于银行余额存取的例子。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 银行账户取值简化版</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">make-simplified-withdraw</span> balance)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (amout)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">set!</span></span> balance (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> balance amout))</span><br><span class=\"line\">        banlance</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 流改造版</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">stream-withdraw</span> balance amount-stream)</span><br><span class=\"line\">    (<span class=\"hljs-name\">cons-stream</span></span><br><span class=\"line\">        balance</span><br><span class=\"line\">        (<span class=\"hljs-name\">stream-withdraw</span></span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> balance (<span class=\"hljs-name\">stream-car</span> amount-stream))</span><br><span class=\"line\">            (<span class=\"hljs-name\">stream-cdr</span> amount-stream)</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>流</code>改造后的取值，输出完全由输入决定，以一种<strong>没有赋值</strong>的状态，把变化的余额用<code>流</code>的方式保存了下来。在这种需要严格遵循执行顺序的现实场景下。<code>流</code>结构无异于是解决的最佳方案。</p>\n<p>&emsp;&emsp;但是<code>流</code>结构也有明显的问题，即执行处理的<code>流</code>的单一性。比如第三章提出的A和B共享账户的场景下，这种单一<code>流</code>就不能完美的处理产生的问题，需要将两个用户产生的两个流进行数据处理的<strong>归并</strong>。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;随着<strong>赋值</strong>和<strong>时间</strong>概念的引入，计算机模拟现实的模型越来越复杂。如何降低<strong>时间</strong>模型的复杂度，也许<strong>流</strong>的数据结构是一个答案。<br></p>","more":"<br>&emsp;&emsp;我们先来回忆下之前书写过的标准迭代风格的<strong>根据区间求素数和</strong>的函数。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sum-primes</span> a b)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">iter</span> count accum)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> count b) accum)</span><br><span class=\"line\">              ((<span class=\"name\">prime?</span> count) (<span class=\"name\">iter</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> count <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> count accum)))</span><br><span class=\"line\">              (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">iter</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> count <span class=\"number\">1</span>) accum))))</span><br><span class=\"line\">    (<span class=\"name\">iter</span> a <span class=\"number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们使用第二章第二小节提到的序列操作来改造一下求区间内素数和的函数。使用<code>accumulate</code>来进行一个总和的累计，通过<code>filter</code>遍历区间<code>a到b</code>,筛选出所有为素数的数字。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sum-prime</span> a b)</span><br><span class=\"line\">    (<span class=\"name\">accumulate</span> + <span class=\"number\">0</span> (<span class=\"name\">filter</span> prime ? (<span class=\"name\">enumerate-interval</span> a b)))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在对比两种方式，我们可以发现，迭代风格使用<code>递归的方式</code>。每一次更新<code>iter</code>函数的起点<code>count</code>和累计和<code>accum</code>，当count大于<code>b</code>区间终点的时候停止迭代。只需要保存两个数值，即可完成对区间内素数和计算。而第二种方式，确需要<code>enumerate-interval</code>，生成<code>a到b</code>之间的所有数值，然后对其进行循环遍历。这种储存开销，可以说是无法容忍的。</p>\n<p>&emsp;&emsp;流结构就是在此基础上面产生的，它的设计理念就是拥有<code>序列操作</code>的优雅，确能节省序列操作的储存列表的开销。</p>\n<p>&emsp;&emsp;从表面上看，流有点近似<strong>表</strong>，它满足以下操作规则。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 构造流 const-stream</span></span><br><span class=\"line\"><span class=\"comment\">;; 流基础结构满足</span></span><br><span class=\"line\"><span class=\"comment\">;; (stream-car (cons-stream x y)) = x</span></span><br><span class=\"line\"><span class=\"comment\">;; (stream-cdr (const-stream x y)) = y</span></span><br><span class=\"line\"><span class=\"comment\">;; 判断是否是空流</span></span><br><span class=\"line\"><span class=\"comment\">;; (stream-null? stream-list)</span></span><br><span class=\"line\"><span class=\"comment\">;; 空流</span></span><br><span class=\"line\"><span class=\"comment\">;; the-empty-stream</span></span><br><span class=\"line\"><span class=\"comment\">;; 流的各种操作</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">stream-ref</span> s n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\">stream-car</span> s)</span><br><span class=\"line\">        (<span class=\"name\">stream-ref</span> (<span class=\"name\">stream-cdr</span> s) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>))</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; map</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">stream-map</span> proc s)</span><br><span class=\"line\">    <span class=\"comment\">;; 是否为空流</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">stream-null?</span> s)</span><br><span class=\"line\">        the-empty-stream</span><br><span class=\"line\">        (<span class=\"name\">cons-stream</span> (<span class=\"name\">proc</span> (<span class=\"name\">stream-car</span> s))</span><br><span class=\"line\">            (<span class=\"name\">stream-map</span> proc (<span class=\"name\">stream-cdr</span> s)))))</span><br><span class=\"line\"><span class=\"comment\">;; forEach</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">stream-for-each</span> proc s)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">stream-null?</span> s)</span><br><span class=\"line\">        <span class=\"symbol\">'done</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> (<span class=\"name\">proc</span> (<span class=\"name\">stream-car</span> s))</span><br><span class=\"line\">               (<span class=\"name\">stream-for-each</span> proc (<span class=\"name\">stream-cdr</span> s))))</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;流的操作方式和序列的操作方式类似，不同的是，为了弥补序列操作需要生成整个需求的缺陷，流不是在构造<code>const-stream</code>的时候进行求值，而是保存一个生成过程，然后在<code>cdr-stream</code>的时候再去求值。因此<code>(cons-stream &lt;a&gt; &lt;b&gt;)</code>类似于<code>(const &lt;a&gt; (delay &lt;b&gt;))</code>的方式。保存了一个起始值和一个取值时的生成值的<code>delay</code>过程。因此，<code>stream-car</code>和<code>stream-car</code>应该是<code>(define (stream-car stream) (car stream))</code>和<code>(define (stream-cdr stream) (force (cdr stream)))</code>。</p>\n<p>&emsp;&emsp;我们现在使用<code>流</code>结构来改造重写一下求素数和的例子。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">stream-car</span></span><br><span class=\"line\">    (<span class=\"name\">stream-cdr</span></span><br><span class=\"line\">        (<span class=\"name\">stream-filter</span> prime?</span><br><span class=\"line\">            (<span class=\"name\">stream-enumerate-interval</span> a b))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">stream-enumerate-interval</span> low high)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> low high)</span><br><span class=\"line\">        the-empty-stream</span><br><span class=\"line\">        (<span class=\"name\">cons-stream</span></span><br><span class=\"line\">            low</span><br><span class=\"line\">            (<span class=\"name\">stream-enumerate-interval</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> low <span class=\"number\">1</span>) high))))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此处的<code>stream-enumerate-interval</code>返回的就是<code>流</code>的结构，它的第一项(<code>car</code>)值为流的起点，<code>cdr</code>的值为一个函数过程，也可以称之为<code>允诺</code>。当<code>stream-cdr</code>的时候，不是单单的取值，而且执行这个允诺，获得生成的新的<code>流</code>的值。我们可以根据这个思路来写出我们的<code>stream-filter</code>函数。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">stream-filter</span> pred stream)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\">strean-null?</span> stream) the-empty-stream)</span><br><span class=\"line\">          ((<span class=\"name\">pred</span> (<span class=\"name\">stream-car</span> stream))</span><br><span class=\"line\">            (<span class=\"name\">cond-stream</span> (<span class=\"name\">stream-car</span> stream)</span><br><span class=\"line\">                (<span class=\"name\">stream-filter</span> pred (<span class=\"name\">stream-cdr</span> stream))))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">stream-filter</span> pred (<span class=\"name\">stream-cdr</span> stream)))))</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;拥有了流的数据结构之后，因为流不是实际保存一个范围的数据，所以我们可以方便的定义各种特殊的无穷的流结构，比如<code>斐波那契</code>,比如<code>无穷素数流</code>。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 不能被7整除的流</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">divisible?</span> x y) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">remainder</span></span> x y) <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> no-sevens</span><br><span class=\"line\">    (<span class=\"name\">stream-filter</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x) (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\">divisible?</span> x <span class=\"number\">7</span>))) integers)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 斐波那契数列</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">fibgen</span> a b)</span><br><span class=\"line\">    (<span class=\"name\">cons-stream</span> a (<span class=\"name\">fibgen</span> b (<span class=\"name\"><span class=\"builtin-name\">+</span></span> a b)))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> fibs (<span class=\"name\">fibgen</span> <span class=\"number\">0</span> <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 无穷素数集</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sieve</span> stream)</span><br><span class=\"line\">    (<span class=\"name\">cons-stream</span></span><br><span class=\"line\">        (<span class=\"name\">stream-car</span> stream)</span><br><span class=\"line\">        (<span class=\"name\">sieve</span></span><br><span class=\"line\">            (<span class=\"name\">stream-filter</span></span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x) (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\">divisible?</span> x (<span class=\"name\">stream-car</span> stream))))</span><br><span class=\"line\">            (<span class=\"name\">stream-cdr</span> stream)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> primes (<span class=\"name\">sieve</span> (<span class=\"name\">integers-starting-from</span> <span class=\"number\">2</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>流</code>结构的设计思想，补全了函数编程上范围需要储存的空缺。用<code>流</code>结构基础的函数式编程的方式，能够很大程度上解决开头提出的引入<code>赋值和变动对象</code>带来<code>时间</code>即程序执行顺序的问题。因为函数式编程，本质上是一个类似于管道流的序对的方式，来进行执行的。我们可以简单回顾下第三章刚开始提出的，关于银行余额存取的例子。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 银行账户取值简化版</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">make-simplified-withdraw</span> balance)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (amout)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> balance (<span class=\"name\"><span class=\"builtin-name\">-</span></span> balance amout))</span><br><span class=\"line\">        banlance</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">;; 流改造版</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">stream-withdraw</span> balance amount-stream)</span><br><span class=\"line\">    (<span class=\"name\">cons-stream</span></span><br><span class=\"line\">        balance</span><br><span class=\"line\">        (<span class=\"name\">stream-withdraw</span></span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">-</span></span> balance (<span class=\"name\">stream-car</span> amount-stream))</span><br><span class=\"line\">            (<span class=\"name\">stream-cdr</span> amount-stream)</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>流</code>改造后的取值，输出完全由输入决定，以一种<strong>没有赋值</strong>的状态，把变化的余额用<code>流</code>的方式保存了下来。在这种需要严格遵循执行顺序的现实场景下。<code>流</code>结构无异于是解决的最佳方案。</p>\n<p>&emsp;&emsp;但是<code>流</code>结构也有明显的问题，即执行处理的<code>流</code>的单一性。比如第三章提出的A和B共享账户的场景下，这种单一<code>流</code>就不能完美的处理产生的问题，需要将两个用户产生的两个流进行数据处理的<strong>归并</strong>。</p>"},{"title":"《计算机程序的构造和解释》(sicp) 开篇","date":"2019-05-12T11:40:00.000Z","_content":"心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：\n1. 将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。\n2. 将两个知识放在一起对照，不管它们如何简单或复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。\n3. 将有关知识与那些实际中和它们同在的所有其他认识隔离开。\n这就是抽象，所有**具有普遍性的认识**都是这样得到的。\n——John Locke\n<!--more-->\n\n## 开篇\n\n### sicp是什么\n&emsp;&emsp;Structure and Interpretation of Computer Programs(sicp)，计算机程序的构造和解释，曾为MIT计算机科学的入门书籍。本书以Lisp的**scheme**作为主语言,从程序设计思想开始到模块和设计，最后到编译层，贯穿整个计算机程序领域，是一本不折不扣的编程思想气宗书。\n\n### 为什么我要读这本书\n&emsp;&emsp;读这本书起因是我的直系主管强烈的推荐，因为他对我评价是，JS基础很好，代码质量很高，但是没有程序设计和规划的理念，需要编程共同性抽象方面的认识。希望我通过这本书，能够学习到程序的设计，和模块的规划。\n\n&emsp;&emsp;刚开始阅读是很痛苦的。scheme语言语法及其不符合人正常思维和逻辑(事实上这本书后来也被用Python重写)，而且scheme语言极简，本质上除了基本的加减乘除，变量函数声明，以及条件判断之外，没有任何的其他功能。变量是无法在中途进行**赋值**的，循环语句也需要使用递归去实现。从JS语言过来对我来说简直是折磨。课后习题又是偏数学的内容，本来艰涩难懂的内容，加上scheme艰涩难懂的语言语法，使得课后习题做起来真的是一种折磨。\n\n&emsp;&emsp;事实上我刚开阅读这本书的时候也是很焦虑的，第一感觉就是读这本书对我直接帮助提升可以说是趋近于0。半路出家的我对自己的规划是很焦急的，今年希望能够好好研习下React源码以及刷算法题，来年能够摆脱外包，进入到一家稍微大一些稳定的甲方公司当中去。我今年也26了，马上就要到程序员的死刑期35，现在连工作都没有稳定下来，每天过的都非常急躁。感觉什么都想去学，什么也都不想去学。这个节骨点上，让我去读这样一本书，不知道能不能静下心了。在杭州这个前端招聘市场上面，招聘要求上面漫天的各种工具熟练使用的要求，也没有多少面试官愿意和你聊sicp上面相关的内容。都是怼怼api，怼怼算法。\n\n&emsp;&emsp;在通过一周的深入阅读之后，开始逐渐明朗自己在编程上面逻辑和思维的欠缺，这些缺陷在平时理所当然调用api的时候你是感受不到的。网上有个段子说写代码的三个境界，第二个境界就是看山不是山，看水不是水。在一切化繁为简之后，再回头去看自己当时写JS时，纠结几个api的使用，或者学习到了新的api很开心很兴奋的自己是真的很可笑的。潜下心来，决定认认真真的把这本书读完。\n\n&emsp;&emsp;最后说一句，写多了之后，scheme真香！据说scheme语言全部的语法介绍只有50行，还比不上lisp common语言介绍的目录！不用一直查MDN，一直写代码的感觉真好，可以把逻辑点回归到问题上面来，归纳到抽象思维上面去。\n\n### 这系读书笔记将会怎么写\n\n&emsp;&emsp;本书读起来很费劲，阅读进度会很慢，所以尽量采取一章节一篇读书笔记的方式，以陈述自己阅读的**思想理解**为主，而不是以归纳总结为主。希望通过输出的方式，倒逼自己能够提升对本书籍的理解。\n\n&emsp;&emsp;受限于工作强度的原因，我不能把每一道习题都去从认认真真的写完。所以习题会挑选受益比较深的几个章节模块，会去集中在 [github](https://github.com/tangdingga1/sicp) 上面实现。这些完整的代码就在github上。而不会出现在文章中。\n\n### 如果有幸你阅读了这系阅读笔记\n&emsp;&emsp;希望我写的这sicp的阅读笔记，能够引发你对编程最原始共同的抽象处的一些思考。能够在这个整体都很浮躁的环境下，去认认真真的思考研究一些原始的东西，激发你去阅读这本书的兴趣，一起去提升进步。","source":"_posts/scip/scip(start).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) 开篇\ndate: 2019/5/12 19:40:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：\n1. 将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。\n2. 将两个知识放在一起对照，不管它们如何简单或复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。\n3. 将有关知识与那些实际中和它们同在的所有其他认识隔离开。\n这就是抽象，所有**具有普遍性的认识**都是这样得到的。\n——John Locke\n<!--more-->\n\n## 开篇\n\n### sicp是什么\n&emsp;&emsp;Structure and Interpretation of Computer Programs(sicp)，计算机程序的构造和解释，曾为MIT计算机科学的入门书籍。本书以Lisp的**scheme**作为主语言,从程序设计思想开始到模块和设计，最后到编译层，贯穿整个计算机程序领域，是一本不折不扣的编程思想气宗书。\n\n### 为什么我要读这本书\n&emsp;&emsp;读这本书起因是我的直系主管强烈的推荐，因为他对我评价是，JS基础很好，代码质量很高，但是没有程序设计和规划的理念，需要编程共同性抽象方面的认识。希望我通过这本书，能够学习到程序的设计，和模块的规划。\n\n&emsp;&emsp;刚开始阅读是很痛苦的。scheme语言语法及其不符合人正常思维和逻辑(事实上这本书后来也被用Python重写)，而且scheme语言极简，本质上除了基本的加减乘除，变量函数声明，以及条件判断之外，没有任何的其他功能。变量是无法在中途进行**赋值**的，循环语句也需要使用递归去实现。从JS语言过来对我来说简直是折磨。课后习题又是偏数学的内容，本来艰涩难懂的内容，加上scheme艰涩难懂的语言语法，使得课后习题做起来真的是一种折磨。\n\n&emsp;&emsp;事实上我刚开阅读这本书的时候也是很焦虑的，第一感觉就是读这本书对我直接帮助提升可以说是趋近于0。半路出家的我对自己的规划是很焦急的，今年希望能够好好研习下React源码以及刷算法题，来年能够摆脱外包，进入到一家稍微大一些稳定的甲方公司当中去。我今年也26了，马上就要到程序员的死刑期35，现在连工作都没有稳定下来，每天过的都非常急躁。感觉什么都想去学，什么也都不想去学。这个节骨点上，让我去读这样一本书，不知道能不能静下心了。在杭州这个前端招聘市场上面，招聘要求上面漫天的各种工具熟练使用的要求，也没有多少面试官愿意和你聊sicp上面相关的内容。都是怼怼api，怼怼算法。\n\n&emsp;&emsp;在通过一周的深入阅读之后，开始逐渐明朗自己在编程上面逻辑和思维的欠缺，这些缺陷在平时理所当然调用api的时候你是感受不到的。网上有个段子说写代码的三个境界，第二个境界就是看山不是山，看水不是水。在一切化繁为简之后，再回头去看自己当时写JS时，纠结几个api的使用，或者学习到了新的api很开心很兴奋的自己是真的很可笑的。潜下心来，决定认认真真的把这本书读完。\n\n&emsp;&emsp;最后说一句，写多了之后，scheme真香！据说scheme语言全部的语法介绍只有50行，还比不上lisp common语言介绍的目录！不用一直查MDN，一直写代码的感觉真好，可以把逻辑点回归到问题上面来，归纳到抽象思维上面去。\n\n### 这系读书笔记将会怎么写\n\n&emsp;&emsp;本书读起来很费劲，阅读进度会很慢，所以尽量采取一章节一篇读书笔记的方式，以陈述自己阅读的**思想理解**为主，而不是以归纳总结为主。希望通过输出的方式，倒逼自己能够提升对本书籍的理解。\n\n&emsp;&emsp;受限于工作强度的原因，我不能把每一道习题都去从认认真真的写完。所以习题会挑选受益比较深的几个章节模块，会去集中在 [github](https://github.com/tangdingga1/sicp) 上面实现。这些完整的代码就在github上。而不会出现在文章中。\n\n### 如果有幸你阅读了这系阅读笔记\n&emsp;&emsp;希望我写的这sicp的阅读笔记，能够引发你对编程最原始共同的抽象处的一些思考。能够在这个整体都很浮躁的环境下，去认认真真的思考研究一些原始的东西，激发你去阅读这本书的兴趣，一起去提升进步。","slug":"scip/scip(start)","published":1,"updated":"2020-06-11T01:43:32.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhyc002q9r2vrkllwzrb","content":"<p>心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：</p>\n<ol>\n<li>将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。</li>\n<li>将两个知识放在一起对照，不管它们如何简单或复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。</li>\n<li>将有关知识与那些实际中和它们同在的所有其他认识隔离开。<br>这就是抽象，所有<strong>具有普遍性的认识</strong>都是这样得到的。<br>——John Locke<a id=\"more\"></a>\n</li>\n</ol>\n<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><h3 id=\"sicp是什么\"><a href=\"#sicp是什么\" class=\"headerlink\" title=\"sicp是什么\"></a>sicp是什么</h3><p>&emsp;&emsp;Structure and Interpretation of Computer Programs(sicp)，计算机程序的构造和解释，曾为MIT计算机科学的入门书籍。本书以Lisp的<strong>scheme</strong>作为主语言,从程序设计思想开始到模块和设计，最后到编译层，贯穿整个计算机程序领域，是一本不折不扣的编程思想气宗书。</p>\n<h3 id=\"为什么我要读这本书\"><a href=\"#为什么我要读这本书\" class=\"headerlink\" title=\"为什么我要读这本书\"></a>为什么我要读这本书</h3><p>&emsp;&emsp;读这本书起因是我的直系主管强烈的推荐，因为他对我评价是，JS基础很好，代码质量很高，但是没有程序设计和规划的理念，需要编程共同性抽象方面的认识。希望我通过这本书，能够学习到程序的设计，和模块的规划。</p>\n<p>&emsp;&emsp;刚开始阅读是很痛苦的。scheme语言语法及其不符合人正常思维和逻辑(事实上这本书后来也被用Python重写)，而且scheme语言极简，本质上除了基本的加减乘除，变量函数声明，以及条件判断之外，没有任何的其他功能。变量是无法在中途进行<strong>赋值</strong>的，循环语句也需要使用递归去实现。从JS语言过来对我来说简直是折磨。课后习题又是偏数学的内容，本来艰涩难懂的内容，加上scheme艰涩难懂的语言语法，使得课后习题做起来真的是一种折磨。</p>\n<p>&emsp;&emsp;事实上我刚开阅读这本书的时候也是很焦虑的，第一感觉就是读这本书对我直接帮助提升可以说是趋近于0。半路出家的我对自己的规划是很焦急的，今年希望能够好好研习下React源码以及刷算法题，来年能够摆脱外包，进入到一家稍微大一些稳定的甲方公司当中去。我今年也26了，马上就要到程序员的死刑期35，现在连工作都没有稳定下来，每天过的都非常急躁。感觉什么都想去学，什么也都不想去学。这个节骨点上，让我去读这样一本书，不知道能不能静下心了。在杭州这个前端招聘市场上面，招聘要求上面漫天的各种工具熟练使用的要求，也没有多少面试官愿意和你聊sicp上面相关的内容。都是怼怼api，怼怼算法。</p>\n<p>&emsp;&emsp;在通过一周的深入阅读之后，开始逐渐明朗自己在编程上面逻辑和思维的欠缺，这些缺陷在平时理所当然调用api的时候你是感受不到的。网上有个段子说写代码的三个境界，第二个境界就是看山不是山，看水不是水。在一切化繁为简之后，再回头去看自己当时写JS时，纠结几个api的使用，或者学习到了新的api很开心很兴奋的自己是真的很可笑的。潜下心来，决定认认真真的把这本书读完。</p>\n<p>&emsp;&emsp;最后说一句，写多了之后，scheme真香！据说scheme语言全部的语法介绍只有50行，还比不上lisp common语言介绍的目录！不用一直查MDN，一直写代码的感觉真好，可以把逻辑点回归到问题上面来，归纳到抽象思维上面去。</p>\n<h3 id=\"这系读书笔记将会怎么写\"><a href=\"#这系读书笔记将会怎么写\" class=\"headerlink\" title=\"这系读书笔记将会怎么写\"></a>这系读书笔记将会怎么写</h3><p>&emsp;&emsp;本书读起来很费劲，阅读进度会很慢，所以尽量采取一章节一篇读书笔记的方式，以陈述自己阅读的<strong>思想理解</strong>为主，而不是以归纳总结为主。希望通过输出的方式，倒逼自己能够提升对本书籍的理解。</p>\n<p>&emsp;&emsp;受限于工作强度的原因，我不能把每一道习题都去从认认真真的写完。所以习题会挑选受益比较深的几个章节模块，会去集中在 <a href=\"https://github.com/tangdingga1/sicp\" target=\"_blank\" rel=\"noopener\">github</a> 上面实现。这些完整的代码就在github上。而不会出现在文章中。</p>\n<h3 id=\"如果有幸你阅读了这系阅读笔记\"><a href=\"#如果有幸你阅读了这系阅读笔记\" class=\"headerlink\" title=\"如果有幸你阅读了这系阅读笔记\"></a>如果有幸你阅读了这系阅读笔记</h3><p>&emsp;&emsp;希望我写的这sicp的阅读笔记，能够引发你对编程最原始共同的抽象处的一些思考。能够在这个整体都很浮躁的环境下，去认认真真的思考研究一些原始的东西，激发你去阅读这本书的兴趣，一起去提升进步。</p>\n","site":{"data":{}},"excerpt":"<p>心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：</p>\n<ol>\n<li>将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。</li>\n<li>将两个知识放在一起对照，不管它们如何简单或复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。</li>\n<li>将有关知识与那些实际中和它们同在的所有其他认识隔离开。<br>这就是抽象，所有<strong>具有普遍性的认识</strong>都是这样得到的。<br>——John Locke</li></ol>","more":"</li>\n</ol>\n<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><h3 id=\"sicp是什么\"><a href=\"#sicp是什么\" class=\"headerlink\" title=\"sicp是什么\"></a>sicp是什么</h3><p>&emsp;&emsp;Structure and Interpretation of Computer Programs(sicp)，计算机程序的构造和解释，曾为MIT计算机科学的入门书籍。本书以Lisp的<strong>scheme</strong>作为主语言,从程序设计思想开始到模块和设计，最后到编译层，贯穿整个计算机程序领域，是一本不折不扣的编程思想气宗书。</p>\n<h3 id=\"为什么我要读这本书\"><a href=\"#为什么我要读这本书\" class=\"headerlink\" title=\"为什么我要读这本书\"></a>为什么我要读这本书</h3><p>&emsp;&emsp;读这本书起因是我的直系主管强烈的推荐，因为他对我评价是，JS基础很好，代码质量很高，但是没有程序设计和规划的理念，需要编程共同性抽象方面的认识。希望我通过这本书，能够学习到程序的设计，和模块的规划。</p>\n<p>&emsp;&emsp;刚开始阅读是很痛苦的。scheme语言语法及其不符合人正常思维和逻辑(事实上这本书后来也被用Python重写)，而且scheme语言极简，本质上除了基本的加减乘除，变量函数声明，以及条件判断之外，没有任何的其他功能。变量是无法在中途进行<strong>赋值</strong>的，循环语句也需要使用递归去实现。从JS语言过来对我来说简直是折磨。课后习题又是偏数学的内容，本来艰涩难懂的内容，加上scheme艰涩难懂的语言语法，使得课后习题做起来真的是一种折磨。</p>\n<p>&emsp;&emsp;事实上我刚开阅读这本书的时候也是很焦虑的，第一感觉就是读这本书对我直接帮助提升可以说是趋近于0。半路出家的我对自己的规划是很焦急的，今年希望能够好好研习下React源码以及刷算法题，来年能够摆脱外包，进入到一家稍微大一些稳定的甲方公司当中去。我今年也26了，马上就要到程序员的死刑期35，现在连工作都没有稳定下来，每天过的都非常急躁。感觉什么都想去学，什么也都不想去学。这个节骨点上，让我去读这样一本书，不知道能不能静下心了。在杭州这个前端招聘市场上面，招聘要求上面漫天的各种工具熟练使用的要求，也没有多少面试官愿意和你聊sicp上面相关的内容。都是怼怼api，怼怼算法。</p>\n<p>&emsp;&emsp;在通过一周的深入阅读之后，开始逐渐明朗自己在编程上面逻辑和思维的欠缺，这些缺陷在平时理所当然调用api的时候你是感受不到的。网上有个段子说写代码的三个境界，第二个境界就是看山不是山，看水不是水。在一切化繁为简之后，再回头去看自己当时写JS时，纠结几个api的使用，或者学习到了新的api很开心很兴奋的自己是真的很可笑的。潜下心来，决定认认真真的把这本书读完。</p>\n<p>&emsp;&emsp;最后说一句，写多了之后，scheme真香！据说scheme语言全部的语法介绍只有50行，还比不上lisp common语言介绍的目录！不用一直查MDN，一直写代码的感觉真好，可以把逻辑点回归到问题上面来，归纳到抽象思维上面去。</p>\n<h3 id=\"这系读书笔记将会怎么写\"><a href=\"#这系读书笔记将会怎么写\" class=\"headerlink\" title=\"这系读书笔记将会怎么写\"></a>这系读书笔记将会怎么写</h3><p>&emsp;&emsp;本书读起来很费劲，阅读进度会很慢，所以尽量采取一章节一篇读书笔记的方式，以陈述自己阅读的<strong>思想理解</strong>为主，而不是以归纳总结为主。希望通过输出的方式，倒逼自己能够提升对本书籍的理解。</p>\n<p>&emsp;&emsp;受限于工作强度的原因，我不能把每一道习题都去从认认真真的写完。所以习题会挑选受益比较深的几个章节模块，会去集中在 <a href=\"https://github.com/tangdingga1/sicp\" target=\"_blank\" rel=\"noopener\">github</a> 上面实现。这些完整的代码就在github上。而不会出现在文章中。</p>\n<h3 id=\"如果有幸你阅读了这系阅读笔记\"><a href=\"#如果有幸你阅读了这系阅读笔记\" class=\"headerlink\" title=\"如果有幸你阅读了这系阅读笔记\"></a>如果有幸你阅读了这系阅读笔记</h3><p>&emsp;&emsp;希望我写的这sicp的阅读笔记，能够引发你对编程最原始共同的抽象处的一些思考。能够在这个整体都很浮躁的环境下，去认认真真的思考研究一些原始的东西，激发你去阅读这本书的兴趣，一起去提升进步。</p>"},{"title":"《计算机程序的构造和解释》(sicp) chap-1","date":"2019-05-18T11:40:00.000Z","_content":"## 第一章 构造过程抽象\n本章主要讲述程序**运行过程**的共通抽象部分：\n1. 包括程序设计的基本元素\n2. 过程循环的抽象(迭代和递归)\n3. 抽象过程传递给过程(高阶函数)\n<!--more-->\n\n## 1.1 程序设计的基本元素\n&emsp;&emsp;每一种编程语言的设计，都应该具备三种最基本的机制：基本表达式，组合的方法，抽象的方法。\n\n&emsp;&emsp;所有程序设计中，我们需要关心的永远只有**数据**和**过程**。通俗的讲，平时编写代码，无非就是**变量**和**函数**两个部分组成，函数就是过程，用以操作数据，最后达成我们想要的效果。就前端来说，不管你是写css样式，还是js代码，最终都是把一个具量化的结果，传递到显示终端(浏览器)当中，显示渲染。\n\n### 表达式\n&emsp;&emsp;基本表达式实质就是**最简单的词法单元**，也就是碎片化的过程。比如在 scheme 中，输入`512`，编译器返回`512`，这就是一个最基本的表达式。书中通过本节简单介绍了 scheme 基本语法。\n\n```scheme\n;; (运算符 被运算单元 运算单元 )\n(+ 10 20)\n(- 10 20)\n(* 20 30)\n(/ 20 30)\n\n;; 括号的语法使得运算优先级很明确\n(/ 20\n    (+ 20 30)\n    (- 10 (* 20 30)))\n```\n\n### 命名和环境\n\n&emsp;&emsp;最简单的抽象方法，就是给予一个对象**命名**，通过使用名字的方法去进行计算，就是程序设计当中俗称的**变量**。在我的理解当中变量的存在是为了方便代码的**复用**和程序的**可读性**，在日常代码过程当中，变量命名除了一眼就能知道它所代表的的意义外，还要符合变量种类的命名规范(比如常量使用全大写，类名使用大写开头)，有效率的传达到多种意义。\n\n&emsp;&emsp;变量所能访问到的上下文位置，称为**环境**，也就是我们常说的**作用域**。\n\n&emsp;&emsp;scheme 当中，使用 `(define 变量名 变量值)`的方式来进行变量的声明。值得一提的是，scheme 中变量是没有赋值方法的。也就是说，变量永远当做常量来进行使用。\n```scheme\n(define PI 3.1415926)\nPI\n;; 3.1415926\n```\n\n### 复合过程\n&emsp;&emsp;定义过程是一种强大的抽象过程，合理的程序设计当中应该存在。定义过程实际上就是一段**表达式**的复用。scheme中我们使用define来定义一个过程`(define (name parameters) body)`。\n\n```scheme\n;; 这里我们定义一个求放入两个参数的平方和的过程(函数)\n(define (sum-square par1 par2) \n    (+\n        (* par1 par1)\n        (* par2 par2)))\n;; 使用函数\n(sum-square 1 2)\n;; 等同于1 + 4, 5\n```\n\n### 过程应用的代换模型\n&emsp;&emsp;过程的抽象解释，分为**正则序**和**应用序**两种模型。正则序的特征为**完全展开后规约**，而应用序为**先求值参数而后规约**。\n\n&emsp;&emsp;**正则序**和**应用序**是程序解释器两种解释顺序模型的简单体现。\n\n&emsp;&emsp;下面是刚才`sum-square`函数正则序和应用序的示例。\n```scheme\n;; 调用 sum-square\n(define par1 10)\n(sum-square par1 (+ 10 20))\n\n;; 正则序代换\n;; 1\n(sum-square par1 (+ 10 20))\n;; 2\n(+\n    (* par1 par1)\n    (* (+ 10 20) (+ 10 20))))\n;; 3\n(+\n    (* 10 10)\n    (* (+ 10 20) (+ 10 20))))\n\n;; 应用序代换\n;; 1\n(sum-square 10 (+ 10 20))\n;; 2\n(sum-square 10 30)\n;; 3\n(+\n    (* 10 10)\n    (* 30 30)))\n```\n\n### 条件表达式和谓词\n&emsp;&emsp;条件表达式是增强过程谓词的关键。根据不同的情况执行不同的过程步骤是必要的功能。\n\n&emsp;&emsp;scheme中有`if`和`cond`两种条件语句。\n\n```scheme\n;; cond 适用多分支的情况\n(cond (p e)\n      (p e)\n      (else e))\n\n;; if 适用于两种情况的模式\n(if p e elseE)\n\n;; 这里用大于0时候加上2，否则减去2为例书写一下 cond 和 if\n\n;; 这儿为了展示cond的多分支特性，特意书写=0的情况\n(cond ((> x 0) (+ x 2))\n      ((= x 0) (+ x 2))\n      (else (- x 2))\n)\n(if (< x 0)\n    (- x 2)\n    (+ x 2)\n)\n```\n&emsp;&emsp;scheme还有三个基础的逻辑复合运算符。`and not or`。运算返回布尔值`#t #f`。and为一假为假，全真为真。or为一真为真，全假为假，not为取相反。\n```scheme\n(and e1 ... e2)\n(not e1)\n(or e1 ... e2)\n```\n### 过程作为黑箱抽象\n&emsp;&emsp;过程的封装需要有**黑箱**的抽象概念，即任何使用过程的用户，只需要关心**输入**，和得到的**输出**，不要去关心其他任何的东西。为此，我们可以把过程所用到的东西，封装在过程当中，唯一露出给使用者的就是他所输入的函数。这种结构称之为**块结构**。\n\n&emsp;&emsp;这里，我们设计一个函数`isEven`，用户输入一个数字，判断这个数字是否是偶数，是的话反而真，不是返回false。\n\n```scheme\n;; 函数的思路是一直减少2，直到小于2为止，如果为0，那么是偶数，否则为奇数\n;; 用户只需要关心输入的 isEven 以及它的返回值 #t #f\n(define (isEven testNum)\n    ;; 定义过程，输入一个数字 返回它减2的值\n    ;; 这个减2的过程封装在 isEven 当中\n    (define (sub2 num) (- num 2))\n    ;; 递归，如果没有小于2继续\n    (if (< testNum 2) (= testNum 0)\n        (isEven (sub2 testNum))\n    )\n)\n```\n\n## 1.2 过程与它们所产生的的计算\n&emsp;&emsp;这里一小节将重点研究递归循环过程的两种形态，以及如何计算它们的运算复杂度(算法的概念)。\n\n### 线性的递归和迭代与树形递归的比较\n&emsp;&emsp;线性的递归，即每一步平行复杂度的递归方式。这里使用一个求数阶乘的函数来说明。\n```scheme\n;; factorial 输入一个n 求n的阶乘 n! 即 n * (n - 1) * ... 1 \n(define (factorial n)\n    ;; calnum 当前计算的值\n    ;; counter 当前计算到哪一个数字\n    ;; max-count 求乘阶的值\n    (define (fact-iter calnum counter max-count)\n        (if (> counter max-count)\n            calnum\n            (fact-iter \n                (* calnum counter) \n                (+ counter 1) \n                max-count)))\n    (fact-iter 1 1 n)\n)\n```\n&emsp;&emsp;上面的`factorial`函数，在输入6的时候使用应用替换模型进行展开的话，不难发现每一步都是平行复杂度的的。\n```scheme\n(factorial 6)\n(fact-iter 1 1 6)\n(fact-iter 1 2 6)\n(fact-iter 2 3 6)\n(fact-iter 6 4 6)\n;; ...以下省略\n```\n&emsp;&emsp;整个运算过程如同一条直线，因此是线性的递归思路。这种迭代写法的特征就是会用一个**专门的值**去保存需要返回计算的值，即**累计器**的概念。\n\n&emsp;&emsp;下面我们看一下**树形迭代**的概念，用树形迭代的思想来重写`factorial`函数。\n```scheme\n;; factorial-treeway 树形迭代求阶乘\n(define (factorial-treeway n)\n    ;; counter 当前计算到的值\n    ;; max-count 求乘阶的值\n    (define (fact-iter counter max-count)\n        (if (= counter max-count)\n            max-count\n            (* counter (fact-iter (+ counter 1) max-count))))\n    (fact-iter 1 n))\n```\n\n&emsp;&emsp;我们把`factorial-treeway`用应用序展开。\n\n```scheme\n(factorial-treeway 6)\n(fact-iter 1 6)\n(fact-iter (* 1 (fact-iter 2 6)) 6)\n(fact-iter (* 1 (* 2 (fact-iter 3 6))) 6)\n(fact-iter (* 1 (* 2 (* 3 (fact-iter 4 6)))) 6)\n;; 括号看得我脑壳有点疼，以下过程省略\n```\n&emsp;&emsp;我们不难看到树型迭代是一个**展开的过程**，而不是像线性递归一样，每一步都是平行前行的。树形迭代的特点就是没有一个特定的变量去保存函数需要返回的值，而是通过到递归终止条件，去进行一个展开的过程。\n\n### 增长的阶\n&emsp;&emsp;为了比较两种递归的方法差异，这里书本引入了`θ`记资源消耗的概念，其实这儿就是**算法复杂度**的思想。\n\n&emsp;&emsp;我们需要一个抽象的概念去衡量一个程序消耗的资源程度，来规避一些影响条件(如计算机硬件)。这里的`θ`就相当于算法中的O表示法，表示**一步**程序运行所消耗的资源。比如`(+ 1 2)`，这里执行了一步程序操作，`1+2`。这里的消耗就是`θ(1)`。记总消耗为`f(n)`，消耗了`n步`,那么这个公式就可以写成`f(n)=θ(n)`。\n\n&emsp;&emsp;具体算法方面的内容，我在 [github](https://github.com/tangdingga1/Algorithm-in-JavaScript) 上面用`node`写了一个学习的库，感兴趣的可以去看一下，这里就不展开讨论了。\n\n## 1.3 高阶函数做抽象\n&emsp;&emsp;这一章主要讲述了高阶函数的函数式编程的概念。所谓高阶函数，就是能把函数作为参数传递给一个函数，并且还能作为返回值来返回一个函数。`React`当中的高阶组件，其实就是高阶函数的思想组件版。\n\n&emsp;&emsp;以过程作为参数，返回一个过程，这个过程称为高阶过程。这种强有力的抽象机制，极大的增强语言的表述能力。\n\n&emsp;&emsp;scheme中为了方便过程的传递，创造了`lambda`和`let`的方式来方便进行函数的传递。下面我们来定义一个函数，功能类似于for循环，它能够接收一个过程和一个区间范围，返回过程计算的区间范围的值。\n\n```scheme\n;; each 循环的过程\n;; cal 累计器的初始值\n;; a 起始点\n;; b 结束点\n(define (eachInterval each cal a b)\n    ;; a小于等于b的时候进行循环操作\n    (if (not (> a b))\n        (eachInterval each (each a cal) (+ a 1) b)\n        cal\n    )\n)\n```\n&emsp;&emsp;我们可以使用 `lambda` 来方便的传递过程给 `eachInterval`。`lambda`使用的方式是`(lambda (parms) body)`。\n\n```scheme\n;; 计算1+100的值，虽然我们都知道是5050\n(eachInterval (lambda (nowIdx cal) (+ cal nowIdx)) 0 1 100)\n```\n&emsp;&emsp;scheme中还可以使用`let`来创建一个结构代码块。注意，`let`创建的变量仅在`let`结构块中生效。\n\n```scheme\n(let (\n    (val1 exp1)\n    (val2 exp2)\n) body)\n\n;; 这里简单说明一下作用域的例子\n(define x 10)\n(let (\n    (x 3)\n    ;; 此时y赋值时引用的x仍为外部定义的x\n    (y (+ x 2))\n    ;; let 定义的 x 和 y 仅在 body体 当中生效！在参数定义部分使用的话仍然使用的是全局变量的值\n) (* x y))\n```\n## 总结\n&emsp;&emsp;其实本质上，第一章是在介绍 scheme 写法的基本要素。变量声明，定义函数，循环的用法以及高阶函数的用法。但是本书通过抽象的思想把scheme的这些基本语法，站在**程序的设计共通性**的高度上讲解了出来。这就是这本书高明的地方。编程修炼的内功，就是指这些思考吧。\n\n&emsp;&emsp;多去总结共性，抓住本质，是写代码和学习的时候永恒的主题啊。代码中，我们把共同性的部分提炼成函数，加以复用。学习中，共同性的部分能大大加深我们学习的眼界和学习的速度。本章的习题部分挑选了部分习题，放在我的 [github sicp第一章](https://github.com/tangdingga1/sicp) 当中，欢迎来一起学习讨论。\n\n","source":"_posts/scip/sicp(chap1).md","raw":"---\ntitle: 《计算机程序的构造和解释》(sicp) chap-1\ndate: 2019/5/18 19:40:00\ncategories:\n- [读书笔记, sicp]\ntags:\n- sicp\n- 读书笔记\n---\n## 第一章 构造过程抽象\n本章主要讲述程序**运行过程**的共通抽象部分：\n1. 包括程序设计的基本元素\n2. 过程循环的抽象(迭代和递归)\n3. 抽象过程传递给过程(高阶函数)\n<!--more-->\n\n## 1.1 程序设计的基本元素\n&emsp;&emsp;每一种编程语言的设计，都应该具备三种最基本的机制：基本表达式，组合的方法，抽象的方法。\n\n&emsp;&emsp;所有程序设计中，我们需要关心的永远只有**数据**和**过程**。通俗的讲，平时编写代码，无非就是**变量**和**函数**两个部分组成，函数就是过程，用以操作数据，最后达成我们想要的效果。就前端来说，不管你是写css样式，还是js代码，最终都是把一个具量化的结果，传递到显示终端(浏览器)当中，显示渲染。\n\n### 表达式\n&emsp;&emsp;基本表达式实质就是**最简单的词法单元**，也就是碎片化的过程。比如在 scheme 中，输入`512`，编译器返回`512`，这就是一个最基本的表达式。书中通过本节简单介绍了 scheme 基本语法。\n\n```scheme\n;; (运算符 被运算单元 运算单元 )\n(+ 10 20)\n(- 10 20)\n(* 20 30)\n(/ 20 30)\n\n;; 括号的语法使得运算优先级很明确\n(/ 20\n    (+ 20 30)\n    (- 10 (* 20 30)))\n```\n\n### 命名和环境\n\n&emsp;&emsp;最简单的抽象方法，就是给予一个对象**命名**，通过使用名字的方法去进行计算，就是程序设计当中俗称的**变量**。在我的理解当中变量的存在是为了方便代码的**复用**和程序的**可读性**，在日常代码过程当中，变量命名除了一眼就能知道它所代表的的意义外，还要符合变量种类的命名规范(比如常量使用全大写，类名使用大写开头)，有效率的传达到多种意义。\n\n&emsp;&emsp;变量所能访问到的上下文位置，称为**环境**，也就是我们常说的**作用域**。\n\n&emsp;&emsp;scheme 当中，使用 `(define 变量名 变量值)`的方式来进行变量的声明。值得一提的是，scheme 中变量是没有赋值方法的。也就是说，变量永远当做常量来进行使用。\n```scheme\n(define PI 3.1415926)\nPI\n;; 3.1415926\n```\n\n### 复合过程\n&emsp;&emsp;定义过程是一种强大的抽象过程，合理的程序设计当中应该存在。定义过程实际上就是一段**表达式**的复用。scheme中我们使用define来定义一个过程`(define (name parameters) body)`。\n\n```scheme\n;; 这里我们定义一个求放入两个参数的平方和的过程(函数)\n(define (sum-square par1 par2) \n    (+\n        (* par1 par1)\n        (* par2 par2)))\n;; 使用函数\n(sum-square 1 2)\n;; 等同于1 + 4, 5\n```\n\n### 过程应用的代换模型\n&emsp;&emsp;过程的抽象解释，分为**正则序**和**应用序**两种模型。正则序的特征为**完全展开后规约**，而应用序为**先求值参数而后规约**。\n\n&emsp;&emsp;**正则序**和**应用序**是程序解释器两种解释顺序模型的简单体现。\n\n&emsp;&emsp;下面是刚才`sum-square`函数正则序和应用序的示例。\n```scheme\n;; 调用 sum-square\n(define par1 10)\n(sum-square par1 (+ 10 20))\n\n;; 正则序代换\n;; 1\n(sum-square par1 (+ 10 20))\n;; 2\n(+\n    (* par1 par1)\n    (* (+ 10 20) (+ 10 20))))\n;; 3\n(+\n    (* 10 10)\n    (* (+ 10 20) (+ 10 20))))\n\n;; 应用序代换\n;; 1\n(sum-square 10 (+ 10 20))\n;; 2\n(sum-square 10 30)\n;; 3\n(+\n    (* 10 10)\n    (* 30 30)))\n```\n\n### 条件表达式和谓词\n&emsp;&emsp;条件表达式是增强过程谓词的关键。根据不同的情况执行不同的过程步骤是必要的功能。\n\n&emsp;&emsp;scheme中有`if`和`cond`两种条件语句。\n\n```scheme\n;; cond 适用多分支的情况\n(cond (p e)\n      (p e)\n      (else e))\n\n;; if 适用于两种情况的模式\n(if p e elseE)\n\n;; 这里用大于0时候加上2，否则减去2为例书写一下 cond 和 if\n\n;; 这儿为了展示cond的多分支特性，特意书写=0的情况\n(cond ((> x 0) (+ x 2))\n      ((= x 0) (+ x 2))\n      (else (- x 2))\n)\n(if (< x 0)\n    (- x 2)\n    (+ x 2)\n)\n```\n&emsp;&emsp;scheme还有三个基础的逻辑复合运算符。`and not or`。运算返回布尔值`#t #f`。and为一假为假，全真为真。or为一真为真，全假为假，not为取相反。\n```scheme\n(and e1 ... e2)\n(not e1)\n(or e1 ... e2)\n```\n### 过程作为黑箱抽象\n&emsp;&emsp;过程的封装需要有**黑箱**的抽象概念，即任何使用过程的用户，只需要关心**输入**，和得到的**输出**，不要去关心其他任何的东西。为此，我们可以把过程所用到的东西，封装在过程当中，唯一露出给使用者的就是他所输入的函数。这种结构称之为**块结构**。\n\n&emsp;&emsp;这里，我们设计一个函数`isEven`，用户输入一个数字，判断这个数字是否是偶数，是的话反而真，不是返回false。\n\n```scheme\n;; 函数的思路是一直减少2，直到小于2为止，如果为0，那么是偶数，否则为奇数\n;; 用户只需要关心输入的 isEven 以及它的返回值 #t #f\n(define (isEven testNum)\n    ;; 定义过程，输入一个数字 返回它减2的值\n    ;; 这个减2的过程封装在 isEven 当中\n    (define (sub2 num) (- num 2))\n    ;; 递归，如果没有小于2继续\n    (if (< testNum 2) (= testNum 0)\n        (isEven (sub2 testNum))\n    )\n)\n```\n\n## 1.2 过程与它们所产生的的计算\n&emsp;&emsp;这里一小节将重点研究递归循环过程的两种形态，以及如何计算它们的运算复杂度(算法的概念)。\n\n### 线性的递归和迭代与树形递归的比较\n&emsp;&emsp;线性的递归，即每一步平行复杂度的递归方式。这里使用一个求数阶乘的函数来说明。\n```scheme\n;; factorial 输入一个n 求n的阶乘 n! 即 n * (n - 1) * ... 1 \n(define (factorial n)\n    ;; calnum 当前计算的值\n    ;; counter 当前计算到哪一个数字\n    ;; max-count 求乘阶的值\n    (define (fact-iter calnum counter max-count)\n        (if (> counter max-count)\n            calnum\n            (fact-iter \n                (* calnum counter) \n                (+ counter 1) \n                max-count)))\n    (fact-iter 1 1 n)\n)\n```\n&emsp;&emsp;上面的`factorial`函数，在输入6的时候使用应用替换模型进行展开的话，不难发现每一步都是平行复杂度的的。\n```scheme\n(factorial 6)\n(fact-iter 1 1 6)\n(fact-iter 1 2 6)\n(fact-iter 2 3 6)\n(fact-iter 6 4 6)\n;; ...以下省略\n```\n&emsp;&emsp;整个运算过程如同一条直线，因此是线性的递归思路。这种迭代写法的特征就是会用一个**专门的值**去保存需要返回计算的值，即**累计器**的概念。\n\n&emsp;&emsp;下面我们看一下**树形迭代**的概念，用树形迭代的思想来重写`factorial`函数。\n```scheme\n;; factorial-treeway 树形迭代求阶乘\n(define (factorial-treeway n)\n    ;; counter 当前计算到的值\n    ;; max-count 求乘阶的值\n    (define (fact-iter counter max-count)\n        (if (= counter max-count)\n            max-count\n            (* counter (fact-iter (+ counter 1) max-count))))\n    (fact-iter 1 n))\n```\n\n&emsp;&emsp;我们把`factorial-treeway`用应用序展开。\n\n```scheme\n(factorial-treeway 6)\n(fact-iter 1 6)\n(fact-iter (* 1 (fact-iter 2 6)) 6)\n(fact-iter (* 1 (* 2 (fact-iter 3 6))) 6)\n(fact-iter (* 1 (* 2 (* 3 (fact-iter 4 6)))) 6)\n;; 括号看得我脑壳有点疼，以下过程省略\n```\n&emsp;&emsp;我们不难看到树型迭代是一个**展开的过程**，而不是像线性递归一样，每一步都是平行前行的。树形迭代的特点就是没有一个特定的变量去保存函数需要返回的值，而是通过到递归终止条件，去进行一个展开的过程。\n\n### 增长的阶\n&emsp;&emsp;为了比较两种递归的方法差异，这里书本引入了`θ`记资源消耗的概念，其实这儿就是**算法复杂度**的思想。\n\n&emsp;&emsp;我们需要一个抽象的概念去衡量一个程序消耗的资源程度，来规避一些影响条件(如计算机硬件)。这里的`θ`就相当于算法中的O表示法，表示**一步**程序运行所消耗的资源。比如`(+ 1 2)`，这里执行了一步程序操作，`1+2`。这里的消耗就是`θ(1)`。记总消耗为`f(n)`，消耗了`n步`,那么这个公式就可以写成`f(n)=θ(n)`。\n\n&emsp;&emsp;具体算法方面的内容，我在 [github](https://github.com/tangdingga1/Algorithm-in-JavaScript) 上面用`node`写了一个学习的库，感兴趣的可以去看一下，这里就不展开讨论了。\n\n## 1.3 高阶函数做抽象\n&emsp;&emsp;这一章主要讲述了高阶函数的函数式编程的概念。所谓高阶函数，就是能把函数作为参数传递给一个函数，并且还能作为返回值来返回一个函数。`React`当中的高阶组件，其实就是高阶函数的思想组件版。\n\n&emsp;&emsp;以过程作为参数，返回一个过程，这个过程称为高阶过程。这种强有力的抽象机制，极大的增强语言的表述能力。\n\n&emsp;&emsp;scheme中为了方便过程的传递，创造了`lambda`和`let`的方式来方便进行函数的传递。下面我们来定义一个函数，功能类似于for循环，它能够接收一个过程和一个区间范围，返回过程计算的区间范围的值。\n\n```scheme\n;; each 循环的过程\n;; cal 累计器的初始值\n;; a 起始点\n;; b 结束点\n(define (eachInterval each cal a b)\n    ;; a小于等于b的时候进行循环操作\n    (if (not (> a b))\n        (eachInterval each (each a cal) (+ a 1) b)\n        cal\n    )\n)\n```\n&emsp;&emsp;我们可以使用 `lambda` 来方便的传递过程给 `eachInterval`。`lambda`使用的方式是`(lambda (parms) body)`。\n\n```scheme\n;; 计算1+100的值，虽然我们都知道是5050\n(eachInterval (lambda (nowIdx cal) (+ cal nowIdx)) 0 1 100)\n```\n&emsp;&emsp;scheme中还可以使用`let`来创建一个结构代码块。注意，`let`创建的变量仅在`let`结构块中生效。\n\n```scheme\n(let (\n    (val1 exp1)\n    (val2 exp2)\n) body)\n\n;; 这里简单说明一下作用域的例子\n(define x 10)\n(let (\n    (x 3)\n    ;; 此时y赋值时引用的x仍为外部定义的x\n    (y (+ x 2))\n    ;; let 定义的 x 和 y 仅在 body体 当中生效！在参数定义部分使用的话仍然使用的是全局变量的值\n) (* x y))\n```\n## 总结\n&emsp;&emsp;其实本质上，第一章是在介绍 scheme 写法的基本要素。变量声明，定义函数，循环的用法以及高阶函数的用法。但是本书通过抽象的思想把scheme的这些基本语法，站在**程序的设计共通性**的高度上讲解了出来。这就是这本书高明的地方。编程修炼的内功，就是指这些思考吧。\n\n&emsp;&emsp;多去总结共性，抓住本质，是写代码和学习的时候永恒的主题啊。代码中，我们把共同性的部分提炼成函数，加以复用。学习中，共同性的部分能大大加深我们学习的眼界和学习的速度。本章的习题部分挑选了部分习题，放在我的 [github sicp第一章](https://github.com/tangdingga1/sicp) 当中，欢迎来一起学习讨论。\n\n","slug":"scip/sicp(chap1)","published":1,"updated":"2020-06-11T01:43:32.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckba4hhyc002r9r2vq3vrzm73","content":"<h2 id=\"第一章-构造过程抽象\"><a href=\"#第一章-构造过程抽象\" class=\"headerlink\" title=\"第一章 构造过程抽象\"></a>第一章 构造过程抽象</h2><p>本章主要讲述程序<strong>运行过程</strong>的共通抽象部分：</p>\n<ol>\n<li>包括程序设计的基本元素</li>\n<li>过程循环的抽象(迭代和递归)</li>\n<li>抽象过程传递给过程(高阶函数)<a id=\"more\"></a>\n</li>\n</ol>\n<h2 id=\"1-1-程序设计的基本元素\"><a href=\"#1-1-程序设计的基本元素\" class=\"headerlink\" title=\"1.1 程序设计的基本元素\"></a>1.1 程序设计的基本元素</h2><p>&emsp;&emsp;每一种编程语言的设计，都应该具备三种最基本的机制：基本表达式，组合的方法，抽象的方法。</p>\n<p>&emsp;&emsp;所有程序设计中，我们需要关心的永远只有<strong>数据</strong>和<strong>过程</strong>。通俗的讲，平时编写代码，无非就是<strong>变量</strong>和<strong>函数</strong>两个部分组成，函数就是过程，用以操作数据，最后达成我们想要的效果。就前端来说，不管你是写css样式，还是js代码，最终都是把一个具量化的结果，传递到显示终端(浏览器)当中，显示渲染。</p>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><p>&emsp;&emsp;基本表达式实质就是<strong>最简单的词法单元</strong>，也就是碎片化的过程。比如在 scheme 中，输入<code>512</code>，编译器返回<code>512</code>，这就是一个最基本的表达式。书中通过本节简单介绍了 scheme 基本语法。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; (运算符 被运算单元 运算单元 )</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">20</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">20</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">30</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 括号的语法使得运算优先级很明确</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">/</span></span> <span class=\"hljs-number\">20</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">30</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> <span class=\"hljs-number\">10</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">30</span>)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名和环境\"><a href=\"#命名和环境\" class=\"headerlink\" title=\"命名和环境\"></a>命名和环境</h3><p>&emsp;&emsp;最简单的抽象方法，就是给予一个对象<strong>命名</strong>，通过使用名字的方法去进行计算，就是程序设计当中俗称的<strong>变量</strong>。在我的理解当中变量的存在是为了方便代码的<strong>复用</strong>和程序的<strong>可读性</strong>，在日常代码过程当中，变量命名除了一眼就能知道它所代表的的意义外，还要符合变量种类的命名规范(比如常量使用全大写，类名使用大写开头)，有效率的传达到多种意义。</p>\n<p>&emsp;&emsp;变量所能访问到的上下文位置，称为<strong>环境</strong>，也就是我们常说的<strong>作用域</strong>。</p>\n<p>&emsp;&emsp;scheme 当中，使用 <code>(define 变量名 变量值)</code>的方式来进行变量的声明。值得一提的是，scheme 中变量是没有赋值方法的。也就是说，变量永远当做常量来进行使用。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> PI <span class=\"hljs-number\">3.1415926</span>)</span><br><span class=\"line\">PI</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 3.1415926</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"复合过程\"><a href=\"#复合过程\" class=\"headerlink\" title=\"复合过程\"></a>复合过程</h3><p>&emsp;&emsp;定义过程是一种强大的抽象过程，合理的程序设计当中应该存在。定义过程实际上就是一段<strong>表达式</strong>的复用。scheme中我们使用define来定义一个过程<code>(define (name parameters) body)</code>。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 这里我们定义一个求放入两个参数的平方和的过程(函数)</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sum-square</span> par1 par2) </span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span></span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> par1 par1)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> par2 par2)))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 使用函数</span></span><br><span class=\"line\">(<span class=\"hljs-name\">sum-square</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 等同于1 + 4, 5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"过程应用的代换模型\"><a href=\"#过程应用的代换模型\" class=\"headerlink\" title=\"过程应用的代换模型\"></a>过程应用的代换模型</h3><p>&emsp;&emsp;过程的抽象解释，分为<strong>正则序</strong>和<strong>应用序</strong>两种模型。正则序的特征为<strong>完全展开后规约</strong>，而应用序为<strong>先求值参数而后规约</strong>。</p>\n<p>&emsp;&emsp;<strong>正则序</strong>和<strong>应用序</strong>是程序解释器两种解释顺序模型的简单体现。</p>\n<p>&emsp;&emsp;下面是刚才<code>sum-square</code>函数正则序和应用序的示例。<br><figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 调用 sum-square</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> par1 <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">sum-square</span> par1 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">20</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 正则序代换</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"hljs-name\">sum-square</span> par1 (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">20</span>))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 2</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> par1 par1)</span><br><span class=\"line\">    (* (+ 10 20) (+ 10 20))))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 3</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\">    (* (+ 10 20) (+ 10 20))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 应用序代换</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"hljs-name\">sum-square</span> <span class=\"hljs-number\">10</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">20</span>))</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 2</span></span><br><span class=\"line\">(<span class=\"hljs-name\">sum-square</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">30</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 3</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\">    (* 30 30)))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"条件表达式和谓词\"><a href=\"#条件表达式和谓词\" class=\"headerlink\" title=\"条件表达式和谓词\"></a>条件表达式和谓词</h3><p>&emsp;&emsp;条件表达式是增强过程谓词的关键。根据不同的情况执行不同的过程步骤是必要的功能。</p>\n<p>&emsp;&emsp;scheme中有<code>if</code>和<code>cond</code>两种条件语句。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; cond 适用多分支的情况</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> (<span class=\"hljs-name\">p</span> e)</span><br><span class=\"line\">      (<span class=\"hljs-name\">p</span> e)</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> e))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; if 适用于两种情况的模式</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> p e elseE)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 这里用大于0时候加上2，否则减去2为例书写一下 cond 和 if</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 这儿为了展示cond的多分支特性，特意书写=0的情况</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> x <span class=\"hljs-number\">0</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> x <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\">      ((<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> x <span class=\"hljs-number\">0</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> x <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\">      (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">else</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> x <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> x <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> x <span class=\"hljs-number\">2</span>)</span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> x <span class=\"hljs-number\">2</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;scheme还有三个基础的逻辑复合运算符。<code>and not or</code>。运算返回布尔值<code>#t #f</code>。and为一假为假，全真为真。or为一真为真，全假为假，not为取相反。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">and</span></span> e1 ... e2)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> e1)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">or</span></span> e1 ... e2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"过程作为黑箱抽象\"><a href=\"#过程作为黑箱抽象\" class=\"headerlink\" title=\"过程作为黑箱抽象\"></a>过程作为黑箱抽象</h3><p>&emsp;&emsp;过程的封装需要有<strong>黑箱</strong>的抽象概念，即任何使用过程的用户，只需要关心<strong>输入</strong>，和得到的<strong>输出</strong>，不要去关心其他任何的东西。为此，我们可以把过程所用到的东西，封装在过程当中，唯一露出给使用者的就是他所输入的函数。这种结构称之为<strong>块结构</strong>。</p>\n<p>&emsp;&emsp;这里，我们设计一个函数<code>isEven</code>，用户输入一个数字，判断这个数字是否是偶数，是的话反而真，不是返回false。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 函数的思路是一直减少2，直到小于2为止，如果为0，那么是偶数，否则为奇数</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 用户只需要关心输入的 isEven 以及它的返回值 #t #f</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">isEven</span> testNum)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 定义过程，输入一个数字 返回它减2的值</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 这个减2的过程封装在 isEven 当中</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">sub2</span> num) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-</span></span> num <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 递归，如果没有小于2继续</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&lt;</span></span> testNum <span class=\"hljs-number\">2</span>) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> testNum <span class=\"hljs-number\">0</span>)</span><br><span class=\"line\">        (<span class=\"hljs-name\">isEven</span> (<span class=\"hljs-name\">sub2</span> testNum))</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-过程与它们所产生的的计算\"><a href=\"#1-2-过程与它们所产生的的计算\" class=\"headerlink\" title=\"1.2 过程与它们所产生的的计算\"></a>1.2 过程与它们所产生的的计算</h2><p>&emsp;&emsp;这里一小节将重点研究递归循环过程的两种形态，以及如何计算它们的运算复杂度(算法的概念)。</p>\n<h3 id=\"线性的递归和迭代与树形递归的比较\"><a href=\"#线性的递归和迭代与树形递归的比较\" class=\"headerlink\" title=\"线性的递归和迭代与树形递归的比较\"></a>线性的递归和迭代与树形递归的比较</h3><p>&emsp;&emsp;线性的递归，即每一步平行复杂度的递归方式。这里使用一个求数阶乘的函数来说明。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; factorial 输入一个n 求n的阶乘 n! 即 n * (n - 1) * ... 1 </span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">factorial</span> n)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; calnum 当前计算的值</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">;; counter 当前计算到哪一个数字</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">;; max-count 求乘阶的值</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">fact-iter</span> calnum counter max-count)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> counter max-count)</span><br><span class=\"line\">            calnum</span><br><span class=\"line\">            (<span class=\"hljs-name\">fact-iter</span> </span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> calnum counter) </span><br><span class=\"line\">                (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> counter <span class=\"hljs-number\">1</span>) </span><br><span class=\"line\">                max-count)))</span><br><span class=\"line\">    (<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> n)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;上面的<code>factorial</code>函数，在输入6的时候使用应用替换模型进行展开的话，不难发现每一步都是平行复杂度的的。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\">factorial</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; ...以下省略</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;整个运算过程如同一条直线，因此是线性的递归思路。这种迭代写法的特征就是会用一个<strong>专门的值</strong>去保存需要返回计算的值，即<strong>累计器</strong>的概念。</p>\n<p>&emsp;&emsp;下面我们看一下<strong>树形迭代</strong>的概念，用树形迭代的思想来重写<code>factorial</code>函数。<br><figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; factorial-treeway 树形迭代求阶乘</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">factorial-treeway</span> n)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; counter 当前计算到的值</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">;; max-count 求乘阶的值</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">fact-iter</span> counter max-count)</span><br><span class=\"line\">        (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">=</span></span> counter max-count)</span><br><span class=\"line\">            max-count</span><br><span class=\"line\">            (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> counter (<span class=\"hljs-name\">fact-iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> counter <span class=\"hljs-number\">1</span>) max-count))))</span><br><span class=\"line\">    (<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">1</span> n))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们把<code>factorial-treeway</code>用应用序展开。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\">factorial-treeway</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">1</span> (<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">6</span>)) <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">2</span> (<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">6</span>))) <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\">fact-iter</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">1</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">2</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> <span class=\"hljs-number\">3</span> (<span class=\"hljs-name\">fact-iter</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span>)))) <span class=\"hljs-number\">6</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">;; 括号看得我脑壳有点疼，以下过程省略</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们不难看到树型迭代是一个<strong>展开的过程</strong>，而不是像线性递归一样，每一步都是平行前行的。树形迭代的特点就是没有一个特定的变量去保存函数需要返回的值，而是通过到递归终止条件，去进行一个展开的过程。</p>\n<h3 id=\"增长的阶\"><a href=\"#增长的阶\" class=\"headerlink\" title=\"增长的阶\"></a>增长的阶</h3><p>&emsp;&emsp;为了比较两种递归的方法差异，这里书本引入了<code>θ</code>记资源消耗的概念，其实这儿就是<strong>算法复杂度</strong>的思想。</p>\n<p>&emsp;&emsp;我们需要一个抽象的概念去衡量一个程序消耗的资源程度，来规避一些影响条件(如计算机硬件)。这里的<code>θ</code>就相当于算法中的O表示法，表示<strong>一步</strong>程序运行所消耗的资源。比如<code>(+ 1 2)</code>，这里执行了一步程序操作，<code>1+2</code>。这里的消耗就是<code>θ(1)</code>。记总消耗为<code>f(n)</code>，消耗了<code>n步</code>,那么这个公式就可以写成<code>f(n)=θ(n)</code>。</p>\n<p>&emsp;&emsp;具体算法方面的内容，我在 <a href=\"https://github.com/tangdingga1/Algorithm-in-JavaScript\" target=\"_blank\" rel=\"noopener\">github</a> 上面用<code>node</code>写了一个学习的库，感兴趣的可以去看一下，这里就不展开讨论了。</p>\n<h2 id=\"1-3-高阶函数做抽象\"><a href=\"#1-3-高阶函数做抽象\" class=\"headerlink\" title=\"1.3 高阶函数做抽象\"></a>1.3 高阶函数做抽象</h2><p>&emsp;&emsp;这一章主要讲述了高阶函数的函数式编程的概念。所谓高阶函数，就是能把函数作为参数传递给一个函数，并且还能作为返回值来返回一个函数。<code>React</code>当中的高阶组件，其实就是高阶函数的思想组件版。</p>\n<p>&emsp;&emsp;以过程作为参数，返回一个过程，这个过程称为高阶过程。这种强有力的抽象机制，极大的增强语言的表述能力。</p>\n<p>&emsp;&emsp;scheme中为了方便过程的传递，创造了<code>lambda</code>和<code>let</code>的方式来方便进行函数的传递。下面我们来定义一个函数，功能类似于for循环，它能够接收一个过程和一个区间范围，返回过程计算的区间范围的值。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; each 循环的过程</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; cal 累计器的初始值</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; a 起始点</span></span><br><span class=\"line\"><span class=\"hljs-comment\">;; b 结束点</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> (<span class=\"hljs-name\">eachInterval</span> each cal a b)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; a小于等于b的时候进行循环操作</span></span><br><span class=\"line\">    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">not</span></span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">&gt;</span></span> a b))</span><br><span class=\"line\">        (<span class=\"hljs-name\">eachInterval</span> each (<span class=\"hljs-name\">each</span> a cal) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> a <span class=\"hljs-number\">1</span>) b)</span><br><span class=\"line\">        cal</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以使用 <code>lambda</code> 来方便的传递过程给 <code>eachInterval</code>。<code>lambda</code>使用的方式是<code>(lambda (parms) body)</code>。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">;; 计算1+100的值，虽然我们都知道是5050</span></span><br><span class=\"line\">(<span class=\"hljs-name\">eachInterval</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">lambda</span></span> (nowIdx cal) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> cal nowIdx)) <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">100</span>)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;scheme中还可以使用<code>let</code>来创建一个结构代码块。注意，<code>let</code>创建的变量仅在<code>let</code>结构块中生效。</p>\n<figure class=\"highlight scheme hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> (</span><br><span class=\"line\">    (<span class=\"hljs-name\">val1</span> exp1)</span><br><span class=\"line\">    (<span class=\"hljs-name\">val2</span> exp2)</span><br><span class=\"line\">) body)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">;; 这里简单说明一下作用域的例子</span></span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">define</span></span> x <span class=\"hljs-number\">10</span>)</span><br><span class=\"line\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> (</span><br><span class=\"line\">    (<span class=\"hljs-name\">x</span> <span class=\"hljs-number\">3</span>)</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; 此时y赋值时引用的x仍为外部定义的x</span></span><br><span class=\"line\">    (<span class=\"hljs-name\">y</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">+</span></span> x <span class=\"hljs-number\">2</span>))</span><br><span class=\"line\">    <span class=\"hljs-comment\">;; let 定义的 x 和 y 仅在 body体 当中生效！在参数定义部分使用的话仍然使用的是全局变量的值</span></span><br><span class=\"line\">) (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">*</span></span> x y))</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>&emsp;&emsp;其实本质上，第一章是在介绍 scheme 写法的基本要素。变量声明，定义函数，循环的用法以及高阶函数的用法。但是本书通过抽象的思想把scheme的这些基本语法，站在<strong>程序的设计共通性</strong>的高度上讲解了出来。这就是这本书高明的地方。编程修炼的内功，就是指这些思考吧。</p>\n<p>&emsp;&emsp;多去总结共性，抓住本质，是写代码和学习的时候永恒的主题啊。代码中，我们把共同性的部分提炼成函数，加以复用。学习中，共同性的部分能大大加深我们学习的眼界和学习的速度。本章的习题部分挑选了部分习题，放在我的 <a href=\"https://github.com/tangdingga1/sicp\" target=\"_blank\" rel=\"noopener\">github sicp第一章</a> 当中，欢迎来一起学习讨论。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第一章-构造过程抽象\"><a href=\"#第一章-构造过程抽象\" class=\"headerlink\" title=\"第一章 构造过程抽象\"></a>第一章 构造过程抽象</h2><p>本章主要讲述程序<strong>运行过程</strong>的共通抽象部分：</p>\n<ol>\n<li>包括程序设计的基本元素</li>\n<li>过程循环的抽象(迭代和递归)</li>\n<li>抽象过程传递给过程(高阶函数)</li></ol>","more":"</li>\n</ol>\n<h2 id=\"1-1-程序设计的基本元素\"><a href=\"#1-1-程序设计的基本元素\" class=\"headerlink\" title=\"1.1 程序设计的基本元素\"></a>1.1 程序设计的基本元素</h2><p>&emsp;&emsp;每一种编程语言的设计，都应该具备三种最基本的机制：基本表达式，组合的方法，抽象的方法。</p>\n<p>&emsp;&emsp;所有程序设计中，我们需要关心的永远只有<strong>数据</strong>和<strong>过程</strong>。通俗的讲，平时编写代码，无非就是<strong>变量</strong>和<strong>函数</strong>两个部分组成，函数就是过程，用以操作数据，最后达成我们想要的效果。就前端来说，不管你是写css样式，还是js代码，最终都是把一个具量化的结果，传递到显示终端(浏览器)当中，显示渲染。</p>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><p>&emsp;&emsp;基本表达式实质就是<strong>最简单的词法单元</strong>，也就是碎片化的过程。比如在 scheme 中，输入<code>512</code>，编译器返回<code>512</code>，这就是一个最基本的表达式。书中通过本节简单介绍了 scheme 基本语法。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; (运算符 被运算单元 运算单元 )</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">10</span> <span class=\"number\">20</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">10</span> <span class=\"number\">20</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">20</span> <span class=\"number\">30</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">/</span></span> <span class=\"number\">20</span> <span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 括号的语法使得运算优先级很明确</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">/</span></span> <span class=\"number\">20</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">20</span> <span class=\"number\">30</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">10</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">20</span> <span class=\"number\">30</span>)))</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名和环境\"><a href=\"#命名和环境\" class=\"headerlink\" title=\"命名和环境\"></a>命名和环境</h3><p>&emsp;&emsp;最简单的抽象方法，就是给予一个对象<strong>命名</strong>，通过使用名字的方法去进行计算，就是程序设计当中俗称的<strong>变量</strong>。在我的理解当中变量的存在是为了方便代码的<strong>复用</strong>和程序的<strong>可读性</strong>，在日常代码过程当中，变量命名除了一眼就能知道它所代表的的意义外，还要符合变量种类的命名规范(比如常量使用全大写，类名使用大写开头)，有效率的传达到多种意义。</p>\n<p>&emsp;&emsp;变量所能访问到的上下文位置，称为<strong>环境</strong>，也就是我们常说的<strong>作用域</strong>。</p>\n<p>&emsp;&emsp;scheme 当中，使用 <code>(define 变量名 变量值)</code>的方式来进行变量的声明。值得一提的是，scheme 中变量是没有赋值方法的。也就是说，变量永远当做常量来进行使用。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> PI <span class=\"number\">3.1415926</span>)</span><br><span class=\"line\">PI</span><br><span class=\"line\"><span class=\"comment\">;; 3.1415926</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"复合过程\"><a href=\"#复合过程\" class=\"headerlink\" title=\"复合过程\"></a>复合过程</h3><p>&emsp;&emsp;定义过程是一种强大的抽象过程，合理的程序设计当中应该存在。定义过程实际上就是一段<strong>表达式</strong>的复用。scheme中我们使用define来定义一个过程<code>(define (name parameters) body)</code>。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 这里我们定义一个求放入两个参数的平方和的过程(函数)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sum-square</span> par1 par2) </span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">*</span></span> par1 par1)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">*</span></span> par2 par2)))</span><br><span class=\"line\"><span class=\"comment\">;; 使用函数</span></span><br><span class=\"line\">(<span class=\"name\">sum-square</span> <span class=\"number\">1</span> <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">;; 等同于1 + 4, 5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"过程应用的代换模型\"><a href=\"#过程应用的代换模型\" class=\"headerlink\" title=\"过程应用的代换模型\"></a>过程应用的代换模型</h3><p>&emsp;&emsp;过程的抽象解释，分为<strong>正则序</strong>和<strong>应用序</strong>两种模型。正则序的特征为<strong>完全展开后规约</strong>，而应用序为<strong>先求值参数而后规约</strong>。</p>\n<p>&emsp;&emsp;<strong>正则序</strong>和<strong>应用序</strong>是程序解释器两种解释顺序模型的简单体现。</p>\n<p>&emsp;&emsp;下面是刚才<code>sum-square</code>函数正则序和应用序的示例。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 调用 sum-square</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> par1 <span class=\"number\">10</span>)</span><br><span class=\"line\">(<span class=\"name\">sum-square</span> par1 (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">10</span> <span class=\"number\">20</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 正则序代换</span></span><br><span class=\"line\"><span class=\"comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"name\">sum-square</span> par1 (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">10</span> <span class=\"number\">20</span>))</span><br><span class=\"line\"><span class=\"comment\">;; 2</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> par1 par1)</span><br><span class=\"line\">    (* (+ 10 20) (+ 10 20))))</span><br><span class=\"line\"><span class=\"comment\">;; 3</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">10</span> <span class=\"number\">10</span>)</span><br><span class=\"line\">    (* (+ 10 20) (+ 10 20))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 应用序代换</span></span><br><span class=\"line\"><span class=\"comment\">;; 1</span></span><br><span class=\"line\">(<span class=\"name\">sum-square</span> <span class=\"number\">10</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">10</span> <span class=\"number\">20</span>))</span><br><span class=\"line\"><span class=\"comment\">;; 2</span></span><br><span class=\"line\">(<span class=\"name\">sum-square</span> <span class=\"number\">10</span> <span class=\"number\">30</span>)</span><br><span class=\"line\"><span class=\"comment\">;; 3</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">10</span> <span class=\"number\">10</span>)</span><br><span class=\"line\">    (* 30 30)))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"条件表达式和谓词\"><a href=\"#条件表达式和谓词\" class=\"headerlink\" title=\"条件表达式和谓词\"></a>条件表达式和谓词</h3><p>&emsp;&emsp;条件表达式是增强过程谓词的关键。根据不同的情况执行不同的过程步骤是必要的功能。</p>\n<p>&emsp;&emsp;scheme中有<code>if</code>和<code>cond</code>两种条件语句。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; cond 适用多分支的情况</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\">p</span> e)</span><br><span class=\"line\">      (<span class=\"name\">p</span> e)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> e))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; if 适用于两种情况的模式</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> p e elseE)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 这里用大于0时候加上2，否则减去2为例书写一下 cond 和 if</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 这儿为了展示cond的多分支特性，特意书写=0的情况</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">cond</span></span> ((<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> x <span class=\"number\">0</span>) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">2</span>))</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">2</span>))</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">2</span>))</span><br><span class=\"line\">)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">2</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">2</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;scheme还有三个基础的逻辑复合运算符。<code>and not or</code>。运算返回布尔值<code>#t #f</code>。and为一假为假，全真为真。or为一真为真，全假为假，not为取相反。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">and</span></span> e1 ... e2)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">not</span></span> e1)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">or</span></span> e1 ... e2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"过程作为黑箱抽象\"><a href=\"#过程作为黑箱抽象\" class=\"headerlink\" title=\"过程作为黑箱抽象\"></a>过程作为黑箱抽象</h3><p>&emsp;&emsp;过程的封装需要有<strong>黑箱</strong>的抽象概念，即任何使用过程的用户，只需要关心<strong>输入</strong>，和得到的<strong>输出</strong>，不要去关心其他任何的东西。为此，我们可以把过程所用到的东西，封装在过程当中，唯一露出给使用者的就是他所输入的函数。这种结构称之为<strong>块结构</strong>。</p>\n<p>&emsp;&emsp;这里，我们设计一个函数<code>isEven</code>，用户输入一个数字，判断这个数字是否是偶数，是的话反而真，不是返回false。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 函数的思路是一直减少2，直到小于2为止，如果为0，那么是偶数，否则为奇数</span></span><br><span class=\"line\"><span class=\"comment\">;; 用户只需要关心输入的 isEven 以及它的返回值 #t #f</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">isEven</span> testNum)</span><br><span class=\"line\">    <span class=\"comment\">;; 定义过程，输入一个数字 返回它减2的值</span></span><br><span class=\"line\">    <span class=\"comment\">;; 这个减2的过程封装在 isEven 当中</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">sub2</span> num) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> num <span class=\"number\">2</span>))</span><br><span class=\"line\">    <span class=\"comment\">;; 递归，如果没有小于2继续</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> testNum <span class=\"number\">2</span>) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> testNum <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\">isEven</span> (<span class=\"name\">sub2</span> testNum))</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-过程与它们所产生的的计算\"><a href=\"#1-2-过程与它们所产生的的计算\" class=\"headerlink\" title=\"1.2 过程与它们所产生的的计算\"></a>1.2 过程与它们所产生的的计算</h2><p>&emsp;&emsp;这里一小节将重点研究递归循环过程的两种形态，以及如何计算它们的运算复杂度(算法的概念)。</p>\n<h3 id=\"线性的递归和迭代与树形递归的比较\"><a href=\"#线性的递归和迭代与树形递归的比较\" class=\"headerlink\" title=\"线性的递归和迭代与树形递归的比较\"></a>线性的递归和迭代与树形递归的比较</h3><p>&emsp;&emsp;线性的递归，即每一步平行复杂度的递归方式。这里使用一个求数阶乘的函数来说明。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; factorial 输入一个n 求n的阶乘 n! 即 n * (n - 1) * ... 1 </span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">factorial</span> n)</span><br><span class=\"line\">    <span class=\"comment\">;; calnum 当前计算的值</span></span><br><span class=\"line\">    <span class=\"comment\">;; counter 当前计算到哪一个数字</span></span><br><span class=\"line\">    <span class=\"comment\">;; max-count 求乘阶的值</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">fact-iter</span> calnum counter max-count)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> counter max-count)</span><br><span class=\"line\">            calnum</span><br><span class=\"line\">            (<span class=\"name\">fact-iter</span> </span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">*</span></span> calnum counter) </span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">+</span></span> counter <span class=\"number\">1</span>) </span><br><span class=\"line\">                max-count)))</span><br><span class=\"line\">    (<span class=\"name\">fact-iter</span> <span class=\"number\">1</span> <span class=\"number\">1</span> n)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;上面的<code>factorial</code>函数，在输入6的时候使用应用替换模型进行展开的话，不难发现每一步都是平行复杂度的的。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">factorial</span> <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> <span class=\"number\">6</span> <span class=\"number\">4</span> <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"comment\">;; ...以下省略</span></span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;整个运算过程如同一条直线，因此是线性的递归思路。这种迭代写法的特征就是会用一个<strong>专门的值</strong>去保存需要返回计算的值，即<strong>累计器</strong>的概念。</p>\n<p>&emsp;&emsp;下面我们看一下<strong>树形迭代</strong>的概念，用树形迭代的思想来重写<code>factorial</code>函数。<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; factorial-treeway 树形迭代求阶乘</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">factorial-treeway</span> n)</span><br><span class=\"line\">    <span class=\"comment\">;; counter 当前计算到的值</span></span><br><span class=\"line\">    <span class=\"comment\">;; max-count 求乘阶的值</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">fact-iter</span> counter max-count)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> counter max-count)</span><br><span class=\"line\">            max-count</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">*</span></span> counter (<span class=\"name\">fact-iter</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> counter <span class=\"number\">1</span>) max-count))))</span><br><span class=\"line\">    (<span class=\"name\">fact-iter</span> <span class=\"number\">1</span> n))</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;我们把<code>factorial-treeway</code>用应用序展开。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">factorial-treeway</span> <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> <span class=\"number\">1</span> <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">1</span> (<span class=\"name\">fact-iter</span> <span class=\"number\">2</span> <span class=\"number\">6</span>)) <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">2</span> (<span class=\"name\">fact-iter</span> <span class=\"number\">3</span> <span class=\"number\">6</span>))) <span class=\"number\">6</span>)</span><br><span class=\"line\">(<span class=\"name\">fact-iter</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">2</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">3</span> (<span class=\"name\">fact-iter</span> <span class=\"number\">4</span> <span class=\"number\">6</span>)))) <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"comment\">;; 括号看得我脑壳有点疼，以下过程省略</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们不难看到树型迭代是一个<strong>展开的过程</strong>，而不是像线性递归一样，每一步都是平行前行的。树形迭代的特点就是没有一个特定的变量去保存函数需要返回的值，而是通过到递归终止条件，去进行一个展开的过程。</p>\n<h3 id=\"增长的阶\"><a href=\"#增长的阶\" class=\"headerlink\" title=\"增长的阶\"></a>增长的阶</h3><p>&emsp;&emsp;为了比较两种递归的方法差异，这里书本引入了<code>θ</code>记资源消耗的概念，其实这儿就是<strong>算法复杂度</strong>的思想。</p>\n<p>&emsp;&emsp;我们需要一个抽象的概念去衡量一个程序消耗的资源程度，来规避一些影响条件(如计算机硬件)。这里的<code>θ</code>就相当于算法中的O表示法，表示<strong>一步</strong>程序运行所消耗的资源。比如<code>(+ 1 2)</code>，这里执行了一步程序操作，<code>1+2</code>。这里的消耗就是<code>θ(1)</code>。记总消耗为<code>f(n)</code>，消耗了<code>n步</code>,那么这个公式就可以写成<code>f(n)=θ(n)</code>。</p>\n<p>&emsp;&emsp;具体算法方面的内容，我在 <a href=\"https://github.com/tangdingga1/Algorithm-in-JavaScript\" target=\"_blank\" rel=\"noopener\">github</a> 上面用<code>node</code>写了一个学习的库，感兴趣的可以去看一下，这里就不展开讨论了。</p>\n<h2 id=\"1-3-高阶函数做抽象\"><a href=\"#1-3-高阶函数做抽象\" class=\"headerlink\" title=\"1.3 高阶函数做抽象\"></a>1.3 高阶函数做抽象</h2><p>&emsp;&emsp;这一章主要讲述了高阶函数的函数式编程的概念。所谓高阶函数，就是能把函数作为参数传递给一个函数，并且还能作为返回值来返回一个函数。<code>React</code>当中的高阶组件，其实就是高阶函数的思想组件版。</p>\n<p>&emsp;&emsp;以过程作为参数，返回一个过程，这个过程称为高阶过程。这种强有力的抽象机制，极大的增强语言的表述能力。</p>\n<p>&emsp;&emsp;scheme中为了方便过程的传递，创造了<code>lambda</code>和<code>let</code>的方式来方便进行函数的传递。下面我们来定义一个函数，功能类似于for循环，它能够接收一个过程和一个区间范围，返回过程计算的区间范围的值。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; each 循环的过程</span></span><br><span class=\"line\"><span class=\"comment\">;; cal 累计器的初始值</span></span><br><span class=\"line\"><span class=\"comment\">;; a 起始点</span></span><br><span class=\"line\"><span class=\"comment\">;; b 结束点</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> (<span class=\"name\">eachInterval</span> each cal a b)</span><br><span class=\"line\">    <span class=\"comment\">;; a小于等于b的时候进行循环操作</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> a b))</span><br><span class=\"line\">        (<span class=\"name\">eachInterval</span> each (<span class=\"name\">each</span> a cal) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> a <span class=\"number\">1</span>) b)</span><br><span class=\"line\">        cal</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们可以使用 <code>lambda</code> 来方便的传递过程给 <code>eachInterval</code>。<code>lambda</code>使用的方式是<code>(lambda (parms) body)</code>。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; 计算1+100的值，虽然我们都知道是5050</span></span><br><span class=\"line\">(<span class=\"name\">eachInterval</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (nowIdx cal) (<span class=\"name\"><span class=\"builtin-name\">+</span></span> cal nowIdx)) <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;scheme中还可以使用<code>let</code>来创建一个结构代码块。注意，<code>let</code>创建的变量仅在<code>let</code>结构块中生效。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> (</span><br><span class=\"line\">    (<span class=\"name\">val1</span> exp1)</span><br><span class=\"line\">    (<span class=\"name\">val2</span> exp2)</span><br><span class=\"line\">) body)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;; 这里简单说明一下作用域的例子</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> x <span class=\"number\">10</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> (</span><br><span class=\"line\">    (<span class=\"name\">x</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"comment\">;; 此时y赋值时引用的x仍为外部定义的x</span></span><br><span class=\"line\">    (<span class=\"name\">y</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">2</span>))</span><br><span class=\"line\">    <span class=\"comment\">;; let 定义的 x 和 y 仅在 body体 当中生效！在参数定义部分使用的话仍然使用的是全局变量的值</span></span><br><span class=\"line\">) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>&emsp;&emsp;其实本质上，第一章是在介绍 scheme 写法的基本要素。变量声明，定义函数，循环的用法以及高阶函数的用法。但是本书通过抽象的思想把scheme的这些基本语法，站在<strong>程序的设计共通性</strong>的高度上讲解了出来。这就是这本书高明的地方。编程修炼的内功，就是指这些思考吧。</p>\n<p>&emsp;&emsp;多去总结共性，抓住本质，是写代码和学习的时候永恒的主题啊。代码中，我们把共同性的部分提炼成函数，加以复用。学习中，共同性的部分能大大加深我们学习的眼界和学习的速度。本章的习题部分挑选了部分习题，放在我的 <a href=\"https://github.com/tangdingga1/sicp\" target=\"_blank\" rel=\"noopener\">github sicp第一章</a> 当中，欢迎来一起学习讨论。</p>"},{"title":"async await的多异步处理方式","date":"2020-07-23T11:00:00.000Z","_content":"&emsp;&emsp;写爬虫时候遇到的批量异步处理的一些思考和总结。\n<!--more-->\n## async/await是什么\n&emsp;&emsp;`async/await`是ES2017加入的标准，它允许用同步的**写法**来进行**异步**的操作，它的本质是ES6引入的`Promise`和`Generator`函数的语法糖。\n\n```javascript\nasync function sleepy() {\n  await sleep(1000, 'I awake');\n  await sleep(500, 'and sleep');\n  console.log('awake now');\n  return 0;\n}\n\n/**\n * @params {number} sleepTime\n * @params {string} awakeText\n * @params {string} error\n * @returns Promise<pending>\n*/\nfunction sleep(sleepTime, awakeText, error) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(awakeText);\n      if (error) {\n        reject(error);\n      } else {\n        resolve(awakeText);\n      }\n    }, sleepTime);\n  });\n}\n```\n\n&emsp;&emsp;通过`async`前缀定义一个特殊函数，在函数的内部可以使用`await`关键字来接一个`Promise`类型的值，按照从上到下的顺序来执行函数。先通过`setTimeout`和`Promise`定义一个最简单的异步函数`sleep`。\n\n&emsp;&emsp;执行`sleepy`函数之后，会按照顺序输出`I awake -> and sleep -> awake now`。\n\n&emsp;&emsp;前文也说到了`async/await`实质上是`Promise`和`Generator`的语法糖，上文的`sleepy`可以改写成如下形式：\n```javascript\nfunction *sleepy() {\n  yield sleep(1000, 'I awake');\n  yield sleep(500, 'and sleep');\n  console.log('awake now');\n}\n```\n\n## 批量处理异步请求\n&emsp;&emsp;实际过程中，批量处理异步请求时常常会遇到与期望不符的情况。我们假设存在复数的请求，我们需要得到这些请求的值。\n\n```javascript\n// sleepy 异步的请求\nconst requests = new Array(10).fill(sleepy);\nconst results = requests.map(async (request) => await request()); // [Promise<pending>]\n```\n\n&emsp;&emsp;上面的例子尝试将数组中复数的请求通过map方法返回所有请求的结果来进行批量处理，实际上得到的只能是一个`pending`状态的`Promise`数组。其实我们很容易想到这样产生的原因，`map`等一系列数组方法是在`ES5`版本加入的，当时没有`Promise`的提案，更没有`async/await`。当时的`map`方法应该是直接执行传入的函数。\n\n\n```javascript\n// map 的简单实现\nArray.prototype.map = function (handler) {\n  let result = [];\n  for(var i = 0; i < this.length; i++) {\n    result.push(\n      handler(this[i], i, this)\n    );\n  }\n  return handler;\n}\n```\n\n&emsp;&emsp;但是既然既然返回的是`Promise<pending>[]`类型，其实可以很简单的使用`Promise.all`的 api 来完成想要操作的结果。\n\n```javascript\nPromise.all(\n  requests.map(request => request())\n)\n  .then(results => { /* 省略继续的逻辑 */ });\n```\n\n&emsp;&emsp;这样能够实现并发多个请求，并在所有请求处理完毕后返回处理结果数组的需求。而在我自己的爬虫项目中，需要打开很多个详情页并爬取对应的数据。如果同时并发请求，在数据量大的情况话，可能顺时切开上百个详情页。此时需要顺序完成请求操作。\n\n```javascript\n(async function () {\n  const result = [];\n  while (requests.length) {\n    const res = await awaitAwait(bottle.length);\n    result.push(res);\n    requests.shift();\n  }\n})();\n```\n\n&emsp;&emsp;因为await关键字只能在`async`函数定义中有效。因此使用`IIFE`来产生async函数环境，达成次序执行的目的。\n","source":"_posts/js/async.md","raw":"---\ntitle: async await的多异步处理方式\ndate: 2020/7/23 19:00\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;写爬虫时候遇到的批量异步处理的一些思考和总结。\n<!--more-->\n## async/await是什么\n&emsp;&emsp;`async/await`是ES2017加入的标准，它允许用同步的**写法**来进行**异步**的操作，它的本质是ES6引入的`Promise`和`Generator`函数的语法糖。\n\n```javascript\nasync function sleepy() {\n  await sleep(1000, 'I awake');\n  await sleep(500, 'and sleep');\n  console.log('awake now');\n  return 0;\n}\n\n/**\n * @params {number} sleepTime\n * @params {string} awakeText\n * @params {string} error\n * @returns Promise<pending>\n*/\nfunction sleep(sleepTime, awakeText, error) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(awakeText);\n      if (error) {\n        reject(error);\n      } else {\n        resolve(awakeText);\n      }\n    }, sleepTime);\n  });\n}\n```\n\n&emsp;&emsp;通过`async`前缀定义一个特殊函数，在函数的内部可以使用`await`关键字来接一个`Promise`类型的值，按照从上到下的顺序来执行函数。先通过`setTimeout`和`Promise`定义一个最简单的异步函数`sleep`。\n\n&emsp;&emsp;执行`sleepy`函数之后，会按照顺序输出`I awake -> and sleep -> awake now`。\n\n&emsp;&emsp;前文也说到了`async/await`实质上是`Promise`和`Generator`的语法糖，上文的`sleepy`可以改写成如下形式：\n```javascript\nfunction *sleepy() {\n  yield sleep(1000, 'I awake');\n  yield sleep(500, 'and sleep');\n  console.log('awake now');\n}\n```\n\n## 批量处理异步请求\n&emsp;&emsp;实际过程中，批量处理异步请求时常常会遇到与期望不符的情况。我们假设存在复数的请求，我们需要得到这些请求的值。\n\n```javascript\n// sleepy 异步的请求\nconst requests = new Array(10).fill(sleepy);\nconst results = requests.map(async (request) => await request()); // [Promise<pending>]\n```\n\n&emsp;&emsp;上面的例子尝试将数组中复数的请求通过map方法返回所有请求的结果来进行批量处理，实际上得到的只能是一个`pending`状态的`Promise`数组。其实我们很容易想到这样产生的原因，`map`等一系列数组方法是在`ES5`版本加入的，当时没有`Promise`的提案，更没有`async/await`。当时的`map`方法应该是直接执行传入的函数。\n\n\n```javascript\n// map 的简单实现\nArray.prototype.map = function (handler) {\n  let result = [];\n  for(var i = 0; i < this.length; i++) {\n    result.push(\n      handler(this[i], i, this)\n    );\n  }\n  return handler;\n}\n```\n\n&emsp;&emsp;但是既然既然返回的是`Promise<pending>[]`类型，其实可以很简单的使用`Promise.all`的 api 来完成想要操作的结果。\n\n```javascript\nPromise.all(\n  requests.map(request => request())\n)\n  .then(results => { /* 省略继续的逻辑 */ });\n```\n\n&emsp;&emsp;这样能够实现并发多个请求，并在所有请求处理完毕后返回处理结果数组的需求。而在我自己的爬虫项目中，需要打开很多个详情页并爬取对应的数据。如果同时并发请求，在数据量大的情况话，可能顺时切开上百个详情页。此时需要顺序完成请求操作。\n\n```javascript\n(async function () {\n  const result = [];\n  while (requests.length) {\n    const res = await awaitAwait(bottle.length);\n    result.push(res);\n    requests.shift();\n  }\n})();\n```\n\n&emsp;&emsp;因为await关键字只能在`async`函数定义中有效。因此使用`IIFE`来产生async函数环境，达成次序执行的目的。\n","slug":"js/async","published":1,"updated":"2020-08-10T11:18:31.650Z","_id":"ckcyi7puz0001f12v2w4i2qs4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>&emsp;&emsp;写爬虫时候遇到的批量异步处理的一些思考和总结。<br><a id=\"more\"></a></p>\n<h2 id=\"async-await是什么\"><a href=\"#async-await是什么\" class=\"headerlink\" title=\"async/await是什么\"></a>async/await是什么</h2><p>&emsp;&emsp;<code>async/await</code>是ES2017加入的标准，它允许用同步的<strong>写法</strong>来进行<strong>异步</strong>的操作，它的本质是ES6引入的<code>Promise</code>和<code>Generator</code>函数的语法糖。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sleepy</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">await</span> sleep(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">'I awake'</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">await</span> sleep(<span class=\"hljs-number\">500</span>, <span class=\"hljs-string\">'and sleep'</span>);</span><br><span class=\"line\">  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'awake now'</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@params <span class=\"hljs-type\">&#123;number&#125;</span> <span class=\"hljs-variable\">sleepTime</span></span></span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@params <span class=\"hljs-type\">&#123;string&#125;</span> <span class=\"hljs-variable\">awakeText</span></span></span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@params <span class=\"hljs-type\">&#123;string&#125;</span> <span class=\"hljs-variable\">error</span></span></span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns </span>Promise&lt;pending&gt;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">*/</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sleep</span>(<span class=\"hljs-params\">sleepTime, awakeText, error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-built_in\">console</span>.log(awakeText);</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        reject(error);</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(awakeText);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, sleepTime);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;通过<code>async</code>前缀定义一个特殊函数，在函数的内部可以使用<code>await</code>关键字来接一个<code>Promise</code>类型的值，按照从上到下的顺序来执行函数。先通过<code>setTimeout</code>和<code>Promise</code>定义一个最简单的异步函数<code>sleep</code>。</p>\n<p>&emsp;&emsp;执行<code>sleepy</code>函数之后，会按照顺序输出<code>I awake -&gt; and sleep -&gt; awake now</code>。</p>\n<p>&emsp;&emsp;前文也说到了<code>async/await</code>实质上是<code>Promise</code>和<code>Generator</code>的语法糖，上文的<code>sleepy</code>可以改写成如下形式：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">sleepy</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">yield</span> sleep(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">'I awake'</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">yield</span> sleep(<span class=\"hljs-number\">500</span>, <span class=\"hljs-string\">'and sleep'</span>);</span><br><span class=\"line\">  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'awake now'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"批量处理异步请求\"><a href=\"#批量处理异步请求\" class=\"headerlink\" title=\"批量处理异步请求\"></a>批量处理异步请求</h2><p>&emsp;&emsp;实际过程中，批量处理异步请求时常常会遇到与期望不符的情况。我们假设存在复数的请求，我们需要得到这些请求的值。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// sleepy 异步的请求</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> requests = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">10</span>).fill(sleepy);</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> results = requests.map(<span class=\"hljs-keyword\">async</span> (request) =&gt; <span class=\"hljs-keyword\">await</span> request()); <span class=\"hljs-comment\">// [Promise&lt;pending&gt;]</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面的例子尝试将数组中复数的请求通过map方法返回所有请求的结果来进行批量处理，实际上得到的只能是一个<code>pending</code>状态的<code>Promise</code>数组。其实我们很容易想到这样产生的原因，<code>map</code>等一系列数组方法是在<code>ES5</code>版本加入的，当时没有<code>Promise</code>的提案，更没有<code>async/await</code>。当时的<code>map</code>方法应该是直接执行传入的函数。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// map 的简单实现</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Array</span>.prototype.map = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> result = [];</span><br><span class=\"line\">  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">    result.push(</span><br><span class=\"line\">      handler(<span class=\"hljs-keyword\">this</span>[i], i, <span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;但是既然既然返回的是<code>Promise&lt;pending&gt;[]</code>类型，其实可以很简单的使用<code>Promise.all</code>的 api 来完成想要操作的结果。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">Promise</span>.all(</span><br><span class=\"line\">  requests.map(<span class=\"hljs-function\"><span class=\"hljs-params\">request</span> =&gt;</span> request())</span><br><span class=\"line\">)</span><br><span class=\"line\">  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">results</span> =&gt;</span> &#123; <span class=\"hljs-comment\">/* 省略继续的逻辑 */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样能够实现并发多个请求，并在所有请求处理完毕后返回处理结果数组的需求。而在我自己的爬虫项目中，需要打开很多个详情页并爬取对应的数据。如果同时并发请求，在数据量大的情况话，可能顺时切开上百个详情页。此时需要顺序完成请求操作。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (requests.length) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> awaitAwait(bottle.length);</span><br><span class=\"line\">    result.push(res);</span><br><span class=\"line\">    requests.shift();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;因为await关键字只能在<code>async</code>函数定义中有效。因此使用<code>IIFE</code>来产生async函数环境，达成次序执行的目的。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;写爬虫时候遇到的批量异步处理的一些思考和总结。<br></p>","more":"</p>\n<h2 id=\"async-await是什么\"><a href=\"#async-await是什么\" class=\"headerlink\" title=\"async/await是什么\"></a>async/await是什么</h2><p>&emsp;&emsp;<code>async/await</code>是ES2017加入的标准，它允许用同步的<strong>写法</strong>来进行<strong>异步</strong>的操作，它的本质是ES6引入的<code>Promise</code>和<code>Generator</code>函数的语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleepy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> sleep(<span class=\"number\">1000</span>, <span class=\"string\">'I awake'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> sleep(<span class=\"number\">500</span>, <span class=\"string\">'and sleep'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'awake now'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@params <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">sleepTime</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@params <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">awakeText</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@params <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">error</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns </span>Promise&lt;pending&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">sleepTime, awakeText, error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(awakeText);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        reject(error);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(awakeText);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, sleepTime);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;通过<code>async</code>前缀定义一个特殊函数，在函数的内部可以使用<code>await</code>关键字来接一个<code>Promise</code>类型的值，按照从上到下的顺序来执行函数。先通过<code>setTimeout</code>和<code>Promise</code>定义一个最简单的异步函数<code>sleep</code>。</p>\n<p>&emsp;&emsp;执行<code>sleepy</code>函数之后，会按照顺序输出<code>I awake -&gt; and sleep -&gt; awake now</code>。</p>\n<p>&emsp;&emsp;前文也说到了<code>async/await</code>实质上是<code>Promise</code>和<code>Generator</code>的语法糖，上文的<code>sleepy</code>可以改写成如下形式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">sleepy</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> sleep(<span class=\"number\">1000</span>, <span class=\"string\">'I awake'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> sleep(<span class=\"number\">500</span>, <span class=\"string\">'and sleep'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'awake now'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"批量处理异步请求\"><a href=\"#批量处理异步请求\" class=\"headerlink\" title=\"批量处理异步请求\"></a>批量处理异步请求</h2><p>&emsp;&emsp;实际过程中，批量处理异步请求时常常会遇到与期望不符的情况。我们假设存在复数的请求，我们需要得到这些请求的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sleepy 异步的请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> requests = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10</span>).fill(sleepy);</span><br><span class=\"line\"><span class=\"keyword\">const</span> results = requests.map(<span class=\"keyword\">async</span> (request) =&gt; <span class=\"keyword\">await</span> request()); <span class=\"comment\">// [Promise&lt;pending&gt;]</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面的例子尝试将数组中复数的请求通过map方法返回所有请求的结果来进行批量处理，实际上得到的只能是一个<code>pending</code>状态的<code>Promise</code>数组。其实我们很容易想到这样产生的原因，<code>map</code>等一系列数组方法是在<code>ES5</code>版本加入的，当时没有<code>Promise</code>的提案，更没有<code>async/await</code>。当时的<code>map</code>方法应该是直接执行传入的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map 的简单实现</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++) &#123;</span><br><span class=\"line\">    result.push(</span><br><span class=\"line\">      handler(<span class=\"keyword\">this</span>[i], i, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;但是既然既然返回的是<code>Promise&lt;pending&gt;[]</code>类型，其实可以很简单的使用<code>Promise.all</code>的 api 来完成想要操作的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.all(</span><br><span class=\"line\">  requests.map(<span class=\"function\"><span class=\"params\">request</span> =&gt;</span> request())</span><br><span class=\"line\">)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">results</span> =&gt;</span> &#123; <span class=\"comment\">/* 省略继续的逻辑 */</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样能够实现并发多个请求，并在所有请求处理完毕后返回处理结果数组的需求。而在我自己的爬虫项目中，需要打开很多个详情页并爬取对应的数据。如果同时并发请求，在数据量大的情况话，可能顺时切开上百个详情页。此时需要顺序完成请求操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (requests.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> awaitAwait(bottle.length);</span><br><span class=\"line\">    result.push(res);</span><br><span class=\"line\">    requests.shift();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;因为await关键字只能在<code>async</code>函数定义中有效。因此使用<code>IIFE</code>来产生async函数环境，达成次序执行的目的。</p>"},{"title":"记一次个人站优化","date":"2020-08-30T11:00:00.000Z","_content":"&emsp;&emsp;贫穷限制了我的服务器带宽，但增长了我对资源处理的知识。\n<!--more-->\n# 缓慢的开始\n&emsp;&emsp;一次偶然中，我发现我的个人站打开需要长达半分多种的时间，吓得我赶紧打开Network看一下到底是什么问题导致的。\n\nName | Size | Time\n---|---|---\ntime.gif | 83.7kb | 3.87s\nmain.js | 1.68mb | 31s\n\n&emsp;&emsp;事实上问题再简单不过了，资源过大了。自己自费的服务器仅仅有1M的带宽，意味着传输的每秒的极限值只能达到100kb。在硬件配置无法提升的情况下，只能通过软件的调整来进行对应的优化了。\n\n# 优化\n## 大体思路\n&emsp;&emsp;web的优化一直是不存在标准答案的，是因为 web 在不同的应用场景下，优化的思路是不同的。但大体上思路可以归纳为**预加载**和**懒加载**两个。\n\n&emsp;&emsp;比如**单页应用/hash路由**的技术，将多个页面打包成一个资源，在用户进行web应用操作的时候实际上网页已经加载完毕了，用户切换页面时不会进行对应**资源**的请求，只会进行一些页面数据请求和局部的更新，保证用户操作的流畅。实际上这是**预加载**的思路。\n\n&emsp;&emsp;在诸如淘宝等商城首页经常会用到**懒加载**的优化思路。即不加载全量的资源，仅仅加载用户当前所需要的资源。在用户进行诸如滚动列表操作的时候，再去请求剩下的资源，与上一种优化思路相反。这种优化思路强调的是**首屏时间**，即把资源快速展现给用户，留住用户的眼球。\n\n&emsp;&emsp;虽然文章开头陈述的场景毫无疑问的需要进行**懒加载**的优化思路，但在实际项目过程中，经常会把两种思路相结合，以针对不同的路径。\n\n## 交互上\n&emsp;&emsp;在我的理解概念中，前端应该是最**贴近用户**的程序员。用户行为交互上的优化不失为一个很好的办法。\n\n&emsp;&emsp;试想一下，当你打开一个网站，如果是一个空白的页面没有任何提示信息时，你能耐心等待几秒。如果是一个量化加载情况进度条，你的耐心值是不是会上升很多呢。实际上可以更进一步，在大型游戏场景加载中，屏幕中间经常会轮番滚动一些场景介绍或者提示文案，让用户**有事可做**，以此来间接掩盖加载的冗长时间。\n\n&emsp;&emsp;在服务器1M带宽的情况下，我尝试在html中加入一个loading图标（一个滚动的小章鱼），并把html和图片资源控制在100kb以内，以便实现首屏的秒现。然后加载完毕的 html 再会去拉取诸如js、css的资源。\n\n## 资源的转移\n### 媒体\n&emsp;&emsp;在自身硬件条件有限的情况下，利用别人的硬件来实现功能，未尝不是一个明智的选择。一个网站中，大型的资源文件往往不是代码，而是图片视频等媒体文件。这些媒体资源文件有一个特征，就是不会受到**跨域**的限制，可以随意引入。\n\n&emsp;&emsp;虽然资源可以随意引入，但这就意味着你把资源的控制权转交到了别人的手上。如果你引入资源的服务器不可靠，很可能会给你带来难以想象的灾难。因此这边推荐媒体的文件引入使用**大型官网**或者**图床**来进行解决。\n\n&emsp;&emsp;**大型官网**的特征就是公司维度，公开，每天需要面对万级别的资源访问。这样的情况决定了**大型官网**的资源变动和调整及其的谨慎规范。因此去**大型官网**上面扒一些资源的链接来直接引入不失为一个好办法。\n\n&emsp;&emsp;**图床**实际上就是一个静态资源服务器站，它能够上传资源，生成对应的连接，供给来使用。简单来说，就是把资源放到别人的服务器上面去管，需要的时候去别人那里拿。但是对应的好用的**图床**大多数都需要收费，免费的**图床**都对功能做了诸如访问量访问速度的诸多限制。但是对一个小型的个人网站来说，已经足够使用了。\n\n&emsp;&emsp;在我的个人站中，**兴趣使然**上做了很多平时游戏相关的小工具。对应的背景图片，视频等资源，都是直接通过上对应的游戏官网，或者对应的游戏微博官方运营号来进行连接的扒取和使用。\n\n### 代码cdn\n&emsp;&emsp;cdn是一种静态资源部署的技术，当访问者获取某个资源的时候，能够找到离访问者最近的服务器返回对应的资源给访问者。而把代码中官方的库和框架抽出来使用cdn的方式剥离，对服务器进行减压。\n\n&emsp;&emsp;webpack 的 externals 配置就是典型的优化方式。你可以在webpack的配置文件中，指定前端的代码依赖从外部获取。\n\n```javascript\nmodule.exports = {\n  externals: {\n    'react': 'React',\n  },\n}\n```\n&emsp;&emsp;进行这个配置项之后，代码中存在`import xx from 'react'`部分，webpack将不会从`node_modules`中引用`react`进行打包，而是会去全局\n找`React`的变量进行引入。你可以在对应的`index.html`中使用`<script src=\"引入资源\" />`来直接进行`react.js`的代码引入。前端的官方库的cdn大多都可以在`cdnjs.com`这个网站上找到。\n\n# 结束\n&emsp;&emsp;通过把`react/react-dom/echart`等大型的官方库转移到cdn，网站的js体积缩小了一倍，加载时间也变为一半。并且在页面加载时会有可爱的章鱼在告诉你页面是 loading 状态。顺便把对应的大型图片转移到了免费的图床上面，虽然免费受限图床的加载速度会很慢。我在首页加载完成之后变回去预加载请求这些图片资源，利用浏览器缓存特性把资源缓存下来，这样在后续切换页面加载图片时就不会产生卡顿的感觉。\n","source":"_posts/js/external.md","raw":"---\ntitle: 记一次个人站优化\ndate: 2020/8/30 19:00\ncategories:\n- [前端, JavaScript]\ntags:\n- 知识点整理\n---\n&emsp;&emsp;贫穷限制了我的服务器带宽，但增长了我对资源处理的知识。\n<!--more-->\n# 缓慢的开始\n&emsp;&emsp;一次偶然中，我发现我的个人站打开需要长达半分多种的时间，吓得我赶紧打开Network看一下到底是什么问题导致的。\n\nName | Size | Time\n---|---|---\ntime.gif | 83.7kb | 3.87s\nmain.js | 1.68mb | 31s\n\n&emsp;&emsp;事实上问题再简单不过了，资源过大了。自己自费的服务器仅仅有1M的带宽，意味着传输的每秒的极限值只能达到100kb。在硬件配置无法提升的情况下，只能通过软件的调整来进行对应的优化了。\n\n# 优化\n## 大体思路\n&emsp;&emsp;web的优化一直是不存在标准答案的，是因为 web 在不同的应用场景下，优化的思路是不同的。但大体上思路可以归纳为**预加载**和**懒加载**两个。\n\n&emsp;&emsp;比如**单页应用/hash路由**的技术，将多个页面打包成一个资源，在用户进行web应用操作的时候实际上网页已经加载完毕了，用户切换页面时不会进行对应**资源**的请求，只会进行一些页面数据请求和局部的更新，保证用户操作的流畅。实际上这是**预加载**的思路。\n\n&emsp;&emsp;在诸如淘宝等商城首页经常会用到**懒加载**的优化思路。即不加载全量的资源，仅仅加载用户当前所需要的资源。在用户进行诸如滚动列表操作的时候，再去请求剩下的资源，与上一种优化思路相反。这种优化思路强调的是**首屏时间**，即把资源快速展现给用户，留住用户的眼球。\n\n&emsp;&emsp;虽然文章开头陈述的场景毫无疑问的需要进行**懒加载**的优化思路，但在实际项目过程中，经常会把两种思路相结合，以针对不同的路径。\n\n## 交互上\n&emsp;&emsp;在我的理解概念中，前端应该是最**贴近用户**的程序员。用户行为交互上的优化不失为一个很好的办法。\n\n&emsp;&emsp;试想一下，当你打开一个网站，如果是一个空白的页面没有任何提示信息时，你能耐心等待几秒。如果是一个量化加载情况进度条，你的耐心值是不是会上升很多呢。实际上可以更进一步，在大型游戏场景加载中，屏幕中间经常会轮番滚动一些场景介绍或者提示文案，让用户**有事可做**，以此来间接掩盖加载的冗长时间。\n\n&emsp;&emsp;在服务器1M带宽的情况下，我尝试在html中加入一个loading图标（一个滚动的小章鱼），并把html和图片资源控制在100kb以内，以便实现首屏的秒现。然后加载完毕的 html 再会去拉取诸如js、css的资源。\n\n## 资源的转移\n### 媒体\n&emsp;&emsp;在自身硬件条件有限的情况下，利用别人的硬件来实现功能，未尝不是一个明智的选择。一个网站中，大型的资源文件往往不是代码，而是图片视频等媒体文件。这些媒体资源文件有一个特征，就是不会受到**跨域**的限制，可以随意引入。\n\n&emsp;&emsp;虽然资源可以随意引入，但这就意味着你把资源的控制权转交到了别人的手上。如果你引入资源的服务器不可靠，很可能会给你带来难以想象的灾难。因此这边推荐媒体的文件引入使用**大型官网**或者**图床**来进行解决。\n\n&emsp;&emsp;**大型官网**的特征就是公司维度，公开，每天需要面对万级别的资源访问。这样的情况决定了**大型官网**的资源变动和调整及其的谨慎规范。因此去**大型官网**上面扒一些资源的链接来直接引入不失为一个好办法。\n\n&emsp;&emsp;**图床**实际上就是一个静态资源服务器站，它能够上传资源，生成对应的连接，供给来使用。简单来说，就是把资源放到别人的服务器上面去管，需要的时候去别人那里拿。但是对应的好用的**图床**大多数都需要收费，免费的**图床**都对功能做了诸如访问量访问速度的诸多限制。但是对一个小型的个人网站来说，已经足够使用了。\n\n&emsp;&emsp;在我的个人站中，**兴趣使然**上做了很多平时游戏相关的小工具。对应的背景图片，视频等资源，都是直接通过上对应的游戏官网，或者对应的游戏微博官方运营号来进行连接的扒取和使用。\n\n### 代码cdn\n&emsp;&emsp;cdn是一种静态资源部署的技术，当访问者获取某个资源的时候，能够找到离访问者最近的服务器返回对应的资源给访问者。而把代码中官方的库和框架抽出来使用cdn的方式剥离，对服务器进行减压。\n\n&emsp;&emsp;webpack 的 externals 配置就是典型的优化方式。你可以在webpack的配置文件中，指定前端的代码依赖从外部获取。\n\n```javascript\nmodule.exports = {\n  externals: {\n    'react': 'React',\n  },\n}\n```\n&emsp;&emsp;进行这个配置项之后，代码中存在`import xx from 'react'`部分，webpack将不会从`node_modules`中引用`react`进行打包，而是会去全局\n找`React`的变量进行引入。你可以在对应的`index.html`中使用`<script src=\"引入资源\" />`来直接进行`react.js`的代码引入。前端的官方库的cdn大多都可以在`cdnjs.com`这个网站上找到。\n\n# 结束\n&emsp;&emsp;通过把`react/react-dom/echart`等大型的官方库转移到cdn，网站的js体积缩小了一倍，加载时间也变为一半。并且在页面加载时会有可爱的章鱼在告诉你页面是 loading 状态。顺便把对应的大型图片转移到了免费的图床上面，虽然免费受限图床的加载速度会很慢。我在首页加载完成之后变回去预加载请求这些图片资源，利用浏览器缓存特性把资源缓存下来，这样在后续切换页面加载图片时就不会产生卡顿的感觉。\n","slug":"js/external","published":1,"updated":"2020-09-22T07:49:10.190Z","_id":"ckeh3cmls0004xi2vypy2857p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>&emsp;&emsp;贫穷限制了我的服务器带宽，但增长了我对资源处理的知识。<br><a id=\"more\"></a></p>\n<h1 id=\"缓慢的开始\"><a href=\"#缓慢的开始\" class=\"headerlink\" title=\"缓慢的开始\"></a>缓慢的开始</h1><p>&emsp;&emsp;一次偶然中，我发现我的个人站打开需要长达半分多种的时间，吓得我赶紧打开Network看一下到底是什么问题导致的。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Size</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>time.gif</td>\n<td>83.7kb</td>\n<td>3.87s</td>\n</tr>\n<tr>\n<td>main.js</td>\n<td>1.68mb</td>\n<td>31s</td>\n</tr>\n</tbody>\n</table>\n<p>&emsp;&emsp;事实上问题再简单不过了，资源过大了。自己自费的服务器仅仅有1M的带宽，意味着传输的每秒的极限值只能达到100kb。在硬件配置无法提升的情况下，只能通过软件的调整来进行对应的优化了。</p>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><h2 id=\"大体思路\"><a href=\"#大体思路\" class=\"headerlink\" title=\"大体思路\"></a>大体思路</h2><p>&emsp;&emsp;web的优化一直是不存在标准答案的，是因为 web 在不同的应用场景下，优化的思路是不同的。但大体上思路可以归纳为<strong>预加载</strong>和<strong>懒加载</strong>两个。</p>\n<p>&emsp;&emsp;比如<strong>单页应用/hash路由</strong>的技术，将多个页面打包成一个资源，在用户进行web应用操作的时候实际上网页已经加载完毕了，用户切换页面时不会进行对应<strong>资源</strong>的请求，只会进行一些页面数据请求和局部的更新，保证用户操作的流畅。实际上这是<strong>预加载</strong>的思路。</p>\n<p>&emsp;&emsp;在诸如淘宝等商城首页经常会用到<strong>懒加载</strong>的优化思路。即不加载全量的资源，仅仅加载用户当前所需要的资源。在用户进行诸如滚动列表操作的时候，再去请求剩下的资源，与上一种优化思路相反。这种优化思路强调的是<strong>首屏时间</strong>，即把资源快速展现给用户，留住用户的眼球。</p>\n<p>&emsp;&emsp;虽然文章开头陈述的场景毫无疑问的需要进行<strong>懒加载</strong>的优化思路，但在实际项目过程中，经常会把两种思路相结合，以针对不同的路径。</p>\n<h2 id=\"交互上\"><a href=\"#交互上\" class=\"headerlink\" title=\"交互上\"></a>交互上</h2><p>&emsp;&emsp;在我的理解概念中，前端应该是最<strong>贴近用户</strong>的程序员。用户行为交互上的优化不失为一个很好的办法。</p>\n<p>&emsp;&emsp;试想一下，当你打开一个网站，如果是一个空白的页面没有任何提示信息时，你能耐心等待几秒。如果是一个量化加载情况进度条，你的耐心值是不是会上升很多呢。实际上可以更进一步，在大型游戏场景加载中，屏幕中间经常会轮番滚动一些场景介绍或者提示文案，让用户<strong>有事可做</strong>，以此来间接掩盖加载的冗长时间。</p>\n<p>&emsp;&emsp;在服务器1M带宽的情况下，我尝试在html中加入一个loading图标（一个滚动的小章鱼），并把html和图片资源控制在100kb以内，以便实现首屏的秒现。然后加载完毕的 html 再会去拉取诸如js、css的资源。</p>\n<h2 id=\"资源的转移\"><a href=\"#资源的转移\" class=\"headerlink\" title=\"资源的转移\"></a>资源的转移</h2><h3 id=\"媒体\"><a href=\"#媒体\" class=\"headerlink\" title=\"媒体\"></a>媒体</h3><p>&emsp;&emsp;在自身硬件条件有限的情况下，利用别人的硬件来实现功能，未尝不是一个明智的选择。一个网站中，大型的资源文件往往不是代码，而是图片视频等媒体文件。这些媒体资源文件有一个特征，就是不会受到<strong>跨域</strong>的限制，可以随意引入。</p>\n<p>&emsp;&emsp;虽然资源可以随意引入，但这就意味着你把资源的控制权转交到了别人的手上。如果你引入资源的服务器不可靠，很可能会给你带来难以想象的灾难。因此这边推荐媒体的文件引入使用<strong>大型官网</strong>或者<strong>图床</strong>来进行解决。</p>\n<p>&emsp;&emsp;<strong>大型官网</strong>的特征就是公司维度，公开，每天需要面对万级别的资源访问。这样的情况决定了<strong>大型官网</strong>的资源变动和调整及其的谨慎规范。因此去<strong>大型官网</strong>上面扒一些资源的链接来直接引入不失为一个好办法。</p>\n<p>&emsp;&emsp;<strong>图床</strong>实际上就是一个静态资源服务器站，它能够上传资源，生成对应的连接，供给来使用。简单来说，就是把资源放到别人的服务器上面去管，需要的时候去别人那里拿。但是对应的好用的<strong>图床</strong>大多数都需要收费，免费的<strong>图床</strong>都对功能做了诸如访问量访问速度的诸多限制。但是对一个小型的个人网站来说，已经足够使用了。</p>\n<p>&emsp;&emsp;在我的个人站中，<strong>兴趣使然</strong>上做了很多平时游戏相关的小工具。对应的背景图片，视频等资源，都是直接通过上对应的游戏官网，或者对应的游戏微博官方运营号来进行连接的扒取和使用。</p>\n<h3 id=\"代码cdn\"><a href=\"#代码cdn\" class=\"headerlink\" title=\"代码cdn\"></a>代码cdn</h3><p>&emsp;&emsp;cdn是一种静态资源部署的技术，当访问者获取某个资源的时候，能够找到离访问者最近的服务器返回对应的资源给访问者。而把代码中官方的库和框架抽出来使用cdn的方式剥离，对服务器进行减压。</p>\n<p>&emsp;&emsp;webpack 的 externals 配置就是典型的优化方式。你可以在webpack的配置文件中，指定前端的代码依赖从外部获取。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    <span class=\"hljs-string\">'react'</span>: <span class=\"hljs-string\">'React'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;进行这个配置项之后，代码中存在<code>import xx from &#39;react&#39;</code>部分，webpack将不会从<code>node_modules</code>中引用<code>react</code>进行打包，而是会去全局<br>找<code>React</code>的变量进行引入。你可以在对应的<code>index.html</code>中使用<code>&lt;script src=&quot;引入资源&quot; /&gt;</code>来直接进行<code>react.js</code>的代码引入。前端的官方库的cdn大多都可以在<code>cdnjs.com</code>这个网站上找到。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>&emsp;&emsp;通过把<code>react/react-dom/echart</code>等大型的官方库转移到cdn，网站的js体积缩小了一倍，加载时间也变为一半。并且在页面加载时会有可爱的章鱼在告诉你页面是 loading 状态。顺便把对应的大型图片转移到了免费的图床上面，虽然免费受限图床的加载速度会很慢。我在首页加载完成之后变回去预加载请求这些图片资源，利用浏览器缓存特性把资源缓存下来，这样在后续切换页面加载图片时就不会产生卡顿的感觉。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;贫穷限制了我的服务器带宽，但增长了我对资源处理的知识。<br></p>","more":"</p>\n<h1 id=\"缓慢的开始\"><a href=\"#缓慢的开始\" class=\"headerlink\" title=\"缓慢的开始\"></a>缓慢的开始</h1><p>&emsp;&emsp;一次偶然中，我发现我的个人站打开需要长达半分多种的时间，吓得我赶紧打开Network看一下到底是什么问题导致的。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Size</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>time.gif</td>\n<td>83.7kb</td>\n<td>3.87s</td>\n</tr>\n<tr>\n<td>main.js</td>\n<td>1.68mb</td>\n<td>31s</td>\n</tr>\n</tbody>\n</table>\n<p>&emsp;&emsp;事实上问题再简单不过了，资源过大了。自己自费的服务器仅仅有1M的带宽，意味着传输的每秒的极限值只能达到100kb。在硬件配置无法提升的情况下，只能通过软件的调整来进行对应的优化了。</p>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><h2 id=\"大体思路\"><a href=\"#大体思路\" class=\"headerlink\" title=\"大体思路\"></a>大体思路</h2><p>&emsp;&emsp;web的优化一直是不存在标准答案的，是因为 web 在不同的应用场景下，优化的思路是不同的。但大体上思路可以归纳为<strong>预加载</strong>和<strong>懒加载</strong>两个。</p>\n<p>&emsp;&emsp;比如<strong>单页应用/hash路由</strong>的技术，将多个页面打包成一个资源，在用户进行web应用操作的时候实际上网页已经加载完毕了，用户切换页面时不会进行对应<strong>资源</strong>的请求，只会进行一些页面数据请求和局部的更新，保证用户操作的流畅。实际上这是<strong>预加载</strong>的思路。</p>\n<p>&emsp;&emsp;在诸如淘宝等商城首页经常会用到<strong>懒加载</strong>的优化思路。即不加载全量的资源，仅仅加载用户当前所需要的资源。在用户进行诸如滚动列表操作的时候，再去请求剩下的资源，与上一种优化思路相反。这种优化思路强调的是<strong>首屏时间</strong>，即把资源快速展现给用户，留住用户的眼球。</p>\n<p>&emsp;&emsp;虽然文章开头陈述的场景毫无疑问的需要进行<strong>懒加载</strong>的优化思路，但在实际项目过程中，经常会把两种思路相结合，以针对不同的路径。</p>\n<h2 id=\"交互上\"><a href=\"#交互上\" class=\"headerlink\" title=\"交互上\"></a>交互上</h2><p>&emsp;&emsp;在我的理解概念中，前端应该是最<strong>贴近用户</strong>的程序员。用户行为交互上的优化不失为一个很好的办法。</p>\n<p>&emsp;&emsp;试想一下，当你打开一个网站，如果是一个空白的页面没有任何提示信息时，你能耐心等待几秒。如果是一个量化加载情况进度条，你的耐心值是不是会上升很多呢。实际上可以更进一步，在大型游戏场景加载中，屏幕中间经常会轮番滚动一些场景介绍或者提示文案，让用户<strong>有事可做</strong>，以此来间接掩盖加载的冗长时间。</p>\n<p>&emsp;&emsp;在服务器1M带宽的情况下，我尝试在html中加入一个loading图标（一个滚动的小章鱼），并把html和图片资源控制在100kb以内，以便实现首屏的秒现。然后加载完毕的 html 再会去拉取诸如js、css的资源。</p>\n<h2 id=\"资源的转移\"><a href=\"#资源的转移\" class=\"headerlink\" title=\"资源的转移\"></a>资源的转移</h2><h3 id=\"媒体\"><a href=\"#媒体\" class=\"headerlink\" title=\"媒体\"></a>媒体</h3><p>&emsp;&emsp;在自身硬件条件有限的情况下，利用别人的硬件来实现功能，未尝不是一个明智的选择。一个网站中，大型的资源文件往往不是代码，而是图片视频等媒体文件。这些媒体资源文件有一个特征，就是不会受到<strong>跨域</strong>的限制，可以随意引入。</p>\n<p>&emsp;&emsp;虽然资源可以随意引入，但这就意味着你把资源的控制权转交到了别人的手上。如果你引入资源的服务器不可靠，很可能会给你带来难以想象的灾难。因此这边推荐媒体的文件引入使用<strong>大型官网</strong>或者<strong>图床</strong>来进行解决。</p>\n<p>&emsp;&emsp;<strong>大型官网</strong>的特征就是公司维度，公开，每天需要面对万级别的资源访问。这样的情况决定了<strong>大型官网</strong>的资源变动和调整及其的谨慎规范。因此去<strong>大型官网</strong>上面扒一些资源的链接来直接引入不失为一个好办法。</p>\n<p>&emsp;&emsp;<strong>图床</strong>实际上就是一个静态资源服务器站，它能够上传资源，生成对应的连接，供给来使用。简单来说，就是把资源放到别人的服务器上面去管，需要的时候去别人那里拿。但是对应的好用的<strong>图床</strong>大多数都需要收费，免费的<strong>图床</strong>都对功能做了诸如访问量访问速度的诸多限制。但是对一个小型的个人网站来说，已经足够使用了。</p>\n<p>&emsp;&emsp;在我的个人站中，<strong>兴趣使然</strong>上做了很多平时游戏相关的小工具。对应的背景图片，视频等资源，都是直接通过上对应的游戏官网，或者对应的游戏微博官方运营号来进行连接的扒取和使用。</p>\n<h3 id=\"代码cdn\"><a href=\"#代码cdn\" class=\"headerlink\" title=\"代码cdn\"></a>代码cdn</h3><p>&emsp;&emsp;cdn是一种静态资源部署的技术，当访问者获取某个资源的时候，能够找到离访问者最近的服务器返回对应的资源给访问者。而把代码中官方的库和框架抽出来使用cdn的方式剥离，对服务器进行减压。</p>\n<p>&emsp;&emsp;webpack 的 externals 配置就是典型的优化方式。你可以在webpack的配置文件中，指定前端的代码依赖从外部获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  externals: &#123;</span><br><span class=\"line\">    <span class=\"string\">'react'</span>: <span class=\"string\">'React'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;进行这个配置项之后，代码中存在<code>import xx from &#39;react&#39;</code>部分，webpack将不会从<code>node_modules</code>中引用<code>react</code>进行打包，而是会去全局<br>找<code>React</code>的变量进行引入。你可以在对应的<code>index.html</code>中使用<code>&lt;script src=&quot;引入资源&quot; /&gt;</code>来直接进行<code>react.js</code>的代码引入。前端的官方库的cdn大多都可以在<code>cdnjs.com</code>这个网站上找到。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>&emsp;&emsp;通过把<code>react/react-dom/echart</code>等大型的官方库转移到cdn，网站的js体积缩小了一倍，加载时间也变为一半。并且在页面加载时会有可爱的章鱼在告诉你页面是 loading 状态。顺便把对应的大型图片转移到了免费的图床上面，虽然免费受限图床的加载速度会很慢。我在首页加载完成之后变回去预加载请求这些图片资源，利用浏览器缓存特性把资源缓存下来，这样在后续切换页面加载图片时就不会产生卡顿的感觉。</p>"},{"title":"建造属于你的react","date":"2020-09-22T06:40:00.000Z","_content":"&emsp;&emsp;转载自翻自Rodrigo Pombo的博文[Build your own React](https://pomb.us/build-your-own-react/)。\n<!--more-->\n\n&emsp;&emsp;我们将一步一步重建一个属于我们自己的react。我们的react架构将和真实的react架构相同，但是去掉了大部分的优化和一些目前不必要的功能。\n\n接下来我们将逐步在自己的react中实现这些能力:\n1. [createElement函数](#createElement)\n2. [render函数](#render)\n3. [Concurrent Mode](#concurrent)\n4. [Fibers（虚拟dom结构）](#fiber)\n5. [Render 和 Commit 阶段](#renderandcommit)\n6. [Reconciliation（调和）](#reconciliation)\n7. [函数组件](#functionalComponent)\n8. [Hooks](#hooks)\n\n\n## 步骤0 回顾\n&emsp;&emsp;实现这些功能前，我们需要回顾一些基本的概念。如果你早就对 `react` , `JSX` 和 `dom` 元素之间的关系以及工作原理了然于胸的话，你可以跳过这个章节。\n\n\n```javascript\nconst element = <h1 title=\"foo\">Hello</h1>\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n&emsp;&emsp;我们将使用这个仅有三行代码的 react 应用来回顾基本概念。第一行代码定义了一个 react 元素，第二行代码从 `document` 中获取到了一个 `dom` 节点。最后把 react 元素渲染到dom节点上面。\n\n&emsp;&emsp;**现在让我们把所有 react 特有的代码部分（jsx）移除，全部替换为原版的js代码。**\n\n&emsp;&emsp;第一行代码我们通过 jsx 语法来定义的元素（h1），不是合法的原生js语法。因此我们需要替换掉 jsx 的部分。\n\n&emsp;&emsp;jsx 转换为 原生 js 需要通过一些诸如`babel`的编译工具。编译的过程通常十分简单，把所有元素标签部分所有内容转换为 `createElement` 函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。\n\n\n```javascript\n// 替换 const element = <h1 title=\"foo\">Hello</h1>\nconst element = React.createElement(\n  \"h1\",\n  { title: \"foo\" },\n  \"Hello\"\n)\n```\n\n&emsp;&emsp;`React.createElement` 通过传入的参数（标签名、prop、children）简单验证后创建一个对象，它的功能就是这么简单。所以我们可以放心的把变量 `element` 的内容直接等价替换为 `createElement` 函数返回值。\n\n```javascript\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n```\n&emsp;&emsp;其实 `element` 的值你可以简单看成一个拥有 `type` 和 `props` 的 key 的对象。（其实还有其它的属性，但是目前我们只关心这两项。点击[这里](https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111)查看详细结构。）\n\n&emsp;&emsp;`element` 中的 `type` 对应你想要创建的 `dom` 元素，就像你使用 `document.createElement` 去创建 `HTML` 元素时传递的标签名参数是一样的。但在 `React.createElement` 中，你还可以传递一个函数给 `type`，详细的部分我们将在第7步来操作。\n\n&emsp;&emsp;`prop`属性对应的是一个对象，它把 `jsx` 上面的所有定义的属性通过*键值对*的方式保存起来。其中还包含一个特殊的属性，`children`属性。在上面的例子中， `children` 是一个字符串类型的值，但在实际使用中，经常为多个以数组形式保存的 `dom/jsx` 元素，这也是为什么我们的元素集经常以`树`的数据结构保存。\n\n&emsp;&emsp;另外一个`react`相关代码需要替换的是`ReactDOM.render`。`render` 函数把 `react` 转换为 `dom`，现在让我们来自己实现这个转换过程。\n\n\n```javascript\n// 替换 ReactDOM.render(element, container)\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n&emsp;&emsp;首先我们创建一个 dom 节点，在上面的例子是`h1`。然后我们把所有相关属性同步到 dom 节点上，在上面例子中仅仅有一个 title。\n\n&emsp;&emsp;接着我们为 dom 节点创建子节点。我们现在仅有字符串类型的文本类型节点需要创建。我们后面都将使用文本节点（textNode）的方式来代替直接插入子节点（innerHTML），这种方式就好像你在 prop 上面定义 nodeValue 值一样：`props: {nodeValue: \"hello\"}`。\n\n&emsp;&emsp;最后我们往 h1 中加入 textNode ，然后往 container 中加入 h1 节点。\n\n```javascript\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n​\nconst container = document.getElementById(\"root\")\n​\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n​\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n​\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n\n&emsp;&emsp;现在我们有了一个去掉所有 react 相关代码的与刚开始功能一致的 demo 应用。\n\n<a name=\"createElement\"></a>\n\n## 步骤1 createElement 函数\n\n```javascript\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n&emsp;&emsp;现在我们从一个新的应用重新开始，这次我们将全部用自己版本的代码来替换 react 代码，现在来实现一个我们自己的`createElement`函数。首先我们来把上面代码部分的jsx替换成`createElement`函数。\n\n```javascript\nconst element = React.createElement(\n  \"div\",\n  { id: \"foo\" },\n  React.createElement(\"a\", null, \"bar\"),\n  React.createElement(\"b\")\n)\n```\n\n&emsp;&emsp;正如我们上一步所说的，一个`react element`实际上就是一个拥有`type`和`props`属性的对象，所以在`createElement`函数中我们唯一需要去做的就是创建这个对象。\n\n&emsp;&emsp;我们使用**对象展开符**来把 `props` 的属性同步到所需要创建的对象的 `props` 上，然后，然后使用 `rest` 语法来把函数剩余的所有入参都作为 `children` 拿过来。这样子在创建的对象上面，`children`将始终为数组。\n\n```javascript\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children,\n    },\n  }\n}\n```\n\n&emsp;&emsp;我们来举几个例子：\n```javascript\n// 使用 createElement(\"div\")，返回：\n{\n  \"type\": \"div\",\n  \"props\": { \"children\": [] }\n}\n// 使用 createElement(\"div\", null, a)， 返回：\n{\n  \"type\": \"div\",\n  \"props\": { \"children\": [a] }\n}\n\n// 使用 createElement(\"div\", null, a, b)，返回：\n{\n  \"type\": \"div\",\n  \"props\": { \"children\": [a, b] }\n}\n```\n\n&emsp;&emsp;`children`数组出了 dom 元素之外，还可以包含一些基本类型的值，比如*字符串*或者*数字*。我们用一个特殊的类型 `TEXT_ELEMENT` 来把这些不是对象子节点给包装成对象类型。\n\n```javascript\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n```\n\n&emsp;&emsp;在实际的 react 代码中是不会去把这些基本类型或者空节点给包装成对象的，但是我们这样去做，以便简化我们后续的代码。\n\n&emsp;&emsp;现在我们来把我们自己写的`createElement`函数替换react的`createElement`， 完成这个步骤需要给我们的库命一个名，我们就叫它`Didact`。但是我们代码还是在使用jsx，如果告诉编译器使用`Didact.createElement`来代替`React.createElement`呢，我们只需要加上下面的注释即可。\n\n```javascript\n/** @jsx Didact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\n```\n<a name=\"render\"></a>\n\n## 步骤2 `render`函数\n&emsp;&emsp;我们现在来写我们自己的 `ReactDOM.render` 函数。\n\n&emsp;&emsp;我们现在先只考虑往 `document` 上面**添加**元素，而不去考虑**更新**或者**删除**元素。\n\n&emsp;&emsp;我们根据 `react element` 上面的 `type` 属性创建一个 dom 元素，然后往`container`中添加节点。我们根据这个思路，来递归的完成所有的子节点的添加。\n\n```javascript\nfunction render(element, container) {\n  const dom = document.createElement(element.type)\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n  container.appendChild(dom)\n}\n```\n&emsp;&emsp;我们需要单独处理文本类型的元素（基本类型元素），如果元素的 `type` 为 `TEXT_ELEMENT`，我们单独为其创建一个文本节点。修改 `dom` 创建如下：\n\n```javascript\nconst dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n```\n\n&emsp;&emsp;最后我们需要把`react element`上的 props 同步到真实的 `dom` 元素上面。\n```javascript\nconst isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n```\n\n&emsp;&emsp;到这一步为止我们有了一个简单的从jsx转换到真实dom的库，你可以在[codesandbox](https://codesandbox.io/s/didact-2-k6rbj)上面尝试这个库。\n\n<a name=\"concurrent\"></a>\n## 步骤3 Concurrent Mode\n&emsp;&emsp;在我们添加新的功能前，我们需要重构一下我们之前的代码。主要在递归调用添加子节点的那部分代码。\n\n&emsp;&emsp;一旦我们开始`rendering`(把 react element 渲染成真实dom)，我们在整个 react element 树递归完成前都不能停止。如果元素树过于庞大，这个渲染过程将会占用主线程过长时间。如果此时浏览器需要去做一些高响应级的操作（如响应用户输入或者运行一些动画特效）将会在渲染完成前产生卡顿。\n\n&emsp;&emsp;因此我们把工作拆成一个个小的单元，每个单元工作完成后我们查看一下浏览器是否有更重要的工作，如果有就打断当前的渲染循环。\n\n\n```javascript\nlet nextUnitOfWork = null\n​\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n  requestIdleCallback(workLoop)\n}\n​\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(nextUnitOfWork) {\n  // TODO\n}\n```\n\n&emsp;&emsp;我们使用[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)这个浏览器api来完成循环。你可以把`requestIdleCallback`理解为近似于`setTimeout`类似的功能(指把任务放置到当前微任务最后)，但是不同的是`requestIdleCallback`会在浏览器会在主线程空闲的时候执行回调函数，而不是和`setTimeout`一样指定一个执行时间。\n\n&emsp;&emsp;react不再使用[requestIdleCallback](https://github.com/facebook/react/issues/11171#issuecomment-417349573)，它在[scheduler package](https://github.com/facebook/react/tree/master/packages/scheduler)中实现了和`requestIdleCallback`一样的功能。\n\n&emsp;&emsp;`requestIdleCallback`同时给我们提供了一个`deadline`的参数，我们可以用它来确认在浏览器接管线程前我们到底有多少时间。\n\n&emsp;&emsp;在直到`2019年11月`的时候 `Concurrent Mode` 在react内部还没有达到一个稳固的版本。稳固版本的代码类似于下面：\n\n```javascript\nwhile (nextUnitOfWork) {\n  nextUnitOfWork = performUnitOfWork(\n    nextUnitOfWork\n  )\n}\n```\n\n&emsp;&emsp;为了实现上面的循环，我们需要完成 `performUnitOfWork` 函数。`performUnitOfWork` 函数除了执行一个小单元的工作外，还需要返回下一个需要被执行的单元工作。\n\n<a name=\"fiber\"></a>\n\n## 步骤4 Fibers\n&emsp;&emsp;为了更好的实现单元工作（unit of work）我们需要引入名为 `fiber` 的数据结构。每一个`react element`都将对应一个`fiber`结构，每一个`fiber`结构都对应一个单元的工作。\n\n&emsp;&emsp;来看下面的例子，我们有这样的一个需要渲染的`元素树`：\n\n```javascript\nDidact.render(\n  <div>\n    <h1>\n      <p />\n      <a />\n    </h1>\n    <h2 />\n  </div>,\n  container\n)\n```\n&emsp;&emsp;上面结构映射成 `fiber` 树后大体为下图结构：\n![](https://pic.downk.cc/item/5f72dabf160a154a6768717d.png)\n\n&emsp;&emsp;在 `render` 中我们需要创建`root fiber`（根fiber）然后在 `nextUnitOfWork` 中设置它。剩下的工作将在 `performUnitOfWork` 函数中完成，我们将对每一个 `fiber` 节点做三件事：\n1. 把 `react element` 渲染到 dom 上。\n2. 给`react element`子节点创建`fiber`节点。\n3. 选择下一个的单元工作。\n\n&emsp;&emsp;`fiber` 结构的一个重要的目标是非常容易找到下一个单元工作，这也是为什么每一个 `fiber` 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 `fiber` 上面的工作后，`fiber` 拥有 `child` 属性可以直接指向下一个需要进行工作的 `fiber` 节点。\n\n&emsp;&emsp;在我们的例子中，当我们在第一个 `div` 节点完成更新任务后，`div` 的下一个单元工作将通过 `child` 属性指向`h1`。\n\n&emsp;&emsp;如果 `fiber` 节点没有子节点（即没有 `child` 属性），我们使用 `sibling` 属性（兄弟节点）作为下一个工作单元。在上面的例子中`p`节点没有 `child` 属性，所以我们通过 `sibling` 找到相邻节点 `a` 作为下一个工作单元。\n\n&emsp;&emsp;当 `fiber` 节点没有`child`也没兄弟节点时，我们去他们的*叔叔*（父节点的兄弟节点）节点，就像上图中的最下面的`a`节点到`h2`节点。如果`fiber`的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次`render`我们完成了所有的工作。\n\n&emsp;&emsp;现在我们来把这些思路用代码实现。\n\n&emsp;&emsp;首先我们移除上面写的 `render` 函数中的所有代码，把它们移到 `createDom` 函数中，后续需要使用。\n\n```javascript\nfunction createDom(fiber) {\n  const dom =\n    fiber.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type)\n​\n  const isProperty = key => key !== \"children\"\n  Object.keys(fiber.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = fiber.props[name]\n    })\n​\n  return dom\n}\n​\nfunction render(element, container) {\n  // TODO set next unit of work\n}\n​\nlet nextUnitOfWork = null\n```\n\n&emsp;&emsp;在`render`函数中我们设置 `nextUnitOfWork` 为 `fiber root` 节点。\n\n```javascript\nfunction render(element, container) {\n  nextUnitOfWork = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n}\n​\nlet nextUnitOfWork = null\n```\n\n&emsp;&emsp;这样当浏览器空闲的时候会调用我们之前写好的 `workLoop` 开始在 `root` 节点上面的工作。\n\n&emsp;&emsp;首先我们创建一个 dom 节点然后添加到 document 上面。然后我们在 fiber 上添加 **dom** 属性来链接到这个真实的 dom 元素。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n​\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n​\n  // TODO create new fibers\n  // TODO return next unit of work\n}\n```\n\n&emsp;&emsp;然后我们循环给所有的子节点创建新的 `fiber` 节点。我们把这些 `fiber` 节点根据是否为**第一个子节点**添加到 `fiber root` 的 `child` 或者`sibling`上面。\n\n\n```javascript\n// TODO create new fibers part\nconst elements = fiber.props.children\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\n  const element = elements[index]\n​    // 创建新 fiber\n  const newFiber = {\n    type: element.type,\n    props: element.props,\n    parent: fiber,\n    dom: null,\n  }\n  // 根据是否为第一个节点，添加到对应的 child / sibling 上面\n  if (index === 0) {\n    fiber.child = newFiber\n  } else {\n    prevSibling.sibling = newFiber\n  }\n​\n  prevSibling = newFiber\n  index++\n}\n```\n\n&emsp;&emsp;最后我们到最后一个部分，返回下一个工作单元。我们先尝试找child节点，然后是兄弟节点，然后是父节点的兄弟节点，继续往上直到结束。\n\n```javascript\n// TODO return next unit of work part\nif (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n&emsp;&emsp;三个连起来就是完整的 `performUnitOfWork` 函数实现。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n​\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n​\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n​\n  while (index < elements.length) {\n    const element = elements[index]\n​\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n​\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n​\n    prevSibling = newFiber\n    index++\n  }\n​\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n<a name=\"renderandcommit\"></a>\n\n## 步骤5 `Render` 和 `Commit` 阶段\n&emsp;&emsp;我们现在又有了一个新问题。\n\n&emsp;&emsp;在上面的实现中，我们在每一个工作单元中添加 `node` 节点到 `document` 上面。但是我们在设计`render`的时候，浏览器可以随时在繁忙的时候打断我们的工作，这样我们可能会看到一个不完整的 `ui` 渲染，我们可不希望这样。\n\n&emsp;&emsp;所以我们删除`performUnitOfWork`中这行添加 `node` 的操作。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  // ... 省略\n  /* 删除 */\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n  /* 删除 */\n  // ... 省略\n}\n```\n\n&emsp;&emsp;取而代之的，我们添加一个名为`wipRoot`或者`work in progress root`的`fiber`来记录 `fiber` 节点的循环更新的节点。一旦我们完成了所有的工作（即不存在 next unit of work）的时候，我们一次性把整个 fiber 树更新到 document 上面。\n\n```javascript\nfunction commitRoot() {\n  // TODO add nodes to dom\n}\n\nfunction render(element, container) {\n  // 流程树\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n  nextUnitOfWork = wipRoot\n}\n\nlet nextUnitOfWork = null\nlet wipRoot = null\n\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n​  // 一次性全部提交\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot()\n  }\n​\n  requestIdleCallback(workLoop)\n}\n```\n\n&emsp;&emsp;我们把这个提交所有 `fiber` 树过程在全新的函数 `commitRoot` 中实现。我们递归的把节点添加到 document 上面。\n\n```javascript\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  wipRoot = null\n}\n​\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  domParent.appendChild(fiber.dom)\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n<a name=\"reconciliation\"></a>\n## 步骤6 `Reconciliation`（调和）\n&emsp;&emsp;目前我们只考虑了往 `document` 上面添加元素，更新和删除却没有去做。我们现在来添加这部分的功能，我们需要比较 `render` 函数这次收到的 `fiber` 结构和我们上次更新的 `fiber` 树的不同。\n\n&emsp;&emsp;因此我们需要在更新完毕之后保存一份更新过的 `fiber` 树，我们叫它 `currentRoot`。在每一个 `fiber` 节点当中我们也添加 `alternate`属性，该属性指向上次更新的`fiber`节点。\n\n```javascript\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  // 添加 currentRoot\n  currentRoot = wipRoot\n  wipRoot = null\n}\n\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    // 添加 alternate\n    alternate: currentRoot,\n  }\n  nextUnitOfWork = wipRoot\n}\n\nlet currentRoot = null\n```\n\n&emsp;&emsp;我们现在把 `performUnitOfWork` 函数创建新 `fiber` 节点部分的代码抽取成 `reconcileChildren` 函数。我们将在 `reconcileChildren` 函数中根据老的 `fiber` 节点来调和新的 react 元素。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n​\n  const elements = fiber.props.children\n  reconcileChildren(fiber, elements)\n​\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let prevSibling = null\n​\n  while (index < elements.length) {\n    const element = elements[index]\n​\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: wipFiber,\n      dom: null,\n    }\n​\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n​\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n&emsp;&emsp;我们同时循环老的 fiber 树的子节点和我们需要调和新的的 react 节点，此刻只关心 oldFiber 和 react element。react element 是我们想要**更新到 document**上面的元素，oldFiber 是我们上次更新完毕的老的 fiber 节点。我们需要比较他们，如果前后有任何的改变都需要更新到 document 上面。\n\n&emsp;&emsp;我们使用 type 来对他们进行比较：\n1. 如果 old fiber 和 react element 都拥有相同的type（dom节点相同），我们只需要更新它的属性。\n2. 如果 type 不同说明这里替换成了新的 dom 节点，我们需要创建。\n3. 如果 type 不同 且同级仅存在 old fiber 说明节点老节点删除了，我们需要移除老的节点。\n\n&emsp;&emsp;react源码中还使用了keys来进行调度调和的优化。比如key通过比较key属性可以得到 react elements 中被替换的明确位置。\n\n```javascript\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n​\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n​     const sameType =\n      oldFiber &&\n      element &&\n      element.type == oldFiber.type\n​\n    if (sameType) {\n      // TODO update the node\n    }\n    if (element && !sameType) {\n      // TODO add this node\n    }\n    if (oldFiber && !sameType) {\n      // TODO delete the oldFiber's node\n    }\n}\n```\n\n&emsp;&emsp;我们现在来完成 type 和 element 的比较部分的代码。\n\n&emsp;&emsp;当 old fiber 和 react element 拥有相同的 type 的时候，我们创建一个新的 fiber 节点来复用老 fiber 的 dom 节点，然后从 react element 上面取到新的props。\n\n&emsp;&emsp;我们还给fiber节点新增一个 `effectTag` 的属性。我们稍后在 commit 阶段会用到这个属性。\n\n&emsp;&emsp;接下来当 react element 需要创建新的 dom 节点的时候，我们给`effectTag`打上 `PLACEMENT` 的标签。\n\n&emsp;&emsp;第三种情况当我们需要删除节点的时候，我们不需要创建新的 fiber 节点，所以我们给old fiber 添加 `effectTag`。但是这样操作的话，当我们把 fiber 树上的节点更新到 document 上面的时候我们不会用到 old fiber的数据结构。这样子会导致删除的操作没有做。所以我们需要添加一个数组，用于留存所有我们需要进行删除的 dom 节点。\n\n&emsp;&emsp;这部分改动同步到 render 函数和 commitRoot 函数。\n\n```javascript\nfunction reconcileChildren(wipFiber, elements) {\n  // ...省略代码\n  // 确定相同的type\n  const sameType =\n        oldFiber &&\n        element &&\n        element.type == oldFiber.type;\n\n  if (sameType) {\n    newFiber = {\n      type: oldFiber.type,\n      props: element.props,\n      dom: oldFiber.dom,\n      parent: wipFiber,\n      alternate: oldFiber,\n      effectTag: \"UPDATE\",\n    }\n  }\n\n  if (element && !sameType) {\n    newFiber = {\n      type: element.type,\n      props: element.props,\n      dom: null,\n      parent: wipFiber,\n      alternate: null,\n      effectTag: \"PLACEMENT\",\n    }\n  }\n\n  if (oldFiber && !sameType) {\n    oldFiber.effectTag = \"DELETION\"\n    deletions.push(oldFiber)\n  }\n  // ...省略代码\n}\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  // 新增记录删除的数组\n  deletions = []\n  nextUnitOfWork = wipRoot\n}\n  ​\nlet nextUnitOfWork = null\nlet currentRoot = null\nlet wipRoot = null\n// 新增记录删除的数组\nlet deletions = null\n\nfunction commitRoot() {\n  // 删除节点操作\n  deletions.forEach(commitWork)\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n```\n&emsp;&emsp;现在让我们来用刚刚添加的 `effectTag` 来更改 `commitWork`函数的代码。\n\n&emsp;&emsp;当 `PLACEMENT` 的 `effectTag` 时我们和之前操作一样，给父 fiber 节点添加子节点。当为 `DELETION` 时，我们进行相反的操作，移除子节点。\n\n&emsp;&emsp;当 `effectTag` 为 `UPDATE` 时我们需要在 dom 节点上面更新改变的 props 属性。\n\n```javascript\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n​\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n&emsp;&emsp;现在我们来完成 `updateDom` 函数。我们比较新老节点上面的props，移除所有多于的属性，设置新的属性，替换更新的属性。我们还需要对事件监听类的属性做一个特殊处理（react中对事件类统一on开头），移除掉`on`的前缀。删除掉更改的事件，添加新的事件。\n\n```javascript\nconst isEvent = key => key.startsWith(\"on\")\nconst isProperty = key =>\n  key !== \"children\" && !isEvent(key)\nconst isNew = (prev, next) => key =>\n  prev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)\nfunction updateDom(dom, prevProps, nextProps) {\n  // Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n​\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = nextProps[name]\n    })\n\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.addEventListener(\n        eventType,\n        nextProps[name]\n      )\n    })\n}\n```\n\n&emsp;&emsp;你可以在[codesandbox](https://codesandbox.io/s/didact-6-96533)上面尝试这个版本的调和（reconciliation）。\n\n<a name=\"functionalComponent\"></a>\n\n## 步骤7 函数组件\n&emsp;&emsp;接下来我们需要增加对函数式组件(function components)的支持。首先我们需要更改例子为简单的函数式组件，它返回一个 h1 元素。\n\n```javascript\n/** @jsx Didact.createElement */\nfunction App(props) {\n  return <h1>Hi {props.name}</h1>\n}\nconst element = <App name=\"foo\" />\nconst container = document.getElementById(\"root\")\nDidact.render(element, container)\n```\n\n&emsp;&emsp;同样的，我们把它从jsx转化为js：\n```javascript\nfunction App(props) {\n  return Didact.createElement(\n    \"h1\",\n    null,\n    \"Hi \",\n    props.name\n  )\n}\nconst element = Didact.createElement(App, {\n  name: \"foo\",\n})\n```\n\n&emsp;&emsp;函数式组件有两点和类组件不同的地方：\n1. 函数式组件的fiber节点没有保存 dom 节点。\n2. 函数式组件的子节点是通过运行函数得到的，而不是从 props 的 children 中得到的。\n\n&emsp;&emsp;我们通过检查fiber的type是否是function来确定它是否为函数式组件从而进行不同的更新。在 `updateHostComponent` 函数中我们仍然进行之前的逻辑进行非函数式组件的更新。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  const isFunctionComponent =\n    fiber.type instanceof Function\n  // 函数式组件进行专门的函数更新\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber)\n  } else {\n    updateHostComponent(fiber)\n  }\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n&emsp;&emsp;随后在`updateFunctionComponent`函数中我们运行函数式组件的函数，得到子节点。比如上面的例子，fiber 节点的 type 保存的是 App 函数，我们运行函数将会得到 h1 节点。\n\n&emsp;&emsp;一旦当我们得到子节点之后，`reconciliation`函数将一样的工作，我们不需要更改任何的部分。\n\n```javascript\nfunction updateFunctionComponent(fiber) {\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n```\n\n&emsp;&emsp;但是`commitWork`函数还是需要进行对应的更改的，因为我们现在拥有了没有保存node节点的函数式组件。我们来更改两个地方。\n\n&emsp;&emsp;首先为了找到dom节点的父节点，我们需要一直往上查找fiber树，直到我们找到拥有dom节点的 fiber 节点（类组件）。\n\n&emsp;&emsp;删除节点的时候我们也需要一直往上查找直到找到拥有node节点的fiber节点。\n\n```javascript\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  let domParentFiber = fiber.parent\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent\n  }\n  const domParent = domParentFiber.dom\n\n}\n\n// 更改为找到拥有dom节点的fiber为止\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom)\n  } else {\n    commitDeletion(fiber.child, domParent)\n  }\n}\n​\n```\n\n<a name=\"hooks\"></a>\n\n## 步骤8 Hooks\n\n&emsp;&emsp;最后一步，我们现在给函数式组件增加 state。我们来改变之前的例子，写一个经典的计数器组件。每当我们点击一下，计数将增加1。我们从`Didact`中调用`useState`。\n\n```javascript\n/** @jsx Didact.createElement */\nfunction Counter() {\n  const [state, setState] = Didact.useState(1)\n  return (\n    <h1 onClick={() => setState(c => c + 1)}>\n      Count: {state}\n    </h1>\n  )\n}\nconst element = <Counter />\n```\n\n&emsp;&emsp;和之前的例子一样，的函数式组件在 `updateFunctionComponent` 函数中完成，然后我们在这之中增加 `useState` 函数。我们需要在调用函数式组件之前初始化一些全局变量，这样我们可以在 `useState` 函数中进行使用。\n\n&emsp;&emsp;首先我们需要设置一个变量为本次调度中的fiber树。我们同样需要增加一个保存hooks的数组来支持fiber在一个组件中调用多次 `useState`。然和我们还需要保持对当前hook的index的追踪，\n\n&emsp;&emsp;当函数式组件使用`useState`的时候，我们先在`alternate`属性上面检查是否拥有老的hook。如果存在老的hook，我们直接复制hook上面的state来给新的hook，如果没有我们初始化一个state。然后我们在fiber上面添加这个新的hook，增加hook的index的追踪，然后返回state。\n\n&emsp;&emsp;useState还需要返回一个更新state的函数，所以我们来完成一个`setState`函数。该函数接受一个`action`的入参，在上面的计数器的例子中action就是个函数来每次给计数加一。\n\n&emsp;&emsp;我们把action保存到hook新增的一个`queue`属性中。接着我们做和`render`函数中类似的事情，新建一个fiber节点，把它设置为`nextUnitOfWork`（下一个工作单元）。这样在后续的更新中会进行调度更新。\n\n&emsp;&emsp;但是目前为止我们仍然未执行 `action` 函数。我们在渲染组件的时候来执行`action`，我们从`queue`中得到所有的`action`，然后一个接一个的执行他们得到新的hook和state。所以我们返回的是已经更新过的state。\n\n\n```javascript\nlet wipFiber = null\nlet hookIndex = null\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber\n  hookIndex = 0\n  wipFiber.hooks = []\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n​\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach(action => {\n    hook.state = action(hook.state)\n  })\n\n  const setState = action => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    // 设置为下一个更新工作单元\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n```\n\n&emsp;&emsp;到此为止。我们建造了我们自己的react。你可以在[codesandbox](https://codesandbox.io/s/didact-8-21ost)或者[github](https://github.com/pomber/didact)上体验它。\n\n## 后记\n&emsp;&emsp;除了帮助你理解react是如何工作的，这篇文章的另一个目的是让你在后续阅读react源码的时候能够更轻松。所以我们多次使用了和react源码中一样的函数名。当你在真正的react应用中打一个断点，你会看到调用栈中存在这些熟悉的名字：\n\n- workLoop\n- performUnitOfWork\n- updateFunctionComponent\n\n&emsp;&emsp;我们省略了很多react的功能和优化部分的代码：\n\n- 在 Didact 我们在 render 阶段循环了整个 fiber 树，react会根据一些关键信息和点来跳过那些没有更新的部分。\n- Didact 在 commit 阶段也循环了整个 fiber 树，但是react在链表中仅仅保存了拥有`effects`标签的fiber节点然后来访问更新他们。\n- 每次我们创建一个单元工作的时候，我们都是创建一个全新的对象给每一个 fiber 节点，react 则进行一个循环利用。\n- Didact 在render阶段收到一个新的更新时，会抛弃当前的工作，从根节点重新开始。react则会给每次的更新标识一个expiration的时间戳，用它来决定哪个更新拥有更高的更新优先级。\n-  还有更多，不一一列举...\n\n&emsp;&emsp;这里还有一些功能你可以轻松的添加上去：\n- 铺平子节点多重数组\n- useEffect\n- 通过key来进行调和调度\n\n欢迎来给[github](https://github.com/pomber/didact)提pull request。感谢你的阅读！\n","source":"_posts/react/buildyourownreact.md","raw":"---\ntitle: 建造属于你的react\ndate: 2020/9/22 14:40\ncategories:\n- [前端, react, 自翻, 转载]\ntags:\n- react\n- 转载\n- 自翻\n---\n&emsp;&emsp;转载自翻自Rodrigo Pombo的博文[Build your own React](https://pomb.us/build-your-own-react/)。\n<!--more-->\n\n&emsp;&emsp;我们将一步一步重建一个属于我们自己的react。我们的react架构将和真实的react架构相同，但是去掉了大部分的优化和一些目前不必要的功能。\n\n接下来我们将逐步在自己的react中实现这些能力:\n1. [createElement函数](#createElement)\n2. [render函数](#render)\n3. [Concurrent Mode](#concurrent)\n4. [Fibers（虚拟dom结构）](#fiber)\n5. [Render 和 Commit 阶段](#renderandcommit)\n6. [Reconciliation（调和）](#reconciliation)\n7. [函数组件](#functionalComponent)\n8. [Hooks](#hooks)\n\n\n## 步骤0 回顾\n&emsp;&emsp;实现这些功能前，我们需要回顾一些基本的概念。如果你早就对 `react` , `JSX` 和 `dom` 元素之间的关系以及工作原理了然于胸的话，你可以跳过这个章节。\n\n\n```javascript\nconst element = <h1 title=\"foo\">Hello</h1>\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n&emsp;&emsp;我们将使用这个仅有三行代码的 react 应用来回顾基本概念。第一行代码定义了一个 react 元素，第二行代码从 `document` 中获取到了一个 `dom` 节点。最后把 react 元素渲染到dom节点上面。\n\n&emsp;&emsp;**现在让我们把所有 react 特有的代码部分（jsx）移除，全部替换为原版的js代码。**\n\n&emsp;&emsp;第一行代码我们通过 jsx 语法来定义的元素（h1），不是合法的原生js语法。因此我们需要替换掉 jsx 的部分。\n\n&emsp;&emsp;jsx 转换为 原生 js 需要通过一些诸如`babel`的编译工具。编译的过程通常十分简单，把所有元素标签部分所有内容转换为 `createElement` 函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。\n\n\n```javascript\n// 替换 const element = <h1 title=\"foo\">Hello</h1>\nconst element = React.createElement(\n  \"h1\",\n  { title: \"foo\" },\n  \"Hello\"\n)\n```\n\n&emsp;&emsp;`React.createElement` 通过传入的参数（标签名、prop、children）简单验证后创建一个对象，它的功能就是这么简单。所以我们可以放心的把变量 `element` 的内容直接等价替换为 `createElement` 函数返回值。\n\n```javascript\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n```\n&emsp;&emsp;其实 `element` 的值你可以简单看成一个拥有 `type` 和 `props` 的 key 的对象。（其实还有其它的属性，但是目前我们只关心这两项。点击[这里](https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111)查看详细结构。）\n\n&emsp;&emsp;`element` 中的 `type` 对应你想要创建的 `dom` 元素，就像你使用 `document.createElement` 去创建 `HTML` 元素时传递的标签名参数是一样的。但在 `React.createElement` 中，你还可以传递一个函数给 `type`，详细的部分我们将在第7步来操作。\n\n&emsp;&emsp;`prop`属性对应的是一个对象，它把 `jsx` 上面的所有定义的属性通过*键值对*的方式保存起来。其中还包含一个特殊的属性，`children`属性。在上面的例子中， `children` 是一个字符串类型的值，但在实际使用中，经常为多个以数组形式保存的 `dom/jsx` 元素，这也是为什么我们的元素集经常以`树`的数据结构保存。\n\n&emsp;&emsp;另外一个`react`相关代码需要替换的是`ReactDOM.render`。`render` 函数把 `react` 转换为 `dom`，现在让我们来自己实现这个转换过程。\n\n\n```javascript\n// 替换 ReactDOM.render(element, container)\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n&emsp;&emsp;首先我们创建一个 dom 节点，在上面的例子是`h1`。然后我们把所有相关属性同步到 dom 节点上，在上面例子中仅仅有一个 title。\n\n&emsp;&emsp;接着我们为 dom 节点创建子节点。我们现在仅有字符串类型的文本类型节点需要创建。我们后面都将使用文本节点（textNode）的方式来代替直接插入子节点（innerHTML），这种方式就好像你在 prop 上面定义 nodeValue 值一样：`props: {nodeValue: \"hello\"}`。\n\n&emsp;&emsp;最后我们往 h1 中加入 textNode ，然后往 container 中加入 h1 节点。\n\n```javascript\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n​\nconst container = document.getElementById(\"root\")\n​\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n​\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n​\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n\n&emsp;&emsp;现在我们有了一个去掉所有 react 相关代码的与刚开始功能一致的 demo 应用。\n\n<a name=\"createElement\"></a>\n\n## 步骤1 createElement 函数\n\n```javascript\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n&emsp;&emsp;现在我们从一个新的应用重新开始，这次我们将全部用自己版本的代码来替换 react 代码，现在来实现一个我们自己的`createElement`函数。首先我们来把上面代码部分的jsx替换成`createElement`函数。\n\n```javascript\nconst element = React.createElement(\n  \"div\",\n  { id: \"foo\" },\n  React.createElement(\"a\", null, \"bar\"),\n  React.createElement(\"b\")\n)\n```\n\n&emsp;&emsp;正如我们上一步所说的，一个`react element`实际上就是一个拥有`type`和`props`属性的对象，所以在`createElement`函数中我们唯一需要去做的就是创建这个对象。\n\n&emsp;&emsp;我们使用**对象展开符**来把 `props` 的属性同步到所需要创建的对象的 `props` 上，然后，然后使用 `rest` 语法来把函数剩余的所有入参都作为 `children` 拿过来。这样子在创建的对象上面，`children`将始终为数组。\n\n```javascript\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children,\n    },\n  }\n}\n```\n\n&emsp;&emsp;我们来举几个例子：\n```javascript\n// 使用 createElement(\"div\")，返回：\n{\n  \"type\": \"div\",\n  \"props\": { \"children\": [] }\n}\n// 使用 createElement(\"div\", null, a)， 返回：\n{\n  \"type\": \"div\",\n  \"props\": { \"children\": [a] }\n}\n\n// 使用 createElement(\"div\", null, a, b)，返回：\n{\n  \"type\": \"div\",\n  \"props\": { \"children\": [a, b] }\n}\n```\n\n&emsp;&emsp;`children`数组出了 dom 元素之外，还可以包含一些基本类型的值，比如*字符串*或者*数字*。我们用一个特殊的类型 `TEXT_ELEMENT` 来把这些不是对象子节点给包装成对象类型。\n\n```javascript\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n```\n\n&emsp;&emsp;在实际的 react 代码中是不会去把这些基本类型或者空节点给包装成对象的，但是我们这样去做，以便简化我们后续的代码。\n\n&emsp;&emsp;现在我们来把我们自己写的`createElement`函数替换react的`createElement`， 完成这个步骤需要给我们的库命一个名，我们就叫它`Didact`。但是我们代码还是在使用jsx，如果告诉编译器使用`Didact.createElement`来代替`React.createElement`呢，我们只需要加上下面的注释即可。\n\n```javascript\n/** @jsx Didact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\n```\n<a name=\"render\"></a>\n\n## 步骤2 `render`函数\n&emsp;&emsp;我们现在来写我们自己的 `ReactDOM.render` 函数。\n\n&emsp;&emsp;我们现在先只考虑往 `document` 上面**添加**元素，而不去考虑**更新**或者**删除**元素。\n\n&emsp;&emsp;我们根据 `react element` 上面的 `type` 属性创建一个 dom 元素，然后往`container`中添加节点。我们根据这个思路，来递归的完成所有的子节点的添加。\n\n```javascript\nfunction render(element, container) {\n  const dom = document.createElement(element.type)\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n  container.appendChild(dom)\n}\n```\n&emsp;&emsp;我们需要单独处理文本类型的元素（基本类型元素），如果元素的 `type` 为 `TEXT_ELEMENT`，我们单独为其创建一个文本节点。修改 `dom` 创建如下：\n\n```javascript\nconst dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n```\n\n&emsp;&emsp;最后我们需要把`react element`上的 props 同步到真实的 `dom` 元素上面。\n```javascript\nconst isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n```\n\n&emsp;&emsp;到这一步为止我们有了一个简单的从jsx转换到真实dom的库，你可以在[codesandbox](https://codesandbox.io/s/didact-2-k6rbj)上面尝试这个库。\n\n<a name=\"concurrent\"></a>\n## 步骤3 Concurrent Mode\n&emsp;&emsp;在我们添加新的功能前，我们需要重构一下我们之前的代码。主要在递归调用添加子节点的那部分代码。\n\n&emsp;&emsp;一旦我们开始`rendering`(把 react element 渲染成真实dom)，我们在整个 react element 树递归完成前都不能停止。如果元素树过于庞大，这个渲染过程将会占用主线程过长时间。如果此时浏览器需要去做一些高响应级的操作（如响应用户输入或者运行一些动画特效）将会在渲染完成前产生卡顿。\n\n&emsp;&emsp;因此我们把工作拆成一个个小的单元，每个单元工作完成后我们查看一下浏览器是否有更重要的工作，如果有就打断当前的渲染循环。\n\n\n```javascript\nlet nextUnitOfWork = null\n​\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n  requestIdleCallback(workLoop)\n}\n​\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(nextUnitOfWork) {\n  // TODO\n}\n```\n\n&emsp;&emsp;我们使用[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)这个浏览器api来完成循环。你可以把`requestIdleCallback`理解为近似于`setTimeout`类似的功能(指把任务放置到当前微任务最后)，但是不同的是`requestIdleCallback`会在浏览器会在主线程空闲的时候执行回调函数，而不是和`setTimeout`一样指定一个执行时间。\n\n&emsp;&emsp;react不再使用[requestIdleCallback](https://github.com/facebook/react/issues/11171#issuecomment-417349573)，它在[scheduler package](https://github.com/facebook/react/tree/master/packages/scheduler)中实现了和`requestIdleCallback`一样的功能。\n\n&emsp;&emsp;`requestIdleCallback`同时给我们提供了一个`deadline`的参数，我们可以用它来确认在浏览器接管线程前我们到底有多少时间。\n\n&emsp;&emsp;在直到`2019年11月`的时候 `Concurrent Mode` 在react内部还没有达到一个稳固的版本。稳固版本的代码类似于下面：\n\n```javascript\nwhile (nextUnitOfWork) {\n  nextUnitOfWork = performUnitOfWork(\n    nextUnitOfWork\n  )\n}\n```\n\n&emsp;&emsp;为了实现上面的循环，我们需要完成 `performUnitOfWork` 函数。`performUnitOfWork` 函数除了执行一个小单元的工作外，还需要返回下一个需要被执行的单元工作。\n\n<a name=\"fiber\"></a>\n\n## 步骤4 Fibers\n&emsp;&emsp;为了更好的实现单元工作（unit of work）我们需要引入名为 `fiber` 的数据结构。每一个`react element`都将对应一个`fiber`结构，每一个`fiber`结构都对应一个单元的工作。\n\n&emsp;&emsp;来看下面的例子，我们有这样的一个需要渲染的`元素树`：\n\n```javascript\nDidact.render(\n  <div>\n    <h1>\n      <p />\n      <a />\n    </h1>\n    <h2 />\n  </div>,\n  container\n)\n```\n&emsp;&emsp;上面结构映射成 `fiber` 树后大体为下图结构：\n![](https://pic.downk.cc/item/5f72dabf160a154a6768717d.png)\n\n&emsp;&emsp;在 `render` 中我们需要创建`root fiber`（根fiber）然后在 `nextUnitOfWork` 中设置它。剩下的工作将在 `performUnitOfWork` 函数中完成，我们将对每一个 `fiber` 节点做三件事：\n1. 把 `react element` 渲染到 dom 上。\n2. 给`react element`子节点创建`fiber`节点。\n3. 选择下一个的单元工作。\n\n&emsp;&emsp;`fiber` 结构的一个重要的目标是非常容易找到下一个单元工作，这也是为什么每一个 `fiber` 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 `fiber` 上面的工作后，`fiber` 拥有 `child` 属性可以直接指向下一个需要进行工作的 `fiber` 节点。\n\n&emsp;&emsp;在我们的例子中，当我们在第一个 `div` 节点完成更新任务后，`div` 的下一个单元工作将通过 `child` 属性指向`h1`。\n\n&emsp;&emsp;如果 `fiber` 节点没有子节点（即没有 `child` 属性），我们使用 `sibling` 属性（兄弟节点）作为下一个工作单元。在上面的例子中`p`节点没有 `child` 属性，所以我们通过 `sibling` 找到相邻节点 `a` 作为下一个工作单元。\n\n&emsp;&emsp;当 `fiber` 节点没有`child`也没兄弟节点时，我们去他们的*叔叔*（父节点的兄弟节点）节点，就像上图中的最下面的`a`节点到`h2`节点。如果`fiber`的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次`render`我们完成了所有的工作。\n\n&emsp;&emsp;现在我们来把这些思路用代码实现。\n\n&emsp;&emsp;首先我们移除上面写的 `render` 函数中的所有代码，把它们移到 `createDom` 函数中，后续需要使用。\n\n```javascript\nfunction createDom(fiber) {\n  const dom =\n    fiber.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type)\n​\n  const isProperty = key => key !== \"children\"\n  Object.keys(fiber.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = fiber.props[name]\n    })\n​\n  return dom\n}\n​\nfunction render(element, container) {\n  // TODO set next unit of work\n}\n​\nlet nextUnitOfWork = null\n```\n\n&emsp;&emsp;在`render`函数中我们设置 `nextUnitOfWork` 为 `fiber root` 节点。\n\n```javascript\nfunction render(element, container) {\n  nextUnitOfWork = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n}\n​\nlet nextUnitOfWork = null\n```\n\n&emsp;&emsp;这样当浏览器空闲的时候会调用我们之前写好的 `workLoop` 开始在 `root` 节点上面的工作。\n\n&emsp;&emsp;首先我们创建一个 dom 节点然后添加到 document 上面。然后我们在 fiber 上添加 **dom** 属性来链接到这个真实的 dom 元素。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n​\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n​\n  // TODO create new fibers\n  // TODO return next unit of work\n}\n```\n\n&emsp;&emsp;然后我们循环给所有的子节点创建新的 `fiber` 节点。我们把这些 `fiber` 节点根据是否为**第一个子节点**添加到 `fiber root` 的 `child` 或者`sibling`上面。\n\n\n```javascript\n// TODO create new fibers part\nconst elements = fiber.props.children\nlet index = 0\nlet prevSibling = null\n​\nwhile (index < elements.length) {\n  const element = elements[index]\n​    // 创建新 fiber\n  const newFiber = {\n    type: element.type,\n    props: element.props,\n    parent: fiber,\n    dom: null,\n  }\n  // 根据是否为第一个节点，添加到对应的 child / sibling 上面\n  if (index === 0) {\n    fiber.child = newFiber\n  } else {\n    prevSibling.sibling = newFiber\n  }\n​\n  prevSibling = newFiber\n  index++\n}\n```\n\n&emsp;&emsp;最后我们到最后一个部分，返回下一个工作单元。我们先尝试找child节点，然后是兄弟节点，然后是父节点的兄弟节点，继续往上直到结束。\n\n```javascript\n// TODO return next unit of work part\nif (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n&emsp;&emsp;三个连起来就是完整的 `performUnitOfWork` 函数实现。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n​\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n​\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n​\n  while (index < elements.length) {\n    const element = elements[index]\n​\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n​\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n​\n    prevSibling = newFiber\n    index++\n  }\n​\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n<a name=\"renderandcommit\"></a>\n\n## 步骤5 `Render` 和 `Commit` 阶段\n&emsp;&emsp;我们现在又有了一个新问题。\n\n&emsp;&emsp;在上面的实现中，我们在每一个工作单元中添加 `node` 节点到 `document` 上面。但是我们在设计`render`的时候，浏览器可以随时在繁忙的时候打断我们的工作，这样我们可能会看到一个不完整的 `ui` 渲染，我们可不希望这样。\n\n&emsp;&emsp;所以我们删除`performUnitOfWork`中这行添加 `node` 的操作。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  // ... 省略\n  /* 删除 */\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n  /* 删除 */\n  // ... 省略\n}\n```\n\n&emsp;&emsp;取而代之的，我们添加一个名为`wipRoot`或者`work in progress root`的`fiber`来记录 `fiber` 节点的循环更新的节点。一旦我们完成了所有的工作（即不存在 next unit of work）的时候，我们一次性把整个 fiber 树更新到 document 上面。\n\n```javascript\nfunction commitRoot() {\n  // TODO add nodes to dom\n}\n\nfunction render(element, container) {\n  // 流程树\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n  nextUnitOfWork = wipRoot\n}\n\nlet nextUnitOfWork = null\nlet wipRoot = null\n\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n​  // 一次性全部提交\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot()\n  }\n​\n  requestIdleCallback(workLoop)\n}\n```\n\n&emsp;&emsp;我们把这个提交所有 `fiber` 树过程在全新的函数 `commitRoot` 中实现。我们递归的把节点添加到 document 上面。\n\n```javascript\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  wipRoot = null\n}\n​\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  domParent.appendChild(fiber.dom)\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n<a name=\"reconciliation\"></a>\n## 步骤6 `Reconciliation`（调和）\n&emsp;&emsp;目前我们只考虑了往 `document` 上面添加元素，更新和删除却没有去做。我们现在来添加这部分的功能，我们需要比较 `render` 函数这次收到的 `fiber` 结构和我们上次更新的 `fiber` 树的不同。\n\n&emsp;&emsp;因此我们需要在更新完毕之后保存一份更新过的 `fiber` 树，我们叫它 `currentRoot`。在每一个 `fiber` 节点当中我们也添加 `alternate`属性，该属性指向上次更新的`fiber`节点。\n\n```javascript\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  // 添加 currentRoot\n  currentRoot = wipRoot\n  wipRoot = null\n}\n\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    // 添加 alternate\n    alternate: currentRoot,\n  }\n  nextUnitOfWork = wipRoot\n}\n\nlet currentRoot = null\n```\n\n&emsp;&emsp;我们现在把 `performUnitOfWork` 函数创建新 `fiber` 节点部分的代码抽取成 `reconcileChildren` 函数。我们将在 `reconcileChildren` 函数中根据老的 `fiber` 节点来调和新的 react 元素。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n​\n  const elements = fiber.props.children\n  reconcileChildren(fiber, elements)\n​\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let prevSibling = null\n​\n  while (index < elements.length) {\n    const element = elements[index]\n​\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: wipFiber,\n      dom: null,\n    }\n​\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n​\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n&emsp;&emsp;我们同时循环老的 fiber 树的子节点和我们需要调和新的的 react 节点，此刻只关心 oldFiber 和 react element。react element 是我们想要**更新到 document**上面的元素，oldFiber 是我们上次更新完毕的老的 fiber 节点。我们需要比较他们，如果前后有任何的改变都需要更新到 document 上面。\n\n&emsp;&emsp;我们使用 type 来对他们进行比较：\n1. 如果 old fiber 和 react element 都拥有相同的type（dom节点相同），我们只需要更新它的属性。\n2. 如果 type 不同说明这里替换成了新的 dom 节点，我们需要创建。\n3. 如果 type 不同 且同级仅存在 old fiber 说明节点老节点删除了，我们需要移除老的节点。\n\n&emsp;&emsp;react源码中还使用了keys来进行调度调和的优化。比如key通过比较key属性可以得到 react elements 中被替换的明确位置。\n\n```javascript\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n​\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n​     const sameType =\n      oldFiber &&\n      element &&\n      element.type == oldFiber.type\n​\n    if (sameType) {\n      // TODO update the node\n    }\n    if (element && !sameType) {\n      // TODO add this node\n    }\n    if (oldFiber && !sameType) {\n      // TODO delete the oldFiber's node\n    }\n}\n```\n\n&emsp;&emsp;我们现在来完成 type 和 element 的比较部分的代码。\n\n&emsp;&emsp;当 old fiber 和 react element 拥有相同的 type 的时候，我们创建一个新的 fiber 节点来复用老 fiber 的 dom 节点，然后从 react element 上面取到新的props。\n\n&emsp;&emsp;我们还给fiber节点新增一个 `effectTag` 的属性。我们稍后在 commit 阶段会用到这个属性。\n\n&emsp;&emsp;接下来当 react element 需要创建新的 dom 节点的时候，我们给`effectTag`打上 `PLACEMENT` 的标签。\n\n&emsp;&emsp;第三种情况当我们需要删除节点的时候，我们不需要创建新的 fiber 节点，所以我们给old fiber 添加 `effectTag`。但是这样操作的话，当我们把 fiber 树上的节点更新到 document 上面的时候我们不会用到 old fiber的数据结构。这样子会导致删除的操作没有做。所以我们需要添加一个数组，用于留存所有我们需要进行删除的 dom 节点。\n\n&emsp;&emsp;这部分改动同步到 render 函数和 commitRoot 函数。\n\n```javascript\nfunction reconcileChildren(wipFiber, elements) {\n  // ...省略代码\n  // 确定相同的type\n  const sameType =\n        oldFiber &&\n        element &&\n        element.type == oldFiber.type;\n\n  if (sameType) {\n    newFiber = {\n      type: oldFiber.type,\n      props: element.props,\n      dom: oldFiber.dom,\n      parent: wipFiber,\n      alternate: oldFiber,\n      effectTag: \"UPDATE\",\n    }\n  }\n\n  if (element && !sameType) {\n    newFiber = {\n      type: element.type,\n      props: element.props,\n      dom: null,\n      parent: wipFiber,\n      alternate: null,\n      effectTag: \"PLACEMENT\",\n    }\n  }\n\n  if (oldFiber && !sameType) {\n    oldFiber.effectTag = \"DELETION\"\n    deletions.push(oldFiber)\n  }\n  // ...省略代码\n}\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  // 新增记录删除的数组\n  deletions = []\n  nextUnitOfWork = wipRoot\n}\n  ​\nlet nextUnitOfWork = null\nlet currentRoot = null\nlet wipRoot = null\n// 新增记录删除的数组\nlet deletions = null\n\nfunction commitRoot() {\n  // 删除节点操作\n  deletions.forEach(commitWork)\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n```\n&emsp;&emsp;现在让我们来用刚刚添加的 `effectTag` 来更改 `commitWork`函数的代码。\n\n&emsp;&emsp;当 `PLACEMENT` 的 `effectTag` 时我们和之前操作一样，给父 fiber 节点添加子节点。当为 `DELETION` 时，我们进行相反的操作，移除子节点。\n\n&emsp;&emsp;当 `effectTag` 为 `UPDATE` 时我们需要在 dom 节点上面更新改变的 props 属性。\n\n```javascript\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n​\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n&emsp;&emsp;现在我们来完成 `updateDom` 函数。我们比较新老节点上面的props，移除所有多于的属性，设置新的属性，替换更新的属性。我们还需要对事件监听类的属性做一个特殊处理（react中对事件类统一on开头），移除掉`on`的前缀。删除掉更改的事件，添加新的事件。\n\n```javascript\nconst isEvent = key => key.startsWith(\"on\")\nconst isProperty = key =>\n  key !== \"children\" && !isEvent(key)\nconst isNew = (prev, next) => key =>\n  prev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)\nfunction updateDom(dom, prevProps, nextProps) {\n  // Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n​\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = nextProps[name]\n    })\n\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.addEventListener(\n        eventType,\n        nextProps[name]\n      )\n    })\n}\n```\n\n&emsp;&emsp;你可以在[codesandbox](https://codesandbox.io/s/didact-6-96533)上面尝试这个版本的调和（reconciliation）。\n\n<a name=\"functionalComponent\"></a>\n\n## 步骤7 函数组件\n&emsp;&emsp;接下来我们需要增加对函数式组件(function components)的支持。首先我们需要更改例子为简单的函数式组件，它返回一个 h1 元素。\n\n```javascript\n/** @jsx Didact.createElement */\nfunction App(props) {\n  return <h1>Hi {props.name}</h1>\n}\nconst element = <App name=\"foo\" />\nconst container = document.getElementById(\"root\")\nDidact.render(element, container)\n```\n\n&emsp;&emsp;同样的，我们把它从jsx转化为js：\n```javascript\nfunction App(props) {\n  return Didact.createElement(\n    \"h1\",\n    null,\n    \"Hi \",\n    props.name\n  )\n}\nconst element = Didact.createElement(App, {\n  name: \"foo\",\n})\n```\n\n&emsp;&emsp;函数式组件有两点和类组件不同的地方：\n1. 函数式组件的fiber节点没有保存 dom 节点。\n2. 函数式组件的子节点是通过运行函数得到的，而不是从 props 的 children 中得到的。\n\n&emsp;&emsp;我们通过检查fiber的type是否是function来确定它是否为函数式组件从而进行不同的更新。在 `updateHostComponent` 函数中我们仍然进行之前的逻辑进行非函数式组件的更新。\n\n```javascript\nfunction performUnitOfWork(fiber) {\n  const isFunctionComponent =\n    fiber.type instanceof Function\n  // 函数式组件进行专门的函数更新\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber)\n  } else {\n    updateHostComponent(fiber)\n  }\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n&emsp;&emsp;随后在`updateFunctionComponent`函数中我们运行函数式组件的函数，得到子节点。比如上面的例子，fiber 节点的 type 保存的是 App 函数，我们运行函数将会得到 h1 节点。\n\n&emsp;&emsp;一旦当我们得到子节点之后，`reconciliation`函数将一样的工作，我们不需要更改任何的部分。\n\n```javascript\nfunction updateFunctionComponent(fiber) {\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n```\n\n&emsp;&emsp;但是`commitWork`函数还是需要进行对应的更改的，因为我们现在拥有了没有保存node节点的函数式组件。我们来更改两个地方。\n\n&emsp;&emsp;首先为了找到dom节点的父节点，我们需要一直往上查找fiber树，直到我们找到拥有dom节点的 fiber 节点（类组件）。\n\n&emsp;&emsp;删除节点的时候我们也需要一直往上查找直到找到拥有node节点的fiber节点。\n\n```javascript\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  let domParentFiber = fiber.parent\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent\n  }\n  const domParent = domParentFiber.dom\n\n}\n\n// 更改为找到拥有dom节点的fiber为止\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom)\n  } else {\n    commitDeletion(fiber.child, domParent)\n  }\n}\n​\n```\n\n<a name=\"hooks\"></a>\n\n## 步骤8 Hooks\n\n&emsp;&emsp;最后一步，我们现在给函数式组件增加 state。我们来改变之前的例子，写一个经典的计数器组件。每当我们点击一下，计数将增加1。我们从`Didact`中调用`useState`。\n\n```javascript\n/** @jsx Didact.createElement */\nfunction Counter() {\n  const [state, setState] = Didact.useState(1)\n  return (\n    <h1 onClick={() => setState(c => c + 1)}>\n      Count: {state}\n    </h1>\n  )\n}\nconst element = <Counter />\n```\n\n&emsp;&emsp;和之前的例子一样，的函数式组件在 `updateFunctionComponent` 函数中完成，然后我们在这之中增加 `useState` 函数。我们需要在调用函数式组件之前初始化一些全局变量，这样我们可以在 `useState` 函数中进行使用。\n\n&emsp;&emsp;首先我们需要设置一个变量为本次调度中的fiber树。我们同样需要增加一个保存hooks的数组来支持fiber在一个组件中调用多次 `useState`。然和我们还需要保持对当前hook的index的追踪，\n\n&emsp;&emsp;当函数式组件使用`useState`的时候，我们先在`alternate`属性上面检查是否拥有老的hook。如果存在老的hook，我们直接复制hook上面的state来给新的hook，如果没有我们初始化一个state。然后我们在fiber上面添加这个新的hook，增加hook的index的追踪，然后返回state。\n\n&emsp;&emsp;useState还需要返回一个更新state的函数，所以我们来完成一个`setState`函数。该函数接受一个`action`的入参，在上面的计数器的例子中action就是个函数来每次给计数加一。\n\n&emsp;&emsp;我们把action保存到hook新增的一个`queue`属性中。接着我们做和`render`函数中类似的事情，新建一个fiber节点，把它设置为`nextUnitOfWork`（下一个工作单元）。这样在后续的更新中会进行调度更新。\n\n&emsp;&emsp;但是目前为止我们仍然未执行 `action` 函数。我们在渲染组件的时候来执行`action`，我们从`queue`中得到所有的`action`，然后一个接一个的执行他们得到新的hook和state。所以我们返回的是已经更新过的state。\n\n\n```javascript\nlet wipFiber = null\nlet hookIndex = null\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber\n  hookIndex = 0\n  wipFiber.hooks = []\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n​\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach(action => {\n    hook.state = action(hook.state)\n  })\n\n  const setState = action => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    // 设置为下一个更新工作单元\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n```\n\n&emsp;&emsp;到此为止。我们建造了我们自己的react。你可以在[codesandbox](https://codesandbox.io/s/didact-8-21ost)或者[github](https://github.com/pomber/didact)上体验它。\n\n## 后记\n&emsp;&emsp;除了帮助你理解react是如何工作的，这篇文章的另一个目的是让你在后续阅读react源码的时候能够更轻松。所以我们多次使用了和react源码中一样的函数名。当你在真正的react应用中打一个断点，你会看到调用栈中存在这些熟悉的名字：\n\n- workLoop\n- performUnitOfWork\n- updateFunctionComponent\n\n&emsp;&emsp;我们省略了很多react的功能和优化部分的代码：\n\n- 在 Didact 我们在 render 阶段循环了整个 fiber 树，react会根据一些关键信息和点来跳过那些没有更新的部分。\n- Didact 在 commit 阶段也循环了整个 fiber 树，但是react在链表中仅仅保存了拥有`effects`标签的fiber节点然后来访问更新他们。\n- 每次我们创建一个单元工作的时候，我们都是创建一个全新的对象给每一个 fiber 节点，react 则进行一个循环利用。\n- Didact 在render阶段收到一个新的更新时，会抛弃当前的工作，从根节点重新开始。react则会给每次的更新标识一个expiration的时间戳，用它来决定哪个更新拥有更高的更新优先级。\n-  还有更多，不一一列举...\n\n&emsp;&emsp;这里还有一些功能你可以轻松的添加上去：\n- 铺平子节点多重数组\n- useEffect\n- 通过key来进行调和调度\n\n欢迎来给[github](https://github.com/pomber/didact)提pull request。感谢你的阅读！\n","slug":"react/buildyourownreact","published":1,"updated":"2020-10-04T07:10:44.373Z","_id":"ckfdnttru0000nq2vhb4ayt3p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>&emsp;&emsp;转载自翻自Rodrigo Pombo的博文<a href=\"https://pomb.us/build-your-own-react/\" target=\"_blank\" rel=\"noopener\">Build your own React</a>。<br><a id=\"more\"></a></p>\n<p>&emsp;&emsp;我们将一步一步重建一个属于我们自己的react。我们的react架构将和真实的react架构相同，但是去掉了大部分的优化和一些目前不必要的功能。</p>\n<p>接下来我们将逐步在自己的react中实现这些能力:</p>\n<ol>\n<li><a href=\"#createElement\">createElement函数</a></li>\n<li><a href=\"#render\">render函数</a></li>\n<li><a href=\"#concurrent\">Concurrent Mode</a></li>\n<li><a href=\"#fiber\">Fibers（虚拟dom结构）</a></li>\n<li><a href=\"#renderandcommit\">Render 和 Commit 阶段</a></li>\n<li><a href=\"#reconciliation\">Reconciliation（调和）</a></li>\n<li><a href=\"#functionalComponent\">函数组件</a></li>\n<li><a href=\"#hooks\">Hooks</a></li>\n</ol>\n<h2 id=\"步骤0-回顾\"><a href=\"#步骤0-回顾\" class=\"headerlink\" title=\"步骤0 回顾\"></a>步骤0 回顾</h2><p>&emsp;&emsp;实现这些功能前，我们需要回顾一些基本的概念。如果你早就对 <code>react</code> , <code>JSX</code> 和 <code>dom</code> 元素之间的关系以及工作原理了然于胸的话，你可以跳过这个章节。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = &lt;h1 title=\"foo\"&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"root\"</span>)</span><br><span class=\"line\">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们将使用这个仅有三行代码的 react 应用来回顾基本概念。第一行代码定义了一个 react 元素，第二行代码从 <code>document</code> 中获取到了一个 <code>dom</code> 节点。最后把 react 元素渲染到dom节点上面。</p>\n<p>&emsp;&emsp;<strong>现在让我们把所有 react 特有的代码部分（jsx）移除，全部替换为原版的js代码。</strong></p>\n<p>&emsp;&emsp;第一行代码我们通过 jsx 语法来定义的元素（h1），不是合法的原生js语法。因此我们需要替换掉 jsx 的部分。</p>\n<p>&emsp;&emsp;jsx 转换为 原生 js 需要通过一些诸如<code>babel</code>的编译工具。编译的过程通常十分简单，把所有元素标签部分所有内容转换为 <code>createElement</code> 函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 替换 const element = &lt;h1 title=\"foo\"&gt;Hello&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"hljs-string\">\"h1\"</span>,</span><br><span class=\"line\">  &#123; <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"foo\"</span> &#125;,</span><br><span class=\"line\">  <span class=\"hljs-string\">\"Hello\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>React.createElement</code> 通过传入的参数（标签名、prop、children）简单验证后创建一个对象，它的功能就是这么简单。所以我们可以放心的把变量 <code>element</code> 的内容直接等价替换为 <code>createElement</code> 函数返回值。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"hljs-string\">\"h1\"</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title: <span class=\"hljs-string\">\"foo\"</span>,</span><br><span class=\"line\">    children: <span class=\"hljs-string\">\"Hello\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其实 <code>element</code> 的值你可以简单看成一个拥有 <code>type</code> 和 <code>props</code> 的 key 的对象。（其实还有其它的属性，但是目前我们只关心这两项。点击<a href=\"https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111\" target=\"_blank\" rel=\"noopener\">这里</a>查看详细结构。）</p>\n<p>&emsp;&emsp;<code>element</code> 中的 <code>type</code> 对应你想要创建的 <code>dom</code> 元素，就像你使用 <code>document.createElement</code> 去创建 <code>HTML</code> 元素时传递的标签名参数是一样的。但在 <code>React.createElement</code> 中，你还可以传递一个函数给 <code>type</code>，详细的部分我们将在第7步来操作。</p>\n<p>&emsp;&emsp;<code>prop</code>属性对应的是一个对象，它把 <code>jsx</code> 上面的所有定义的属性通过<em>键值对</em>的方式保存起来。其中还包含一个特殊的属性，<code>children</code>属性。在上面的例子中， <code>children</code> 是一个字符串类型的值，但在实际使用中，经常为多个以数组形式保存的 <code>dom/jsx</code> 元素，这也是为什么我们的元素集经常以<code>树</code>的数据结构保存。</p>\n<p>&emsp;&emsp;另外一个<code>react</code>相关代码需要替换的是<code>ReactDOM.render</code>。<code>render</code> 函数把 <code>react</code> 转换为 <code>dom</code>，现在让我们来自己实现这个转换过程。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 替换 ReactDOM.render(element, container)</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-built_in\">document</span>.createElement(element.type)</span><br><span class=\"line\">node[<span class=\"hljs-string\">\"title\"</span>] = element.props.title</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-string\">\"\"</span>)</span><br><span class=\"line\">text[<span class=\"hljs-string\">\"nodeValue\"</span>] = element.props.children</span><br><span class=\"line\"></span><br><span class=\"line\">node.appendChild(text)</span><br><span class=\"line\">container.appendChild(node)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;首先我们创建一个 dom 节点，在上面的例子是<code>h1</code>。然后我们把所有相关属性同步到 dom 节点上，在上面例子中仅仅有一个 title。</p>\n<p>&emsp;&emsp;接着我们为 dom 节点创建子节点。我们现在仅有字符串类型的文本类型节点需要创建。我们后面都将使用文本节点（textNode）的方式来代替直接插入子节点（innerHTML），这种方式就好像你在 prop 上面定义 nodeValue 值一样：<code>props: {nodeValue: &quot;hello&quot;}</code>。</p>\n<p>&emsp;&emsp;最后我们往 h1 中加入 textNode ，然后往 container 中加入 h1 节点。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"hljs-string\">\"h1\"</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title: <span class=\"hljs-string\">\"foo\"</span>,</span><br><span class=\"line\">    children: <span class=\"hljs-string\">\"Hello\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"root\"</span>)</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-built_in\">document</span>.createElement(element.type)</span><br><span class=\"line\">node[<span class=\"hljs-string\">\"title\"</span>] = element.props.title</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-string\">\"\"</span>)</span><br><span class=\"line\">text[<span class=\"hljs-string\">\"nodeValue\"</span>] = element.props.children</span><br><span class=\"line\">​</span><br><span class=\"line\">node.appendChild(text)</span><br><span class=\"line\">container.appendChild(node)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们有了一个去掉所有 react 相关代码的与刚开始功能一致的 demo 应用。</p>\n<p><a name=\"createElement\"></a></p>\n<h2 id=\"步骤1-createElement-函数\"><a href=\"#步骤1-createElement-函数\" class=\"headerlink\" title=\"步骤1 createElement 函数\"></a>步骤1 createElement 函数</h2><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div id=<span class=\"hljs-string\">\"foo\"</span>&gt;</span><br><span class=\"line\">    &lt;a&gt;bar&lt;<span class=\"hljs-regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">    &lt;b /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"hljs-regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">)</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">const container = document.getElementById(\"root\")</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">ReactDOM.render(element, container)</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们从一个新的应用重新开始，这次我们将全部用自己版本的代码来替换 react 代码，现在来实现一个我们自己的<code>createElement</code>函数。首先我们来把上面代码部分的jsx替换成<code>createElement</code>函数。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"hljs-string\">\"div\"</span>,</span><br><span class=\"line\">  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"foo\"</span> &#125;,</span><br><span class=\"line\">  React.createElement(<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\"bar\"</span>),</span><br><span class=\"line\">  React.createElement(<span class=\"hljs-string\">\"b\"</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;正如我们上一步所说的，一个<code>react element</code>实际上就是一个拥有<code>type</code>和<code>props</code>属性的对象，所以在<code>createElement</code>函数中我们唯一需要去做的就是创建这个对象。</p>\n<p>&emsp;&emsp;我们使用<strong>对象展开符</strong>来把 <code>props</code> 的属性同步到所需要创建的对象的 <code>props</code> 上，然后，然后使用 <code>rest</code> 语法来把函数剩余的所有入参都作为 <code>children</code> 拿过来。这样子在创建的对象上面，<code>children</code>将始终为数组。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>(<span class=\"hljs-params\">type, props, ...children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      children,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们来举几个例子：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 使用 createElement(\"div\")，返回：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"div\"</span>,</span><br><span class=\"line\">  <span class=\"hljs-string\">\"props\"</span>: &#123; <span class=\"hljs-string\">\"children\"</span>: [] &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 使用 createElement(\"div\", null, a)， 返回：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"div\"</span>,</span><br><span class=\"line\">  <span class=\"hljs-string\">\"props\"</span>: &#123; <span class=\"hljs-string\">\"children\"</span>: [a] &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 使用 createElement(\"div\", null, a, b)，返回：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"div\"</span>,</span><br><span class=\"line\">  <span class=\"hljs-string\">\"props\"</span>: &#123; <span class=\"hljs-string\">\"children\"</span>: [a, b] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>children</code>数组出了 dom 元素之外，还可以包含一些基本类型的值，比如<em>字符串</em>或者<em>数字</em>。我们用一个特殊的类型 <code>TEXT_ELEMENT</code> 来把这些不是对象子节点给包装成对象类型。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>(<span class=\"hljs-params\">type, props, ...children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      children: children.map(<span class=\"hljs-function\"><span class=\"hljs-params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"hljs-keyword\">typeof</span> child === <span class=\"hljs-string\">\"object\"</span></span><br><span class=\"line\">          ? child</span><br><span class=\"line\">          : createTextElement(child)</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createTextElement</span>(<span class=\"hljs-params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"hljs-string\">\"TEXT_ELEMENT\"</span>,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      nodeValue: text,</span><br><span class=\"line\">      children: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在实际的 react 代码中是不会去把这些基本类型或者空节点给包装成对象的，但是我们这样去做，以便简化我们后续的代码。</p>\n<p>&emsp;&emsp;现在我们来把我们自己写的<code>createElement</code>函数替换react的<code>createElement</code>， 完成这个步骤需要给我们的库命一个名，我们就叫它<code>Didact</code>。但是我们代码还是在使用jsx，如果告诉编译器使用<code>Didact.createElement</code>来代替<code>React.createElement</code>呢，我们只需要加上下面的注释即可。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx </span>Didact.createElement */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div id=<span class=\"hljs-string\">\"foo\"</span>&gt;</span><br><span class=\"line\">    &lt;a&gt;bar&lt;<span class=\"hljs-regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">    &lt;b /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"hljs-regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p><a name=\"render\"></a></p>\n<h2 id=\"步骤2-render函数\"><a href=\"#步骤2-render函数\" class=\"headerlink\" title=\"步骤2 render函数\"></a>步骤2 <code>render</code>函数</h2><p>&emsp;&emsp;我们现在来写我们自己的 <code>ReactDOM.render</code> 函数。</p>\n<p>&emsp;&emsp;我们现在先只考虑往 <code>document</code> 上面<strong>添加</strong>元素，而不去考虑<strong>更新</strong>或者<strong>删除</strong>元素。</p>\n<p>&emsp;&emsp;我们根据 <code>react element</code> 上面的 <code>type</code> 属性创建一个 dom 元素，然后往<code>container</code>中添加节点。我们根据这个思路，来递归的完成所有的子节点的添加。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> dom = <span class=\"hljs-built_in\">document</span>.createElement(element.type)</span><br><span class=\"line\">  element.props.children.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">child</span> =&gt;</span></span><br><span class=\"line\">    render(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  container.appendChild(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们需要单独处理文本类型的元素（基本类型元素），如果元素的 <code>type</code> 为 <code>TEXT_ELEMENT</code>，我们单独为其创建一个文本节点。修改 <code>dom</code> 创建如下：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> dom =</span><br><span class=\"line\">    element.type == <span class=\"hljs-string\">\"TEXT_ELEMENT\"</span></span><br><span class=\"line\">      ? <span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-string\">\"\"</span>)</span><br><span class=\"line\">      : <span class=\"hljs-built_in\">document</span>.createElement(element.type)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后我们需要把<code>react element</code>上的 props 同步到真实的 <code>dom</code> 元素上面。<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> isProperty = <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key !== <span class=\"hljs-string\">\"children\"</span></span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.keys(element.props)</span><br><span class=\"line\">    .filter(isProperty)</span><br><span class=\"line\">    .forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.props[name]</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;到这一步为止我们有了一个简单的从jsx转换到真实dom的库，你可以在<a href=\"https://codesandbox.io/s/didact-2-k6rbj\" target=\"_blank\" rel=\"noopener\">codesandbox</a>上面尝试这个库。</p>\n<p><a name=\"concurrent\"></a></p>\n<h2 id=\"步骤3-Concurrent-Mode\"><a href=\"#步骤3-Concurrent-Mode\" class=\"headerlink\" title=\"步骤3 Concurrent Mode\"></a>步骤3 Concurrent Mode</h2><p>&emsp;&emsp;在我们添加新的功能前，我们需要重构一下我们之前的代码。主要在递归调用添加子节点的那部分代码。</p>\n<p>&emsp;&emsp;一旦我们开始<code>rendering</code>(把 react element 渲染成真实dom)，我们在整个 react element 树递归完成前都不能停止。如果元素树过于庞大，这个渲染过程将会占用主线程过长时间。如果此时浏览器需要去做一些高响应级的操作（如响应用户输入或者运行一些动画特效）将会在渲染完成前产生卡顿。</p>\n<p>&emsp;&emsp;因此我们把工作拆成一个个小的单元，每个单元工作完成后我们查看一下浏览器是否有更重要的工作，如果有就打断当前的渲染循环。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> nextUnitOfWork = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">workLoop</span>(<span class=\"hljs-params\">deadline</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> shouldYield = <span class=\"hljs-literal\">false</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = performUnitOfWork(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.timeRemaining() &lt; <span class=\"hljs-number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  requestIdleCallback(workLoop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">requestIdleCallback(workLoop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">nextUnitOfWork</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>这个浏览器api来完成循环。你可以把<code>requestIdleCallback</code>理解为近似于<code>setTimeout</code>类似的功能(指把任务放置到当前微任务最后)，但是不同的是<code>requestIdleCallback</code>会在浏览器会在主线程空闲的时候执行回调函数，而不是和<code>setTimeout</code>一样指定一个执行时间。</p>\n<p>&emsp;&emsp;react不再使用<a href=\"https://github.com/facebook/react/issues/11171#issuecomment-417349573\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>，它在<a href=\"https://github.com/facebook/react/tree/master/packages/scheduler\" target=\"_blank\" rel=\"noopener\">scheduler package</a>中实现了和<code>requestIdleCallback</code>一样的功能。</p>\n<p>&emsp;&emsp;<code>requestIdleCallback</code>同时给我们提供了一个<code>deadline</code>的参数，我们可以用它来确认在浏览器接管线程前我们到底有多少时间。</p>\n<p>&emsp;&emsp;在直到<code>2019年11月</code>的时候 <code>Concurrent Mode</code> 在react内部还没有达到一个稳固的版本。稳固版本的代码类似于下面：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">while</span> (nextUnitOfWork) &#123;</span><br><span class=\"line\">  nextUnitOfWork = performUnitOfWork(</span><br><span class=\"line\">    nextUnitOfWork</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;为了实现上面的循环，我们需要完成 <code>performUnitOfWork</code> 函数。<code>performUnitOfWork</code> 函数除了执行一个小单元的工作外，还需要返回下一个需要被执行的单元工作。</p>\n<p><a name=\"fiber\"></a></p>\n<h2 id=\"步骤4-Fibers\"><a href=\"#步骤4-Fibers\" class=\"headerlink\" title=\"步骤4 Fibers\"></a>步骤4 Fibers</h2><p>&emsp;&emsp;为了更好的实现单元工作（unit of work）我们需要引入名为 <code>fiber</code> 的数据结构。每一个<code>react element</code>都将对应一个<code>fiber</code>结构，每一个<code>fiber</code>结构都对应一个单元的工作。</p>\n<p>&emsp;&emsp;来看下面的例子，我们有这样的一个需要渲染的<code>元素树</code>：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Didact.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;</span><br><span class=\"line\">      &lt;p /&gt;</span><br><span class=\"line\">      &lt;a /&gt;</span><br><span class=\"line\">    &lt;<span class=\"hljs-regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">    &lt;h2 /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"hljs-regexp\">/div&gt;,</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  container</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面结构映射成 <code>fiber</code> 树后大体为下图结构：<br><img src=\"https://pic.downk.cc/item/5f72dabf160a154a6768717d.png\" alt></p>\n<p>&emsp;&emsp;在 <code>render</code> 中我们需要创建<code>root fiber</code>（根fiber）然后在 <code>nextUnitOfWork</code> 中设置它。剩下的工作将在 <code>performUnitOfWork</code> 函数中完成，我们将对每一个 <code>fiber</code> 节点做三件事：</p>\n<ol>\n<li>把 <code>react element</code> 渲染到 dom 上。</li>\n<li>给<code>react element</code>子节点创建<code>fiber</code>节点。</li>\n<li>选择下一个的单元工作。</li>\n</ol>\n<p>&emsp;&emsp;<code>fiber</code> 结构的一个重要的目标是非常容易找到下一个单元工作，这也是为什么每一个 <code>fiber</code> 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 <code>fiber</code> 上面的工作后，<code>fiber</code> 拥有 <code>child</code> 属性可以直接指向下一个需要进行工作的 <code>fiber</code> 节点。</p>\n<p>&emsp;&emsp;在我们的例子中，当我们在第一个 <code>div</code> 节点完成更新任务后，<code>div</code> 的下一个单元工作将通过 <code>child</code> 属性指向<code>h1</code>。</p>\n<p>&emsp;&emsp;如果 <code>fiber</code> 节点没有子节点（即没有 <code>child</code> 属性），我们使用 <code>sibling</code> 属性（兄弟节点）作为下一个工作单元。在上面的例子中<code>p</code>节点没有 <code>child</code> 属性，所以我们通过 <code>sibling</code> 找到相邻节点 <code>a</code> 作为下一个工作单元。</p>\n<p>&emsp;&emsp;当 <code>fiber</code> 节点没有<code>child</code>也没兄弟节点时，我们去他们的<em>叔叔</em>（父节点的兄弟节点）节点，就像上图中的最下面的<code>a</code>节点到<code>h2</code>节点。如果<code>fiber</code>的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次<code>render</code>我们完成了所有的工作。</p>\n<p>&emsp;&emsp;现在我们来把这些思路用代码实现。</p>\n<p>&emsp;&emsp;首先我们移除上面写的 <code>render</code> 函数中的所有代码，把它们移到 <code>createDom</code> 函数中，后续需要使用。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createDom</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> dom =</span><br><span class=\"line\">    fiber.type == <span class=\"hljs-string\">\"TEXT_ELEMENT\"</span></span><br><span class=\"line\">      ? <span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-string\">\"\"</span>)</span><br><span class=\"line\">      : <span class=\"hljs-built_in\">document</span>.createElement(fiber.type)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> isProperty = <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key !== <span class=\"hljs-string\">\"children\"</span></span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.keys(fiber.props)</span><br><span class=\"line\">    .filter(isProperty)</span><br><span class=\"line\">    .forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = fiber.props[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> dom</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// TODO set next unit of work</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> nextUnitOfWork = <span class=\"hljs-literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在<code>render</code>函数中我们设置 <code>nextUnitOfWork</code> 为 <code>fiber root</code> 节点。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  nextUnitOfWork = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> nextUnitOfWork = <span class=\"hljs-literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样当浏览器空闲的时候会调用我们之前写好的 <code>workLoop</code> 开始在 <code>root</code> 节点上面的工作。</p>\n<p>&emsp;&emsp;首先我们创建一个 dom 节点然后添加到 document 上面。然后我们在 fiber 上添加 <strong>dom</strong> 属性来链接到这个真实的 dom 元素。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!fiber.dom) &#123;</span><br><span class=\"line\">    fiber.dom = createDom(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.parent) &#123;</span><br><span class=\"line\">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-comment\">// TODO create new fibers</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;然后我们循环给所有的子节点创建新的 <code>fiber</code> 节点。我们把这些 <code>fiber</code> 节点根据是否为<strong>第一个子节点</strong>添加到 <code>fiber root</code> 的 <code>child</code> 或者<code>sibling</code>上面。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// TODO create new fibers part</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> elements = fiber.props.children</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-keyword\">while</span> (index &lt; elements.length) &#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> element = elements[index]</span><br><span class=\"line\">​    <span class=\"hljs-comment\">// 创建新 fiber</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">    type: element.type,</span><br><span class=\"line\">    props: element.props,</span><br><span class=\"line\">    parent: fiber,</span><br><span class=\"line\">    dom: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 根据是否为第一个节点，添加到对应的 child / sibling 上面</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">    fiber.child = newFiber</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    prevSibling.sibling = newFiber</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  prevSibling = newFiber</span><br><span class=\"line\">  index++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后我们到最后一个部分，返回下一个工作单元。我们先尝试找child节点，然后是兄弟节点，然后是父节点的兄弟节点，继续往上直到结束。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// TODO return next unit of work part</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;三个连起来就是完整的 <code>performUnitOfWork</code> 函数实现。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!fiber.dom) &#123;</span><br><span class=\"line\">    fiber.dom = createDom(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.parent) &#123;</span><br><span class=\"line\">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> elements = fiber.props.children</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (index &lt; elements.length) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> element = elements[index]</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      type: element.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      parent: fiber,</span><br><span class=\"line\">      dom: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.child = newFiber</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.sibling = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"renderandcommit\"></a></p>\n<h2 id=\"步骤5-Render-和-Commit-阶段\"><a href=\"#步骤5-Render-和-Commit-阶段\" class=\"headerlink\" title=\"步骤5 Render 和 Commit 阶段\"></a>步骤5 <code>Render</code> 和 <code>Commit</code> 阶段</h2><p>&emsp;&emsp;我们现在又有了一个新问题。</p>\n<p>&emsp;&emsp;在上面的实现中，我们在每一个工作单元中添加 <code>node</code> 节点到 <code>document</code> 上面。但是我们在设计<code>render</code>的时候，浏览器可以随时在繁忙的时候打断我们的工作，这样我们可能会看到一个不完整的 <code>ui</code> 渲染，我们可不希望这样。</p>\n<p>&emsp;&emsp;所以我们删除<code>performUnitOfWork</code>中这行添加 <code>node</code> 的操作。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">/* 删除 */</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.parent) &#123;</span><br><span class=\"line\">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">/* 删除 */</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// ... 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;取而代之的，我们添加一个名为<code>wipRoot</code>或者<code>work in progress root</code>的<code>fiber</code>来记录 <code>fiber</code> 节点的循环更新的节点。一旦我们完成了所有的工作（即不存在 next unit of work）的时候，我们一次性把整个 fiber 树更新到 document 上面。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitRoot</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// TODO add nodes to dom</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 流程树</span></span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> nextUnitOfWork = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> wipRoot = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">workLoop</span>(<span class=\"hljs-params\">deadline</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> shouldYield = <span class=\"hljs-literal\">false</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = performUnitOfWork(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.timeRemaining() &lt; <span class=\"hljs-number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​  <span class=\"hljs-comment\">// 一次性全部提交</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class=\"line\">    commitRoot()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  requestIdleCallback(workLoop)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们把这个提交所有 <code>fiber</code> 树过程在全新的函数 <code>commitRoot</code> 中实现。我们递归的把节点添加到 document 上面。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitRoot</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  commitWork(wipRoot.child)</span><br><span class=\"line\">  wipRoot = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> domParent = fiber.parent.dom</span><br><span class=\"line\">  domParent.appendChild(fiber.dom)</span><br><span class=\"line\">  commitWork(fiber.child)</span><br><span class=\"line\">  commitWork(fiber.sibling)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"reconciliation\"></a></p>\n<h2 id=\"步骤6-Reconciliation（调和）\"><a href=\"#步骤6-Reconciliation（调和）\" class=\"headerlink\" title=\"步骤6 Reconciliation（调和）\"></a>步骤6 <code>Reconciliation</code>（调和）</h2><p>&emsp;&emsp;目前我们只考虑了往 <code>document</code> 上面添加元素，更新和删除却没有去做。我们现在来添加这部分的功能，我们需要比较 <code>render</code> 函数这次收到的 <code>fiber</code> 结构和我们上次更新的 <code>fiber</code> 树的不同。</p>\n<p>&emsp;&emsp;因此我们需要在更新完毕之后保存一份更新过的 <code>fiber</code> 树，我们叫它 <code>currentRoot</code>。在每一个 <code>fiber</code> 节点当中我们也添加 <code>alternate</code>属性，该属性指向上次更新的<code>fiber</code>节点。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitRoot</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  commitWork(wipRoot.child)</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 添加 currentRoot</span></span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 添加 alternate</span></span><br><span class=\"line\">    alternate: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> currentRoot = <span class=\"hljs-literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在把 <code>performUnitOfWork</code> 函数创建新 <code>fiber</code> 节点部分的代码抽取成 <code>reconcileChildren</code> 函数。我们将在 <code>reconcileChildren</code> 函数中根据老的 <code>fiber</code> 节点来调和新的 react 元素。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!fiber.dom) &#123;</span><br><span class=\"line\">    fiber.dom = createDom(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> elements = fiber.props.children</span><br><span class=\"line\">  reconcileChildren(fiber, elements)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reconcileChildren</span>(<span class=\"hljs-params\">wipFiber, elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (index &lt; elements.length) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> element = elements[index]</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      type: element.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      parent: wipFiber,</span><br><span class=\"line\">      dom: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.child = newFiber</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.sibling = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们同时循环老的 fiber 树的子节点和我们需要调和新的的 react 节点，此刻只关心 oldFiber 和 react element。react element 是我们想要<strong>更新到 document</strong>上面的元素，oldFiber 是我们上次更新完毕的老的 fiber 节点。我们需要比较他们，如果前后有任何的改变都需要更新到 document 上面。</p>\n<p>&emsp;&emsp;我们使用 type 来对他们进行比较：</p>\n<ol>\n<li>如果 old fiber 和 react element 都拥有相同的type（dom节点相同），我们只需要更新它的属性。</li>\n<li>如果 type 不同说明这里替换成了新的 dom 节点，我们需要创建。</li>\n<li>如果 type 不同 且同级仅存在 old fiber 说明节点老节点删除了，我们需要移除老的节点。</li>\n</ol>\n<p>&emsp;&emsp;react源码中还使用了keys来进行调度调和的优化。比如key通过比较key属性可以得到 react elements 中被替换的明确位置。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reconcileChildren</span>(<span class=\"hljs-params\">wipFiber, elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> oldFiber =</span><br><span class=\"line\">    wipFiber.alternate &amp;&amp; wipFiber.alternate.child</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (</span><br><span class=\"line\">    index &lt; elements.length ||</span><br><span class=\"line\">    oldFiber != <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> element = elements[index]</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> newFiber = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">​     <span class=\"hljs-keyword\">const</span> sameType =</span><br><span class=\"line\">      oldFiber &amp;&amp;</span><br><span class=\"line\">      element &amp;&amp;</span><br><span class=\"line\">      element.type == oldFiber.type</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// TODO update the node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// TODO add this node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// TODO delete the oldFiber's node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在来完成 type 和 element 的比较部分的代码。</p>\n<p>&emsp;&emsp;当 old fiber 和 react element 拥有相同的 type 的时候，我们创建一个新的 fiber 节点来复用老 fiber 的 dom 节点，然后从 react element 上面取到新的props。</p>\n<p>&emsp;&emsp;我们还给fiber节点新增一个 <code>effectTag</code> 的属性。我们稍后在 commit 阶段会用到这个属性。</p>\n<p>&emsp;&emsp;接下来当 react element 需要创建新的 dom 节点的时候，我们给<code>effectTag</code>打上 <code>PLACEMENT</code> 的标签。</p>\n<p>&emsp;&emsp;第三种情况当我们需要删除节点的时候，我们不需要创建新的 fiber 节点，所以我们给old fiber 添加 <code>effectTag</code>。但是这样操作的话，当我们把 fiber 树上的节点更新到 document 上面的时候我们不会用到 old fiber的数据结构。这样子会导致删除的操作没有做。所以我们需要添加一个数组，用于留存所有我们需要进行删除的 dom 节点。</p>\n<p>&emsp;&emsp;这部分改动同步到 render 函数和 commitRoot 函数。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reconcileChildren</span>(<span class=\"hljs-params\">wipFiber, elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...省略代码</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 确定相同的type</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> sameType =</span><br><span class=\"line\">        oldFiber &amp;&amp;</span><br><span class=\"line\">        element &amp;&amp;</span><br><span class=\"line\">        element.type == oldFiber.type;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">    newFiber = &#123;</span><br><span class=\"line\">      type: oldFiber.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      dom: oldFiber.dom,</span><br><span class=\"line\">      parent: wipFiber,</span><br><span class=\"line\">      alternate: oldFiber,</span><br><span class=\"line\">      effectTag: <span class=\"hljs-string\">\"UPDATE\"</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">    newFiber = &#123;</span><br><span class=\"line\">      type: element.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      dom: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">      parent: wipFiber,</span><br><span class=\"line\">      alternate: <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">      effectTag: <span class=\"hljs-string\">\"PLACEMENT\"</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">    oldFiber.effectTag = <span class=\"hljs-string\">\"DELETION\"</span></span><br><span class=\"line\">    deletions.push(oldFiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...省略代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    alternate: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 新增记录删除的数组</span></span><br><span class=\"line\">  deletions = []</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  ​</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> nextUnitOfWork = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> currentRoot = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> wipRoot = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 新增记录删除的数组</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> deletions = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitRoot</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 删除节点操作</span></span><br><span class=\"line\">  deletions.forEach(commitWork)</span><br><span class=\"line\">  commitWork(wipRoot.child)</span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在让我们来用刚刚添加的 <code>effectTag</code> 来更改 <code>commitWork</code>函数的代码。</p>\n<p>&emsp;&emsp;当 <code>PLACEMENT</code> 的 <code>effectTag</code> 时我们和之前操作一样，给父 fiber 节点添加子节点。当为 <code>DELETION</code> 时，我们进行相反的操作，移除子节点。</p>\n<p>&emsp;&emsp;当 <code>effectTag</code> 为 <code>UPDATE</code> 时我们需要在 dom 节点上面更新改变的 props 属性。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> domParent = fiber.parent.dom</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (</span><br><span class=\"line\">    fiber.effectTag === <span class=\"hljs-string\">\"PLACEMENT\"</span> &amp;&amp;</span><br><span class=\"line\">    fiber.dom != <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (</span><br><span class=\"line\">    fiber.effectTag === <span class=\"hljs-string\">\"UPDATE\"</span> &amp;&amp;</span><br><span class=\"line\">    fiber.dom != <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    updateDom(</span><br><span class=\"line\">      fiber.dom,</span><br><span class=\"line\">      fiber.alternate.props,</span><br><span class=\"line\">      fiber.props</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fiber.effectTag === <span class=\"hljs-string\">\"DELETION\"</span>) &#123;</span><br><span class=\"line\">    domParent.removeChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  commitWork(fiber.child)</span><br><span class=\"line\">  commitWork(fiber.sibling)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们来完成 <code>updateDom</code> 函数。我们比较新老节点上面的props，移除所有多于的属性，设置新的属性，替换更新的属性。我们还需要对事件监听类的属性做一个特殊处理（react中对事件类统一on开头），移除掉<code>on</code>的前缀。删除掉更改的事件，添加新的事件。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> isEvent = <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key.startsWith(<span class=\"hljs-string\">\"on\"</span>)</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> isProperty = <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span></span><br><span class=\"line\">  key !== <span class=\"hljs-string\">\"children\"</span> &amp;&amp; !isEvent(key)</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> isNew = <span class=\"hljs-function\">(<span class=\"hljs-params\">prev, next</span>) =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span></span><br><span class=\"line\">  prev[key] !== next[key]</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> isGone = <span class=\"hljs-function\">(<span class=\"hljs-params\">prev, next</span>) =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> !(key <span class=\"hljs-keyword\">in</span> next)</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateDom</span>(<span class=\"hljs-params\">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Remove old or changed event listeners</span></span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.keys(prevProps)</span><br><span class=\"line\">    .filter(isEvent)</span><br><span class=\"line\">    .filter(</span><br><span class=\"line\">      key =&gt;</span><br><span class=\"line\">        !(key <span class=\"hljs-keyword\">in</span> nextProps) ||</span><br><span class=\"line\">        isNew(prevProps, nextProps)(key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> eventType = name</span><br><span class=\"line\">        .toLowerCase()</span><br><span class=\"line\">        .substring(<span class=\"hljs-number\">2</span>)</span><br><span class=\"line\">      dom.removeEventListener(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        prevProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-comment\">// Set new or changed properties</span></span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.keys(nextProps)</span><br><span class=\"line\">    .filter(isProperty)</span><br><span class=\"line\">    .filter(isNew(prevProps, nextProps))</span><br><span class=\"line\">    .forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = nextProps[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// Add event listeners</span></span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.keys(nextProps)</span><br><span class=\"line\">    .filter(isEvent)</span><br><span class=\"line\">    .filter(isNew(prevProps, nextProps))</span><br><span class=\"line\">    .forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> eventType = name</span><br><span class=\"line\">        .toLowerCase()</span><br><span class=\"line\">        .substring(<span class=\"hljs-number\">2</span>)</span><br><span class=\"line\">      dom.addEventListener(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        nextProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;你可以在<a href=\"https://codesandbox.io/s/didact-6-96533\" target=\"_blank\" rel=\"noopener\">codesandbox</a>上面尝试这个版本的调和（reconciliation）。</p>\n<p><a name=\"functionalComponent\"></a></p>\n<h2 id=\"步骤7-函数组件\"><a href=\"#步骤7-函数组件\" class=\"headerlink\" title=\"步骤7 函数组件\"></a>步骤7 函数组件</h2><p>&emsp;&emsp;接下来我们需要增加对函数式组件(function components)的支持。首先我们需要更改例子为简单的函数式组件，它返回一个 h1 元素。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx </span>Didact.createElement */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> &lt;h1&gt;Hi &#123;props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = &lt;App name=\"foo\" /&gt;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"root\"</span>)</span><br><span class=\"line\">Didact.render(element, container)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;同样的，我们把它从jsx转化为js：<br><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> Didact.createElement(</span><br><span class=\"line\">    <span class=\"hljs-string\">\"h1\"</span>,</span><br><span class=\"line\">    <span class=\"hljs-literal\">null</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">\"Hi \"</span>,</span><br><span class=\"line\">    props.name</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> element = Didact.createElement(App, &#123;</span><br><span class=\"line\">  name: <span class=\"hljs-string\">\"foo\"</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;函数式组件有两点和类组件不同的地方：</p>\n<ol>\n<li>函数式组件的fiber节点没有保存 dom 节点。</li>\n<li>函数式组件的子节点是通过运行函数得到的，而不是从 props 的 children 中得到的。</li>\n</ol>\n<p>&emsp;&emsp;我们通过检查fiber的type是否是function来确定它是否为函数式组件从而进行不同的更新。在 <code>updateHostComponent</code> 函数中我们仍然进行之前的逻辑进行非函数式组件的更新。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> isFunctionComponent =</span><br><span class=\"line\">    fiber.type <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Function</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 函数式组件进行专门的函数更新</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (isFunctionComponent) &#123;</span><br><span class=\"line\">    updateFunctionComponent(fiber)</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    updateHostComponent(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;随后在<code>updateFunctionComponent</code>函数中我们运行函数式组件的函数，得到子节点。比如上面的例子，fiber 节点的 type 保存的是 App 函数，我们运行函数将会得到 h1 节点。</p>\n<p>&emsp;&emsp;一旦当我们得到子节点之后，<code>reconciliation</code>函数将一样的工作，我们不需要更改任何的部分。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateFunctionComponent</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> children = [fiber.type(fiber.props)]</span><br><span class=\"line\">  reconcileChildren(fiber, children)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;但是<code>commitWork</code>函数还是需要进行对应的更改的，因为我们现在拥有了没有保存node节点的函数式组件。我们来更改两个地方。</p>\n<p>&emsp;&emsp;首先为了找到dom节点的父节点，我们需要一直往上查找fiber树，直到我们找到拥有dom节点的 fiber 节点（类组件）。</p>\n<p>&emsp;&emsp;删除节点的时候我们也需要一直往上查找直到找到拥有node节点的fiber节点。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitWork</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> domParentFiber = fiber.parent</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (!domParentFiber.dom) &#123;</span><br><span class=\"line\">    domParentFiber = domParentFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> domParent = domParentFiber.dom</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 更改为找到拥有dom节点的fiber为止</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">commitDeletion</span>(<span class=\"hljs-params\">fiber, domParent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (fiber.dom) &#123;</span><br><span class=\"line\">    domParent.removeChild(fiber.dom)</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">    commitDeletion(fiber.child, domParent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br></pre></td></tr></table></figure>\n<p><a name=\"hooks\"></a></p>\n<h2 id=\"步骤8-Hooks\"><a href=\"#步骤8-Hooks\" class=\"headerlink\" title=\"步骤8 Hooks\"></a>步骤8 Hooks</h2><p>&emsp;&emsp;最后一步，我们现在给函数式组件增加 state。我们来改变之前的例子，写一个经典的计数器组件。每当我们点击一下，计数将增加1。我们从<code>Didact</code>中调用<code>useState</code>。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx </span>Didact.createElement */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> [state, setState] = Didact.useState(<span class=\"hljs-number\">1</span>)</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> (</span><br><span class=\"line\">    &lt;h1 onClick=&#123;() =&gt; setState(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>)&#125;&gt;</span><br><span class=\"line\">      Count: &#123;state&#125;</span><br><span class=\"line\">    &lt;<span class=\"hljs-regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">  )</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"hljs-regexp\">const element = &lt;Counter /</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;和之前的例子一样，的函数式组件在 <code>updateFunctionComponent</code> 函数中完成，然后我们在这之中增加 <code>useState</code> 函数。我们需要在调用函数式组件之前初始化一些全局变量，这样我们可以在 <code>useState</code> 函数中进行使用。</p>\n<p>&emsp;&emsp;首先我们需要设置一个变量为本次调度中的fiber树。我们同样需要增加一个保存hooks的数组来支持fiber在一个组件中调用多次 <code>useState</code>。然和我们还需要保持对当前hook的index的追踪，</p>\n<p>&emsp;&emsp;当函数式组件使用<code>useState</code>的时候，我们先在<code>alternate</code>属性上面检查是否拥有老的hook。如果存在老的hook，我们直接复制hook上面的state来给新的hook，如果没有我们初始化一个state。然后我们在fiber上面添加这个新的hook，增加hook的index的追踪，然后返回state。</p>\n<p>&emsp;&emsp;useState还需要返回一个更新state的函数，所以我们来完成一个<code>setState</code>函数。该函数接受一个<code>action</code>的入参，在上面的计数器的例子中action就是个函数来每次给计数加一。</p>\n<p>&emsp;&emsp;我们把action保存到hook新增的一个<code>queue</code>属性中。接着我们做和<code>render</code>函数中类似的事情，新建一个fiber节点，把它设置为<code>nextUnitOfWork</code>（下一个工作单元）。这样在后续的更新中会进行调度更新。</p>\n<p>&emsp;&emsp;但是目前为止我们仍然未执行 <code>action</code> 函数。我们在渲染组件的时候来执行<code>action</code>，我们从<code>queue</code>中得到所有的<code>action</code>，然后一个接一个的执行他们得到新的hook和state。所以我们返回的是已经更新过的state。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> wipFiber = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> hookIndex = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateFunctionComponent</span>(<span class=\"hljs-params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  wipFiber = fiber</span><br><span class=\"line\">  hookIndex = <span class=\"hljs-number\">0</span></span><br><span class=\"line\">  wipFiber.hooks = []</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> children = [fiber.type(fiber.props)]</span><br><span class=\"line\">  reconcileChildren(fiber, children)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useState</span>(<span class=\"hljs-params\">initial</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.alternate &amp;&amp;</span><br><span class=\"line\">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class=\"line\">    wipFiber.alternate.hooks[hookIndex]</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    state: oldHook ? oldHook.state : initial,</span><br><span class=\"line\">    queue: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> actions = oldHook ? oldHook.queue : []</span><br><span class=\"line\">  actions.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    hook.state = action(hook.state)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> setState = <span class=\"hljs-function\"><span class=\"hljs-params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    hook.queue.push(action)</span><br><span class=\"line\">    wipRoot = &#123;</span><br><span class=\"line\">      dom: currentRoot.dom,</span><br><span class=\"line\">      props: currentRoot.props,</span><br><span class=\"line\">      alternate: currentRoot,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 设置为下一个更新工作单元</span></span><br><span class=\"line\">    nextUnitOfWork = wipRoot</span><br><span class=\"line\">    deletions = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.hooks.push(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> [hook.state, setState]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;到此为止。我们建造了我们自己的react。你可以在<a href=\"https://codesandbox.io/s/didact-8-21ost\" target=\"_blank\" rel=\"noopener\">codesandbox</a>或者<a href=\"https://github.com/pomber/didact\" target=\"_blank\" rel=\"noopener\">github</a>上体验它。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>&emsp;&emsp;除了帮助你理解react是如何工作的，这篇文章的另一个目的是让你在后续阅读react源码的时候能够更轻松。所以我们多次使用了和react源码中一样的函数名。当你在真正的react应用中打一个断点，你会看到调用栈中存在这些熟悉的名字：</p>\n<ul>\n<li>workLoop</li>\n<li>performUnitOfWork</li>\n<li>updateFunctionComponent</li>\n</ul>\n<p>&emsp;&emsp;我们省略了很多react的功能和优化部分的代码：</p>\n<ul>\n<li>在 Didact 我们在 render 阶段循环了整个 fiber 树，react会根据一些关键信息和点来跳过那些没有更新的部分。</li>\n<li>Didact 在 commit 阶段也循环了整个 fiber 树，但是react在链表中仅仅保存了拥有<code>effects</code>标签的fiber节点然后来访问更新他们。</li>\n<li>每次我们创建一个单元工作的时候，我们都是创建一个全新的对象给每一个 fiber 节点，react 则进行一个循环利用。</li>\n<li>Didact 在render阶段收到一个新的更新时，会抛弃当前的工作，从根节点重新开始。react则会给每次的更新标识一个expiration的时间戳，用它来决定哪个更新拥有更高的更新优先级。</li>\n<li>还有更多，不一一列举…</li>\n</ul>\n<p>&emsp;&emsp;这里还有一些功能你可以轻松的添加上去：</p>\n<ul>\n<li>铺平子节点多重数组</li>\n<li>useEffect</li>\n<li>通过key来进行调和调度</li>\n</ul>\n<p>欢迎来给<a href=\"https://github.com/pomber/didact\" target=\"_blank\" rel=\"noopener\">github</a>提pull request。感谢你的阅读！</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;转载自翻自Rodrigo Pombo的博文<a href=\"https://pomb.us/build-your-own-react/\" target=\"_blank\" rel=\"noopener\">Build your own React</a>。<br></p>","more":"</p>\n<p>&emsp;&emsp;我们将一步一步重建一个属于我们自己的react。我们的react架构将和真实的react架构相同，但是去掉了大部分的优化和一些目前不必要的功能。</p>\n<p>接下来我们将逐步在自己的react中实现这些能力:</p>\n<ol>\n<li><a href=\"#createElement\">createElement函数</a></li>\n<li><a href=\"#render\">render函数</a></li>\n<li><a href=\"#concurrent\">Concurrent Mode</a></li>\n<li><a href=\"#fiber\">Fibers（虚拟dom结构）</a></li>\n<li><a href=\"#renderandcommit\">Render 和 Commit 阶段</a></li>\n<li><a href=\"#reconciliation\">Reconciliation（调和）</a></li>\n<li><a href=\"#functionalComponent\">函数组件</a></li>\n<li><a href=\"#hooks\">Hooks</a></li>\n</ol>\n<h2 id=\"步骤0-回顾\"><a href=\"#步骤0-回顾\" class=\"headerlink\" title=\"步骤0 回顾\"></a>步骤0 回顾</h2><p>&emsp;&emsp;实现这些功能前，我们需要回顾一些基本的概念。如果你早就对 <code>react</code> , <code>JSX</code> 和 <code>dom</code> 元素之间的关系以及工作原理了然于胸的话，你可以跳过这个章节。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &lt;h1 title=\"foo\"&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"root\"</span>)</span><br><span class=\"line\">ReactDOM.render(element, container)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们将使用这个仅有三行代码的 react 应用来回顾基本概念。第一行代码定义了一个 react 元素，第二行代码从 <code>document</code> 中获取到了一个 <code>dom</code> 节点。最后把 react 元素渲染到dom节点上面。</p>\n<p>&emsp;&emsp;<strong>现在让我们把所有 react 特有的代码部分（jsx）移除，全部替换为原版的js代码。</strong></p>\n<p>&emsp;&emsp;第一行代码我们通过 jsx 语法来定义的元素（h1），不是合法的原生js语法。因此我们需要替换掉 jsx 的部分。</p>\n<p>&emsp;&emsp;jsx 转换为 原生 js 需要通过一些诸如<code>babel</code>的编译工具。编译的过程通常十分简单，把所有元素标签部分所有内容转换为 <code>createElement</code> 函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 替换 const element = &lt;h1 title=\"foo\"&gt;Hello&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">\"h1\"</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">title</span>: <span class=\"string\">\"foo\"</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>React.createElement</code> 通过传入的参数（标签名、prop、children）简单验证后创建一个对象，它的功能就是这么简单。所以我们可以放心的把变量 <code>element</code> 的内容直接等价替换为 <code>createElement</code> 函数返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"h1\"</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title: <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    children: <span class=\"string\">\"Hello\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其实 <code>element</code> 的值你可以简单看成一个拥有 <code>type</code> 和 <code>props</code> 的 key 的对象。（其实还有其它的属性，但是目前我们只关心这两项。点击<a href=\"https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111\" target=\"_blank\" rel=\"noopener\">这里</a>查看详细结构。）</p>\n<p>&emsp;&emsp;<code>element</code> 中的 <code>type</code> 对应你想要创建的 <code>dom</code> 元素，就像你使用 <code>document.createElement</code> 去创建 <code>HTML</code> 元素时传递的标签名参数是一样的。但在 <code>React.createElement</code> 中，你还可以传递一个函数给 <code>type</code>，详细的部分我们将在第7步来操作。</p>\n<p>&emsp;&emsp;<code>prop</code>属性对应的是一个对象，它把 <code>jsx</code> 上面的所有定义的属性通过<em>键值对</em>的方式保存起来。其中还包含一个特殊的属性，<code>children</code>属性。在上面的例子中， <code>children</code> 是一个字符串类型的值，但在实际使用中，经常为多个以数组形式保存的 <code>dom/jsx</code> 元素，这也是为什么我们的元素集经常以<code>树</code>的数据结构保存。</p>\n<p>&emsp;&emsp;另外一个<code>react</code>相关代码需要替换的是<code>ReactDOM.render</code>。<code>render</code> 函数把 <code>react</code> 转换为 <code>dom</code>，现在让我们来自己实现这个转换过程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 替换 ReactDOM.render(element, container)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.createElement(element.type)</span><br><span class=\"line\">node[<span class=\"string\">\"title\"</span>] = element.props.title</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">text[<span class=\"string\">\"nodeValue\"</span>] = element.props.children</span><br><span class=\"line\"></span><br><span class=\"line\">node.appendChild(text)</span><br><span class=\"line\">container.appendChild(node)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;首先我们创建一个 dom 节点，在上面的例子是<code>h1</code>。然后我们把所有相关属性同步到 dom 节点上，在上面例子中仅仅有一个 title。</p>\n<p>&emsp;&emsp;接着我们为 dom 节点创建子节点。我们现在仅有字符串类型的文本类型节点需要创建。我们后面都将使用文本节点（textNode）的方式来代替直接插入子节点（innerHTML），这种方式就好像你在 prop 上面定义 nodeValue 值一样：<code>props: {nodeValue: &quot;hello&quot;}</code>。</p>\n<p>&emsp;&emsp;最后我们往 h1 中加入 textNode ，然后往 container 中加入 h1 节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"h1\"</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    title: <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">    children: <span class=\"string\">\"Hello\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"root\"</span>)</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.createElement(element.type)</span><br><span class=\"line\">node[<span class=\"string\">\"title\"</span>] = element.props.title</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">text[<span class=\"string\">\"nodeValue\"</span>] = element.props.children</span><br><span class=\"line\">​</span><br><span class=\"line\">node.appendChild(text)</span><br><span class=\"line\">container.appendChild(node)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们有了一个去掉所有 react 相关代码的与刚开始功能一致的 demo 应用。</p>\n<p><a name=\"createElement\"></a></p>\n<h2 id=\"步骤1-createElement-函数\"><a href=\"#步骤1-createElement-函数\" class=\"headerlink\" title=\"步骤1 createElement 函数\"></a>步骤1 createElement 函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div id=<span class=\"string\">\"foo\"</span>&gt;</span><br><span class=\"line\">    &lt;a&gt;bar&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;b /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\">const container = document.getElementById(\"root\")</span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(element, container)</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们从一个新的应用重新开始，这次我们将全部用自己版本的代码来替换 react 代码，现在来实现一个我们自己的<code>createElement</code>函数。首先我们来把上面代码部分的jsx替换成<code>createElement</code>函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">\"foo\"</span> &#125;,</span><br><span class=\"line\">  React.createElement(<span class=\"string\">\"a\"</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"bar\"</span>),</span><br><span class=\"line\">  React.createElement(<span class=\"string\">\"b\"</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;正如我们上一步所说的，一个<code>react element</code>实际上就是一个拥有<code>type</code>和<code>props</code>属性的对象，所以在<code>createElement</code>函数中我们唯一需要去做的就是创建这个对象。</p>\n<p>&emsp;&emsp;我们使用<strong>对象展开符</strong>来把 <code>props</code> 的属性同步到所需要创建的对象的 <code>props</code> 上，然后，然后使用 <code>rest</code> 语法来把函数剩余的所有入参都作为 <code>children</code> 拿过来。这样子在创建的对象上面，<code>children</code>将始终为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">type, props, ...children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      children,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们来举几个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 createElement(\"div\")，返回：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"props\"</span>: &#123; <span class=\"string\">\"children\"</span>: [] &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用 createElement(\"div\", null, a)， 返回：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"props\"</span>: &#123; <span class=\"string\">\"children\"</span>: [a] &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 createElement(\"div\", null, a, b)，返回：</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"props\"</span>: &#123; <span class=\"string\">\"children\"</span>: [a, b] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>children</code>数组出了 dom 元素之外，还可以包含一些基本类型的值，比如<em>字符串</em>或者<em>数字</em>。我们用一个特殊的类型 <code>TEXT_ELEMENT</code> 来把这些不是对象子节点给包装成对象类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">type, props, ...children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      children: children.map(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">\"object\"</span></span><br><span class=\"line\">          ? child</span><br><span class=\"line\">          : createTextElement(child)</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTextElement</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"TEXT_ELEMENT\"</span>,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      nodeValue: text,</span><br><span class=\"line\">      children: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在实际的 react 代码中是不会去把这些基本类型或者空节点给包装成对象的，但是我们这样去做，以便简化我们后续的代码。</p>\n<p>&emsp;&emsp;现在我们来把我们自己写的<code>createElement</code>函数替换react的<code>createElement</code>， 完成这个步骤需要给我们的库命一个名，我们就叫它<code>Didact</code>。但是我们代码还是在使用jsx，如果告诉编译器使用<code>Didact.createElement</code>来代替<code>React.createElement</code>呢，我们只需要加上下面的注释即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx </span>Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div id=<span class=\"string\">\"foo\"</span>&gt;</span><br><span class=\"line\">    &lt;a&gt;bar&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;b /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p><a name=\"render\"></a></p>\n<h2 id=\"步骤2-render函数\"><a href=\"#步骤2-render函数\" class=\"headerlink\" title=\"步骤2 render函数\"></a>步骤2 <code>render</code>函数</h2><p>&emsp;&emsp;我们现在来写我们自己的 <code>ReactDOM.render</code> 函数。</p>\n<p>&emsp;&emsp;我们现在先只考虑往 <code>document</code> 上面<strong>添加</strong>元素，而不去考虑<strong>更新</strong>或者<strong>删除</strong>元素。</p>\n<p>&emsp;&emsp;我们根据 <code>react element</code> 上面的 <code>type</code> 属性创建一个 dom 元素，然后往<code>container</code>中添加节点。我们根据这个思路，来递归的完成所有的子节点的添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"built_in\">document</span>.createElement(element.type)</span><br><span class=\"line\">  element.props.children.forEach(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    render(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  container.appendChild(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们需要单独处理文本类型的元素（基本类型元素），如果元素的 <code>type</code> 为 <code>TEXT_ELEMENT</code>，我们单独为其创建一个文本节点。修改 <code>dom</code> 创建如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.type == <span class=\"string\">\"TEXT_ELEMENT\"</span></span><br><span class=\"line\">      ? <span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">document</span>.createElement(element.type)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后我们需要把<code>react element</code>上的 props 同步到真实的 <code>dom</code> 元素上面。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isProperty = <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> key !== <span class=\"string\">\"children\"</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(element.props)</span><br><span class=\"line\">    .filter(isProperty)</span><br><span class=\"line\">    .forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.props[name]</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;到这一步为止我们有了一个简单的从jsx转换到真实dom的库，你可以在<a href=\"https://codesandbox.io/s/didact-2-k6rbj\" target=\"_blank\" rel=\"noopener\">codesandbox</a>上面尝试这个库。</p>\n<p><a name=\"concurrent\"></a></p>\n<h2 id=\"步骤3-Concurrent-Mode\"><a href=\"#步骤3-Concurrent-Mode\" class=\"headerlink\" title=\"步骤3 Concurrent Mode\"></a>步骤3 Concurrent Mode</h2><p>&emsp;&emsp;在我们添加新的功能前，我们需要重构一下我们之前的代码。主要在递归调用添加子节点的那部分代码。</p>\n<p>&emsp;&emsp;一旦我们开始<code>rendering</code>(把 react element 渲染成真实dom)，我们在整个 react element 树递归完成前都不能停止。如果元素树过于庞大，这个渲染过程将会占用主线程过长时间。如果此时浏览器需要去做一些高响应级的操作（如响应用户输入或者运行一些动画特效）将会在渲染完成前产生卡顿。</p>\n<p>&emsp;&emsp;因此我们把工作拆成一个个小的单元，每个单元工作完成后我们查看一下浏览器是否有更重要的工作，如果有就打断当前的渲染循环。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">workLoop</span>(<span class=\"params\">deadline</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldYield = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = performUnitOfWork(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.timeRemaining() &lt; <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  requestIdleCallback(workLoop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">requestIdleCallback(workLoop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performUnitOfWork</span>(<span class=\"params\">nextUnitOfWork</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>这个浏览器api来完成循环。你可以把<code>requestIdleCallback</code>理解为近似于<code>setTimeout</code>类似的功能(指把任务放置到当前微任务最后)，但是不同的是<code>requestIdleCallback</code>会在浏览器会在主线程空闲的时候执行回调函数，而不是和<code>setTimeout</code>一样指定一个执行时间。</p>\n<p>&emsp;&emsp;react不再使用<a href=\"https://github.com/facebook/react/issues/11171#issuecomment-417349573\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>，它在<a href=\"https://github.com/facebook/react/tree/master/packages/scheduler\" target=\"_blank\" rel=\"noopener\">scheduler package</a>中实现了和<code>requestIdleCallback</code>一样的功能。</p>\n<p>&emsp;&emsp;<code>requestIdleCallback</code>同时给我们提供了一个<code>deadline</code>的参数，我们可以用它来确认在浏览器接管线程前我们到底有多少时间。</p>\n<p>&emsp;&emsp;在直到<code>2019年11月</code>的时候 <code>Concurrent Mode</code> 在react内部还没有达到一个稳固的版本。稳固版本的代码类似于下面：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (nextUnitOfWork) &#123;</span><br><span class=\"line\">  nextUnitOfWork = performUnitOfWork(</span><br><span class=\"line\">    nextUnitOfWork</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;为了实现上面的循环，我们需要完成 <code>performUnitOfWork</code> 函数。<code>performUnitOfWork</code> 函数除了执行一个小单元的工作外，还需要返回下一个需要被执行的单元工作。</p>\n<p><a name=\"fiber\"></a></p>\n<h2 id=\"步骤4-Fibers\"><a href=\"#步骤4-Fibers\" class=\"headerlink\" title=\"步骤4 Fibers\"></a>步骤4 Fibers</h2><p>&emsp;&emsp;为了更好的实现单元工作（unit of work）我们需要引入名为 <code>fiber</code> 的数据结构。每一个<code>react element</code>都将对应一个<code>fiber</code>结构，每一个<code>fiber</code>结构都对应一个单元的工作。</p>\n<p>&emsp;&emsp;来看下面的例子，我们有这样的一个需要渲染的<code>元素树</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Didact.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;</span><br><span class=\"line\">      &lt;p /&gt;</span><br><span class=\"line\">      &lt;a /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;h2 /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  container</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面结构映射成 <code>fiber</code> 树后大体为下图结构：<br><img src=\"https://pic.downk.cc/item/5f72dabf160a154a6768717d.png\" alt></p>\n<p>&emsp;&emsp;在 <code>render</code> 中我们需要创建<code>root fiber</code>（根fiber）然后在 <code>nextUnitOfWork</code> 中设置它。剩下的工作将在 <code>performUnitOfWork</code> 函数中完成，我们将对每一个 <code>fiber</code> 节点做三件事：</p>\n<ol>\n<li>把 <code>react element</code> 渲染到 dom 上。</li>\n<li>给<code>react element</code>子节点创建<code>fiber</code>节点。</li>\n<li>选择下一个的单元工作。</li>\n</ol>\n<p>&emsp;&emsp;<code>fiber</code> 结构的一个重要的目标是非常容易找到下一个单元工作，这也是为什么每一个 <code>fiber</code> 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 <code>fiber</code> 上面的工作后，<code>fiber</code> 拥有 <code>child</code> 属性可以直接指向下一个需要进行工作的 <code>fiber</code> 节点。</p>\n<p>&emsp;&emsp;在我们的例子中，当我们在第一个 <code>div</code> 节点完成更新任务后，<code>div</code> 的下一个单元工作将通过 <code>child</code> 属性指向<code>h1</code>。</p>\n<p>&emsp;&emsp;如果 <code>fiber</code> 节点没有子节点（即没有 <code>child</code> 属性），我们使用 <code>sibling</code> 属性（兄弟节点）作为下一个工作单元。在上面的例子中<code>p</code>节点没有 <code>child</code> 属性，所以我们通过 <code>sibling</code> 找到相邻节点 <code>a</code> 作为下一个工作单元。</p>\n<p>&emsp;&emsp;当 <code>fiber</code> 节点没有<code>child</code>也没兄弟节点时，我们去他们的<em>叔叔</em>（父节点的兄弟节点）节点，就像上图中的最下面的<code>a</code>节点到<code>h2</code>节点。如果<code>fiber</code>的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次<code>render</code>我们完成了所有的工作。</p>\n<p>&emsp;&emsp;现在我们来把这些思路用代码实现。</p>\n<p>&emsp;&emsp;首先我们移除上面写的 <code>render</code> 函数中的所有代码，把它们移到 <code>createDom</code> 函数中，后续需要使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDom</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    fiber.type == <span class=\"string\">\"TEXT_ELEMENT\"</span></span><br><span class=\"line\">      ? <span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">      : <span class=\"built_in\">document</span>.createElement(fiber.type)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isProperty = <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> key !== <span class=\"string\">\"children\"</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(fiber.props)</span><br><span class=\"line\">    .filter(isProperty)</span><br><span class=\"line\">    .forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = fiber.props[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dom</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO set next unit of work</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在<code>render</code>函数中我们设置 <code>nextUnitOfWork</code> 为 <code>fiber root</code> 节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  nextUnitOfWork = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样当浏览器空闲的时候会调用我们之前写好的 <code>workLoop</code> 开始在 <code>root</code> 节点上面的工作。</p>\n<p>&emsp;&emsp;首先我们创建一个 dom 节点然后添加到 document 上面。然后我们在 fiber 上添加 <strong>dom</strong> 属性来链接到这个真实的 dom 元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.dom) &#123;</span><br><span class=\"line\">    fiber.dom = createDom(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.parent) &#123;</span><br><span class=\"line\">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"comment\">// TODO create new fibers</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;然后我们循环给所有的子节点创建新的 <code>fiber</code> 节点。我们把这些 <code>fiber</code> 节点根据是否为<strong>第一个子节点</strong>添加到 <code>fiber root</code> 的 <code>child</code> 或者<code>sibling</code>上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TODO create new fibers part</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> elements = fiber.props.children</span><br><span class=\"line\"><span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">while</span> (index &lt; elements.length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">​    <span class=\"comment\">// 创建新 fiber</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">    type: element.type,</span><br><span class=\"line\">    props: element.props,</span><br><span class=\"line\">    parent: fiber,</span><br><span class=\"line\">    dom: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 根据是否为第一个节点，添加到对应的 child / sibling 上面</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    fiber.child = newFiber</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    prevSibling.sibling = newFiber</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  prevSibling = newFiber</span><br><span class=\"line\">  index++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后我们到最后一个部分，返回下一个工作单元。我们先尝试找child节点，然后是兄弟节点，然后是父节点的兄弟节点，继续往上直到结束。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TODO return next unit of work part</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;三个连起来就是完整的 <code>performUnitOfWork</code> 函数实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.dom) &#123;</span><br><span class=\"line\">    fiber.dom = createDom(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.parent) &#123;</span><br><span class=\"line\">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.props.children</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      type: element.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      parent: fiber,</span><br><span class=\"line\">      dom: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.child = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.sibling = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"renderandcommit\"></a></p>\n<h2 id=\"步骤5-Render-和-Commit-阶段\"><a href=\"#步骤5-Render-和-Commit-阶段\" class=\"headerlink\" title=\"步骤5 Render 和 Commit 阶段\"></a>步骤5 <code>Render</code> 和 <code>Commit</code> 阶段</h2><p>&emsp;&emsp;我们现在又有了一个新问题。</p>\n<p>&emsp;&emsp;在上面的实现中，我们在每一个工作单元中添加 <code>node</code> 节点到 <code>document</code> 上面。但是我们在设计<code>render</code>的时候，浏览器可以随时在繁忙的时候打断我们的工作，这样我们可能会看到一个不完整的 <code>ui</code> 渲染，我们可不希望这样。</p>\n<p>&emsp;&emsp;所以我们删除<code>performUnitOfWork</code>中这行添加 <code>node</code> 的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略</span></span><br><span class=\"line\">  <span class=\"comment\">/* 删除 */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.parent) &#123;</span><br><span class=\"line\">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* 删除 */</span></span><br><span class=\"line\">  <span class=\"comment\">// ... 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;取而代之的，我们添加一个名为<code>wipRoot</code>或者<code>work in progress root</code>的<code>fiber</code>来记录 <code>fiber</code> 节点的循环更新的节点。一旦我们完成了所有的工作（即不存在 next unit of work）的时候，我们一次性把整个 fiber 树更新到 document 上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitRoot</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO add nodes to dom</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 流程树</span></span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">workLoop</span>(<span class=\"params\">deadline</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldYield = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = performUnitOfWork(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.timeRemaining() &lt; <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​  <span class=\"comment\">// 一次性全部提交</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class=\"line\">    commitRoot()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  requestIdleCallback(workLoop)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们把这个提交所有 <code>fiber</code> 树过程在全新的函数 <code>commitRoot</code> 中实现。我们递归的把节点添加到 document 上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitRoot</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  commitWork(wipRoot.child)</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = fiber.parent.dom</span><br><span class=\"line\">  domParent.appendChild(fiber.dom)</span><br><span class=\"line\">  commitWork(fiber.child)</span><br><span class=\"line\">  commitWork(fiber.sibling)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a name=\"reconciliation\"></a></p>\n<h2 id=\"步骤6-Reconciliation（调和）\"><a href=\"#步骤6-Reconciliation（调和）\" class=\"headerlink\" title=\"步骤6 Reconciliation（调和）\"></a>步骤6 <code>Reconciliation</code>（调和）</h2><p>&emsp;&emsp;目前我们只考虑了往 <code>document</code> 上面添加元素，更新和删除却没有去做。我们现在来添加这部分的功能，我们需要比较 <code>render</code> 函数这次收到的 <code>fiber</code> 结构和我们上次更新的 <code>fiber</code> 树的不同。</p>\n<p>&emsp;&emsp;因此我们需要在更新完毕之后保存一份更新过的 <code>fiber</code> 树，我们叫它 <code>currentRoot</code>。在每一个 <code>fiber</code> 节点当中我们也添加 <code>alternate</code>属性，该属性指向上次更新的<code>fiber</code>节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitRoot</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  commitWork(wipRoot.child)</span><br><span class=\"line\">  <span class=\"comment\">// 添加 currentRoot</span></span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 添加 alternate</span></span><br><span class=\"line\">    alternate: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentRoot = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在把 <code>performUnitOfWork</code> 函数创建新 <code>fiber</code> 节点部分的代码抽取成 <code>reconcileChildren</code> 函数。我们将在 <code>reconcileChildren</code> 函数中根据老的 <code>fiber</code> 节点来调和新的 react 元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.dom) &#123;</span><br><span class=\"line\">    fiber.dom = createDom(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.props.children</span><br><span class=\"line\">  reconcileChildren(fiber, elements)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      type: element.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      parent: wipFiber,</span><br><span class=\"line\">      dom: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.child = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.sibling = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们同时循环老的 fiber 树的子节点和我们需要调和新的的 react 节点，此刻只关心 oldFiber 和 react element。react element 是我们想要<strong>更新到 document</strong>上面的元素，oldFiber 是我们上次更新完毕的老的 fiber 节点。我们需要比较他们，如果前后有任何的改变都需要更新到 document 上面。</p>\n<p>&emsp;&emsp;我们使用 type 来对他们进行比较：</p>\n<ol>\n<li>如果 old fiber 和 react element 都拥有相同的type（dom节点相同），我们只需要更新它的属性。</li>\n<li>如果 type 不同说明这里替换成了新的 dom 节点，我们需要创建。</li>\n<li>如果 type 不同 且同级仅存在 old fiber 说明节点老节点删除了，我们需要移除老的节点。</li>\n</ol>\n<p>&emsp;&emsp;react源码中还使用了keys来进行调度调和的优化。比如key通过比较key属性可以得到 react elements 中被替换的明确位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldFiber =</span><br><span class=\"line\">    wipFiber.alternate &amp;&amp; wipFiber.alternate.child</span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    index &lt; elements.length ||</span><br><span class=\"line\">    oldFiber != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newFiber = <span class=\"literal\">null</span></span><br><span class=\"line\">​     <span class=\"keyword\">const</span> sameType =</span><br><span class=\"line\">      oldFiber &amp;&amp;</span><br><span class=\"line\">      element &amp;&amp;</span><br><span class=\"line\">      element.type == oldFiber.type</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO update the node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO add this node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO delete the oldFiber's node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在来完成 type 和 element 的比较部分的代码。</p>\n<p>&emsp;&emsp;当 old fiber 和 react element 拥有相同的 type 的时候，我们创建一个新的 fiber 节点来复用老 fiber 的 dom 节点，然后从 react element 上面取到新的props。</p>\n<p>&emsp;&emsp;我们还给fiber节点新增一个 <code>effectTag</code> 的属性。我们稍后在 commit 阶段会用到这个属性。</p>\n<p>&emsp;&emsp;接下来当 react element 需要创建新的 dom 节点的时候，我们给<code>effectTag</code>打上 <code>PLACEMENT</code> 的标签。</p>\n<p>&emsp;&emsp;第三种情况当我们需要删除节点的时候，我们不需要创建新的 fiber 节点，所以我们给old fiber 添加 <code>effectTag</code>。但是这样操作的话，当我们把 fiber 树上的节点更新到 document 上面的时候我们不会用到 old fiber的数据结构。这样子会导致删除的操作没有做。所以我们需要添加一个数组，用于留存所有我们需要进行删除的 dom 节点。</p>\n<p>&emsp;&emsp;这部分改动同步到 render 函数和 commitRoot 函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 确定相同的type</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> sameType =</span><br><span class=\"line\">        oldFiber &amp;&amp;</span><br><span class=\"line\">        element &amp;&amp;</span><br><span class=\"line\">        element.type == oldFiber.type;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">    newFiber = &#123;</span><br><span class=\"line\">      type: oldFiber.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      dom: oldFiber.dom,</span><br><span class=\"line\">      parent: wipFiber,</span><br><span class=\"line\">      alternate: oldFiber,</span><br><span class=\"line\">      effectTag: <span class=\"string\">\"UPDATE\"</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">    newFiber = &#123;</span><br><span class=\"line\">      type: element.type,</span><br><span class=\"line\">      props: element.props,</span><br><span class=\"line\">      dom: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      parent: wipFiber,</span><br><span class=\"line\">      alternate: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      effectTag: <span class=\"string\">\"PLACEMENT\"</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">    oldFiber.effectTag = <span class=\"string\">\"DELETION\"</span></span><br><span class=\"line\">    deletions.push(oldFiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">element, container</span>) </span>&#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    dom: container,</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      children: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    alternate: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 新增记录删除的数组</span></span><br><span class=\"line\">  deletions = []</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  ​</span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentRoot = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// 新增记录删除的数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> deletions = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitRoot</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 删除节点操作</span></span><br><span class=\"line\">  deletions.forEach(commitWork)</span><br><span class=\"line\">  commitWork(wipRoot.child)</span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在让我们来用刚刚添加的 <code>effectTag</code> 来更改 <code>commitWork</code>函数的代码。</p>\n<p>&emsp;&emsp;当 <code>PLACEMENT</code> 的 <code>effectTag</code> 时我们和之前操作一样，给父 fiber 节点添加子节点。当为 <code>DELETION</code> 时，我们进行相反的操作，移除子节点。</p>\n<p>&emsp;&emsp;当 <code>effectTag</code> 为 <code>UPDATE</code> 时我们需要在 dom 节点上面更新改变的 props 属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = fiber.parent.dom</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.effectTag === <span class=\"string\">\"PLACEMENT\"</span> &amp;&amp;</span><br><span class=\"line\">    fiber.dom != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.appendChild(fiber.dom)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.effectTag === <span class=\"string\">\"UPDATE\"</span> &amp;&amp;</span><br><span class=\"line\">    fiber.dom != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    updateDom(</span><br><span class=\"line\">      fiber.dom,</span><br><span class=\"line\">      fiber.alternate.props,</span><br><span class=\"line\">      fiber.props</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.effectTag === <span class=\"string\">\"DELETION\"</span>) &#123;</span><br><span class=\"line\">    domParent.removeChild(fiber.dom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  commitWork(fiber.child)</span><br><span class=\"line\">  commitWork(fiber.sibling)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在我们来完成 <code>updateDom</code> 函数。我们比较新老节点上面的props，移除所有多于的属性，设置新的属性，替换更新的属性。我们还需要对事件监听类的属性做一个特殊处理（react中对事件类统一on开头），移除掉<code>on</code>的前缀。删除掉更改的事件，添加新的事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEvent = <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> key.startsWith(<span class=\"string\">\"on\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isProperty = <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">  key !== <span class=\"string\">\"children\"</span> &amp;&amp; !isEvent(key)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isNew = <span class=\"function\">(<span class=\"params\">prev, next</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">  prev[key] !== next[key]</span><br><span class=\"line\"><span class=\"keyword\">const</span> isGone = <span class=\"function\">(<span class=\"params\">prev, next</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> !(key <span class=\"keyword\">in</span> next)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Remove old or changed event listeners</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(prevProps)</span><br><span class=\"line\">    .filter(isEvent)</span><br><span class=\"line\">    .filter(</span><br><span class=\"line\">      key =&gt;</span><br><span class=\"line\">        !(key <span class=\"keyword\">in</span> nextProps) ||</span><br><span class=\"line\">        isNew(prevProps, nextProps)(key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .toLowerCase()</span><br><span class=\"line\">        .substring(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.removeEventListener(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        prevProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"comment\">// Set new or changed properties</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(nextProps)</span><br><span class=\"line\">    .filter(isProperty)</span><br><span class=\"line\">    .filter(isNew(prevProps, nextProps))</span><br><span class=\"line\">    .forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = nextProps[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Add event listeners</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(nextProps)</span><br><span class=\"line\">    .filter(isEvent)</span><br><span class=\"line\">    .filter(isNew(prevProps, nextProps))</span><br><span class=\"line\">    .forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .toLowerCase()</span><br><span class=\"line\">        .substring(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.addEventListener(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        nextProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;你可以在<a href=\"https://codesandbox.io/s/didact-6-96533\" target=\"_blank\" rel=\"noopener\">codesandbox</a>上面尝试这个版本的调和（reconciliation）。</p>\n<p><a name=\"functionalComponent\"></a></p>\n<h2 id=\"步骤7-函数组件\"><a href=\"#步骤7-函数组件\" class=\"headerlink\" title=\"步骤7 函数组件\"></a>步骤7 函数组件</h2><p>&emsp;&emsp;接下来我们需要增加对函数式组件(function components)的支持。首先我们需要更改例子为简单的函数式组件，它返回一个 h1 元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx </span>Didact.createElement */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;Hi &#123;props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = &lt;App name=\"foo\" /&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"root\"</span>)</span><br><span class=\"line\">Didact.render(element, container)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;同样的，我们把它从jsx转化为js：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Didact.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"h1\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Hi \"</span>,</span><br><span class=\"line\">    props.name</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = Didact.createElement(App, &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"foo\"</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;函数式组件有两点和类组件不同的地方：</p>\n<ol>\n<li>函数式组件的fiber节点没有保存 dom 节点。</li>\n<li>函数式组件的子节点是通过运行函数得到的，而不是从 props 的 children 中得到的。</li>\n</ol>\n<p>&emsp;&emsp;我们通过检查fiber的type是否是function来确定它是否为函数式组件从而进行不同的更新。在 <code>updateHostComponent</code> 函数中我们仍然进行之前的逻辑进行非函数式组件的更新。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isFunctionComponent =</span><br><span class=\"line\">    fiber.type <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span></span><br><span class=\"line\">  <span class=\"comment\">// 函数式组件进行专门的函数更新</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isFunctionComponent) &#123;</span><br><span class=\"line\">    updateFunctionComponent(fiber)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateHostComponent(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.child</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.sibling) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.sibling</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;随后在<code>updateFunctionComponent</code>函数中我们运行函数式组件的函数，得到子节点。比如上面的例子，fiber 节点的 type 保存的是 App 函数，我们运行函数将会得到 h1 节点。</p>\n<p>&emsp;&emsp;一旦当我们得到子节点之后，<code>reconciliation</code>函数将一样的工作，我们不需要更改任何的部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.type(fiber.props)]</span><br><span class=\"line\">  reconcileChildren(fiber, children)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;但是<code>commitWork</code>函数还是需要进行对应的更改的，因为我们现在拥有了没有保存node节点的函数式组件。我们来更改两个地方。</p>\n<p>&emsp;&emsp;首先为了找到dom节点的父节点，我们需要一直往上查找fiber树，直到我们找到拥有dom节点的 fiber 节点（类组件）。</p>\n<p>&emsp;&emsp;删除节点的时候我们也需要一直往上查找直到找到拥有node节点的fiber节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitWork</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> domParentFiber = fiber.parent</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!domParentFiber.dom) &#123;</span><br><span class=\"line\">    domParentFiber = domParentFiber.parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = domParentFiber.dom</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更改为找到拥有dom节点的fiber为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">commitDeletion</span>(<span class=\"params\">fiber, domParent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.dom) &#123;</span><br><span class=\"line\">    domParent.removeChild(fiber.dom)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    commitDeletion(fiber.child, domParent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br></pre></td></tr></table></figure>\n<p><a name=\"hooks\"></a></p>\n<h2 id=\"步骤8-Hooks\"><a href=\"#步骤8-Hooks\" class=\"headerlink\" title=\"步骤8 Hooks\"></a>步骤8 Hooks</h2><p>&emsp;&emsp;最后一步，我们现在给函数式组件增加 state。我们来改变之前的例子，写一个经典的计数器组件。每当我们点击一下，计数将增加1。我们从<code>Didact</code>中调用<code>useState</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx </span>Didact.createElement */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [state, setState] = Didact.useState(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;h1 onClick=&#123;() =&gt; setState(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c + <span class=\"number\">1</span>)&#125;&gt;</span><br><span class=\"line\">      Count: &#123;state&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">const element = &lt;Counter /</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;和之前的例子一样，的函数式组件在 <code>updateFunctionComponent</code> 函数中完成，然后我们在这之中增加 <code>useState</code> 函数。我们需要在调用函数式组件之前初始化一些全局变量，这样我们可以在 <code>useState</code> 函数中进行使用。</p>\n<p>&emsp;&emsp;首先我们需要设置一个变量为本次调度中的fiber树。我们同样需要增加一个保存hooks的数组来支持fiber在一个组件中调用多次 <code>useState</code>。然和我们还需要保持对当前hook的index的追踪，</p>\n<p>&emsp;&emsp;当函数式组件使用<code>useState</code>的时候，我们先在<code>alternate</code>属性上面检查是否拥有老的hook。如果存在老的hook，我们直接复制hook上面的state来给新的hook，如果没有我们初始化一个state。然后我们在fiber上面添加这个新的hook，增加hook的index的追踪，然后返回state。</p>\n<p>&emsp;&emsp;useState还需要返回一个更新state的函数，所以我们来完成一个<code>setState</code>函数。该函数接受一个<code>action</code>的入参，在上面的计数器的例子中action就是个函数来每次给计数加一。</p>\n<p>&emsp;&emsp;我们把action保存到hook新增的一个<code>queue</code>属性中。接着我们做和<code>render</code>函数中类似的事情，新建一个fiber节点，把它设置为<code>nextUnitOfWork</code>（下一个工作单元）。这样在后续的更新中会进行调度更新。</p>\n<p>&emsp;&emsp;但是目前为止我们仍然未执行 <code>action</code> 函数。我们在渲染组件的时候来执行<code>action</code>，我们从<code>queue</code>中得到所有的<code>action</code>，然后一个接一个的执行他们得到新的hook和state。所以我们返回的是已经更新过的state。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> wipFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hookIndex = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) </span>&#123;</span><br><span class=\"line\">  wipFiber = fiber</span><br><span class=\"line\">  hookIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  wipFiber.hooks = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.type(fiber.props)]</span><br><span class=\"line\">  reconcileChildren(fiber, children)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useState</span>(<span class=\"params\">initial</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.alternate &amp;&amp;</span><br><span class=\"line\">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class=\"line\">    wipFiber.alternate.hooks[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    state: oldHook ? oldHook.state : initial,</span><br><span class=\"line\">    queue: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">const</span> actions = oldHook ? oldHook.queue : []</span><br><span class=\"line\">  actions.forEach(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    hook.state = action(hook.state)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> setState = <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    hook.queue.push(action)</span><br><span class=\"line\">    wipRoot = &#123;</span><br><span class=\"line\">      dom: currentRoot.dom,</span><br><span class=\"line\">      props: currentRoot.props,</span><br><span class=\"line\">      alternate: currentRoot,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置为下一个更新工作单元</span></span><br><span class=\"line\">    nextUnitOfWork = wipRoot</span><br><span class=\"line\">    deletions = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.hooks.push(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.state, setState]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;到此为止。我们建造了我们自己的react。你可以在<a href=\"https://codesandbox.io/s/didact-8-21ost\" target=\"_blank\" rel=\"noopener\">codesandbox</a>或者<a href=\"https://github.com/pomber/didact\" target=\"_blank\" rel=\"noopener\">github</a>上体验它。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>&emsp;&emsp;除了帮助你理解react是如何工作的，这篇文章的另一个目的是让你在后续阅读react源码的时候能够更轻松。所以我们多次使用了和react源码中一样的函数名。当你在真正的react应用中打一个断点，你会看到调用栈中存在这些熟悉的名字：</p>\n<ul>\n<li>workLoop</li>\n<li>performUnitOfWork</li>\n<li>updateFunctionComponent</li>\n</ul>\n<p>&emsp;&emsp;我们省略了很多react的功能和优化部分的代码：</p>\n<ul>\n<li>在 Didact 我们在 render 阶段循环了整个 fiber 树，react会根据一些关键信息和点来跳过那些没有更新的部分。</li>\n<li>Didact 在 commit 阶段也循环了整个 fiber 树，但是react在链表中仅仅保存了拥有<code>effects</code>标签的fiber节点然后来访问更新他们。</li>\n<li>每次我们创建一个单元工作的时候，我们都是创建一个全新的对象给每一个 fiber 节点，react 则进行一个循环利用。</li>\n<li>Didact 在render阶段收到一个新的更新时，会抛弃当前的工作，从根节点重新开始。react则会给每次的更新标识一个expiration的时间戳，用它来决定哪个更新拥有更高的更新优先级。</li>\n<li>还有更多，不一一列举…</li>\n</ul>\n<p>&emsp;&emsp;这里还有一些功能你可以轻松的添加上去：</p>\n<ul>\n<li>铺平子节点多重数组</li>\n<li>useEffect</li>\n<li>通过key来进行调和调度</li>\n</ul>\n<p>欢迎来给<a href=\"https://github.com/pomber/didact\" target=\"_blank\" rel=\"noopener\">github</a>提pull request。感谢你的阅读！</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckba4hhx900059r2v9tqu269w","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxn000t9r2v7vphx3fq"},{"post_id":"ckba4hhx900059r2v9tqu269w","category_id":"ckba4hhxg000f9r2v95ai2t1x","_id":"ckba4hhxn000v9r2vdib6v5bb"},{"post_id":"ckba4hhx100009r2vca5qklzi","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxp00109r2vmdbd3yu0"},{"post_id":"ckba4hhx100009r2vca5qklzi","category_id":"ckba4hhxj000l9r2vah6izv77","_id":"ckba4hhxq00139r2vvnkjrnf7"},{"post_id":"ckba4hhx900069r2vh0w3v8ey","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxr00189r2v74tz5o3r"},{"post_id":"ckba4hhx900069r2vh0w3v8ey","category_id":"ckba4hhxg000f9r2v95ai2t1x","_id":"ckba4hhxs001a9r2vt3lmyzv8"},{"post_id":"ckba4hhxc00099r2v946p95wc","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxt001e9r2v1gmzknae"},{"post_id":"ckba4hhxc00099r2v946p95wc","category_id":"ckba4hhxg000f9r2v95ai2t1x","_id":"ckba4hhxu001h9r2vmv2qosrt"},{"post_id":"ckba4hhx400019r2vi5enh7gm","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhxw001m9r2vt2cxh5ls"},{"post_id":"ckba4hhx400019r2vi5enh7gm","category_id":"ckba4hhxj000l9r2vah6izv77","_id":"ckba4hhxx001o9r2vvecnlnby"},{"post_id":"ckba4hhx700039r2v2agnq8rs","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhy300239r2vcifjweeu"},{"post_id":"ckba4hhx700039r2v2agnq8rs","category_id":"ckba4hhxg000f9r2v95ai2t1x","_id":"ckba4hhy400269r2vaybgc85o"},{"post_id":"ckba4hhxp00119r2vb0h58ii1","category_id":"ckba4hhyf002z9r2vd0u9zdgm","_id":"ckba4hhyg00359r2vmmlev9n4"},{"post_id":"ckba4hhxq00169r2v883kniit","category_id":"ckba4hhyf00329r2vvz0gjuh3","_id":"ckba4hhyg003a9r2vckh74oz6"},{"post_id":"ckba4hhxs001d9r2vf01ek3n9","category_id":"ckba4hhyf00349r2vfbo1inl7","_id":"ckba4hhyh003e9r2vexdcvfsd"},{"post_id":"ckba4hhxd000a9r2v77d7bkcc","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyi003i9r2vp6t5as5w"},{"post_id":"ckba4hhxd000a9r2v77d7bkcc","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckba4hhyi003k9r2vqjroayeu"},{"post_id":"ckba4hhxt001g9r2vwvze12zw","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyj003n9r2vw6pdgwfr"},{"post_id":"ckba4hhxt001g9r2vwvze12zw","category_id":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckba4hhyj003q9r2vbwvsg9iy"},{"post_id":"ckba4hhxu001k9r2v1sdleikj","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyj003s9r2vszrrfo2y"},{"post_id":"ckba4hhxu001k9r2v1sdleikj","category_id":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckba4hhyk003u9r2v6zthby96"},{"post_id":"ckba4hhxf000d9r2v3vu6di5g","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyl00419r2vgp98xd36"},{"post_id":"ckba4hhxf000d9r2v3vu6di5g","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckba4hhyl00429r2vn4ktbtco"},{"post_id":"ckba4hhxx001q9r2v99ewemqu","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyl00469r2vav7mggu7"},{"post_id":"ckba4hhxx001q9r2v99ewemqu","category_id":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckba4hhym00479r2vr1b6i58g"},{"post_id":"ckba4hhxz001t9r2vxz1ynyjz","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhym004a9r2vf7s6ipzi"},{"post_id":"ckba4hhxz001t9r2vxz1ynyjz","category_id":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckba4hhyn004c9r2vqsv5bjro"},{"post_id":"ckba4hhy0001w9r2v9umpja3m","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhyn004g9r2vpzpxgo3x"},{"post_id":"ckba4hhy0001w9r2v9umpja3m","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhyn004h9r2vqdz4pfpg"},{"post_id":"ckba4hhxf000e9r2vfug60ga3","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyp004k9r2v7ipvf6tv"},{"post_id":"ckba4hhxf000e9r2vfug60ga3","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckba4hhyp004m9r2vtw6ec058"},{"post_id":"ckba4hhy1001y9r2v7zexjasy","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyr004p9r2vl4ewrii9"},{"post_id":"ckba4hhy1001y9r2v7zexjasy","category_id":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckba4hhyr004q9r2vdr0bj5ik"},{"post_id":"ckba4hhy200209r2vprspcjzg","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhys004t9r2vmp6dq4t2"},{"post_id":"ckba4hhy200209r2vprspcjzg","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhys004v9r2vsmmdi562"},{"post_id":"ckba4hhxh000h9r2vj426si9k","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyt004z9r2vw5bw9n8n"},{"post_id":"ckba4hhxh000h9r2vj426si9k","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckba4hhyt00519r2vzs5lj8wf"},{"post_id":"ckba4hhy300249r2vlf81gmlf","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhyu00549r2v1jpw85yg"},{"post_id":"ckba4hhy300249r2vlf81gmlf","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhyu00559r2vtj4zluwx"},{"post_id":"ckba4hhy400289r2vf6s4r0sv","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhyv00589r2v9rfo33g4"},{"post_id":"ckba4hhy400289r2vf6s4r0sv","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhyv005a9r2vskzxv0gf"},{"post_id":"ckba4hhxi000j9r2veypsq97g","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhyx005e9r2vn3luj503"},{"post_id":"ckba4hhxi000j9r2veypsq97g","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckba4hhyx005f9r2vwo5675dj"},{"post_id":"ckba4hhy5002a9r2vmodzwgp2","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhyy005i9r2vfnrhqqf7"},{"post_id":"ckba4hhy5002a9r2vmodzwgp2","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhyy005k9r2v27a6q5eb"},{"post_id":"ckba4hhy6002c9r2v9jsoifdb","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhyy005o9r2v0izrngqm"},{"post_id":"ckba4hhy6002c9r2v9jsoifdb","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhyz005q9r2v2sc4qj2s"},{"post_id":"ckba4hhxk000n9r2vbkzq4kos","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhz0005u9r2vecxfq34q"},{"post_id":"ckba4hhxk000n9r2vbkzq4kos","category_id":"ckba4hhyx005g9r2v9prrd1s2","_id":"ckba4hhz0005v9r2v8fg7frcq"},{"post_id":"ckba4hhy7002f9r2vxwplpe1f","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhz1005y9r2vx8iudo1z"},{"post_id":"ckba4hhy7002f9r2vxwplpe1f","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhz100609r2v0rabtjy4"},{"post_id":"ckba4hhy8002h9r2v6e3vul0o","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhz200649r2vuy5lhndw"},{"post_id":"ckba4hhy8002h9r2v6e3vul0o","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhz300669r2vqnt7k8oh"},{"post_id":"ckba4hhxl000p9r2v507ot6zu","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhz4006a9r2vngh4qi21"},{"post_id":"ckba4hhxl000p9r2v507ot6zu","category_id":"ckba4hhyx005g9r2v9prrd1s2","_id":"ckba4hhz5006c9r2vgadhpw6r"},{"post_id":"ckba4hhya002l9r2vp2np4bow","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhz6006g9r2v0vfi7ljm"},{"post_id":"ckba4hhya002l9r2vp2np4bow","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhz7006i9r2vubv4qk2f"},{"post_id":"ckba4hhya002m9r2v4x5l6btc","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhz7006m9r2vl0s1whze"},{"post_id":"ckba4hhya002m9r2v4x5l6btc","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhz7006o9r2ve0s8wshr"},{"post_id":"ckba4hhyc002q9r2vrkllwzrb","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhz9006x9r2vt411719w"},{"post_id":"ckba4hhyc002q9r2vrkllwzrb","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhz9006z9r2v3z0p0hqc"},{"post_id":"ckba4hhyc002r9r2vq3vrzm73","category_id":"ckba4hhx800049r2vz849w4u8","_id":"ckba4hhza00739r2veu970dvh"},{"post_id":"ckba4hhyc002r9r2vq3vrzm73","category_id":"ckba4hhyl00449r2vrmbiltbr","_id":"ckba4hhza00759r2v30zh35zc"},{"post_id":"ckba4hhxn000u9r2v13bce5je","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhzb00799r2vhu58ssnn"},{"post_id":"ckba4hhxn000u9r2v13bce5je","category_id":"ckba4hhyx005g9r2v9prrd1s2","_id":"ckba4hhzc007b9r2vx4n7dv8i"},{"post_id":"ckba4hhxo000y9r2vhh3188e5","category_id":"ckba4hhye002v9r2vigha9bu9","_id":"ckba4hhzc007f9r2vmgtou41c"},{"post_id":"ckba4hhxo000y9r2vhh3188e5","category_id":"ckba4hhz900719r2v5yxhoj2w","_id":"ckba4hhzd007i9r2vu2kwqq5r"},{"post_id":"ckba4hhxw001n9r2vkax4eedv","category_id":"ckba4hhye002v9r2vigha9bu9","_id":"ckba4hhzd007k9r2vqyho8xks"},{"post_id":"ckba4hhxw001n9r2vkax4eedv","category_id":"ckba4hhza00779r2vz66jkyos","_id":"ckba4hhzd007m9r2vg8g8mh7r"},{"post_id":"ckba4hhxm000s9r2voxid41dl","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckba4hhze007o9r2v7z28lvvw"},{"post_id":"ckba4hhxm000s9r2voxid41dl","category_id":"ckba4hhz5006e9r2vwptzqiz7","_id":"ckba4hhze007q9r2vfzbe8m0v"},{"post_id":"ckba4hhxm000s9r2voxid41dl","category_id":"ckba4hhzc007d9r2v4vvq2nxi","_id":"ckba4hhze007r9r2vyaqwhsrs"},{"post_id":"ckcyi7puz0001f12v2w4i2qs4","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckcyi8kfg0003f12vr6q1icch"},{"post_id":"ckcyi7puz0001f12v2w4i2qs4","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckcyi8kfg0004f12vg92r5yaf"},{"post_id":"ckeh3cmls0004xi2vypy2857p","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckeh3cmlt0006xi2vrdjgw0g4"},{"post_id":"ckeh3cmls0004xi2vypy2857p","category_id":"ckba4hhyg00399r2v1vd3vco2","_id":"ckeh3cmlt0007xi2vgtjid2pj"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","category_id":"ckba4hhxs001b9r2vpty0pjws","_id":"ckfdntts40008nq2v22ksrga9"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","category_id":"ckba4hhyh003c9r2vg6ibemh7","_id":"ckfdntts40009nq2vhkrsir1f"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","category_id":"ckfdntts20002nq2vu4i9zdey","_id":"ckfdntts4000anq2vy2nr4k77"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","category_id":"ckfdntts30004nq2v2zec7w18","_id":"ckfdntts4000bnq2v92tg7my5"}],"PostTag":[{"post_id":"ckba4hhx100009r2vca5qklzi","tag_id":"ckba4hhx600029r2v37uma3vy","_id":"ckba4hhxi000i9r2vjrwvawy8"},{"post_id":"ckba4hhx100009r2vca5qklzi","tag_id":"ckba4hhxa00079r2vw7s6d7rj","_id":"ckba4hhxj000k9r2v5ku1zkfq"},{"post_id":"ckba4hhx100009r2vca5qklzi","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhxl000o9r2v80rg7bzi"},{"post_id":"ckba4hhx400019r2vi5enh7gm","tag_id":"ckba4hhx600029r2v37uma3vy","_id":"ckba4hhxp000z9r2vn6mab6lp"},{"post_id":"ckba4hhx400019r2vi5enh7gm","tag_id":"ckba4hhxa00079r2vw7s6d7rj","_id":"ckba4hhxq00129r2vg4o1chu1"},{"post_id":"ckba4hhx400019r2vi5enh7gm","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhxr00179r2v3v8qoxvz"},{"post_id":"ckba4hhx700039r2v2agnq8rs","tag_id":"ckba4hhxo000w9r2vyvdsst22","_id":"ckba4hhxt001f9r2vjnz1vhjx"},{"post_id":"ckba4hhx700039r2v2agnq8rs","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhxu001i9r2vwndx5nr0"},{"post_id":"ckba4hhx900059r2v9tqu269w","tag_id":"ckba4hhxo000w9r2vyvdsst22","_id":"ckba4hhxz001s9r2vimumue1w"},{"post_id":"ckba4hhx900059r2v9tqu269w","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhxz001u9r2vpkj2t3ar"},{"post_id":"ckba4hhx900069r2vh0w3v8ey","tag_id":"ckba4hhxo000w9r2vyvdsst22","_id":"ckba4hhy300229r2vieeee8e3"},{"post_id":"ckba4hhx900069r2vh0w3v8ey","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhy400259r2v5qoj59n4"},{"post_id":"ckba4hhxc00099r2v946p95wc","tag_id":"ckba4hhxo000w9r2vyvdsst22","_id":"ckba4hhy7002e9r2vq40kksup"},{"post_id":"ckba4hhxc00099r2v946p95wc","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhy8002g9r2vbebw4q2i"},{"post_id":"ckba4hhxd000a9r2v77d7bkcc","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhya002k9r2v011gns0x"},{"post_id":"ckba4hhxf000d9r2v3vu6di5g","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhyc002p9r2vu5lr809u"},{"post_id":"ckba4hhxf000e9r2vfug60ga3","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhye002u9r2vajq6y2yl"},{"post_id":"ckba4hhxh000h9r2vj426si9k","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhyf002x9r2vahlryifd"},{"post_id":"ckba4hhxi000j9r2veypsq97g","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhyf00309r2vc3f9iyqy"},{"post_id":"ckba4hhxk000n9r2vbkzq4kos","tag_id":"ckba4hhyf002y9r2vb8jv1jv8","_id":"ckba4hhyg00369r2vrtezit6g"},{"post_id":"ckba4hhxk000n9r2vbkzq4kos","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhyg00379r2vqwoohc4q"},{"post_id":"ckba4hhxl000p9r2v507ot6zu","tag_id":"ckba4hhyf002y9r2vb8jv1jv8","_id":"ckba4hhyh003d9r2vlrn6343g"},{"post_id":"ckba4hhxl000p9r2v507ot6zu","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhyh003f9r2v5bn47q96"},{"post_id":"ckba4hhxm000s9r2voxid41dl","tag_id":"ckba4hhyg003b9r2vfo0so3qu","_id":"ckba4hhyi003m9r2vtr3px4y0"},{"post_id":"ckba4hhxm000s9r2voxid41dl","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhyj003o9r2vxwqcveom"},{"post_id":"ckba4hhxn000u9r2v13bce5je","tag_id":"ckba4hhyf002y9r2vb8jv1jv8","_id":"ckba4hhyk003w9r2vi7c815ci"},{"post_id":"ckba4hhxn000u9r2v13bce5je","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhyk003x9r2vdofkr90n"},{"post_id":"ckba4hhxo000y9r2vhh3188e5","tag_id":"ckba4hhyk003t9r2vy0iduohm","_id":"ckba4hhyl00409r2v8f3r27ci"},{"post_id":"ckba4hhxp00119r2vb0h58ii1","tag_id":"ckba4hhyk003y9r2v5bjxd7fc","_id":"ckba4hhyl00459r2vhty1n7be"},{"post_id":"ckba4hhxq00169r2v883kniit","tag_id":"ckba4hhyl00439r2vn14omiva","_id":"ckba4hhym004b9r2v8xzeh9ho"},{"post_id":"ckba4hhxs001d9r2vf01ek3n9","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckba4hhyn004f9r2v2e9ubp5z"},{"post_id":"ckba4hhxt001g9r2vwvze12zw","tag_id":"ckba4hhyn004d9r2vsouvkqj6","_id":"ckba4hhyp004l9r2vatfmkrho"},{"post_id":"ckba4hhxu001k9r2v1sdleikj","tag_id":"ckba4hhyn004d9r2vsouvkqj6","_id":"ckba4hhys004u9r2vyps86q95"},{"post_id":"ckba4hhxu001k9r2v1sdleikj","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhys004w9r2vo78xaymp"},{"post_id":"ckba4hhxw001n9r2vkax4eedv","tag_id":"ckba4hhyk003t9r2vy0iduohm","_id":"ckba4hhyt00509r2v4tyl3bhb"},{"post_id":"ckba4hhxx001q9r2v99ewemqu","tag_id":"ckba4hhyn004d9r2vsouvkqj6","_id":"ckba4hhyv00599r2vwvl2ovk6"},{"post_id":"ckba4hhxx001q9r2v99ewemqu","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhyv005b9r2vp3inanjp"},{"post_id":"ckba4hhxz001t9r2vxz1ynyjz","tag_id":"ckba4hhyn004d9r2vsouvkqj6","_id":"ckba4hhyy005j9r2v1d5qv2c5"},{"post_id":"ckba4hhxz001t9r2vxz1ynyjz","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhyy005l9r2vw45e2xri"},{"post_id":"ckba4hhy0001w9r2v9umpja3m","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhyz005p9r2v4t7r4d5t"},{"post_id":"ckba4hhy0001w9r2v9umpja3m","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhyz005r9r2v4gsglrg6"},{"post_id":"ckba4hhy1001y9r2v7zexjasy","tag_id":"ckba4hhyn004d9r2vsouvkqj6","_id":"ckba4hhz1005z9r2vdlchzu5y"},{"post_id":"ckba4hhy1001y9r2v7zexjasy","tag_id":"ckba4hhyf00319r2vcyc7c3au","_id":"ckba4hhz100619r2vajpy493y"},{"post_id":"ckba4hhy200209r2vprspcjzg","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhz200659r2vs9q183p3"},{"post_id":"ckba4hhy200209r2vprspcjzg","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhz300679r2vt09iwugu"},{"post_id":"ckba4hhy300249r2vlf81gmlf","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhz5006b9r2virz5f3qz"},{"post_id":"ckba4hhy300249r2vlf81gmlf","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhz5006d9r2vh1aim9ho"},{"post_id":"ckba4hhy400289r2vf6s4r0sv","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhz6006h9r2vmpbe7s1d"},{"post_id":"ckba4hhy400289r2vf6s4r0sv","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhz7006j9r2v283bfw1w"},{"post_id":"ckba4hhy5002a9r2vmodzwgp2","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhz7006n9r2vmoq8by33"},{"post_id":"ckba4hhy5002a9r2vmodzwgp2","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhz8006p9r2vff734t9y"},{"post_id":"ckba4hhy6002c9r2v9jsoifdb","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhz8006s9r2vs83e4md1"},{"post_id":"ckba4hhy6002c9r2v9jsoifdb","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhz8006t9r2vigz11jm1"},{"post_id":"ckba4hhy7002f9r2vxwplpe1f","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhz9006w9r2vrsier4b6"},{"post_id":"ckba4hhy7002f9r2vxwplpe1f","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhz9006y9r2vuqe1z3mf"},{"post_id":"ckba4hhy8002h9r2v6e3vul0o","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhza00729r2v9nl9slxq"},{"post_id":"ckba4hhy8002h9r2v6e3vul0o","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhza00749r2vdohct30p"},{"post_id":"ckba4hhya002l9r2vp2np4bow","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhzb00789r2vqscpaq5i"},{"post_id":"ckba4hhya002l9r2vp2np4bow","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhzc007a9r2vnyquduyd"},{"post_id":"ckba4hhya002m9r2v4x5l6btc","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhzc007e9r2vd5f4fwn9"},{"post_id":"ckba4hhya002m9r2v4x5l6btc","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhzc007g9r2vgfw6y7oc"},{"post_id":"ckba4hhyc002q9r2vrkllwzrb","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhzd007j9r2v2e1g2mdk"},{"post_id":"ckba4hhyc002q9r2vrkllwzrb","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhzd007l9r2vm5zl7oux"},{"post_id":"ckba4hhyc002r9r2vq3vrzm73","tag_id":"ckba4hhyx005h9r2v1mb75f4g","_id":"ckba4hhzd007n9r2vy18rc1c6"},{"post_id":"ckba4hhyc002r9r2vq3vrzm73","tag_id":"ckba4hhxe000c9r2v7sanzpib","_id":"ckba4hhze007p9r2v0gdzcsz2"},{"post_id":"ckcyi7puz0001f12v2w4i2qs4","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckcyi8kfg0002f12vbxiahlzg"},{"post_id":"ckeh3cmls0004xi2vypy2857p","tag_id":"ckba4hhy6002b9r2v9dw54aat","_id":"ckeh3cmls0005xi2vexry077b"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","tag_id":"ckba4hhyn004d9r2vsouvkqj6","_id":"ckfdntts40005nq2vk9njuhz8"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","tag_id":"ckfdnttrw0001nq2v23ie9eaq","_id":"ckfdntts40006nq2v1g03hi9z"},{"post_id":"ckfdnttru0000nq2vhb4ayt3p","tag_id":"ckfdntts30003nq2viiqh3rm7","_id":"ckfdntts40007nq2vszrwd75f"}],"Tag":[{"name":"js","_id":"ckba4hhx600029r2v37uma3vy"},{"name":"函数式编程","_id":"ckba4hhxa00079r2vw7s6d7rj"},{"name":"读书笔记","_id":"ckba4hhxe000c9r2v7sanzpib"},{"name":"SEO","_id":"ckba4hhxo000w9r2vyvdsst22"},{"name":"知识点整理","_id":"ckba4hhy6002b9r2v9dw54aat"},{"name":"lodash","_id":"ckba4hhyf002y9r2vb8jv1jv8"},{"name":"源码阅读","_id":"ckba4hhyf00319r2vcyc7c3au"},{"name":"npm","_id":"ckba4hhyg003b9r2vfo0so3qu"},{"name":"日语","_id":"ckba4hhyk003t9r2vy0iduohm"},{"name":"生活","_id":"ckba4hhyk003y9r2v5bjxd7fc"},{"name":"环境配置","_id":"ckba4hhyl00439r2vn14omiva"},{"name":"react","_id":"ckba4hhyn004d9r2vsouvkqj6"},{"name":"sicp","_id":"ckba4hhyx005h9r2v1mb75f4g"},{"name":"转载","_id":"ckfdnttrw0001nq2v23ie9eaq"},{"name":"自翻","_id":"ckfdntts30003nq2viiqh3rm7"}]}}